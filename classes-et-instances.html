<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Classes et instances &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Classes et instances<small>27</small></a></h3>

<ul>
    <li><a href="#objets-classe"><small>27.1</small> Objets Classe</a></li>
    <li><a href="#déclarations-de-classe"><small>27.2</small> Déclarations de Classe</a></li>
    <li><a href="#instances-de-classes"><small>27.3</small> Instances de Classes</a></li>
    <li><a href="#expressions-get-et-set"><small>27.4</small> Expressions Get et Set</a></li>
    <li><a href="#défis"><small>27.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="ramasse-miettes.html" title="Ramasse-miettes" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="méthodes-et-initialisateurs.html" title="Méthodes et initialisateurs" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="ramasse-miettes.html" title="Ramasse-miettes" class="prev">←</a>
<a href="méthodes-et-initialisateurs.html" title="Méthodes et initialisateurs" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Classes et instances<small>27</small></a></h3>

<ul>
    <li><a href="#objets-classe"><small>27.1</small> Objets Classe</a></li>
    <li><a href="#déclarations-de-classe"><small>27.2</small> Déclarations de Classe</a></li>
    <li><a href="#instances-de-classes"><small>27.3</small> Instances de Classes</a></li>
    <li><a href="#expressions-get-et-set"><small>27.4</small> Expressions Get et Set</a></li>
    <li><a href="#défis"><small>27.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="ramasse-miettes.html" title="Ramasse-miettes" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="méthodes-et-initialisateurs.html" title="Méthodes et initialisateurs" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">27</div>
  <h1>Classes et instances</h1>

<blockquote>
<p>S&rsquo;inquiéter trop pour les objets peut vous détruire. Seulement<span class="em">&mdash;</span>si vous tenez assez à une chose, elle prend une vie propre, n&rsquo;est-ce pas ? Et n&rsquo;est-ce pas tout le point des choses<span class="em">&mdash;</span>des belles choses<span class="em">&mdash;</span>qu&rsquo;elles vous connectent à une plus grande beauté ?</p>
<p><cite>Donna Tartt, <em>Le Chardonneret</em></cite></p>
</blockquote>
<p>La dernière zone laissée à implémenter dans clox est la programmation orientée objet. La <span name="oop">POO</span> est un paquet de fonctionnalités entrelacées : classes, instances, champs, méthodes, initialisateurs, et héritage. Utilisant du Java de relativement haut niveau, nous avons emballé tout cela dans deux chapitres. Maintenant que nous codons en C, qui ressemble à construire une maquette de la tour Eiffel avec des cure-dents, nous dévouerons trois chapitres à couvrir le même territoire. Cela fait une promenade tranquille à travers l&rsquo;implémentation. Après des chapitres ardus comme <a href="fermetures.html">les fermetures</a> et le <a href="ramasse-miettes.html">ramasse-miettes</a>, vous avez mérité un repos. En fait, le livre devrait être facile à partir de maintenant.</p>
<aside name="oop">
<p>Les gens qui ont des opinions fortes sur la programmation orientée objet<span class="em">&mdash;</span>lisez &ldquo;tout le monde&rdquo;<span class="em">&mdash;</span>tendent à supposer que la POO signifie une liste très spécifique de fonctionnalités de langage, mais vraiment il y a tout un espace à explorer, et chaque langage a ses propres ingrédients et recettes.</p>
<p>Self a des objets mais pas de classes. CLOS a des méthodes mais ne les attache à aucune classe spécifique. C++ initialement n&rsquo;avait pas de polymorphisme d&rsquo;exécution<span class="em">&mdash;</span>pas de méthodes virtuelles. Python a l&rsquo;héritage multiple, mais Java ne l&rsquo;a pas. Ruby attache les méthodes aux classes, mais vous pouvez aussi définir des méthodes sur un seul objet.</p>
</aside>
<p>Dans ce chapitre, nous couvrons les trois premières fonctionnalités : classes, instances, et champs. C&rsquo;est le côté avec état de l&rsquo;orientation objet. Ensuite dans les deux prochains chapitres, nous accrocherons le comportement et la réutilisation de code à ces objets.</p>
<h2><a href="#objets-classe" id="objets-classe"><small>27&#8202;.&#8202;1</small>Objets Classe</a></h2>
<p>Dans un langage orienté objet basé sur les classes, tout commence avec les classes. Elles définissent quelles sortes d&rsquo;objets existent dans le programme et sont les usines utilisées pour produire de nouvelles instances. Allant de bas en haut, nous commencerons avec leur représentation à l&rsquo;exécution et ensuite accrocherons cela dans le langage.</p>
<p>À ce point, nous sommes bien accoutumés avec le processus d&rsquo;ajouter un nouveau type d&rsquo;objet à la VM. Nous commençons avec une struct.</p>
<div class="codehilite"><pre class="insert-before">} ObjClosure;
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClosure</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">ObjString</span>* <span class="i">name</span>;
} <span class="t">ObjClass</span>;
</pre><pre class="insert-after">

ObjClosure* newClosure(ObjFunction* function);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClosure</em></div>

<p>Après l&rsquo;en-tête Obj, nous stockons le nom de la classe. Ce n&rsquo;est pas strictement nécessaire pour le programme de l&rsquo;utilisateur, mais cela nous laisse montrer le nom à l&rsquo;exécution pour des choses comme les traces de pile.</p>
<p>Le nouveau type nécessite un cas correspondant dans l&rsquo;énumération ObjType.</p>
<div class="codehilite"><pre class="insert-before">typedef enum {
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_CLASS</span>,
</pre><pre class="insert-after">  OBJ_CLOSURE,
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>Et ce type obtient une paire de macros correspondante. D&rsquo;abord, pour tester le type d&rsquo;un objet :</p>
<div class="codehilite"><pre class="insert-before">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define IS_CLASS(value)        isObjType(value, OBJ_CLASS)</span>
</pre><pre class="insert-after">#define IS_CLOSURE(value)      isObjType(value, OBJ_CLOSURE)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Et ensuite pour caster une Value en un pointeur ObjClass :</p>
<div class="codehilite"><pre class="insert-before">#define IS_STRING(value)       isObjType(value, OBJ_STRING)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define AS_CLASS(value)        ((ObjClass*)AS_OBJ(value))</span>
</pre><pre class="insert-after">#define AS_CLOSURE(value)      ((ObjClosure*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>La VM crée de nouveaux objets classe utilisant cette fonction :</p>
<div class="codehilite"><pre class="insert-before">} ObjClass;

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClass</em></div>
<pre class="insert"><span class="t">ObjClass</span>* <span class="i">newClass</span>(<span class="t">ObjString</span>* <span class="i">name</span>);
</pre><pre class="insert-after">ObjClosure* newClosure(ObjFunction* function);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClass</em></div>

<p>L&rsquo;implémentation vit par ici :</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>allocateObject</em>()</div>
<pre><span class="t">ObjClass</span>* <span class="i">newClass</span>(<span class="t">ObjString</span>* <span class="i">name</span>) {
  <span class="t">ObjClass</span>* <span class="i">klass</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjClass</span>, <span class="a">OBJ_CLASS</span>);
  <span class="i">klass</span>-&gt;<span class="i">name</span> = <span class="i">name</span>;<span name="klass"> </span>
  <span class="k">return</span> <span class="i">klass</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateObject</em>()</div>

<p>Quasiment tout du code standard. Elle prend le nom de la classe comme une chaîne et le stocke. Chaque fois que l&rsquo;utilisateur déclare une nouvelle classe, la VM créera une nouvelle de ces structs ObjClass pour la représenter.</p>
<aside name="klass"><img src="image/classes-and-instances/klass.png" alt="'Klass' dans une police farfelue pour enfants."/>
<p>J&rsquo;ai nommé la variable &ldquo;klass&rdquo; pas juste pour donner à la VM une sensation farfelue de maternelle &ldquo;Coin des Enfants&rdquo;. Cela rend plus facile de faire compiler clox comme du C++ où &ldquo;class&rdquo; est un mot réservé.</p>
</aside>
<p>Quand la VM n&rsquo;a plus besoin d&rsquo;une classe, elle la libère comme ceci :</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_CLASS</span>: {
      <span class="a">FREE</span>(<span class="t">ObjClass</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }<span name="braces"> </span>
</pre><pre class="insert-after">    case OBJ_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<aside name="braces">
<p>Les accolades ici sont inutiles maintenant, mais seront utiles dans le prochain chapitre quand nous ajouterons un peu plus de code au case du switch.</p>
</aside>
<p>Nous avons un gestionnaire de mémoire maintenant, donc nous devons aussi supporter le traçage à travers les objets classe.</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_CLASS</span>: {
      <span class="t">ObjClass</span>* <span class="i">klass</span> = (<span class="t">ObjClass</span>*)<span class="i">object</span>;
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">klass</span>-&gt;<span class="i">name</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>Quand le GC atteint un objet classe, il marque le nom de la classe pour garder cette chaîne vivante aussi.</p>
<p>La dernière opération que la VM peut effectuer sur une classe est de l&rsquo;afficher.</p>
<div class="codehilite"><pre class="insert-before">  switch (OBJ_TYPE(value)) {
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_CLASS</span>:
      <span class="i">printf</span>(<span class="s">&quot;%s&quot;</span>, <span class="a">AS_CLASS</span>(<span class="i">value</span>)-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_CLOSURE:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p>Une classe dit simplement son propre nom.</p>
<h2><a href="#déclarations-de-classe" id="déclarations-de-classe"><small>27&#8202;.&#8202;2</small>Déclarations de Classe</a></h2>
<p>Représentation runtime en main, nous sommes prêts à ajouter le support pour les classes au langage. Ensuite, nous bougeons dans l&rsquo;analyseur.</p>
<div class="codehilite"><pre class="insert-before">static void declaration() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declaration</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_CLASS</span>)) {
    <span class="i">classDeclaration</span>();
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_FUN</span>)) {
</pre><pre class="insert-after">    funDeclaration();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>(), replace 1 line</div>

<p>Les déclarations de classe sont des instructions, et l&rsquo;analyseur en reconnaît une par le mot-clé <code>class</code> en tête. Le reste de la compilation se passe par ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>function</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">classDeclaration</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="s">&quot;Expect class name.&quot;</span>);
  <span class="t">uint8_t</span> <span class="i">nameConstant</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);
  <span class="i">declareVariable</span>();

  <span class="i">emitBytes</span>(<span class="a">OP_CLASS</span>, <span class="i">nameConstant</span>);
  <span class="i">defineVariable</span>(<span class="i">nameConstant</span>);

  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_BRACE</span>, <span class="s">&quot;Expect &#39;{&#39; before class body.&quot;</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_BRACE</span>, <span class="s">&quot;Expect &#39;}&#39; after class body.&quot;</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>function</em>()</div>

<p>Immédiatement après le mot-clé <code>class</code> est le nom de la classe. Nous prenons cet identifiant et l&rsquo;ajoutons à la table de constantes de la fonction environnante comme une chaîne. Comme vous venez de le voir, afficher une classe montre son nom, donc le compilateur a besoin de fourrer la chaîne du nom quelque part que le runtime peut trouver. La table de constantes est la façon de faire cela.</p>
<p>Le <span name="variable">nom</span> de la classe est aussi utilisé pour lier l&rsquo;objet classe à une variable du même nom. Donc nous déclarons une variable avec cet identifiant juste après avoir consommé son jeton.</p>
<aside name="variable">
<p>Nous aurions pu faire que les déclarations de classe soient des <em>expressions</em> au lieu d&rsquo;instructions<span class="em">&mdash;</span>elles sont essentiellement un littéral qui produit une valeur après tout. Alors les utilisateurs auraient à lier explicitement la classe à une variable eux-mêmes comme :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="t">Pie</span> = <span class="k">class</span> {}
</pre></div>
<p>Sorte de comme les fonctions lambda mais pour les classes. Mais puisque nous voulons généralement que les classes soient nommées de toute façon, cela a du sens de les traiter comme des déclarations.</p>
</aside>
<p>Ensuite, nous émettons une nouvelle instruction pour créer réellement l&rsquo;objet classe à l&rsquo;exécution. Cette instruction prend l&rsquo;index de table de constantes du nom de la classe comme un opérande.</p>
<p>Après cela, mais avant de compiler le corps de la classe, nous définissons la variable pour le nom de la classe. <em>Déclarer</em> la variable l&rsquo;ajoute à la portée, mais rappelez-vous d&rsquo;<a href="variables-locales.html#un-autre-cas-limite-de-portée">un chapitre précédent</a> que nous ne pouvons pas <em>utiliser</em> la variable jusqu&rsquo;à ce qu&rsquo;elle soit <em>définie</em>. Pour les classes, nous définissons la variable avant le corps. De cette façon, les utilisateurs peuvent se référer à la classe contenante à l&rsquo;intérieur des corps de ses propres méthodes. C&rsquo;est utile pour des choses comme les méthodes usines qui produisent de nouvelles instances de la classe.</p>
<p>Finalement, nous compilons le corps. Nous n&rsquo;avons pas de méthodes encore, donc juste maintenant c&rsquo;est simplement une paire d&rsquo;accolades vide. Lox ne requiert pas que les champs soient déclarés dans la classe, donc nous en avons fini avec le corps<span class="em">&mdash;</span>et l&rsquo;analyseur<span class="em">&mdash;</span>pour l&rsquo;instant.</p>
<p>Le compilateur émet une nouvelle instruction, donc définissons cela.</p>
<div class="codehilite"><pre class="insert-before">  OP_RETURN,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_CLASS</span>,
</pre><pre class="insert-after">} OpCode;
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Et ajoutons-la au désassembleur :</p>
<div class="codehilite"><pre class="insert-before">    case OP_RETURN:
      return simpleInstruction(&quot;OP_RETURN&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_CLASS</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_CLASS&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    default:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Pour une fonctionnalité d&rsquo;apparence si large, le support de l&rsquo;interpréteur est minimal.</p>
<div class="codehilite"><pre class="insert-before">        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_CLASS</span>:
        <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">newClass</span>(<span class="a">READ_STRING</span>())));
        <span class="k">break</span>;
</pre><pre class="insert-after">    }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nous chargeons la chaîne pour le nom de la classe depuis la table de constantes et passons cela à <code>newClass()</code>. Cela crée un nouvel objet classe avec le nom donné. Nous empilons cela sur la pile et nous sommes bons. Si la classe est liée à une variable globale, alors l&rsquo;appel du compilateur à <code>defineVariable()</code> émettra du code pour stocker cet objet de la pile dans la table des variables globales. Sinon, c&rsquo;est juste où cela doit être sur la pile pour une nouvelle variable <span name="local">locale</span>.</p>
<aside name="local">
<p>Les classes &ldquo;locales&rdquo;<span class="em">&mdash;</span>classes déclarées à l&rsquo;intérieur du corps d&rsquo;une fonction ou d&rsquo;un bloc, sont un concept inhabituel. Beaucoup de langages ne les permettent pas du tout. Mais puisque Lox est un langage de script typé dynamiquement, il traite le niveau supérieur d&rsquo;un programme et les corps des fonctions et des blocs uniformément. Les classes sont juste une autre sorte de déclaration, et puisque vous pouvez déclarer des variables et des fonctions à l&rsquo;intérieur des blocs, vous pouvez déclarer des classes là-dedans aussi.</p>
</aside>
<p>Là vous l&rsquo;avez, notre VM supporte les classes maintenant. Vous pouvez exécuter ceci :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Brioche</span> {}
<span class="k">print</span> <span class="t">Brioche</span>;
</pre></div>
<p>Malheureusement, afficher est à propos de <em>tout</em> ce que vous pouvez faire avec les classes, donc la suite est de les rendre plus utiles.</p>
<h2><a href="#instances-de-classes" id="instances-de-classes"><small>27&#8202;.&#8202;3</small>Instances de Classes</a></h2>
<p>Les classes servent deux buts principaux dans un langage :</p>
<ul>
<li>
<p><strong>Elles sont comment vous créez de nouvelles instances.</strong> Parfois cela implique un mot-clé <code>new</code>, d&rsquo;autres fois c&rsquo;est un appel de méthode sur l&rsquo;objet classe, mais vous mentionnez habituellement la classe par nom <em>d&rsquo;une façon ou d&rsquo;une autre</em> pour obtenir une nouvelle instance.</p>
</li>
<li>
<p><strong>Elles contiennent des méthodes.</strong> Celles-ci définissent comment toutes les instances de la classe se comportent.</p>
</li>
</ul>
<p>Nous n&rsquo;arriverons pas aux méthodes avant le prochain chapitre, donc pour l&rsquo;instant nous nous inquiéterons seulement de la première partie. Avant que les classes puissent créer des instances, nous avons besoin d&rsquo;une représentation pour elles.</p>
<div class="codehilite"><pre class="insert-before">} ObjClass;
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClass</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">ObjClass</span>* <span class="i">klass</span>;
  <span class="t">Table</span> <span class="i">fields</span>;<span name="fields"> </span>
} <span class="t">ObjInstance</span>;
</pre><pre class="insert-after">

ObjClass* newClass(ObjString* name);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClass</em></div>

<p>Les instances connaissent leur classe<span class="em">&mdash;</span>chaque instance a un pointeur vers la classe dont elle est une instance. Nous n&rsquo;utiliserons pas beaucoup cela dans ce chapitre, mais cela deviendra critique quand nous ajouterons les méthodes.</p>
<p>Plus important à ce chapitre est comment les instances stockent leur état. Lox laisse les utilisateurs ajouter librement des champs à une instance à l&rsquo;exécution. Cela signifie que nous avons besoin d&rsquo;un mécanisme de stockage qui peut grandir. Nous pourrions utiliser un tableau dynamique, mais nous voulons aussi chercher les champs par nom aussi vite que possible. Il y a une structure de données qui est juste parfaite pour accéder rapidement à un ensemble de valeurs par nom et<span class="em">&mdash;</span>encore plus commodément<span class="em">&mdash;</span>nous l&rsquo;avons déjà implémentée. Chaque instance stocke ses champs utilisant une table de hachage.</p>
<aside name="fields">
<p>Être capable d&rsquo;ajouter librement des champs à un objet à l&rsquo;exécution est une grosse différence pratique entre la plupart des langages dynamiques et statiques. Les langages typés statiquement requièrent souvent que les champs soient explicitement déclarés. De cette façon, le compilateur sait exactement quels champs chaque instance a. Il peut utiliser cela pour déterminer la quantité précise de mémoire nécessaire pour chaque instance et les décalages dans cette mémoire où chaque champ peut être trouvé.</p>
<p>Dans Lox et d&rsquo;autres langages dynamiques, accéder à un champ est habituellement une recherche dans une table de hachage. Temps constant, mais toujours assez lourd. Dans un langage comme C++, accéder à un champ est aussi rapide que décaler un pointeur par une constante entière.</p>
</aside>
<p>Nous avons seulement besoin d&rsquo;ajouter une inclusion, et nous l&rsquo;avons.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;chunk.h&quot;
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#include &quot;table.h&quot;</span>
</pre><pre class="insert-after">#include &quot;value.h&quot;
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Cette nouvelle struct obtient un nouveau type d&rsquo;objet.</p>
<div class="codehilite"><pre class="insert-before">  OBJ_FUNCTION,
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_INSTANCE</span>,
</pre><pre class="insert-after">  OBJ_NATIVE,
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>Je veux ralentir un peu ici parce que la notion de &ldquo;type&rdquo; du <em>langage</em> Lox et la notion de &ldquo;type&rdquo; de l&rsquo;<em>implémentation</em> de la VM se frottent l&rsquo;une contre l&rsquo;autre de façons qui peuvent être déroutantes. À l&rsquo;intérieur du code C qui fait clox, il y a un nombre de différents types d&rsquo;Obj<span class="em">&mdash;</span>ObjString, ObjClosure, etc. Chacun a sa propre représentation interne et sémantique.</p>
<p>Dans le <em>langage</em> Lox, les utilisateurs peuvent définir leurs propres classes<span class="em">&mdash;</span>disons Gateau et Tarte<span class="em">&mdash;</span>et ensuite créer des instances de ces classes. De la perspective de l&rsquo;utilisateur, une instance de Gateau est un type d&rsquo;objet différent qu&rsquo;une instance de Tarte. Mais, de la perspective de la VM, chaque classe que l&rsquo;utilisateur définit est simplement une autre valeur de type ObjClass. De même, chaque instance dans le programme de l&rsquo;utilisateur, peu importe de quelle classe elle est une instance, est une ObjInstance. Ce seul type d&rsquo;objet VM couvre les instances de toutes les classes. Les deux mondes mappent l&rsquo;un à l&rsquo;autre quelque chose comme ceci :</p><img src="image/classes-and-instances/lox-clox.png" alt="Un ensemble de déclarations de classe et d'instances, et les représentations runtime auxquelles chacune mappe."/>
<p>Compris ? OK, retour à l&rsquo;implémentation. Nous obtenons aussi nos macros habituelles.</p>
<div class="codehilite"><pre class="insert-before">#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define IS_INSTANCE(value)     isObjType(value, OBJ_INSTANCE)</span>
</pre><pre class="insert-after">#define IS_NATIVE(value)       isObjType(value, OBJ_NATIVE)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Et :</p>
<div class="codehilite"><pre class="insert-before">#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define AS_INSTANCE(value)     ((ObjInstance*)AS_OBJ(value))</span>
</pre><pre class="insert-after">#define AS_NATIVE(value) \
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Puisque les champs sont ajoutés après que l&rsquo;instance est créée, la fonction &ldquo;constructeur&rdquo; a seulement besoin de connaître la classe.</p>
<div class="codehilite"><pre class="insert-before">ObjFunction* newFunction();
</pre><div class="source-file"><em>object.h</em><br>
add after <em>newFunction</em>()</div>
<pre class="insert"><span class="t">ObjInstance</span>* <span class="i">newInstance</span>(<span class="t">ObjClass</span>* <span class="i">klass</span>);
</pre><pre class="insert-after">ObjNative* newNative(NativeFn function);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after <em>newFunction</em>()</div>

<p>Nous implémentons cette fonction ici :</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>newFunction</em>()</div>
<pre><span class="t">ObjInstance</span>* <span class="i">newInstance</span>(<span class="t">ObjClass</span>* <span class="i">klass</span>) {
  <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjInstance</span>, <span class="a">OBJ_INSTANCE</span>);
  <span class="i">instance</span>-&gt;<span class="i">klass</span> = <span class="i">klass</span>;
  <span class="i">initTable</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>);
  <span class="k">return</span> <span class="i">instance</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>newFunction</em>()</div>

<p>Nous stockons une référence vers la classe de l&rsquo;instance. Ensuite nous initialisons la table des champs à une table de hachage vide. Un nouveau bébé objet est né !
À la fin plus triste de la durée de vie de l&rsquo;instance, elle est libérée.</p>
<div class="codehilite"><pre class="insert-before">      FREE(ObjFunction, object);
      break;
    }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_INSTANCE</span>: {
      <span class="t">ObjInstance</span>* <span class="i">instance</span> = (<span class="t">ObjInstance</span>*)<span class="i">object</span>;
      <span class="i">freeTable</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>);
      <span class="a">FREE</span>(<span class="t">ObjInstance</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_NATIVE:
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>L&rsquo;instance possède sa table de champs donc lors de la libération de l&rsquo;instance, nous libérons aussi la table. Nous ne libérons pas explicitement les entrées <em>dans</em> la table, parce qu&rsquo;il peut y avoir d&rsquo;autres références à ces objets. Le ramasse-miettes prendra soin de ceux-là pour nous. Ici nous libérons seulement le tableau d&rsquo;entrée de la table elle-même.</p>
<p>Parlant du ramasse-miettes, il a besoin de support pour tracer à travers les instances.</p>
<div class="codehilite"><pre class="insert-before">      markArray(&amp;function-&gt;chunk.constants);
      break;
    }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_INSTANCE</span>: {
      <span class="t">ObjInstance</span>* <span class="i">instance</span> = (<span class="t">ObjInstance</span>*)<span class="i">object</span>;
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">instance</span>-&gt;<span class="i">klass</span>);
      <span class="i">markTable</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_UPVALUE:
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>Si l&rsquo;instance est vivante, nous avons besoin de garder sa classe autour. Aussi, nous avons besoin de garder chaque objet référencé par les champs de l&rsquo;instance. La plupart des objets vivants qui ne sont pas des racines sont atteignables parce que quelque instance se réfère à l&rsquo;objet dans un champ. Heureusement, nous avons déjà une belle fonction <code>markTable()</code> pour rendre leur traçage facile.</p>
<p>Moins critique mais toujours important est l&rsquo;affichage.</p>
<div class="codehilite"><pre class="insert-before">      break;
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_INSTANCE</span>:
      <span class="i">printf</span>(<span class="s">&quot;%s instance&quot;</span>,
             <span class="a">AS_INSTANCE</span>(<span class="i">value</span>)-&gt;<span class="i">klass</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_NATIVE:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p><span name="print">Une</span> instance affiche son nom suivi par &ldquo;instance&rdquo;. (La partie &ldquo;instance&rdquo; est principalement pour que les classes et les instances n&rsquo;affichent pas la même chose.)</p>
<aside name="print">
<p>La plupart des langages orientés objet laissent une classe définir quelque sorte de méthode <code>toString()</code> qui laisse la classe spécifier comment ses instances sont converties en une chaîne et affichées. Si Lox était moins un langage jouet, je voudrais supporter cela aussi.</p>
</aside>
<p>Le vrai amusement se passe là-bas dans l&rsquo;interpréteur. Lox n&rsquo;a pas de mot-clé spécial <code>new</code>. La façon de créer une instance d&rsquo;une classe est d&rsquo;invoquer la classe elle-même comme si c&rsquo;était une fonction. Le runtime supporte déjà les appels de fonction, et il vérifie le type de l&rsquo;objet étant appelé pour s&rsquo;assurer que l&rsquo;utilisateur n&rsquo;essaie pas d&rsquo;invoquer un nombre ou un autre type invalide.</p>
<p>Nous étendons cette vérification runtime avec un nouveau cas.</p>
<div class="codehilite"><pre class="insert-before">    switch (OBJ_TYPE(callee)) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>callValue</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OBJ_CLASS</span>: {
        <span class="t">ObjClass</span>* <span class="i">klass</span> = <span class="a">AS_CLASS</span>(<span class="i">callee</span>);
        <span class="i">vm</span>.<span class="i">stackTop</span>[-<span class="i">argCount</span> - <span class="n">1</span>] = <span class="a">OBJ_VAL</span>(<span class="i">newInstance</span>(<span class="i">klass</span>));
        <span class="k">return</span> <span class="k">true</span>;
      }
</pre><pre class="insert-after">      case OBJ_CLOSURE:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>

<p>Si la valeur étant appelée<span class="em">&mdash;</span>l&rsquo;objet qui résulte lors de l&rsquo;évaluation de l&rsquo;expression à la gauche de la parenthèse ouvrante<span class="em">&mdash;</span>est une classe, alors nous la traitons comme un appel de constructeur. Nous <span name="args">créons</span> une nouvelle instance de la classe appelée et stockons le résultat sur la pile.</p>
<aside name="args">
<p>Nous ignorons tous arguments passés à l&rsquo;appel pour l&rsquo;instant. Nous revisiterons ce code dans le <a href="méthodes-et-initialisateurs.html">prochain chapitre</a> quand nous ajouterons le support pour les initialisateurs.</p>
</aside>
<p>Nous sommes une étape plus loin. Maintenant nous pouvons définir des classes et créer des instances d&rsquo;elles.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Brioche</span> {}
<span class="k">print</span> <span class="t">Brioche</span>();
</pre></div>
<p>Notez les parenthèses après <code>Brioche</code> sur la seconde ligne maintenant. Ceci affiche &ldquo;Brioche instance&rdquo;.</p>
<h2><a href="#expressions-get-et-set" id="expressions-get-et-set"><small>27&#8202;.&#8202;4</small>Expressions Get et Set</a></h2>
<p>Notre représentation objet pour les instances peut déjà stocker l&rsquo;état, donc tout ce qui reste est d&rsquo;exposer cette fonctionnalité à l&rsquo;utilisateur. Les champs sont accédés et modifiés utilisant des expressions get et set. Pas un pour rompre avec la tradition, Lox utilise la syntaxe &ldquo;point&rdquo; classique :</p>
<div class="codehilite"><pre><span class="i">eclair</span>.<span class="i">filling</span> = <span class="s">&quot;pastry creme&quot;</span>;
<span class="k">print</span> <span class="i">eclair</span>.<span class="i">filling</span>;
</pre></div>
<p>Le point fonctionne <span name="sort">sorte</span> de comme un opérateur infixe. Il y a une expression à la gauche qui est évaluée d&rsquo;abord et produit une instance. Après cela est le <code>.</code> suivi par un nom de champ. Puisqu&rsquo;il y a un opérande précédent, nous accrochons ceci dans la table d&rsquo;analyse comme une expression infixe.</p>
<aside name="sort">
<p>Je dis &ldquo;sorte de&rdquo; parce que le côté droit après le <code>.</code> n&rsquo;est pas une expression, mais un seul identifiant dont la sémantique est gérée par l&rsquo;expression get ou set elle-même. C&rsquo;est vraiment plus proche d&rsquo;une expression postfixe.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  [TOKEN_COMMA]         = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_DOT</span>]           = {<span class="a">NULL</span>,     <span class="i">dot</span>,    <span class="a">PREC_CALL</span>},
</pre><pre class="insert-after">  [TOKEN_MINUS]         = {unary,    binary, PREC_TERM},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Comme dans d&rsquo;autres langages, l&rsquo;opérateur <code>.</code> lie fortement, avec une précédence aussi haute que les parenthèses dans un appel de fonction. Après que l&rsquo;analyseur consomme le jeton point, il dépêche vers une nouvelle fonction d&rsquo;analyse.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>call</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">dot</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="s">&quot;Expect property name after &#39;.&#39;.&quot;</span>);
  <span class="t">uint8_t</span> <span class="i">name</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);

  <span class="k">if</span> (<span class="i">canAssign</span> &amp;&amp; <span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">expression</span>();
    <span class="i">emitBytes</span>(<span class="a">OP_SET_PROPERTY</span>, <span class="i">name</span>);
  } <span class="k">else</span> {
    <span class="i">emitBytes</span>(<span class="a">OP_GET_PROPERTY</span>, <span class="i">name</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>call</em>()</div>

<p>L&rsquo;analyseur s&rsquo;attend à trouver un nom de <span name="prop">propriété</span> immédiatement après le point. Nous chargeons le lexème de ce jeton dans la table de constantes comme une chaîne pour que le nom soit disponible à l&rsquo;exécution.</p>
<aside name="prop">
<p>Le compilateur utilise &ldquo;propriété&rdquo; au lieu de &ldquo;champ&rdquo; ici parce que, rappelez-vous, Lox vous laisse aussi utiliser la syntaxe point pour accéder à une méthode sans l&rsquo;appeler. &ldquo;Propriété&rdquo; est le terme général que nous utilisons pour nous référer à n&rsquo;importe quelle entité nommée que vous pouvez accéder sur une instance. Les champs sont le sous-ensemble des propriétés qui sont soutenues par l&rsquo;état de l&rsquo;instance.</p>
</aside>
<p>Nous avons deux nouvelles formes d&rsquo;expression<span class="em">&mdash;</span>getters et setters<span class="em">&mdash;</span>que cette seule fonction gère. Si nous voyons un signe égal après le nom de champ, cela doit être une expression set qui assigne à un champ. Mais nous ne permettons pas <em>toujours</em> à un signe égal après le champ d&rsquo;être compilé. Considérez :</p>
<div class="codehilite"><pre><span class="i">a</span> + <span class="i">b</span>.<span class="i">c</span> = <span class="n">3</span>
</pre></div>
<p>Ceci est syntaxiquement invalide selon la grammaire de Lox, ce qui signifie que notre implémentation Lox est obligée de détecter et rapporter l&rsquo;erreur. Si <code>dot()</code> analysait silencieusement la partie <code>= 3</code>, nous interpréterions incorrectement le code comme si l&rsquo;utilisateur avait écrit :</p>
<div class="codehilite"><pre><span class="i">a</span> + (<span class="i">b</span>.<span class="i">c</span> = <span class="n">3</span>)
</pre></div>
<p>Le problème est que le côté <code>=</code> d&rsquo;une expression set a une précédence beaucoup plus basse que la partie <code>.</code>. L&rsquo;analyseur peut appeler <code>dot()</code> dans un contexte qui est de trop haute précédence pour permettre à un setter d&rsquo;apparaître. Pour éviter de permettre incorrectement cela, nous analysons et compilons la partie égale seulement quand <code>canAssign</code> est vrai. Si un jeton égal apparaît quand <code>canAssign</code> est faux, <code>dot()</code> le laisse tranquille et retourne. Dans ce cas, le compilateur finira par dérouler jusqu&rsquo;à <code>parsePrecedence()</code>, qui s&rsquo;arrête au <code>=</code> inattendu étant toujours assis comme le prochain jeton et rapporte une erreur.</p>
<p>Si nous trouvons un <code>=</code> dans un contexte où il <em>est</em> permis, alors nous compilons l&rsquo;expression qui suit. Après cela, nous émettons une nouvelle instruction <span name="set"><code>OP_SET_PROPERTY</code></span>. Celle-là prend un seul opérande pour l&rsquo;index du nom de la propriété dans la table de constantes. Si nous n&rsquo;avons pas compilé une expression set, nous supposons que c&rsquo;est un getter et émettons une instruction <code>OP_GET_PROPERTY</code>, qui prend aussi un opérande pour le nom de la propriété.</p>
<aside name="set">
<p>Vous ne pouvez pas <em>régler</em> une propriété non-champ, donc je suppose que cette instruction aurait pu être <code>OP_SET_FIELD</code>, mais j&rsquo;ai pensé que cela semblait plus joli d&rsquo;être cohérent avec l&rsquo;instruction get.</p>
</aside>
<p>Maintenant est un bon moment pour définir ces deux nouvelles instructions.</p>
<div class="codehilite"><pre class="insert-before">  OP_SET_UPVALUE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_GET_PROPERTY</span>,
  <span class="a">OP_SET_PROPERTY</span>,
</pre><pre class="insert-after">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Et ajouter le support pour les désassembler :</p>
<div class="codehilite"><pre class="insert-before">      return byteInstruction(&quot;OP_SET_UPVALUE&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_GET_PROPERTY</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_GET_PROPERTY&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SET_PROPERTY</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_SET_PROPERTY&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<h3><a href="#interpréter-les-expressions-getter-et-setter" id="interpréter-les-expressions-getter-et-setter"><small>27&#8202;.&#8202;4&#8202;.&#8202;1</small>Interpréter les expressions getter et setter</a></h3>
<p>Glissant vers le runtime, nous commencerons avec les expressions get puisque celles-ci sont un peu plus simples.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GET_PROPERTY</span>: {
        <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">AS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">0</span>));
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();

        <span class="t">Value</span> <span class="i">value</span>;
        <span class="k">if</span> (<span class="i">tableGet</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>, <span class="i">name</span>, &amp;<span class="i">value</span>)) {
          <span class="i">pop</span>(); <span class="c">// Instance.</span>
          <span class="i">push</span>(<span class="i">value</span>);
          <span class="k">break</span>;
        }
      }
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Quand l&rsquo;interpréteur atteint cette instruction, l&rsquo;expression à la gauche du point a déjà été exécutée et l&rsquo;instance résultante est au sommet de la pile. Nous lisons le nom de champ depuis la table de constantes et le cherchons dans la table de champs de l&rsquo;instance. Si la table de hachage contient une entrée avec ce nom, nous dépilons l&rsquo;instance et empilons la valeur de l&rsquo;entrée comme le résultat.</p>
<p>Bien sûr, le champ pourrait ne pas exister. Dans Lox, nous avons défini cela comme étant une erreur d&rsquo;exécution. Donc nous ajoutons une vérification pour cela et avortons si cela arrive.</p>
<div class="codehilite"><pre class="insert-before">          push(value);
          break;
        }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">

        <span class="i">runtimeError</span>(<span class="s">&quot;Undefined property &#39;%s&#39;.&quot;</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
        <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
</pre><pre class="insert-after">      }
      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p><span name="field">Il</span> y a un autre mode d&rsquo;échec à gérer que vous avez probablement remarqué. Le code ci-dessus suppose que l&rsquo;expression à la gauche du point a bien évalué à une ObjInstance. Mais il n&rsquo;y a rien empêchant un utilisateur d&rsquo;écrire ceci :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">obj</span> = <span class="s">&quot;not an instance&quot;</span>;
<span class="k">print</span> <span class="i">obj</span>.<span class="i">field</span>;
</pre></div>
<p>Le programme de l&rsquo;utilisateur est faux, mais la VM doit quand même gérer cela avec quelque grâce. Juste maintenant, elle mésinterprétera les bits de l&rsquo;ObjString comme une ObjInstance et, je ne sais pas, prendra feu ou quelque chose définitivement pas gracieux.</p>
<p>Dans Lox, seules les instances sont permises d&rsquo;avoir des champs. Vous ne pouvez pas fourrer un champ sur une chaîne ou un nombre. Donc nous avons besoin de vérifier que la valeur est une instance avant d&rsquo;accéder à tout champ dessus.</p>
<aside name="field">
<p>Lox <em>pourrait</em> supporter l&rsquo;ajout de champs aux valeurs d&rsquo;autres types. C&rsquo;est notre langage et nous pouvons faire ce que nous voulons. Mais c&rsquo;est probablement une mauvaise idée. Cela complique significativement l&rsquo;implémentation de façons qui blessent la performance<span class="em">&mdash;</span>par exemple, l&rsquo;internement de chaîne devient beaucoup plus dur.</p>
<p>Aussi, cela soulève des questions sémantiques noueuses autour de l&rsquo;égalité et de l&rsquo;identité des valeurs. Si j&rsquo;attache un champ au nombre <code>3</code>, est-ce que le résultat de <code>1 + 2</code> a ce champ aussi ? Si oui, comment l&rsquo;implémentation suit-elle cela ? Si non, est-ce que ces deux &ldquo;trois&rdquo; résultants sont toujours considérés égaux ?</p>
</aside>
<div class="codehilite"><pre class="insert-before">      case OP_GET_PROPERTY: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="k">if</span> (!<span class="a">IS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">0</span>))) {
          <span class="i">runtimeError</span>(<span class="s">&quot;Only instances have properties.&quot;</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }

</pre><pre class="insert-after">        ObjInstance* instance = AS_INSTANCE(peek(0));
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Si la valeur sur la pile n&rsquo;est pas une instance, nous rapportons une erreur d&rsquo;exécution et sortons sûrement.</p>
<p>Bien sûr, les expressions get ne sont pas très utiles quand aucune instance n&rsquo;a de champs. Pour cela nous avons besoin des setters.</p>
<div class="codehilite"><pre class="insert-before">        return INTERPRET_RUNTIME_ERROR;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_SET_PROPERTY</span>: {
        <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">AS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">1</span>));
        <span class="i">tableSet</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>, <span class="a">READ_STRING</span>(), <span class="i">peek</span>(<span class="n">0</span>));
        <span class="t">Value</span> <span class="i">value</span> = <span class="i">pop</span>();
        <span class="i">pop</span>();
        <span class="i">push</span>(<span class="i">value</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Ceci est un peu plus complexe que <code>OP_GET_PROPERTY</code>. Quand cela s&rsquo;exécute, le sommet de la pile a l&rsquo;instance dont le champ est en train d&rsquo;être réglé et au-dessus de cela, la valeur à stocker. Comme avant, nous lisons l&rsquo;opérande de l&rsquo;instruction et trouvons la chaîne du nom de champ. Utilisant cela, nous stockons la valeur au sommet de la pile dans la table de champs de l&rsquo;instance.</p>
<p>Après cela est un peu de jonglerie de <span name="stack">pile</span>. Nous dépilons la valeur stockée, puis dépilons l&rsquo;instance, et finalement empilons la valeur de retour. En d&rsquo;autres termes, nous enlevons le <em>second</em> élément de la pile tout en laissant le sommet seul. Un setter est lui-même une expression dont le résultat est la valeur assignée, donc nous avons besoin de laisser cette valeur sur la pile. Voici ce que je veux dire :</p>
<aside name="stack">
<p>Les opérations de pile vont comme ceci :</p><img src="image/classes-and-instances/stack.png" alt="Dépilant deux valeurs et ensuite empilant la première valeur de retour sur la pile."/>
</aside>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Toast</span> {}
<span class="k">var</span> <span class="i">toast</span> = <span class="t">Toast</span>();
<span class="k">print</span> <span class="i">toast</span>.<span class="i">jam</span> = <span class="s">&quot;grape&quot;</span>; <span class="c">// Affiche &quot;grape&quot;.</span>
</pre></div>
<p>Contrairement à lors de la lecture d&rsquo;un champ, nous n&rsquo;avons pas besoin de nous inquiéter que la table de hachage ne contienne pas le champ. Un setter crée implicitement le champ si nécessaire. Nous avons besoin de gérer l&rsquo;utilisateur essayant incorrectement de stocker un champ sur une valeur qui n&rsquo;est pas une instance.</p>
<div class="codehilite"><pre class="insert-before">      case OP_SET_PROPERTY: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="k">if</span> (!<span class="a">IS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">1</span>))) {
          <span class="i">runtimeError</span>(<span class="s">&quot;Only instances have fields.&quot;</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }

</pre><pre class="insert-after">        ObjInstance* instance = AS_INSTANCE(peek(1));
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Exactement comme avec les expressions get, nous vérifions le type de la valeur et rapportons une erreur d&rsquo;exécution si c&rsquo;est invalide. Et, avec cela, le côté avec état du support de Lox pour la programmation orientée objet est en place. Donnez-lui un essai :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Pair</span> {}

<span class="k">var</span> <span class="i">pair</span> = <span class="t">Pair</span>();
<span class="i">pair</span>.<span class="i">first</span> = <span class="n">1</span>;
<span class="i">pair</span>.<span class="i">second</span> = <span class="n">2</span>;
<span class="k">print</span> <span class="i">pair</span>.<span class="i">first</span> + <span class="i">pair</span>.<span class="i">second</span>; <span class="c">// 3.</span>
</pre></div>
<p>Ceci ne se sent pas vraiment très orienté <em>objet</em>. C&rsquo;est plus comme une variante étrange, typée dynamiquement du C où les objets sont des sacs de données lâches semblables à des struct. Sorte d&rsquo;un langage procédural dynamique. Mais c&rsquo;est une grande étape en expressivité. Notre implémentation Lox laisse maintenant les utilisateurs agréger librement des données en de plus grandes unités. Dans le prochain chapitre, nous insufflerons la vie dans ces blobs inertes.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>27&#8202;.&#8202;5</small>Défis</a></h2>
<ol>
<li>
<p>Essayer d&rsquo;accéder à un champ inexistant sur un objet avorte immédiatement la VM entière. L&rsquo;utilisateur n&rsquo;a aucun moyen de récupérer de cette erreur d&rsquo;exécution, ni n&rsquo;y a-t-il aucun moyen de voir si un champ existe <em>avant</em> d&rsquo;essayer d&rsquo;y accéder. C&rsquo;est à l&rsquo;utilisateur d&rsquo;assurer par lui-même que seuls des champs valides sont lus.</p>
<p>Comment d&rsquo;autres langages typés dynamiquement gèrent-ils les champs manquants ? Que pensez-vous que Lox devrait faire ? Implémentez votre solution.</p>
</li>
<li>
<p>Les champs sont accédés à l&rsquo;exécution par leur nom de <em>chaîne</em>. Mais ce nom doit toujours apparaître directement dans le code source comme un <em>jeton identifiant</em>. Un programme utilisateur ne peut pas impérativement construire une valeur chaîne et ensuite utiliser cela comme le nom d&rsquo;un champ. Pensez-vous qu&rsquo;ils devraient être capables de le faire ? Concevez une fonctionnalité de langage qui permet cela et implémentez-la.</p>
</li>
<li>
<p>Inversement, Lox n&rsquo;offre aucun moyen d&rsquo;<em>enlever</em> un champ d&rsquo;une instance. Vous pouvez régler la valeur d&rsquo;un champ à <code>nil</code>, mais l&rsquo;entrée dans la table de hachage est toujours là. Comment d&rsquo;autres langages gèrent-ils cela ? Choisissez et implémentez une stratégie pour Lox.</p>
</li>
<li>
<p>Parce que les champs sont accédés par nom à l&rsquo;exécution, travailler avec l&rsquo;état d&rsquo;instance est lent. C&rsquo;est techniquement une opération en temps constant<span class="em">&mdash;</span>merci, tables de hachage<span class="em">&mdash;</span>mais les facteurs constants sont relativement grands. C&rsquo;est un composant majeur de pourquoi les langages dynamiques sont plus lents que ceux typés statiquement.</p>
<p>Comment les implémentations sophistiquées de langages typés dynamiquement gèrent-elles et optimisent-elles cela ?</p>
</li>
</ol>
</div>

<footer>
<a href="méthodes-et-initialisateurs.html" class="next">
  Next Chapter: &ldquo;Méthodes et initialisateurs&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
