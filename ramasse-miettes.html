<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Ramasse-miettes &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Ramasse-miettes<small>26</small></a></h3>

<ul>
    <li><a href="#accessibilité"><small>26.1</small> Accessibilité</a></li>
    <li><a href="#ramasse-miettes-mark-sweep"><small>26.2</small> Ramasse-miettes Mark-Sweep</a></li>
    <li><a href="#marquer-les-racines"><small>26.3</small> Marquer les Racines</a></li>
    <li><a href="#tracer-les-références-dobjet"><small>26.4</small> Tracer les Références d&#x27;Objet</a></li>
    <li><a href="#balayer-les-objets-inutilisés"><small>26.5</small> Balayer les Objets Inutilisés</a></li>
    <li><a href="#quand-collecter"><small>26.6</small> Quand Collecter</a></li>
    <li><a href="#bugs-de-ramasse-miettes"><small>26.7</small> Bugs de Ramasse-miettes</a></li>
    <li><a href="#défis"><small>26.8</small> Défis</a></li>
    <li><a href="#note-de-conception--collecteurs-générationnels"><small>26.9</small> Note de Conception : Collecteurs Générationnels</a></li>
</ul>


<div class="prev-next">
    <a href="fermetures.html" title="Fermetures" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="classes-et-instances.html" title="Classes et instances" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="fermetures.html" title="Fermetures" class="prev">←</a>
<a href="classes-et-instances.html" title="Classes et instances" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Ramasse-miettes<small>26</small></a></h3>

<ul>
    <li><a href="#accessibilité"><small>26.1</small> Accessibilité</a></li>
    <li><a href="#ramasse-miettes-mark-sweep"><small>26.2</small> Ramasse-miettes Mark-Sweep</a></li>
    <li><a href="#marquer-les-racines"><small>26.3</small> Marquer les Racines</a></li>
    <li><a href="#tracer-les-références-dobjet"><small>26.4</small> Tracer les Références d&#x27;Objet</a></li>
    <li><a href="#balayer-les-objets-inutilisés"><small>26.5</small> Balayer les Objets Inutilisés</a></li>
    <li><a href="#quand-collecter"><small>26.6</small> Quand Collecter</a></li>
    <li><a href="#bugs-de-ramasse-miettes"><small>26.7</small> Bugs de Ramasse-miettes</a></li>
    <li><a href="#défis"><small>26.8</small> Défis</a></li>
    <li><a href="#note-de-conception--collecteurs-générationnels"><small>26.9</small> Note de Conception : Collecteurs Générationnels</a></li>
</ul>


<div class="prev-next">
    <a href="fermetures.html" title="Fermetures" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="classes-et-instances.html" title="Classes et instances" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">26</div>
  <h1>Ramasse-miettes</h1>

<blockquote>
<p>I wanna, I wanna,<br />
I wanna, I wanna,<br />
I wanna be trash.<br /></p>
<p><cite>The Whip, &ldquo;Trash&rdquo;</cite></p>
</blockquote>
<p>Nous disons que Lox est un langage de &ldquo;haut niveau&rdquo; parce qu&rsquo;il libère les programmeurs de s&rsquo;inquiéter des détails non pertinents au problème qu&rsquo;ils résolvent. L&rsquo;utilisateur devient un exécutif, donnant à la machine des buts abstraits et laissant l&rsquo;humble ordinateur trouver comment y arriver.</p>
<p>L&rsquo;allocation dynamique de mémoire est un candidat parfait pour l&rsquo;automatisation. C&rsquo;est nécessaire pour un programme fonctionnel, fastidieux à faire à la main, et pourtant encore sujet aux erreurs. Les erreurs inévitables peuvent être catastrophiques, menant à des plantages, de la corruption de mémoire, ou des violations de sécurité. C&rsquo;est le genre de travail risqué-mais-ennuyeux auquel les machines excellent par rapport aux humains.</p>
<p>C&rsquo;est pourquoi Lox est un <strong>langage géré</strong>, ce qui signifie que l&rsquo;implémentation du langage gère l&rsquo;allocation mémoire et la libération au nom de l&rsquo;utilisateur. Quand un utilisateur effectue une opération qui requiert un peu de mémoire dynamique, la VM l&rsquo;alloue automatiquement. Le programmeur ne s&rsquo;inquiète jamais de désallouer quoi que ce soit. La machine assure que toute mémoire que le programme utilise reste dans les parages aussi longtemps que nécessaire.</p>
<p>Lox fournit l&rsquo;illusion que l&rsquo;ordinateur a une quantité infinie de mémoire. Les utilisateurs peuvent allouer et allouer et allouer et ne jamais une fois penser à d&rsquo;où tous ces octets viennent. Bien sûr, les ordinateurs n&rsquo;<em>ont</em> pas encore de mémoire infinie. Donc la façon dont les langages gérés maintiennent cette illusion est en allant dans le dos du programmeur et en réclamant la mémoire dont le programme n&rsquo;a plus besoin. Le composant qui fait cela est appelé un <strong>ramasse-miettes</strong> (garbage <span name="recycle">collector</span>).</p>
<aside name="recycle">
<p>Recyclage serait vraiment une meilleure métaphore pour cela. Le GC ne <em>jette pas</em> la mémoire, il la réclame pour être réutilisée pour de nouvelles données. Mais les langages gérés sont plus vieux que le Jour de la Terre, donc les inventeurs sont allés avec l&rsquo;analogie qu&rsquo;ils connaissaient.</p><img src="image/garbage-collection/recycle.png" class="above" alt="Une poubelle de recyclage pleine de bits." />
</aside>
<h2><a href="#accessibilité" id="accessibilité"><small>26&#8202;.&#8202;1</small>Accessibilité</a></h2>
<p>Cela soulève une question étonnamment difficile : comment une VM dit-elle quelle mémoire n&rsquo;est <em>pas</em> nécessaire ? La mémoire est seulement nécessaire si elle est lue dans le futur, mais à moins d&rsquo;avoir une machine à voyager dans le temps, comment une implémentation peut-elle dire quel code le programme <em>exécutera</em> et quelles données il <em>utilisera</em> ? Spoiler alert : les VMs ne peuvent pas voyager dans le futur. Au lieu de cela, le langage fait une approximation <span name="conservative">conservatrice</span> : il considère un morceau de mémoire comme étant encore utilisé s&rsquo;il <em>pourrait possiblement</em> être lu dans le futur.</p>
<aside name="conservative">
<p>J&rsquo;utilise &ldquo;conservateur&rdquo; dans le sens général. Il y a une chose telle qu&rsquo;un &ldquo;ramasse-miettes conservateur&rdquo; ce qui signifie quelque chose de plus spécifique. Tous les ramasse-miettes sont &ldquo;conservateurs&rdquo; en ce qu&rsquo;ils gardent la mémoire vivante si elle <em>pourrait</em> être accédée, au lieu d&rsquo;avoir une boule magique numéro 8 qui leur laisse savoir plus précisément quelles données <em>seront</em> accédées.</p>
<p>Un <strong>GC conservateur</strong> est une sorte spéciale de collecteur qui considère n&rsquo;importe quel morceau de mémoire comme un pointeur si la valeur dedans ressemble à ce qu&rsquo;elle pourrait être une adresse. C&rsquo;est en contraste avec un <strong>GC précis</strong><span class="em">&mdash;</span>qui est ce que nous implémenterons<span class="em">&mdash;</span>qui sait exactement quels mots en mémoire sont des pointeurs et lesquels stockent d&rsquo;autres sortes de valeurs comme des nombres ou des chaînes.</p>
</aside>
<p>Cela semble <em>trop</em> conservateur. <em>N&rsquo;importe quel</em> bout de mémoire ne pourrait-il pas potentiellement être lu ? En fait, non, au moins pas dans un langage sûr en mémoire comme Lox. Voici un exemple :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;first value&quot;</span>;
<span class="i">a</span> = <span class="s">&quot;updated&quot;</span>;
<span class="c">// GC here.</span>
<span class="k">print</span> <span class="i">a</span>;
</pre></div>
<p>Disons que nous courons le GC après que l&rsquo;assignation a complété sur la seconde ligne. La chaîne &ldquo;first value&rdquo; est encore assise en mémoire, mais il n&rsquo;y a aucun moyen pour le programme de l&rsquo;utilisateur d&rsquo;arriver à elle. Une fois que <code>a</code> a été réassigné, le programme a perdu toute référence à cette chaîne. Nous pouvons la libérer sûrement. Une valeur est <strong>accessible</strong> (reachable) s&rsquo;il y a quelque moyen pour un programme utilisateur de la référencer. Sinon, comme la chaîne &ldquo;first value&rdquo; ici, elle est <strong>inaccessible</strong> (unreachable).</p>
<p>Beaucoup de valeurs peuvent être directement accédées par la VM. Jetez un coup d&rsquo;œil à :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">global</span> = <span class="s">&quot;string&quot;</span>;
{
  <span class="k">var</span> <span class="i">local</span> = <span class="s">&quot;another&quot;</span>;
  <span class="k">print</span> <span class="i">global</span> + <span class="i">local</span>;
}
</pre></div>
<p>Mettez le programme en pause juste après que les deux chaînes ont été concaténées mais avant que l&rsquo;instruction <code>print</code> ait exécuté. La VM peut atteindre <code>"string"</code> en regardant à travers la table des variables globales et en trouvant l&rsquo;entrée pour <code>global</code>. Elle peut trouver <code>"another"</code> en marchant la pile de valeurs et en frappant l&rsquo;emplacement pour la variable locale <code>local</code>. Elle peut même trouver la chaîne concaténée <code>"stringanother"</code> puisque cette valeur temporaire est aussi assise sur la pile de la VM au point où nous avons pausé notre programme.</p>
<p>Toutes ces valeurs sont appelées des <strong>racines</strong>. Une racine est n&rsquo;importe quel objet que la VM peut atteindre directement sans passer par une référence dans quelque autre objet. La plupart des racines sont des variables globales ou sur la pile, mais comme nous verrons, il y a une paire d&rsquo;autres endroits où la VM stocke des références aux objets qu&rsquo;elle peut trouver.</p>
<p>D&rsquo;autres valeurs peuvent être trouvées en passant par une référence à l&rsquo;intérieur d&rsquo;une autre valeur. Les <span name="class">champs</span> sur les instances de classes sont le cas le plus évident, mais nous n&rsquo;avons pas ceux-là encore. Même sans ceux-là, notre VM a encore des références indirectes. Considérez :</p>
<aside name="class">
<p>Nous y arriverons <a href="classes-et-instances.html">bientôt</a>, cependant !</p>
</aside>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">makeClosure</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;data&quot;</span>;

  <span class="k">fun</span> <span class="i">f</span>() { <span class="k">print</span> <span class="i">a</span>; }
  <span class="k">return</span> <span class="i">f</span>;
}

{
  <span class="k">var</span> <span class="i">closure</span> = <span class="i">makeClosure</span>();
  <span class="c">// GC here.</span>
  <span class="i">closure</span>();
}
</pre></div>
<p>Disons que nous mettons en pause le programme sur la ligne marquée et courons le ramasse-miettes. Quand le collecteur a fini et que le programme reprend, il appellera la fermeture, qui appellera à son tour l&rsquo;affichage de <code>"data"</code>. Donc le collecteur a besoin de <em>ne pas</em> libérer cette chaîne. Mais voici à quoi la pile ressemble quand nous mettons en pause le programme :</p><img src="image/garbage-collection/stack.png" alt="La pile, contenant seulement le script et la fermeture." />
<p>La chaîne <code>"data"</code> n&rsquo;est nulle part dessus. Elle a déjà été hissée hors de la pile et déplacée dans l&rsquo;upvalue fermée que la fermeture utilise. La fermeture elle-même est sur la pile. Mais pour arriver à la chaîne, nous avons besoin de tracer à travers la fermeture et son tableau d&rsquo;upvalues. Puisqu&rsquo;il <em>est</em> possible pour le programme de l&rsquo;utilisateur de faire cela, tous ces objets indirectement accessibles sont aussi considérés accessibles.</p><img src="image/garbage-collection/reachable.png" class="wide" alt="Tous les objets référencés depuis la fermeture, et le chemin vers la chaîne 'data' depuis la pile." />
<p>Cela nous donne une définition inductive de l&rsquo;accessibilité :</p>
<ul>
<li>
<p>Toutes les racines sont accessibles.</p>
</li>
<li>
<p>N&rsquo;importe quel objet référé depuis un objet accessible est lui-même accessible.</p>
</li>
</ul>
<p>Ce sont les valeurs qui sont encore &ldquo;vivantes&rdquo; et ont besoin de rester en mémoire. Toute valeur qui ne <em>rencontre pas</em> cette définition est juste gibier pour le collecteur à moissonner. Cette paire récursive de règles laisse entendre un algorithme récursif que nous pouvons utiliser pour libérer la mémoire non nécessaire :</p>
<ol>
<li>
<p>Commençant avec les racines, traverser à travers les références d&rsquo;objet pour trouver l&rsquo;ensemble complet des objets accessibles.</p>
</li>
<li>
<p>Libérer tous les objets <em>pas</em> dans cet ensemble.</p>
</li>
</ol>
<p>Beaucoup d&rsquo;algorithmes de ramasse-miettes <span name="handbook">différents</span> sont en usage aujourd&rsquo;hui, mais ils suivent tous grossièrement cette même structure. Certains peuvent entremêler les étapes ou les mélanger, mais les deux opérations fondamentales sont là. Ils diffèrent surtout dans <em>comment</em> ils effectuent chaque étape.</p>
<aside name="handbook">
<p>Si vous voulez explorer d&rsquo;autres algorithmes de GC,
<a href="http://gchandbook.org/"><em>The Garbage Collection Handbook</em></a> (Jones, et al.) est la référence canonique. Pour un gros livre sur un tel sujet profond, étroit, il est assez agréable à lire. Ou peut-être j&rsquo;ai une idée étrange du fun.</p>
</aside>
<h2><a href="#ramasse-miettes-mark-sweep" id="ramasse-miettes-mark-sweep"><small>26&#8202;.&#8202;2</small>Ramasse-miettes Mark-Sweep</a></h2>
<p>Le premier langage géré fut Lisp, le second langage de &ldquo;haut niveau&rdquo; à être inventé, juste après Fortran. John McCarthy considéra utiliser la gestion manuelle de mémoire ou le comptage de références, mais s&rsquo;installa <span name="procrastination">éventuellement</span> sur (et inventa le terme) ramasse-miettes<span class="em">&mdash;</span>une fois que le programme était à court de mémoire, il retournerait en arrière et trouverait le stockage inutilisé qu&rsquo;il pourrait réclamer.</p>
<aside name="procrastination">
<p>Dans &ldquo;History of Lisp&rdquo; de John McCarthy, il note : &ldquo;Une fois que nous avons décidé sur le ramasse-miettes, son implémentation actuelle pouvait être reportée, parce que seulement des exemples jouets étaient faits.&rdquo; Notre choix de procrastiner l&rsquo;ajout du GC à clox suit dans les pas des géants.</p>
</aside>
<p>Il a conçu le tout premier, plus simple algorithme de ramasse-miettes, appelé <strong>mark-and-sweep</strong> (marquer-et-balayer) ou juste <strong>mark-sweep</strong>. Sa description tient dans trois courts paragraphes dans le papier initial sur Lisp. Malgré son âge et sa simplicité, le même algorithme fondamental sous-tend beaucoup de gestionnaires de mémoire modernes. Certains coins de l&rsquo;informatique semblent être intemporels.</p>
<p>Comme le nom l&rsquo;implique, le mark-sweep fonctionne en deux phases :</p>
<ul>
<li>
<p><strong>Marquage (Marking) :</strong> Nous commençons avec les racines et traversons ou <span name="trace"><em>traçons</em></span> à travers tous les objets auxquels ces racines se réfèrent. C&rsquo;est une traversée de graphe classique de tous les objets accessibles. Chaque fois que nous visitons un objet, nous le <em>marquons</em> de quelque manière. (Les implémentations diffèrent dans comment elles enregistrent la marque.)</p>
</li>
<li>
<p><strong>Balayage (Sweeping) :</strong> Une fois que la phase de marquage complète, chaque objet accessible dans le tas a été marqué. Cela signifie que tout objet non marqué est inaccessible et mûr pour la réclamation. Nous passons à travers tous les objets non marqués et libérons chacun d&rsquo;eux.</p>
</li>
</ul>
<p>Cela ressemble à quelque chose comme ceci :</p><img src="image/garbage-collection/mark-sweep.png" class="wide" alt="Commençant depuis un graphe d'objets, d'abord les accessibles sont marqués, les restants sont balayés, et ensuite seulement les accessibles restent." />
<aside name="trace">
<p>Un <strong>ramasse-miettes traceur</strong> est n&rsquo;importe quel algorithme qui trace à travers le graphe des références d&rsquo;objet. C&rsquo;est en contraste avec le comptage de références, qui a une stratégie différente pour suivre les objets accessibles.</p>
</aside>
<p>C&rsquo;est ce que nous allons implémenter. Chaque fois que nous décidons qu&rsquo;il est temps de réclamer quelques octets, nous tracerons tout et marquerons tous les objets accessibles, libérerons ce qui n&rsquo;a pas été marqué, et ensuite reprendrons le programme de l&rsquo;utilisateur.</p>
<h3><a href="#collecter-les-miettes" id="collecter-les-miettes"><small>26&#8202;.&#8202;2&#8202;.&#8202;1</small>Collecter les miettes</a></h3>
<p>Ce chapitre entier est à propos d&rsquo;implémenter cette <span name="one">fonction</span> unique :</p>
<aside name="one">
<p>Bien sûr, nous finirons par ajouter un tas de fonctions d&rsquo;aide aussi.</p>
</aside>
<div class="codehilite"><pre class="insert-before">void* reallocate(void* pointer, size_t oldSize, size_t newSize);
</pre><div class="source-file"><em>memory.h</em><br>
add after <em>reallocate</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">collectGarbage</span>();
</pre><pre class="insert-after">void freeObjects();
</pre></div>
<div class="source-file-narrow"><em>memory.h</em>, add after <em>reallocate</em>()</div>

<p>Nous travaillerons notre chemin vers une implémentation complète commençant avec cette coque vide :</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
add after <em>freeObject</em>()</div>
<pre><span class="t">void</span> <span class="i">collectGarbage</span>() {
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>freeObject</em>()</div>

<p>La première question que vous pourriez demander est, Quand cette fonction est-elle appelée ? Il s&rsquo;avère que c&rsquo;est une question subtile sur laquelle nous passerons un peu de temps plus tard dans le chapitre. Pour le moment nous esquiverons le problème et nous construirons un outil de diagnostic pratique dans le processus.</p>
<div class="codehilite"><pre class="insert-before">#define DEBUG_TRACE_EXECUTION
</pre><div class="source-file"><em>common.h</em></div>
<pre class="insert">

<span class="a">#define DEBUG_STRESS_GC</span>
</pre><pre class="insert-after">

#define UINT8_COUNT (UINT8_MAX + 1)
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>

<p>Nous ajouterons un mode optionnel &ldquo;stress test&rdquo; pour le ramasse-miettes. Quand ce drapeau est défini, le GC court aussi souvent qu&rsquo;il peut possiblement. C&rsquo;est, évidemment, horrifique pour la performance. Mais c&rsquo;est génial pour débusquer les bugs de gestion de mémoire qui se produisent seulement quand un GC est déclenché juste au bon moment. Si <em>chaque</em> moment déclenche un GC, vous êtes susceptibles de trouver ces bugs.</p>
<div class="codehilite"><pre class="insert-before">void* reallocate(void* pointer, size_t oldSize, size_t newSize) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>reallocate</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">newSize</span> &gt; <span class="i">oldSize</span>) {
<span class="a">#ifdef DEBUG_STRESS_GC</span>
    <span class="i">collectGarbage</span>();
<span class="a">#endif</span>
  }

</pre><pre class="insert-after">  if (newSize == 0) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>reallocate</em>()</div>

<p>Chaque fois que nous appelons <code>reallocate()</code> pour acquérir plus de mémoire, nous forçons une collection à courir. La vérification if est parce que <code>reallocate()</code> est aussi appelé pour libérer ou rétrécir une allocation. Nous ne voulons pas déclencher un GC pour cela<span class="em">&mdash;</span>en particulier parce que le GC lui-même appellera <code>reallocate()</code> pour libérer de la mémoire.</p>
<p>Collecter juste avant l&rsquo;<span name="demand">allocation</span> est la façon classique de câbler un GC dans une VM. Vous appelez déjà dans le gestionnaire de mémoire, donc c&rsquo;est un endroit facile pour accrocher le code. Aussi, l&rsquo;allocation est le seul moment où vous avez vraiment <em>besoin</em> de mémoire libérée pour que vous puissiez la réutiliser. Si vous n&rsquo;utilisez <em>pas</em> l&rsquo;allocation pour déclencher un GC, vous devez vous assurer que chaque endroit possible dans le code où vous pouvez boucler et allouer de la mémoire a aussi un moyen de déclencher le collecteur. Sinon, la VM peut entrer dans un état affamé où elle a besoin de plus de mémoire mais n&rsquo;en collecte jamais.</p>
<aside name="demand">
<p>Des collecteurs plus sophistiqués pourraient courir sur un fil séparé ou être entrelacés périodiquement durant l&rsquo;exécution du programme<span class="em">&mdash;</span>souvent aux frontières d&rsquo;appel de fonction ou quand un saut en arrière se produit.</p>
</aside>
<h3><a href="#journalisation-de-débogage" id="journalisation-de-débogage"><small>26&#8202;.&#8202;2&#8202;.&#8202;2</small>Journalisation de débogage</a></h3>
<p>Pendant que nous sommes sur le sujet des diagnostics, mettons-en un peu plus. Un vrai défi que j&rsquo;ai trouvé avec les ramasse-miettes est qu&rsquo;ils sont opaques. Nous avons couru des tas de programmes Lox juste bien sans aucun GC <em>du tout</em> jusqu&rsquo;ici. Une fois que nous en ajoutons un, comment disons-nous s&rsquo;il fait quoi que ce soit d&rsquo;utile ? Pouvons-nous dire seulement si nous écrivons des programmes qui labourent à travers des acres de mémoire ? Comment déboguons-nous cela ?</p>
<p>Un moyen facile de briller une lumière dans les fonctionnements internes du GC est avec un peu de journalisation.</p>
<div class="codehilite"><pre class="insert-before">#define DEBUG_STRESS_GC
</pre><div class="source-file"><em>common.h</em></div>
<pre class="insert"><span class="a">#define DEBUG_LOG_GC</span>
</pre><pre class="insert-after">

#define UINT8_COUNT (UINT8_MAX + 1)
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>

<p>Quand c&rsquo;est activé, clox affiche de l&rsquo;information sur la console quand il fait quelque chose avec la mémoire dynamique.</p>
<p>Nous avons besoin d&rsquo;une paire d&rsquo;includes.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;vm.h&quot;
</pre><div class="source-file"><em>memory.c</em></div>
<pre class="insert">

<span class="a">#ifdef DEBUG_LOG_GC</span>
<span class="a">#include &lt;stdio.h&gt;</span>
<span class="a">#include &quot;debug.h&quot;</span>
<span class="a">#endif</span>
</pre><pre class="insert-after">

void* reallocate(void* pointer, size_t oldSize, size_t newSize) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em></div>

<p>Nous n&rsquo;avons pas de collecteur encore, mais nous pouvons commencer à mettre dedans certaines des journalisations maintenant. Nous voudrons savoir quand une course de collection démarre.</p>
<div class="codehilite"><pre class="insert-before">void collectGarbage() {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>collectGarbage</em>()</div>
<pre class="insert"><span class="a">#ifdef DEBUG_LOG_GC</span>
  <span class="i">printf</span>(<span class="s">&quot;-- gc begin</span><span class="e">\n</span><span class="s">&quot;</span>);
<span class="a">#endif</span>
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>

<p>Éventuellement nous journaliserons quelques autres opérations durant la collection, donc nous voudrons aussi savoir quand le spectacle est fini.</p>
<div class="codehilite"><pre class="insert-before">  printf(&quot;-- gc begin\n&quot;);
#endif
</pre><div class="source-file"><em>memory.c</em><br>
in <em>collectGarbage</em>()</div>
<pre class="insert">

<span class="a">#ifdef DEBUG_LOG_GC</span>
  <span class="i">printf</span>(<span class="s">&quot;-- gc end</span><span class="e">\n</span><span class="s">&quot;</span>);
<span class="a">#endif</span>
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>

<p>Nous n&rsquo;avons aucun code pour le collecteur encore, mais nous avons bien des fonctions pour allouer et libérer, donc nous pouvons instrumenter celles-là maintenant.</p>
<div class="codehilite"><pre class="insert-before">  vm.objects = object;
</pre><div class="source-file"><em>object.c</em><br>
in <em>allocateObject</em>()</div>
<pre class="insert">

<span class="a">#ifdef DEBUG_LOG_GC</span>
  <span class="i">printf</span>(<span class="s">&quot;%p allocate %zu for %d</span><span class="e">\n</span><span class="s">&quot;</span>, (<span class="t">void</span>*)<span class="i">object</span>, <span class="i">size</span>, <span class="i">type</span>);
<span class="a">#endif</span>

</pre><pre class="insert-after">  return object;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>allocateObject</em>()</div>

<p>Et à la fin de la durée de vie d&rsquo;un objet :</p>
<div class="codehilite"><pre class="insert-before">static void freeObject(Obj* object) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert"><span class="a">#ifdef DEBUG_LOG_GC</span>
  <span class="i">printf</span>(<span class="s">&quot;%p free type %d</span><span class="e">\n</span><span class="s">&quot;</span>, (<span class="t">void</span>*)<span class="i">object</span>, <span class="i">object</span>-&gt;<span class="i">type</span>);
<span class="a">#endif</span>

</pre><pre class="insert-after">  switch (object-&gt;type) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>Avec ces deux drapeaux, nous devrions être capables de voir que nous faisons des progrès comme nous travaillons à travers le reste du chapitre.</p>
<h2><a href="#marquer-les-racines" id="marquer-les-racines"><small>26&#8202;.&#8202;3</small>Marquer les Racines</a></h2>
<p>Les objets sont dispersés à travers le tas comme des étoiles dans le ciel nocturne d&rsquo;encre. Une référence d&rsquo;un objet à un autre forme une connexion, et ces constellations sont le graphe que la phase de marquage traverse. Le marquage commence aux racines.</p>
<div class="codehilite"><pre class="insert-before">#ifdef DEBUG_LOG_GC
  printf(&quot;-- gc begin\n&quot;);
#endif
</pre><div class="source-file"><em>memory.c</em><br>
in <em>collectGarbage</em>()</div>
<pre class="insert">

  <span class="i">markRoots</span>();
</pre><pre class="insert-after">

#ifdef DEBUG_LOG_GC
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>

<p>La plupart des racines sont des variables locales ou temporaires assises juste dans la pile de la VM, donc nous commençons par marcher celle-là.</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
add after <em>freeObject</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">markRoots</span>() {
  <span class="k">for</span> (<span class="t">Value</span>* <span class="i">slot</span> = <span class="i">vm</span>.<span class="i">stack</span>; <span class="i">slot</span> &lt; <span class="i">vm</span>.<span class="i">stackTop</span>; <span class="i">slot</span>++) {
    <span class="i">markValue</span>(*<span class="i">slot</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>freeObject</em>()</div>

<p>Pour marquer une valeur Lox, nous utilisons cette nouvelle fonction :</p>
<div class="codehilite"><pre class="insert-before">void* reallocate(void* pointer, size_t oldSize, size_t newSize);
</pre><div class="source-file"><em>memory.h</em><br>
add after <em>reallocate</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">markValue</span>(<span class="t">Value</span> <span class="i">value</span>);
</pre><pre class="insert-after">void collectGarbage();
</pre></div>
<div class="source-file-narrow"><em>memory.h</em>, add after <em>reallocate</em>()</div>

<p>Son implémentation est ici :</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
add after <em>reallocate</em>()</div>
<pre><span class="t">void</span> <span class="i">markValue</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="k">if</span> (<span class="a">IS_OBJ</span>(<span class="i">value</span>)) <span class="i">markObject</span>(<span class="a">AS_OBJ</span>(<span class="i">value</span>));
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>reallocate</em>()</div>

<p>Certaines valeurs Lox<span class="em">&mdash;</span>nombres, Booléens, et <code>nil</code><span class="em">&mdash;</span>sont stockées directement en ligne dans Value et ne requièrent aucune allocation tas. Le ramasse-miettes n&rsquo;a pas besoin de s&rsquo;inquiéter à propos d&rsquo;elles du tout, donc la première chose que nous faisons est d&rsquo;assurer que la valeur est un objet tas réel. Si oui, le vrai travail se passe dans cette fonction :</p>
<div class="codehilite"><pre class="insert-before">void* reallocate(void* pointer, size_t oldSize, size_t newSize);
</pre><div class="source-file"><em>memory.h</em><br>
add after <em>reallocate</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">markObject</span>(<span class="t">Obj</span>* <span class="i">object</span>);
</pre><pre class="insert-after">void markValue(Value value);
</pre></div>
<div class="source-file-narrow"><em>memory.h</em>, add after <em>reallocate</em>()</div>

<p>Qui est définie ici :</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
add after <em>reallocate</em>()</div>
<pre><span class="t">void</span> <span class="i">markObject</span>(<span class="t">Obj</span>* <span class="i">object</span>) {
  <span class="k">if</span> (<span class="i">object</span> == <span class="a">NULL</span>) <span class="k">return</span>;
  <span class="i">object</span>-&gt;<span class="i">isMarked</span> = <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>reallocate</em>()</div>

<p>La vérification <code>NULL</code> est inutile quand appelée depuis <code>markValue()</code>. Une Value Lox qui est quelque sorte de type Obj aura toujours un pointeur valide. Mais plus tard nous appellerons cette fonction directement depuis d&rsquo;autres codes, et dans certains de ces endroits, l&rsquo;objet étant pointé est optionnel.</p>
<p>Supposant que nous avons bien un objet valide, nous le marquons en mettant un drapeau. Ce nouveau champ vit dans la structure d&rsquo;en-tête Obj que tous les objets partagent.</p>
<div class="codehilite"><pre class="insert-before">  ObjType type;
</pre><div class="source-file"><em>object.h</em><br>
in struct <em>Obj</em></div>
<pre class="insert">  <span class="t">bool</span> <span class="i">isMarked</span>;
</pre><pre class="insert-after">  struct Obj* next;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>Obj</em></div>

<p>Chaque nouvel objet commence sa vie non marqué parce que nous n&rsquo;avons pas encore déterminé s&rsquo;il est accessible ou non.</p>
<div class="codehilite"><pre class="insert-before">  object-&gt;type = type;
</pre><div class="source-file"><em>object.c</em><br>
in <em>allocateObject</em>()</div>
<pre class="insert">  <span class="i">object</span>-&gt;<span class="i">isMarked</span> = <span class="k">false</span>;
</pre><pre class="insert-after">

  object-&gt;next = vm.objects;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>allocateObject</em>()</div>

<p>Avant que nous allions plus loin, ajoutons un peu de journalisation à <code>markObject()</code>.</p>
<div class="codehilite"><pre class="insert-before">void markObject(Obj* object) {
  if (object == NULL) return;
</pre><div class="source-file"><em>memory.c</em><br>
in <em>markObject</em>()</div>
<pre class="insert"><span class="a">#ifdef DEBUG_LOG_GC</span>
  <span class="i">printf</span>(<span class="s">&quot;%p mark &quot;</span>, (<span class="t">void</span>*)<span class="i">object</span>);
  <span class="i">printValue</span>(<span class="a">OBJ_VAL</span>(<span class="i">object</span>));
  <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
<span class="a">#endif</span>

</pre><pre class="insert-after">  object-&gt;isMarked = true;
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markObject</em>()</div>

<p>De cette façon nous pouvons voir ce que la phase de marquage fait. Marquer la pile s&rsquo;occupe des variables locales et temporaires. L&rsquo;autre source principale de racines sont les variables globales.</p>
<div class="codehilite"><pre class="insert-before">    markValue(*slot);
  }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>markRoots</em>()</div>
<pre class="insert">

  <span class="i">markTable</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markRoots</em>()</div>

<p>Celles-là vivent dans une table de hachage possédée par la VM, donc nous déclarerons une autre fonction d&rsquo;aide pour marquer tous les objets dans une table.</p>
<div class="codehilite"><pre class="insert-before">ObjString* tableFindString(Table* table, const char* chars,
                           int length, uint32_t hash);
</pre><div class="source-file"><em>table.h</em><br>
add after <em>tableFindString</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">markTable</span>(<span class="t">Table</span>* <span class="i">table</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>table.h</em>, add after <em>tableFindString</em>()</div>

<p>Nous implémentons cela dans le module &ldquo;table&rdquo; ici :</p>
<div class="codehilite"><div class="source-file"><em>table.c</em><br>
add after <em>tableFindString</em>()</div>
<pre><span class="t">void</span> <span class="i">markTable</span>(<span class="t">Table</span>* <span class="i">table</span>) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">table</span>-&gt;<span class="i">capacity</span>; <span class="i">i</span>++) {
    <span class="t">Entry</span>* <span class="i">entry</span> = &amp;<span class="i">table</span>-&gt;<span class="i">entries</span>[<span class="i">i</span>];
    <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">entry</span>-&gt;<span class="i">key</span>);
    <span class="i">markValue</span>(<span class="i">entry</span>-&gt;<span class="i">value</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, add after <em>tableFindString</em>()</div>

<p>Assez direct. Nous marchons le tableau d&rsquo;entrées. Pour chacune, nous marquons sa valeur. Nous marquons aussi les chaînes clés pour chaque entrée puisque le GC gère ces chaînes aussi.</p>
<h3><a href="#racines-moins-évidentes" id="racines-moins-évidentes"><small>26&#8202;.&#8202;3&#8202;.&#8202;1</small>Racines moins évidentes</a></h3>
<p>Celles-là couvrent les racines auxquelles nous pensons typiquement<span class="em">&mdash;</span>les valeurs qui sont évidemment accessibles parce qu&rsquo;elles sont stockées dans des variables que le programme de l&rsquo;utilisateur peut voir. Mais la VM a quelques-uns de ses propres trous de cachette où elle écureuille des références à des valeurs qu&rsquo;elle accède directement.</p>
<p>La plupart de l&rsquo;état d&rsquo;appel de fonction vit dans la pile de valeurs, mais la VM maintient une pile séparée de CallFrames. Chaque CallFrame contient un pointeur vers la fermeture étant appelée. La VM utilise ces pointeurs pour accéder aux constantes et upvalues, donc ces fermetures ont besoin d&rsquo;être gardées autour aussi.</p>
<div class="codehilite"><pre class="insert-before">  }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>markRoots</em>()</div>
<pre class="insert">

  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">vm</span>.<span class="i">frameCount</span>; <span class="i">i</span>++) {
    <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">i</span>].<span class="i">closure</span>);
  }
</pre><pre class="insert-after">

  markTable(&amp;vm.globals);
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markRoots</em>()</div>

<p>Parlant d&rsquo;upvalues, la liste d&rsquo;upvalues ouvertes est un autre ensemble de valeurs que la VM peut atteindre directement.</p>
<div class="codehilite"><pre class="insert-before">  for (int i = 0; i &lt; vm.frameCount; i++) {
    markObject((Obj*)vm.frames[i].closure);
  }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>markRoots</em>()</div>
<pre class="insert">

  <span class="k">for</span> (<span class="t">ObjUpvalue</span>* <span class="i">upvalue</span> = <span class="i">vm</span>.<span class="i">openUpvalues</span>;
       <span class="i">upvalue</span> != <span class="a">NULL</span>;
       <span class="i">upvalue</span> = <span class="i">upvalue</span>-&gt;<span class="i">next</span>) {
    <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">upvalue</span>);
  }
</pre><pre class="insert-after">

  markTable(&amp;vm.globals);
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markRoots</em>()</div>

<p>Rappelez-vous aussi qu&rsquo;une collection peut commencer durant <em>n&rsquo;importe quelle</em> allocation. Ces allocations n&rsquo;arrivent pas juste pendant que le programme de l&rsquo;utilisateur court. Le compilateur lui-même attrape périodiquement de la mémoire depuis le tas pour les littéraux et la table des constantes. Si le GC court pendant que nous sommes au milieu de la compilation, alors toutes valeurs que le compilateur accède directement ont besoin d&rsquo;être traitées comme des racines aussi.</p>
<p>Pour garder le module compilateur proprement séparé du reste de la VM, nous ferons cela dans une fonction séparée.</p>
<div class="codehilite"><pre class="insert-before">  markTable(&amp;vm.globals);
</pre><div class="source-file"><em>memory.c</em><br>
in <em>markRoots</em>()</div>
<pre class="insert">  <span class="i">markCompilerRoots</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markRoots</em>()</div>

<p>C&rsquo;est déclaré ici :</p>
<div class="codehilite"><pre class="insert-before">ObjFunction* compile(const char* source);
</pre><div class="source-file"><em>compiler.h</em><br>
add after <em>compile</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">markCompilerRoots</span>();
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em>, add after <em>compile</em>()</div>

<p>Ce qui signifie que le module &ldquo;memory&rdquo; a besoin d&rsquo;un include.</p>
<div class="codehilite"><pre class="insert-before">#include &lt;stdlib.h&gt;

</pre><div class="source-file"><em>memory.c</em></div>
<pre class="insert"><span class="a">#include &quot;compiler.h&quot;</span>
</pre><pre class="insert-after">#include &quot;memory.h&quot;
</pre></div>
<div class="source-file-narrow"><em>memory.c</em></div>

<p>Et la définition est là-bas dans le module &ldquo;compiler&rdquo;.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>compile</em>()</div>
<pre><span class="t">void</span> <span class="i">markCompilerRoots</span>() {
  <span class="t">Compiler</span>* <span class="i">compiler</span> = <span class="i">current</span>;
  <span class="k">while</span> (<span class="i">compiler</span> != <span class="a">NULL</span>) {
    <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">compiler</span>-&gt;<span class="i">function</span>);
    <span class="i">compiler</span> = <span class="i">compiler</span>-&gt;<span class="i">enclosing</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>compile</em>()</div>

<p>Heureusement, le compilateur n&rsquo;a pas trop de valeurs auxquelles il s&rsquo;accroche. Le seul objet qu&rsquo;il utilise est l&rsquo;ObjFunction dans lequel il compile. Puisque les déclarations de fonction peuvent s&rsquo;imbriquer, le compilateur a une liste chaînée de celles-ci et nous marchons la liste entière.</p>
<p>Puisque le module &ldquo;compiler&rdquo; appelle <code>markObject()</code>, il a aussi besoin d&rsquo;un include.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;compiler.h&quot;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert"><span class="a">#include &quot;memory.h&quot;</span>
</pre><pre class="insert-after">#include &quot;scanner.h&quot;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>Ce sont toutes les racines. Après avoir couru cela, chaque objet que la VM<span class="em">&mdash;</span>runtime et compilateur<span class="em">&mdash;</span>peut atteindre <em>sans</em> passer par quelque autre objet a son bit de marque mis.</p>
<h2><a href="#tracer-les-références-dobjet" id="tracer-les-références-dobjet"><small>26&#8202;.&#8202;4</small>Tracer les Références d&rsquo;Objet</a></h2>
<p>L&rsquo;étape suivante dans le processus de marquage est de tracer à travers le graphe des références entre les objets pour trouver les valeurs indirectement accessibles. Nous n&rsquo;avons pas d&rsquo;instances avec des champs encore, donc il n&rsquo;y a pas beaucoup d&rsquo;objets qui contiennent des références, mais nous en avons <span name="some">quelques-uns</span>. En particulier, ObjClosure a la liste des ObjUpvalues sur lesquels il ferme ainsi qu&rsquo;une référence à l&rsquo;ObjFunction brut qu&rsquo;il enveloppe. ObjFunction, à son tour, a une table constante empaquetée pleine de références vers tous les littéraux créés dans le corps de la fonction. C&rsquo;est assez pour construire une toile d&rsquo;objets assez complexe pour le collecteur à travers laquelle ramper.</p>
<aside name="some">
<p>J&rsquo;ai inséré ce chapitre dans le livre juste ici spécifiquement <em>parce que</em> nous avons maintenant des fermetures qui nous donnent des objets intéressants pour le ramasse-miettes à traiter.</p>
</aside>
<p>Maintenant il est temps d&rsquo;implémenter cette traversée. Nous pouvons aller en largeur d&rsquo;abord, en profondeur d&rsquo;abord, ou dans quelque autre ordre. Puisque nous avons juste besoin de trouver l&rsquo;<em>ensemble</em> de tous les objets accessibles, l&rsquo;ordre dans lequel nous les visitons <span name="dfs">surtout</span> n&rsquo;importe pas.</p>
<aside name="dfs">
<p>Je dis &ldquo;surtout&rdquo; parce que certains ramasse-miettes déplacent les objets dans l&rsquo;ordre où ils sont visités, donc l&rsquo;ordre de traversée détermine quels objets finissent adjacents en mémoire. Cela impacte la performance parce que le CPU utilise la localité pour déterminer quelle mémoire précharger dans les caches.</p>
<p>Même quand l&rsquo;ordre de traversée importe, il n&rsquo;est pas clair quel ordre est le <em>meilleur</em>. Il est très difficile de déterminer dans quel ordre les objets seront utilisés dans le futur, donc il est dur pour le GC de savoir quel ordre aidera la performance.</p>
</aside>
<h3><a href="#labstraction-tricolore" id="labstraction-tricolore"><small>26&#8202;.&#8202;4&#8202;.&#8202;1</small>L&rsquo;abstraction tricolore</a></h3>
<p>Comme le collecteur erre à travers le graphe d&rsquo;objets, nous avons besoin de nous assurer qu&rsquo;il ne perd pas la trace de où il est ou ne reste pas coincé à aller en cercles. C&rsquo;est particulièrement une préoccupation pour les implémentations avancées comme les GCs incrémentaux qui entremêlent le marquage avec l&rsquo;exécution de morceaux du programme de l&rsquo;utilisateur. Le collecteur a besoin d&rsquo;être capable de mettre en pause et ensuite reprendre où il s&rsquo;est arrêté plus tard.</p>
<p>Pour nous aider humains au cerveau mou à raisonner sur ce processus complexe, les hackers de VM sont venus avec une métaphore appelée l&rsquo;<span name="color"></span><strong>abstraction tricolore</strong> (tricolor abstraction). Chaque objet a une &ldquo;couleur&rdquo; conceptuelle qui suit dans quel état l&rsquo;objet est, et quel travail est laissé à faire.</p>
<aside name="color">
<p>Les algorithmes de ramasse-miettes avancés ajoutent souvent d&rsquo;autres couleurs à l&rsquo;abstraction. J&rsquo;ai vu de multiples nuances de gris, et même pourpre dans certaines conceptions. Mon papier de collecteur puce-chartreuse-fuchsia-malachite n&rsquo;a, hélas, pas été accepté pour publication.</p>
</aside>
<ul>
<li>
<p><strong><img src="image/garbage-collection/white.png" alt="Un cercle blanc." class="dot" /> Blanc :</strong> Au début d&rsquo;un ramasse-miettes, chaque objet est blanc. Cette couleur signifie que nous n&rsquo;avons pas atteint ou traité l&rsquo;objet du tout.</p>
</li>
<li>
<p><strong><img src="image/garbage-collection/gray.png" alt="Un cercle gris." class="dot" /> Gris :</strong> Durant le marquage, quand nous atteignons d&rsquo;abord un objet, nous l&rsquo;assombrissons en gris. Cette couleur signifie que nous savons que l&rsquo;objet lui-même est accessible et ne devrait pas être collecté. Mais nous n&rsquo;avons pas encore tracé <em>à travers</em> lui pour voir quels <em>autres</em> objets il référence. En termes d&rsquo;algorithme de graphe, c&rsquo;est la <em>worklist</em> (liste de travail)<span class="em">&mdash;</span>l&rsquo;ensemble des objets que nous connaissons mais n&rsquo;avons pas traités encore.</p>
</li>
<li>
<p><strong><img src="image/garbage-collection/black.png" alt="Un cercle noir." class="dot" /> Noir :</strong> Quand nous prenons un objet gris et marquons tous les objets qu&rsquo;il référence, nous tournons alors l&rsquo;objet gris en noir. Cette couleur signifie que la phase de marquage a fini de traiter cet objet.</p>
</li>
</ul>
<p>En termes de cette abstraction, le processus de marquage ressemble maintenant à ceci :</p>
<ol>
<li>
<p>Démarrer avec tous les objets blancs.</p>
</li>
<li>
<p>Trouver toutes les racines et les marquer grises.</p>
</li>
<li>
<p>Répéter tant qu&rsquo;il y a encore des objets gris :</p>
<ol>
<li>
<p>Prendre un objet gris. Tourner tous objets blancs que l&rsquo;objet mentionne en gris.</p>
</li>
<li>
<p>Marquer l&rsquo;objet gris original en noir.</p>
</li>
</ol>
</li>
</ol>
<p>Je trouve que cela aide de visualiser ceci. Vous avez une toile d&rsquo;objets avec des références entre eux. Initialement, ils sont tous de petits points blancs. Sur le côté sont quelques arêtes entrantes depuis la VM qui pointent vers les racines. Ces racines tournent gris. Ensuite les frères et sœurs de chaque objet gris tournent gris tandis que l&rsquo;objet lui-même tourne noir. L&rsquo;effet complet est un front d&rsquo;onde gris qui passe à travers le graphe, laissant un champ d&rsquo;objets noirs accessibles derrière lui. Les objets inaccessibles ne sont pas touchés par le front d&rsquo;onde et restent blancs.</p><img src="image/garbage-collection/tricolor-trace.png" class="wide" alt="Un front d'onde gris travaillant à travers un graphe de nœuds." />
<p>À la <span name="invariant">fin</span>, vous êtes laissés avec une mer d&rsquo;objets noirs, atteints saupoudrée avec des îles d&rsquo;objets blancs qui peuvent être balayés et libérés. Une fois que les objets inaccessibles sont libérés, les objets restants<span class="em">&mdash;</span>tous noirs<span class="em">&mdash;</span>sont remis à zéro à blanc pour le prochain cycle de ramasse-miettes.</p>
<aside name="invariant">
<p>Notez qu&rsquo;à chaque étape de ce processus aucun nœud noir ne pointe jamais vers un nœud blanc. Cette propriété est appelée l&rsquo;<strong>invariant tricolore</strong>. Le processus de traversée maintient cet invariant pour assurer qu&rsquo;aucun objet accessible n&rsquo;est jamais collecté.</p>
</aside>
<h3><a href="#une-liste-de-travail-pour-les-objets-gris" id="une-liste-de-travail-pour-les-objets-gris"><small>26&#8202;.&#8202;4&#8202;.&#8202;2</small>Une liste de travail pour les objets gris</a></h3>
<p>Dans notre implémentation nous avons déjà marqué les racines. Elles sont toutes grises. L&rsquo;étape suivante est de commencer à les prendre et traverser leurs références. Mais nous n&rsquo;avons aucun moyen facile de les trouver. Nous mettons un champ sur l&rsquo;objet, mais c&rsquo;est tout. Nous ne voulons pas avoir à traverser la liste d&rsquo;objets entière cherchant des objets avec ce champ mis.</p>
<p>Au lieu de cela, nous créerons une liste de travail séparée pour garder trace de tous les objets gris. Quand un objet tourne gris, en plus de mettre le champ de marque nous l&rsquo;ajouterons aussi à la liste de travail.</p>
<div class="codehilite"><pre class="insert-before">  object-&gt;isMarked = true;
</pre><div class="source-file"><em>memory.c</em><br>
in <em>markObject</em>()</div>
<pre class="insert">

  <span class="k">if</span> (<span class="i">vm</span>.<span class="i">grayCapacity</span> &lt; <span class="i">vm</span>.<span class="i">grayCount</span> + <span class="n">1</span>) {
    <span class="i">vm</span>.<span class="i">grayCapacity</span> = <span class="a">GROW_CAPACITY</span>(<span class="i">vm</span>.<span class="i">grayCapacity</span>);
    <span class="i">vm</span>.<span class="i">grayStack</span> = (<span class="t">Obj</span>**)<span class="i">realloc</span>(<span class="i">vm</span>.<span class="i">grayStack</span>,
                                  <span class="k">sizeof</span>(<span class="t">Obj</span>*) * <span class="i">vm</span>.<span class="i">grayCapacity</span>);
  }

  <span class="i">vm</span>.<span class="i">grayStack</span>[<span class="i">vm</span>.<span class="i">grayCount</span>++] = <span class="i">object</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markObject</em>()</div>

<p>Nous pourrions utiliser n&rsquo;importe quelle sorte de structure de données qui nous laisse mettre des éléments dedans et les sortir facilement. J&rsquo;ai pris une pile parce que c&rsquo;est le plus simple à implémenter avec un tableau dynamique en C. Cela fonctionne surtout comme d&rsquo;autres tableaux dynamiques que nous avons construits dans Lox, <em>sauf</em>, notez qu&rsquo;il appelle la fonction <code>realloc()</code> du <em>système</em> et pas notre propre enveloppe <code>reallocate()</code>. La mémoire pour la pile grise elle-même n&rsquo;est <em>pas</em> gérée par le ramasse-miettes. Nous ne voulons pas que faire grandir la pile grise durant un GC cause le GC à démarrer récursivement un nouveau GC. Cela pourrait déchirer un trou dans le continuum espace-temps.</p>
<p>Nous gérerons sa mémoire nous-mêmes, explicitement. La VM possède la pile grise.</p>
<div class="codehilite"><pre class="insert-before">  Obj* objects;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">int</span> <span class="i">grayCount</span>;
  <span class="t">int</span> <span class="i">grayCapacity</span>;
  <span class="t">Obj</span>** <span class="i">grayStack</span>;
</pre><pre class="insert-after">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>Elle commence vide.</p>
<div class="codehilite"><pre class="insert-before">  vm.objects = NULL;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">

  <span class="i">vm</span>.<span class="i">grayCount</span> = <span class="n">0</span>;
  <span class="i">vm</span>.<span class="i">grayCapacity</span> = <span class="n">0</span>;
  <span class="i">vm</span>.<span class="i">grayStack</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">

  initTable(&amp;vm.globals);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>Et nous avons besoin de la libérer quand la VM s&rsquo;arrête.</p>
<div class="codehilite"><pre class="insert-before">    object = next;
  }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObjects</em>()</div>
<pre class="insert">

  <span class="i">free</span>(<span class="i">vm</span>.<span class="i">grayStack</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObjects</em>()</div>

<p><span name="robust">Nous</span> prenons pleine responsabilité pour ce tableau. Cela inclut l&rsquo;échec d&rsquo;allocation. Si nous ne pouvons pas créer ou faire grandir la pile grise, alors nous ne pouvons pas finir le ramasse-miettes. C&rsquo;est de mauvaises nouvelles pour la VM, mais heureusement rare puisque la pile grise tend à être assez petite. Ce serait bien de faire quelque chose de plus gracieux, mais pour garder le code dans ce livre simple, nous avortons juste.</p>
<aside name="robust">
<p>Pour être plus robuste, nous pouvons allouer un bloc de mémoire &ldquo;fonds pour les mauvais jours&rdquo; quand nous démarrons la VM. Si l&rsquo;allocation de la pile grise échoue, nous libérons le bloc mauvais jours et essayons encore. Cela peut nous donner assez de marge de manœuvre sur le tas pour créer la pile grise, finir le GC, et libérer plus de mémoire.</p>
</aside>
<div class="codehilite"><pre class="insert-before">    vm.grayStack = (Obj**)realloc(vm.grayStack,
                                  sizeof(Obj*) * vm.grayCapacity);
</pre><div class="source-file"><em>memory.c</em><br>
in <em>markObject</em>()</div>
<pre class="insert">

    <span class="k">if</span> (<span class="i">vm</span>.<span class="i">grayStack</span> == <span class="a">NULL</span>) <span class="i">exit</span>(<span class="n">1</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markObject</em>()</div>

<h3><a href="#traiter-les-objets-gris" id="traiter-les-objets-gris"><small>26&#8202;.&#8202;4&#8202;.&#8202;3</small>Traiter les objets gris</a></h3>
<p>OK, maintenant quand nous avons fini de marquer les racines, nous avons à la fois mis un tas de champs et rempli notre liste de travail avec des objets à mâcher. C&rsquo;est le moment pour la phase suivante.</p>
<div class="codehilite"><pre class="insert-before">  markRoots();
</pre><div class="source-file"><em>memory.c</em><br>
in <em>collectGarbage</em>()</div>
<pre class="insert">  <span class="i">traceReferences</span>();
</pre><pre class="insert-after">

#ifdef DEBUG_LOG_GC
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>

<p>Voici l&rsquo;implémentation :</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
add after <em>markRoots</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">traceReferences</span>() {
  <span class="k">while</span> (<span class="i">vm</span>.<span class="i">grayCount</span> &gt; <span class="n">0</span>) {
    <span class="t">Obj</span>* <span class="i">object</span> = <span class="i">vm</span>.<span class="i">grayStack</span>[--<span class="i">vm</span>.<span class="i">grayCount</span>];
    <span class="i">blackenObject</span>(<span class="i">object</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>markRoots</em>()</div>

<p>C&rsquo;est aussi proche de cet algorithme textuel que vous pouvez obtenir. Jusqu&rsquo;à ce que la pile se vide, nous continuons de tirer des objets gris, traversant leurs références, et ensuite les marquant noirs. Traverser les références d&rsquo;un objet peut faire apparaître de nouveaux objets blancs qui deviennent marqués gris et ajoutés à la pile. Donc cette fonction oscille en avant et en arrière entre tourner les objets blancs gris et les objets gris noirs, avançant graduellement le front d&rsquo;onde entier vers l&rsquo;avant.</p>
<p>C&rsquo;est ici que nous traversons les références d&rsquo;un objet unique :</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
add after <em>markValue</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">blackenObject</span>(<span class="t">Obj</span>* <span class="i">object</span>) {
  <span class="k">switch</span> (<span class="i">object</span>-&gt;<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">OBJ_NATIVE</span>:
    <span class="k">case</span> <span class="a">OBJ_STRING</span>:
      <span class="k">break</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>markValue</em>()</div>

<p>Chaque <span name="leaf">sorte</span> d&rsquo;objet a différents champs qui pourraient référencer d&rsquo;autres objets, donc nous avons besoin d&rsquo;un bloc de code spécifique pour chaque type. Nous commençons avec les faciles<span class="em">&mdash;</span>chaînes et objets de fonction native ne contiennent aucune référence sortante donc il n&rsquo;y a rien à traverser.</p>
<aside name="leaf">
<p>Une optimisation facile que nous pourrions faire dans <code>markObject()</code> est de sauter l&rsquo;ajout de chaînes et fonctions natives à la pile grise du tout puisque nous savons qu&rsquo;elles n&rsquo;ont pas besoin d&rsquo;être traitées. Au lieu de cela, elles pourraient s&rsquo;assombrir de blanc directement à noir.</p>
</aside>
<p>Notez que nous ne mettons aucun état dans l&rsquo;objet traversé lui-même. Il n&rsquo;y a pas d&rsquo;encodage direct de &ldquo;noir&rdquo; dans l&rsquo;état de l&rsquo;objet. Un objet noir est n&rsquo;importe quel objet dont le champ <code>isMarked</code> est <span name="field">mis</span> et qui n&rsquo;est plus dans la pile grise.</p>
<aside name="field">
<p>Vous pouvez justement vous demander pourquoi nous avons le champ <code>isMarked</code> du tout. Tout en bon temps, ami.</p>
</aside>
<p>Maintenant commençons à ajouter dedans les autres types d&rsquo;objet. Le plus simple est les upvalues.</p>
<div class="codehilite"><pre class="insert-before">static void blackenObject(Obj* object) {
  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_UPVALUE</span>:
      <span class="i">markValue</span>(((<span class="t">ObjUpvalue</span>*)<span class="i">object</span>)-&gt;<span class="i">closed</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_NATIVE:
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>Quand une upvalue est fermée, elle contient une référence à la valeur fermée. Puisque la valeur n&rsquo;est plus sur la pile, nous avons besoin de nous assurer que nous traçons la référence à elle depuis l&rsquo;upvalue.</p>
<p>Ensuite sont les fonctions.</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_FUNCTION</span>: {
      <span class="t">ObjFunction</span>* <span class="i">function</span> = (<span class="t">ObjFunction</span>*)<span class="i">object</span>;
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">function</span>-&gt;<span class="i">name</span>);
      <span class="i">markArray</span>(&amp;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">constants</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_UPVALUE:
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>Chaque fonction a une référence à un ObjString contenant le nom de la fonction. Plus important, la fonction a une table constante empaquetée pleine de références à d&rsquo;autres objets. Nous traçons tous ceux-là en utilisant cet assistant :</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
add after <em>markValue</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">markArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">array</span>-&gt;<span class="i">count</span>; <span class="i">i</span>++) {
    <span class="i">markValue</span>(<span class="i">array</span>-&gt;<span class="i">values</span>[<span class="i">i</span>]);
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>markValue</em>()</div>

<p>Le dernier type d&rsquo;objet que nous avons maintenant<span class="em">&mdash;</span>nous en ajouterons plus dans les chapitres suivants<span class="em">&mdash;</span>est les fermetures.</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_CLOSURE</span>: {
      <span class="t">ObjClosure</span>* <span class="i">closure</span> = (<span class="t">ObjClosure</span>*)<span class="i">object</span>;
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">closure</span>-&gt;<span class="i">function</span>);
      <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">closure</span>-&gt;<span class="i">upvalueCount</span>; <span class="i">i</span>++) {
        <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">closure</span>-&gt;<span class="i">upvalues</span>[<span class="i">i</span>]);
      }
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_FUNCTION: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>Chaque fermeture a une référence à la fonction nue qu&rsquo;elle enveloppe, aussi bien qu&rsquo;un tableau de pointeurs vers les upvalues qu&rsquo;elle capture. Nous traçons tous ceux-là.</p>
<p>C&rsquo;est le mécanisme de base pour traiter un objet gris, mais il y a deux bouts lâches à attacher. D&rsquo;abord, un peu de journalisation.</p>
<div class="codehilite"><pre class="insert-before">static void blackenObject(Obj* object) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert"><span class="a">#ifdef DEBUG_LOG_GC</span>
  <span class="i">printf</span>(<span class="s">&quot;%p blacken &quot;</span>, (<span class="t">void</span>*)<span class="i">object</span>);
  <span class="i">printValue</span>(<span class="a">OBJ_VAL</span>(<span class="i">object</span>));
  <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
<span class="a">#endif</span>

</pre><pre class="insert-after">  switch (object-&gt;type) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>De cette façon, nous pouvons regarder le traçage percoler à travers le graphe d&rsquo;objets. Parlant de quoi, notez que j&rsquo;ai dit <em>graphe</em>. Les références entre objets sont dirigées, mais cela ne signifie pas qu&rsquo;elles sont <em>acycliques !</em> Il est entièrement possible d&rsquo;avoir des cycles d&rsquo;objets. Quand cela arrive, nous avons besoin d&rsquo;assurer que notre collecteur ne reste pas coincé dans une boucle infinie comme il ré-ajoute continuellement la même série d&rsquo;objets à la pile grise.</p>
<p>La correction est facile.</p>
<div class="codehilite"><pre class="insert-before">  if (object == NULL) return;
</pre><div class="source-file"><em>memory.c</em><br>
in <em>markObject</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">object</span>-&gt;<span class="i">isMarked</span>) <span class="k">return</span>;

</pre><pre class="insert-after">#ifdef DEBUG_LOG_GC
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markObject</em>()</div>

<p>Si l&rsquo;objet est déjà marqué, nous ne le marquons pas encore et ainsi ne l&rsquo;ajoutons pas à la pile grise. Cela assure qu&rsquo;un objet déjà gris n&rsquo;est pas ajouté de façon redondante et qu&rsquo;un objet noir n&rsquo;est pas tourné par inadvertance de retour à gris. En d&rsquo;autres termes, cela garde le front d&rsquo;onde en mouvement vers l&rsquo;avant à travers seulement les objets blancs.</p>
<h2><a href="#balayer-les-objets-inutilisés" id="balayer-les-objets-inutilisés"><small>26&#8202;.&#8202;5</small>Balayer les Objets Inutilisés</a></h2>
<p>Quand la boucle dans <code>traceReferences()</code> sort, nous avons traité tous les objets sur lesquels nous pouvions mettre nos mains. La pile grise est vide, et chaque objet dans le tas est soit noir soit blanc. Les objets noirs sont accessibles, et nous voulons nous accrocher à eux. Tout ce qui est encore blanc n&rsquo;a jamais été touché par la trace et est ainsi déchet. Tout ce qui reste est de les réclamer.</p>
<div class="codehilite"><pre class="insert-before">  traceReferences();
</pre><div class="source-file"><em>memory.c</em><br>
in <em>collectGarbage</em>()</div>
<pre class="insert">  <span class="i">sweep</span>();
</pre><pre class="insert-after">

#ifdef DEBUG_LOG_GC
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>

<p>Toute la logique vit dans une fonction.</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
add after <em>traceReferences</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">sweep</span>() {
  <span class="t">Obj</span>* <span class="i">previous</span> = <span class="a">NULL</span>;
  <span class="t">Obj</span>* <span class="i">object</span> = <span class="i">vm</span>.<span class="i">objects</span>;
  <span class="k">while</span> (<span class="i">object</span> != <span class="a">NULL</span>) {
    <span class="k">if</span> (<span class="i">object</span>-&gt;<span class="i">isMarked</span>) {
      <span class="i">previous</span> = <span class="i">object</span>;
      <span class="i">object</span> = <span class="i">object</span>-&gt;<span class="i">next</span>;
    } <span class="k">else</span> {
      <span class="t">Obj</span>* <span class="i">unreached</span> = <span class="i">object</span>;
      <span class="i">object</span> = <span class="i">object</span>-&gt;<span class="i">next</span>;
      <span class="k">if</span> (<span class="i">previous</span> != <span class="a">NULL</span>) {
        <span class="i">previous</span>-&gt;<span class="i">next</span> = <span class="i">object</span>;
      } <span class="k">else</span> {
        <span class="i">vm</span>.<span class="i">objects</span> = <span class="i">object</span>;
      }

      <span class="i">freeObject</span>(<span class="i">unreached</span>);
    }
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>traceReferences</em>()</div>

<p>Je sais que c&rsquo;est en quelque sorte beaucoup de code et de manigances de pointeur, mais il n&rsquo;y a pas grand-chose dedans une fois que vous travaillez à travers. La boucle extérieure <code>while</code> marche la liste chaînée de chaque objet dans le tas, vérifiant leurs bits de marque. Si un objet est marqué (noir), nous le laissons seul et continuons passé lui. S&rsquo;il est non marqué (blanc), nous le délions de la liste et le libérons en utilisant la fonction <code>freeObject()</code> que nous avons déjà écrite.</p><img src="image/garbage-collection/unlink.png" alt="Une poubelle de recyclage pleine de bits." />
<p>La plupart de l&rsquo;autre code ici s&rsquo;occupe du fait que retirer un nœud d&rsquo;une liste unilatéralement chaînée est encombrant. Nous devons continuellement nous souvenir du nœud précédent pour que nous puissions délier son pointeur suivant, et nous devons gérer le cas limite où nous libérons le premier nœud. Mais, sinon, c&rsquo;est assez simple<span class="em">&mdash;</span>supprimer chaque nœud dans une liste chaînée qui n&rsquo;a pas un bit mis dedans.</p>
<p>Il y a un petit ajout :</p>
<div class="codehilite"><pre class="insert-before">    if (object-&gt;isMarked) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>sweep</em>()</div>
<pre class="insert">      <span class="i">object</span>-&gt;<span class="i">isMarked</span> = <span class="k">false</span>;
</pre><pre class="insert-after">      previous = object;
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>sweep</em>()</div>

<p>Après que <code>sweep()</code> complète, les seuls objets restants sont les noirs vivants avec leurs bits de marque mis. C&rsquo;est correct, mais quand le <em>prochain</em> cycle de collection démarre, nous avons besoin que chaque objet soit blanc. Donc chaque fois que nous atteignons un objet noir, nous allons de l&rsquo;avant et effaçons le bit maintenant en anticipation de la prochaine course.</p>
<h3><a href="#références-faibles-et-la-piscine-de-chaînes" id="références-faibles-et-la-piscine-de-chaînes"><small>26&#8202;.&#8202;5&#8202;.&#8202;1</small>Références faibles et la piscine de chaînes</a></h3>
<p>Nous avons presque fini de collecter. Il reste un coin restant de la VM qui a quelques exigences inhabituelles autour de la mémoire. Rappelez-vous que quand nous avons ajouté les chaînes à clox nous avons fait que la VM les interne toutes. Cela signifie que la VM a une table de hachage contenant un pointeur vers chaque chaîne unique dans le tas. La VM utilise cela pour dé-dupliquer les chaînes.</p>
<p>Durant la phase de marquage, nous n&rsquo;avons délibérément <em>pas</em> traité la table de chaînes de la VM comme une source de racines. Si nous avions, aucune <span name="intern">chaîne</span> ne serait <em>jamais</em> collectée. La table de chaînes grandirait et grandirait et ne céderait jamais un seul octet de mémoire de retour au système d&rsquo;exploitation. Cela serait mauvais.</p>
<aside name="intern">
<p>Cela peut être un vrai problème. Java n&rsquo;interne pas <em>toutes</em> les chaînes, mais il interne bien les <em>littéraux</em> chaîne. Il fournit aussi une API pour ajouter des chaînes à la table de chaînes. Pendant de nombreuses années, la capacité de cette table était fixe, et les chaînes ajoutées à elle ne pouvaient jamais être retirées. Si les utilisateurs n&rsquo;étaient pas prudents sur leur utilisation de <code>String.intern()</code>, ils pouvaient tomber à court de mémoire et planter.</p>
<p>Ruby a eu un problème similaire pendant des années où les symboles<span class="em">&mdash;</span>valeurs comme des chaînes internées<span class="em">&mdash;</span>n&rsquo;étaient pas ramassés. Les deux ont éventuellement activé le GC pour collecter ces chaînes.</p>
</aside>
<p>En même temps, si nous laissons <em>bien</em> le GC libérer les chaînes, alors la table de chaînes de la VM sera laissée avec des pointeurs ballants vers la mémoire libérée. Ce serait encore pire.</p>
<p>La table de chaînes est spéciale et nous avons besoin de support spécial pour elle. En particulier, elle a besoin d&rsquo;une sorte spéciale de référence. La table devrait être capable de référer à une chaîne, mais ce lien ne devrait pas être considéré comme une racine lors de la détermination de l&rsquo;accessibilité. Cela implique que l&rsquo;objet référencé peut être libéré. Quand cela arrive, la référence ballante doit être fixée aussi, sorte de comme un pointeur magique, auto-nettoyant. Cet ensemble particulier de sémantiques survient assez fréquemment pour qu&rsquo;il ait un nom : une <a href="https://fr.wikipedia.org/wiki/Référence_faible"><strong>référence faible</strong></a>.</p>
<p>Nous avons déjà implicitement implémenté la moitié du comportement unique de la table de chaînes par vertu du fait que nous ne la traversons <em>pas</em> durant le marquage. Cela signifie qu&rsquo;elle ne force pas les chaînes à être accessibles. La pièce restante est d&rsquo;effacer tous pointeurs ballants pour les chaînes qui sont libérées.
Pour retirer les références aux chaînes inaccessibles, nous avons besoin de savoir quelles chaînes <em>sont</em> inaccessibles. Nous ne savons pas cela jusqu&rsquo;à après que la phase de marquage a complété. Mais nous ne pouvons pas attendre jusqu&rsquo;à après que la phase de balayage soit faite parce que d&rsquo;ici là les objets<span class="em">&mdash;</span>et leurs bits de marque<span class="em">&mdash;</span>ne sont plus autour pour vérifier. Donc le bon moment est exactement entre les phases de marquage et de balayage.</p>
<div class="codehilite"><pre class="insert-before">  traceReferences();
</pre><div class="source-file"><em>memory.c</em><br>
in <em>collectGarbage</em>()</div>
<pre class="insert">  <span class="i">tableRemoveWhite</span>(&amp;<span class="i">vm</span>.<span class="i">strings</span>);
</pre><pre class="insert-after">  sweep();
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>

<p>La logique pour retirer les chaînes sur-le-point-d&rsquo;être-supprimées existe dans une nouvelle fonction dans le module &ldquo;table&rdquo;.</p>
<div class="codehilite"><pre class="insert-before">ObjString* tableFindString(Table* table, const char* chars,
                           int length, uint32_t hash);
</pre><div class="source-file"><em>table.h</em><br>
add after <em>tableFindString</em>()</div>
<pre class="insert">

<span class="t">void</span> <span class="i">tableRemoveWhite</span>(<span class="t">Table</span>* <span class="i">table</span>);
</pre><pre class="insert-after">void markTable(Table* table);

</pre></div>
<div class="source-file-narrow"><em>table.h</em>, add after <em>tableFindString</em>()</div>

<p>L&rsquo;implémentation est ici :</p>
<div class="codehilite"><div class="source-file"><em>table.c</em><br>
add after <em>tableFindString</em>()</div>
<pre><span class="t">void</span> <span class="i">tableRemoveWhite</span>(<span class="t">Table</span>* <span class="i">table</span>) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">table</span>-&gt;<span class="i">capacity</span>; <span class="i">i</span>++) {
    <span class="t">Entry</span>* <span class="i">entry</span> = &amp;<span class="i">table</span>-&gt;<span class="i">entries</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">entry</span>-&gt;<span class="i">key</span> != <span class="a">NULL</span> &amp;&amp; !<span class="i">entry</span>-&gt;<span class="i">key</span>-&gt;<span class="i">obj</span>.<span class="i">isMarked</span>) {
      <span class="i">tableDelete</span>(<span class="i">table</span>, <span class="i">entry</span>-&gt;<span class="i">key</span>);
    }
  }
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, add after <em>tableFindString</em>()</div>

<p>Nous marchons chaque entrée dans la table. La table d&rsquo;internement de chaînes utilise seulement la clé de chaque entrée<span class="em">&mdash;</span>c&rsquo;est basiquement un hash <em>set</em> pas une hash <em>map</em>. Si le bit de marque de l&rsquo;objet chaîne clé n&rsquo;est pas mis, alors c&rsquo;est un objet blanc qui est à moments d&rsquo;être balayé au loin. Nous le supprimons de la table de hachage d&rsquo;abord et assurons ainsi que nous ne verrons aucun pointeur ballant.</p>
<h2><a href="#quand-collecter" id="quand-collecter"><small>26&#8202;.&#8202;6</small>Quand Collecter</a></h2>
<p>Nous avons un ramasse-miettes mark-sweep pleinement fonctionnel maintenant. Quand le drapeau de test de stress est activé, il est appelé tout le temps, et avec la journalisation activée aussi, nous pouvons le regarder faire sa chose et voir qu&rsquo;il réclame en effet de la mémoire. Mais, quand le drapeau de test de stress est éteint, il ne court jamais du tout. Il est temps de décider quand le collecteur devrait être invoqué durant l&rsquo;exécution normale du programme.</p>
<p>Autant que je peux dire, cette question est pauvrement répondue par la littérature. Quand les ramasse-miettes furent d&rsquo;abord inventés, les ordinateurs avaient une quantité minuscule, fixe de mémoire. Beaucoup des premiers papiers de GC supposaient que vous mettiez de côté quelques milliers de mots de mémoire<span class="em">&mdash;</span>en d&rsquo;autres termes, la plupart d&rsquo;elle<span class="em">&mdash;</span>et invoquiez le collecteur chaque fois que vous étiez à court. Simple.</p>
<p>Les machines modernes ont des gigas de RAM physique, cachés derrière l&rsquo;abstraction de mémoire virtuelle encore plus large du système d&rsquo;exploitation, qui est partagée parmi une flopée d&rsquo;autres programmes tous se battant pour leur morceau de mémoire. Le système d&rsquo;exploitation laissera votre programme demander autant qu&rsquo;il veut et ensuite paginer dedans et dehors depuis le disque quand la mémoire physique devient pleine. Vous ne &ldquo;tombez jamais vraiment à court&rdquo; de mémoire, vous devenez juste plus lent et plus lent.</p>
<h3><a href="#latence-et-débit" id="latence-et-débit"><small>26&#8202;.&#8202;6&#8202;.&#8202;1</small>Latence et débit</a></h3>
<p>Cela n&rsquo;a plus de sens d&rsquo;attendre jusqu&rsquo;à ce que vous &ldquo;deviez&rdquo;, pour courir le GC, donc nous avons besoin d&rsquo;une stratégie de timing plus subtile. Pour raisonner à propos de ceci plus précisément, il est temps d&rsquo;introduire deux nombres fondamentaux utilisés lors de la mesure de la performance d&rsquo;un gestionnaire de mémoire : <em>débit</em> (throughput) et <em>latence</em> (latency).</p>
<p>Chaque langage géré paie un prix de performance comparé à la désallocation explicite, auteur-utilisateur. Le temps passé à libérer réellement la mémoire est le même, mais le GC passe des cycles à trouver <em>quelle</em> mémoire libérer. C&rsquo;est du temps <em>non</em> passé à courir le code de l&rsquo;utilisateur et faire du travail utile. Dans notre implémentation, c&rsquo;est l&rsquo;entièreté de la phase de marquage. Le but d&rsquo;un ramasse-miettes sophistiqué est de minimiser ce surcoût.</p>
<p>Il y a deux métriques clés que nous pouvons utiliser pour mieux comprendre ce coût :</p>
<ul>
<li>
<p><strong>Débit</strong> est la fraction totale de temps passée à courir le code utilisateur versus faire du travail de ramasse-miettes. Disons que vous courez un programme clox pour dix secondes et il passe une seconde de cela à l&rsquo;intérieur de <code>collectGarbage()</code>. Cela signifie que le débit est 90%<span class="em">&mdash;</span>il a passé 90% du temps à courir le programme et 10% sur le surcoût GC.</p>
<p>Le débit est la mesure la plus fondamentale parce qu&rsquo;elle suit le coût total du surcoût de collection. Tout le reste étant égal, vous voulez maximiser le débit. Jusqu&rsquo;à ce chapitre, clox n&rsquo;avait aucun GC du tout et ainsi <span name="hundred">100%</span> de débit. C&rsquo;est assez dur à battre. Bien sûr, cela venait à la légère dépense de tomber potentiellement à court de mémoire et planter si le programme de l&rsquo;utilisateur courait assez longtemps. Vous pouvez regarder le but d&rsquo;un GC comme fixer ce &ldquo;glitch&rdquo; tout en sacrifiant aussi peu de débit que possible.</p>
</li>
</ul>
<aside name="hundred">
<p>Bien, pas <em>exactement</em> 100%. Il mettait encore bien les objets alloués dans une liste chaînée, donc il y avait un minuscule surcoût pour mettre ces pointeurs.</p>
</aside>
<ul>
<li>
<p><strong>Latence</strong> est le plus long morceau <em>continu</em> de temps où le programme de l&rsquo;utilisateur est complètement mis en pause pendant que le ramasse-miettes arrive. C&rsquo;est une mesure de comment &ldquo;grossier&rdquo; (chunky) le collecteur est. La latence est une métrique entièrement différente du débit.</p>
<p>Considérez deux courses d&rsquo;un programme clox qui prennent toutes deux dix secondes. Dans la première course, le GC démarre une fois et passe une seconde solide dans <code>collectGarbage()</code> en une collection massive. Dans la seconde course, le GC est invoqué cinq fois, chacune pour un cinquième de seconde. La quantité <em>totale</em> de temps passée à collecter est encore une seconde, donc le débit est 90% dans les deux cas. Mais dans la seconde course, la latence est seulement 1/5ème de seconde, cinq fois moins que dans la première.</p>
</li>
</ul>
<p><span name="latency"></span></p><img src="image/garbage-collection/latency-throughput.png" alt="Une barre représentant le temps d'exécution avec des tranches pour courir le code utilisateur et courir le GC. La plus large tranche GC est la latence. La taille de toutes les tranches de code utilisateur est le débit." />
<aside name="latency">
<p>La barre représente l&rsquo;exécution d&rsquo;un programme, divisée en temps passé à courir le code utilisateur et temps passé dans le GC. La taille de la plus grande tranche unique de temps courant le GC est la latence. La taille de toutes les tranches de code utilisateur additionnées est le débit.</p>
</aside>
<p>Si vous aimez les analogies, imaginez que votre programme est une boulangerie vendant du pain frais aux clients. Le débit est le nombre total de baguettes chaudes, croustillantes que vous pouvez servir aux clients en un seul jour. La latence est combien de temps le client le plus malchanceux a à attendre en ligne avant qu&rsquo;il soit servi.</p>
<p><span name="dishwasher">Courir</span> le ramasse-miettes est comme fermer la boulangerie temporairement pour passer à travers toute la vaisselle, trier la sale de la propre, et ensuite laver les utilisées. Dans notre analogie, nous n&rsquo;avons pas de plongeurs dédiés, donc pendant que cela se passe, aucune cuisson n&rsquo;arrive. Le boulanger est en train de laver.</p>
<aside name="dishwasher">
<p>Si chaque personne représente un thread, alors une optimisation évidente est d&rsquo;avoir des threads séparés courant le ramasse-miettes, vous donnant un <strong>ramasse-miettes concurrent</strong>. En d&rsquo;autres termes, embauchez quelques plongeurs pour nettoyer pendant que d&rsquo;autres cuisinent. C&rsquo;est comment les GCs très sophistiqués fonctionnent parce qu&rsquo;il laisse bien les boulangers<span class="em">&mdash;</span>les threads travailleurs<span class="em">&mdash;</span>continuer de courir le code utilisateur avec peu d&rsquo;interruption.</p>
<p>Cependant, la coordination est requise. Vous ne voulez pas qu&rsquo;un plongeur attrape un bol hors des mains d&rsquo;un boulanger ! Cette coordination ajoute du surcoût et beaucoup de complexité. Les collecteurs concurrents sont rapides, mais difficiles à implémenter correctement.</p><img src="image/garbage-collection/baguette.png" class="above" alt="Une baguette." />
</aside>
<p>Vendre moins de miches de pain par jour est mauvais, et faire s&rsquo;asseoir et attendre n&rsquo;importe quel client particulier pendant que vous nettoyez toute la vaisselle l&rsquo;est aussi. Le but est de maximiser le débit et minimiser la latence, mais il n&rsquo;y a pas de repas gratuit, même à l&rsquo;intérieur d&rsquo;une boulangerie. Les ramasse-miettes font différents compromis entre combien de débit ils sacrifient et de latence ils tolèrent.</p>
<p>Être capable de faire ces compromis est utile parce que différents programmes utilisateurs ont différents besoins. Un travail par lot de nuit qui génère un rapport depuis un téraoctet de données a juste besoin d&rsquo;obtenir autant de travail fait aussi vite que possible. Le débit est reine. Pendant ce temps, une app courant sur le smartphone d&rsquo;un utilisateur a besoin de toujours répondre immédiatement à l&rsquo;entrée utilisateur pour que glisser sur l&rsquo;écran se sente <span name="butter">beurré</span> doux. L&rsquo;app ne peut pas geler pour quelques secondes pendant que le GC patauge dans le tas.</p>
<aside name="butter">
<p>Clairement l&rsquo;analogie de boulangerie me monte à la tête.</p>
</aside>
<p>Comme auteur de ramasse-miettes, vous contrôlez une partie du compromis entre débit et latence par votre choix d&rsquo;algorithme de collection. Mais même au sein d&rsquo;un algorithme unique, nous avons beaucoup de contrôle sur <em>combien fréquemment</em> le collecteur court.</p>
<p>Notre collecteur est un <span name="incremental"><strong>GC stop-the-world</strong></span> ce qui signifie que le programme de l&rsquo;utilisateur est mis en pause jusqu&rsquo;à ce que le processus de ramasse-miettes entier ait complété. Si nous attendons un long moment avant que nous courions le collecteur, alors un grand nombre d&rsquo;objets morts s&rsquo;accumuleront. Cela mène à une pause très longue pendant que le collecteur court, et ainsi une latence élevée. Donc, clairement, nous voulons courir le collecteur vraiment fréquemment.</p>
<aside name="incremental">
<p>En contraste, un <strong>ramasse-miettes incrémental</strong> peut faire une petite collection, ensuite courir un peu de code utilisateur, ensuite collecter un peu plus, et ainsi de suite.</p>
</aside>
<p>Mais chaque fois que le collecteur court, il passe un peu de temps à visiter les objets vivants. Cela ne <em>fait</em> pas vraiment quelque chose d&rsquo;utile (à part assurer qu&rsquo;ils ne sont pas incorrectement supprimés). Le temps visitant les objets vivants est du temps ne libérant pas de mémoire et aussi du temps ne courant pas le code utilisateur. Si vous courez le GC <em>vraiment</em> fréquemment, alors le programme de l&rsquo;utilisateur n&rsquo;a pas assez de temps pour même générer de nouveaux déchets pour que la VM collecte. La VM passera tout son temps à revisiter obsessivement le même ensemble d&rsquo;objets vivants encore et encore, et le débit souffrira. Donc, clairement, nous voulons courir le collecteur vraiment <em>in</em>fréquemment.</p>
<p>En fait, nous voulons quelque chose au milieu, et la fréquence de quand le collecteur court est l&rsquo;un de nos principaux boutons pour régler le compromis entre latence et débit.</p>
<h3><a href="#tas-auto-ajustable" id="tas-auto-ajustable"><small>26&#8202;.&#8202;6&#8202;.&#8202;2</small>Tas auto-ajustable</a></h3>
<p>Nous voulons que notre GC coure assez fréquemment pour minimiser la latence mais assez infréquemment pour maintenir un débit décent. Mais comment trouvons-nous l&rsquo;équilibre entre ceux-ci quand nous n&rsquo;avons aucune idée de combien de mémoire le programme de l&rsquo;utilisateur a besoin et combien souvent il alloue ? Nous pourrions refiler le problème à l&rsquo;utilisateur et le forcer à choisir en exposant des paramètres de réglage GC. Beaucoup de VMs font cela. Mais si nous, les auteurs de GC, ne savons pas comment bien le régler, les chances sont bonnes que la plupart des utilisateurs ne le sauront pas non plus. Ils méritent un comportement par défaut raisonnable.</p>
<p>Je serai honnête avec vous, ce n&rsquo;est pas mon aire d&rsquo;expertise. J&rsquo;ai parlé à un nombre de hackers de GC professionnels<span class="em">&mdash;</span>c&rsquo;est quelque chose sur quoi vous pouvez construire une carrière entière<span class="em">&mdash;</span>et lu beaucoup de la littérature, et toutes les réponses que j&rsquo;ai obtenues étaient<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>vagues. La stratégie que j&rsquo;ai fini par choisir est commune, assez simple, et (j&rsquo;espère !) assez bonne pour la plupart des usages.</p>
<p>L&rsquo;idée est que la fréquence du collecteur s&rsquo;ajuste automatiquement basé sur la taille vivante du tas. Nous suivons le nombre total d&rsquo;octets de mémoire gérée que la VM a alloué. Quand cela va au-dessus de quelque seuil, nous déclenchons un GC. Après cela, nous notons combien d&rsquo;octets de mémoire restent<span class="em">&mdash;</span>combien n&rsquo;ont <em>pas</em> été libérés. Ensuite nous ajustons le seuil à quelque valeur plus grande que cela.</p>
<p>Le résultat est que comme la quantité de mémoire vivante augmente, nous collectons moins fréquemment afin d&rsquo;éviter de sacrifier le débit en re-traversant la pile grandissante d&rsquo;objets vivants. Comme la quantité de mémoire vivante descend, nous collectons plus fréquemment pour que nous ne perdions pas trop de latence en attendant trop longtemps.</p>
<p>L&rsquo;implémentation requiert deux nouveaux champs de comptabilité dans la VM.</p>
<div class="codehilite"><pre class="insert-before">  ObjUpvalue* openUpvalues;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">

  <span class="t">size_t</span> <span class="i">bytesAllocated</span>;
  <span class="t">size_t</span> <span class="i">nextGC</span>;
</pre><pre class="insert-after">  Obj* objects;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>Le premier est un total courant du nombre d&rsquo;octets de mémoire gérée que la VM a alloué. Le second est le seuil qui déclenche la prochaine collection. Nous les initialisons quand la VM démarre.</p>
<div class="codehilite"><pre class="insert-before">  vm.objects = NULL;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">  <span class="i">vm</span>.<span class="i">bytesAllocated</span> = <span class="n">0</span>;
  <span class="i">vm</span>.<span class="i">nextGC</span> = <span class="n">1024</span> * <span class="n">1024</span>;
</pre><pre class="insert-after">

  vm.grayCount = 0;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>Le seuil de départ ici est <span name="lab">arbitraire</span>. C&rsquo;est similaire à la capacité initiale que nous avons prise pour nos divers tableaux dynamiques. Le but est de ne pas déclencher les premiers quelques GCs <em>trop</em> rapidement mais aussi de ne pas attendre trop longtemps. Si nous avions quelques programmes Lox du monde réel, nous pourrions profiler ceux-ci pour régler cela. Mais puisque tout ce que nous avons sont des programmes jouets, j&rsquo;ai juste pris un nombre.</p>
<aside name="lab">
<p>Un défi avec l&rsquo;apprentissage des ramasse-miettes est qu&rsquo;il est <em>très</em> dur de découvrir les meilleures pratiques dans un environnement de laboratoire isolé. Vous ne voyez pas comment un collecteur performe réellement à moins que vous le courriez sur le genre de programmes du monde réel, larges, désordonnés pour lesquels il est réellement prévu. C&rsquo;est comme régler une voiture de rallye<span class="em">&mdash;</span>vous devez la sortir sur la course.</p>
</aside>
<p>Chaque fois que nous allouons ou libérons un peu de mémoire, nous ajustons le compteur par ce delta.</p>
<div class="codehilite"><pre class="insert-before">void* reallocate(void* pointer, size_t oldSize, size_t newSize) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>reallocate</em>()</div>
<pre class="insert">  <span class="i">vm</span>.<span class="i">bytesAllocated</span> += <span class="i">newSize</span> - <span class="i">oldSize</span>;
</pre><pre class="insert-after">  if (newSize &gt; oldSize) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>reallocate</em>()</div>

<p>Quand le total traverse la limite, nous courons le collecteur.</p>
<div class="codehilite"><pre class="insert-before">    collectGarbage();
#endif
</pre><div class="source-file"><em>memory.c</em><br>
in <em>reallocate</em>()</div>
<pre class="insert">

    <span class="k">if</span> (<span class="i">vm</span>.<span class="i">bytesAllocated</span> &gt; <span class="i">vm</span>.<span class="i">nextGC</span>) {
      <span class="i">collectGarbage</span>();
    }
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>reallocate</em>()</div>

<p>Maintenant, finalement, notre ramasse-miettes fait réellement quelque chose quand l&rsquo;utilisateur court un programme sans notre drapeau de diagnostic caché activé. La phase de balayage libère les objets en appelant <code>reallocate()</code>, ce qui abaisse la valeur de <code>bytesAllocated</code>, donc après que la collection complète, nous savons combien d&rsquo;octets vivants restent. Nous ajustons le seuil du prochain GC basé sur cela.</p>
<div class="codehilite"><pre class="insert-before">  sweep();
</pre><div class="source-file"><em>memory.c</em><br>
in <em>collectGarbage</em>()</div>
<pre class="insert">

  <span class="i">vm</span>.<span class="i">nextGC</span> = <span class="i">vm</span>.<span class="i">bytesAllocated</span> * <span class="a">GC_HEAP_GROW_FACTOR</span>;
</pre><pre class="insert-after">

#ifdef DEBUG_LOG_GC
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>

<p>Le seuil est un multiple de la taille du tas. De cette façon, comme la quantité de mémoire que le programme utilise grandit, le seuil bouge plus loin pour limiter le temps total passé à re-traverser l&rsquo;ensemble vivant plus large. Comme d&rsquo;autres nombres dans ce chapitre, le facteur d&rsquo;échelle est basiquement arbitraire.</p>
<div class="codehilite"><pre class="insert-before">#endif
</pre><div class="source-file"><em>memory.c</em></div>
<pre class="insert">

<span class="a">#define GC_HEAP_GROW_FACTOR 2</span>
</pre><pre class="insert-after">

void* reallocate(void* pointer, size_t oldSize, size_t newSize) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em></div>

<p>Vous voudriez régler cela dans votre implémentation une fois que vous auriez quelques vrais programmes sur lesquels le benchmarker. Juste maintenant, nous pouvons au moins journaliser quelques-unes des statistiques que nous avons. Nous capturons la taille du tas avant la collection.</p>
<div class="codehilite"><pre class="insert-before">  printf(&quot;-- gc begin\n&quot;);
</pre><div class="source-file"><em>memory.c</em><br>
in <em>collectGarbage</em>()</div>
<pre class="insert">  <span class="t">size_t</span> <span class="i">before</span> = <span class="i">vm</span>.<span class="i">bytesAllocated</span>;
</pre><pre class="insert-after">#endif
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>

<p>Et ensuite affichons les résultats à la fin.</p>
<div class="codehilite"><pre class="insert-before">  printf(&quot;-- gc end\n&quot;);
</pre><div class="source-file"><em>memory.c</em><br>
in <em>collectGarbage</em>()</div>
<pre class="insert">  <span class="i">printf</span>(<span class="s">&quot;   collected %zu bytes (from %zu to %zu) next at %zu</span><span class="e">\n</span><span class="s">&quot;</span>,
         <span class="i">before</span> - <span class="i">vm</span>.<span class="i">bytesAllocated</span>, <span class="i">before</span>, <span class="i">vm</span>.<span class="i">bytesAllocated</span>,
         <span class="i">vm</span>.<span class="i">nextGC</span>);
</pre><pre class="insert-after">#endif
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>

<p>De cette façon nous pouvons voir combien le ramasse-miettes a accompli pendant qu&rsquo;il courait.</p>
<h2><a href="#bugs-de-ramasse-miettes" id="bugs-de-ramasse-miettes"><small>26&#8202;.&#8202;7</small>Bugs de Ramasse-miettes</a></h2>
<p>En théorie, nous avons tout fini maintenant. Nous avons un GC. Il démarre périodiquement, collecte ce qu&rsquo;il peut, et laisse le reste. Si c&rsquo;était un manuel typique, nous essuierions la poussière de nos mains et nous prélasserions dans la lueur douce de l&rsquo;édifice de marbre sans défaut que nous avons créé.</p>
<p>Mais je vise à vous enseigner non juste la théorie des langages de programmation mais la réalité parfois douloureuse. Je vais rouler une bûche pourrie et vous montrer les vilains bugs qui vivent dessous, et les bugs de ramasse-miettes sont vraiment certains des invertébrés les plus grossiers là-bas.</p>
<p>Le travail du collecteur est de libérer les objets morts et préserver les vivants. Les erreurs sont faciles à faire dans les deux directions. Si la VM échoue à libérer les objets qui ne sont pas nécessaires, elle fuit lentement de la mémoire. Si elle libère un objet qui est en usage, le programme de l&rsquo;utilisateur peut accéder à de la mémoire invalide. Ces échecs ne causent souvent pas immédiatement un plantage, ce qui rend difficile pour nous de tracer en arrière dans le temps pour trouver le bug.</p>
<p>Ceci est rendu plus dur par le fait que nous ne savons pas quand le collecteur courra. Tout appel qui alloue éventuellement un peu de mémoire est un endroit dans la VM où une collection pourrait arriver. C&rsquo;est comme les chaises musicales. À n&rsquo;importe quel point, le GC pourrait arrêter la musique. Chaque objet alloué sur le tas unique que nous voulons garder a besoin de trouver une chaise rapidement<span class="em">&mdash;</span>être marqué comme une racine ou stocké comme une référence dans quelque autre objet<span class="em">&mdash;</span>avant que la phase de balayage vienne pour l&rsquo;éjecter du jeu.</p>
<p>Comment est-il possible pour la VM d&rsquo;utiliser un objet plus tard<span class="em">&mdash;</span>un que le GC lui-même ne voit pas ? Comment la VM peut-elle le trouver ? La réponse la plus commune est par un pointeur stocké dans quelque variable locale sur la pile C. Le GC marche les piles de valeurs et CallFrame de la <em>VM</em>, mais la pile C est <span name="c">cachée</span> à lui.</p>
<aside name="c">
<p>Notre GC ne peut pas trouver les adresses dans la pile C, mais beaucoup le peuvent. Les ramasse-miettes conservateurs regardent tout à travers la mémoire, incluant la pile native. Le plus bien connu de cette variété est le <a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector"><strong>ramasse-miettes Boehm–Demers–Weiser</strong></a>, habituellement juste appelé le &ldquo;collecteur Boehm&rdquo;. (Le chemin le plus court vers la célébrité en CS est un nom de famille qui est alphabétiquement tôt pour qu&rsquo;il apparaisse premier dans les listes triées de noms.)</p>
<p>Beaucoup de GCs précis marchent la pile C aussi. Même ceux-là doivent être prudents à propos des pointeurs vers les objets vivants qui existent seulement dans les <em>registres CPU</em>.</p>
</aside>
<p>Dans les chapitres précédents, nous avons écrit du code apparemment sans but qui poussait un objet sur la pile de valeurs de la VM, faisait un petit travail, et ensuite le dépilait juste après. La plupart du temps, j&rsquo;ai dit que c&rsquo;était pour le bénéfice du GC. Maintenant vous voyez pourquoi. Le code entre pousser et dépiler alloue potentiellement de la mémoire et peut ainsi déclencher un GC. Nous devions nous assurer que l&rsquo;objet était sur la pile de valeurs pour que la phase de marquage du collecteur le trouve et le garde vivant.</p>
<p>J&rsquo;ai écrit l&rsquo;implémentation clox entière avant de la séparer en chapitres et d&rsquo;écrire la prose, donc j&rsquo;ai eu plein de temps pour trouver tous ces coins et débusquer la plupart de ces bugs. Le code de test de stress que nous avons mis au début de ce chapitre et une assez bonne suite de tests étaient très utiles.</p>
<p>Mais j&rsquo;ai fixé seulement la <em>plupart</em> d&rsquo;entre eux. J&rsquo;en ai laissé une paire dedans parce que je veux vous donner un indice de ce que c&rsquo;est que de rencontrer ces bugs dans la nature. Si vous activez le drapeau de test de stress et courez quelques programmes Lox jouets, vous pouvez probablement trébucher sur quelques-uns. Donnez-lui un essai et <em>voyez si vous pouvez en fixer n&rsquo;importe lesquels vous-mêmes</em>.</p>
<h3><a href="#ajouter-&agrave;-la-table-de-constantes" id="ajouter-&agrave;-la-table-de-constantes"><small>26&#8202;.&#8202;7&#8202;.&#8202;1</small>Ajouter &agrave; la table de constantes</a></h3>
<p>Vous êtes très susceptibles de frapper le premier bug. La table de constantes que chaque morceau possède est un tableau dynamique. Quand le compilateur ajoute une nouvelle constante à la table de la fonction courante, ce tableau peut avoir besoin de grandir. La constante elle-même peut aussi être quelque objet alloué sur le tas comme une chaîne ou une fonction imbriquée.</p>
<p>Le nouvel objet étant ajouté à la table de constantes est passé à <code>addConstant()</code>. À ce moment, l&rsquo;objet peut être trouvé seulement dans le paramètre à cette fonction sur la pile C. Cette fonction ajoute l&rsquo;objet à la table de constantes. Si la table n&rsquo;a pas assez de capacité et a besoin de grandir, elle appelle <code>reallocate()</code>. Cela déclenche à son tour un GC, qui échoue à marquer le nouvel objet constant et ainsi le balaie juste avant que nous ayons une chance de l&rsquo;ajouter à la table. Plantage.</p>
<p>La correction, comme vous avez vu dans d&rsquo;autres endroits, est de pousser la constante sur la pile temporairement.</p>
<div class="codehilite"><pre class="insert-before">int addConstant(Chunk* chunk, Value value) {
</pre><div class="source-file"><em>chunk.c</em><br>
in <em>addConstant</em>()</div>
<pre class="insert">  <span class="i">push</span>(<span class="i">value</span>);
</pre><pre class="insert-after">  writeValueArray(&amp;chunk-&gt;constants, value);
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>addConstant</em>()</div>

<p>Une fois que la table de constantes contient l&rsquo;objet, nous le dépilons de la pile.</p>
<div class="codehilite"><pre class="insert-before">  writeValueArray(&amp;chunk-&gt;constants, value);
</pre><div class="source-file"><em>chunk.c</em><br>
in <em>addConstant</em>()</div>
<pre class="insert">  <span class="i">pop</span>();
</pre><pre class="insert-after">  return chunk-&gt;constants.count - 1;
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>addConstant</em>()</div>

<p>Quand le GC marque les racines, il marche la chaîne de compilateurs et marque chacune de leurs fonctions, donc la nouvelle constante est accessible maintenante. Nous avons besoin d&rsquo;un include pour appeler dans la VM depuis le module &ldquo;chunk&rdquo;.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;memory.h&quot;
</pre><div class="source-file"><em>chunk.c</em></div>
<pre class="insert"><span class="a">#include &quot;vm.h&quot;</span>
</pre><pre class="insert-after">

void initChunk(Chunk* chunk) {
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em></div>

<h3><a href="#interner-les-chaînes" id="interner-les-chaînes"><small>26&#8202;.&#8202;7&#8202;.&#8202;2</small>Interner les chaînes</a></h3>
<p>Voici en un autre similaire. Toutes les chaînes sont internées dans clox, donc chaque fois que nous créons une nouvelle chaîne, nous l&rsquo;ajoutons aussi à la table d&rsquo;internement. Vous pouvez voir où cela va. Puisque la chaîne est toute neuve, elle n&rsquo;est accessible nulle part. Et redimensionner la piscine de chaînes peut déclencher une collection. Encore, nous allons de l&rsquo;avant et planquons la chaîne sur la pile d&rsquo;abord.</p>
<div class="codehilite"><pre class="insert-before">  string-&gt;chars = chars;
  string-&gt;hash = hash;
</pre><div class="source-file"><em>object.c</em><br>
in <em>allocateString</em>()</div>
<pre class="insert">

  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">string</span>));
</pre><pre class="insert-after">  tableSet(&amp;vm.strings, string, NIL_VAL);
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>allocateString</em>()</div>

<p>Et ensuite la dépilons une fois qu&rsquo;elle est sûrement nichée dans la table.</p>
<div class="codehilite"><pre class="insert-before">  tableSet(&amp;vm.strings, string, NIL_VAL);
</pre><div class="source-file"><em>object.c</em><br>
in <em>allocateString</em>()</div>
<pre class="insert">  <span class="i">pop</span>();

</pre><pre class="insert-after">  return string;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>allocateString</em>()</div>

<p>Cela assure que la chaîne est sûre pendant que la table est redimensionnée. Une fois qu&rsquo;elle survit à cela, <code>allocateString()</code> la retournera à quelque appelant qui peut alors prendre la responsabilité d&rsquo;assurer que la chaîne est encore accessible avant que la prochaine allocation tas se produise.</p>
<h3><a href="#concaténer-les-chaînes" id="concaténer-les-chaînes"><small>26&#8202;.&#8202;7&#8202;.&#8202;3</small>Concaténer les chaînes</a></h3>
<p>Un dernier exemple : Là-bas dans l&rsquo;interpréteur, l&rsquo;instruction <code>OP_ADD</code> peut être utilisée pour concaténer deux chaînes. Comme elle le fait avec les nombres, elle dépile les deux opérandes de la pile, calcule le résultat, et pousse cette nouvelle valeur de retour sur la pile. Pour les nombres c&rsquo;est parfaitement sûr.</p>
<p>Mais concaténer deux chaînes requiert d&rsquo;allouer un nouveau tableau de caractères sur le tas, ce qui peut à son tour déclencher un GC. Puisque nous avons déjà dépilé les chaînes opérandes à ce point, elles peuvent potentiellement être manquées par la phase de marquage et être balayées au loin. Au lieu de les dépiler de la pile avidement, nous les jetons un coup d&rsquo;œil (peek).</p>
<div class="codehilite"><pre class="insert-before">static void concatenate() {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>concatenate</em>()<br>
replace 2 lines</div>
<pre class="insert">  <span class="t">ObjString</span>* <span class="i">b</span> = <span class="a">AS_STRING</span>(<span class="i">peek</span>(<span class="n">0</span>));
  <span class="t">ObjString</span>* <span class="i">a</span> = <span class="a">AS_STRING</span>(<span class="i">peek</span>(<span class="n">1</span>));
</pre><pre class="insert-after">

  int length = a-&gt;length + b-&gt;length;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>concatenate</em>(), replace 2 lines</div>

<p>De cette façon, elles traînent encore sur la pile quand nous créons la chaîne résultat. Une fois que c&rsquo;est fait, nous pouvons sûrement les dépiler et les remplacer avec le résultat.</p>
<div class="codehilite"><pre class="insert-before">  ObjString* result = takeString(chars, length);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>concatenate</em>()</div>
<pre class="insert">  <span class="i">pop</span>();
  <span class="i">pop</span>();
</pre><pre class="insert-after">  push(OBJ_VAL(result));
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>concatenate</em>()</div>

<p>Celles-là étaient toutes assez faciles, spécialement parce que je vous ai <em>montré</em> où la correction était. En pratique, les <em>trouver</em> est la partie dure. Tout ce que vous voyez est un objet qui <em>devrait</em> être là mais n&rsquo;est pas. Ce n&rsquo;est pas comme d&rsquo;autres bugs où vous cherchez le code qui <em>cause</em> quelque problème. Vous cherchez l&rsquo;<em>absence</em> de code qui échoue à <em>prévenir</em> un problème, et c&rsquo;est une recherche beaucoup plus dure.</p>
<p>Mais, pour le moment au moins, vous pouvez vous reposer facile. Autant que je sache, nous avons trouvé tous les bugs de collection dans clox, et maintenant nous avons un ramasse-miettes mark-sweep fonctionnel, robuste, auto-réglable.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>26&#8202;.&#8202;8</small>Défis</a></h2>
<ol>
<li>
<p>La structure d&rsquo;en-tête Obj au sommet de chaque objet a maintenant trois champs : <code>type</code>, <code>isMarked</code>, et <code>next</code>. Combien de mémoire ceux-là prennent-ils (sur votre machine) ? Pouvez-vous venir avec quelque chose de plus compact ? Y a-t-il un coût à l&rsquo;exécution à faire ainsi ?</p>
</li>
<li>
<p>Quand la phase de balayage traverse un objet vivant, elle efface le champ <code>isMarked</code> pour le préparer pour le prochain cycle de collection. Pouvez-vous venir avec une approche plus efficace ?</p>
</li>
<li>
<p>Mark-sweep est seulement un d&rsquo;une variété d&rsquo;algorithmes de ramasse-miettes là-bas. Explorez ceux-là en remplaçant ou augmentant le collecteur actuel avec un autre. De bons candidats à considérer sont le comptage de référence, l&rsquo;algorithme de Cheney, ou l&rsquo;algorithme mark-compact Lisp 2.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--collecteurs-générationnels" id="note-de-conception--collecteurs-générationnels"><small>26&#8202;.&#8202;9</small>Note de Conception : Collecteurs Générationnels</a></h2>
<p>Un collecteur perd du débit s&rsquo;il passe un long moment à re-visiter des objets qui sont encore vivants. Mais il peut augmenter la latence s&rsquo;il évite de collecter et accumule une large pile de déchets à travers laquelle patauger. Si seulement il y avait quelque moyen de dire quels objets étaient susceptibles d&rsquo;être à longue vie et les quels ne l&rsquo;étaient pas. Alors le GC pourrait éviter de revisiter ceux à longue vie aussi souvent et nettoyer les éphémères plus fréquemment.</p>
<p>Il s&rsquo;avère qu&rsquo;il y a en quelque sorte. Il y a beaucoup d&rsquo;années, les chercheurs en GC ont rassemblé des métriques sur la durée de vie des objets dans des programmes courant dans le monde réel. Ils ont suivi chaque objet quand il était alloué, et éventuellement quand il n&rsquo;était plus nécessaire, et ensuite graphé combien de temps les objets tendaient à vivre.</p>
<p>Ils ont découvert quelque chose qu&rsquo;ils ont appelé l&rsquo;<strong>hypothèse générationnelle</strong>, ou le terme beaucoup moins plein de tact <strong>mortalité infantile</strong>. Leur observation était que la plupart des objets sont à très courte vie mais une fois qu&rsquo;ils survivent au-delà d&rsquo;un certain âge, ils tendent à rester dans les parages tout à fait un long moment. Plus long un objet <em>a</em> vécu, plus longtemps il vivra probablement <em>continuer</em>. Cette observation est puissante parce qu&rsquo;elle leur a donné une poignée sur comment partitionner les objets dans des groupes qui bénéficient de collections fréquentes et ceux qui ne le font pas.</p>
<p>Ils ont conçu une technique appelée <strong>ramasse-miettes générationnel</strong>. Cela fonctionne comme ceci : Chaque fois qu&rsquo;un nouvel objet est alloué, il va dans une région spéciale, relativement petite du tas appelée la &ldquo;pouponnière&rdquo; (nursery). Puisque les objets tendent à mourir jeunes, le ramasse-miettes est invoqué <span name="nursery">fréquemment</span> sur les objets juste dans cette région.</p>
<aside name="nursery">
<p>Les pouponnières sont aussi habituellement gérées utilisant un collecteur copieur qui est plus rapide à allouer et libérer les objets qu&rsquo;un collecteur mark-sweep.</p>
</aside>
<p>Chaque fois que le GC court sur la pouponnière est appelé une &ldquo;génération&rdquo;. Tous objets qui ne sont plus nécessaires sont libérés. Ceux qui survivent sont maintenant considérés une génération plus vieux, et le GC suit cela pour chaque objet. Si un objet survit un certain nombre de générations<span class="em">&mdash;</span>souvent juste une collection unique<span class="em">&mdash;</span>il devient <em>titularisé</em>. À ce point, il est copié hors de la pouponnière dans une région de tas beaucoup plus large pour les objets à longue vie. Le ramasse-miettes court sur cette région aussi, mais beaucoup moins fréquemment puisque les chances sont bonnes que la plupart de ces objets seront encore vivants.</p>
<p>Les collecteurs générationnels sont un beau mariage de données empiriques<span class="em">&mdash;</span>l&rsquo;observation que les durées de vie d&rsquo;objet ne sont <em>pas</em> distribuées également<span class="em">&mdash;</span>et de conception d&rsquo;algorithme intelligente qui prend avantage de ce fait. Ils sont aussi conceptuellement assez simples. Vous pouvez penser à l&rsquo;un comme juste deux GCs réglés séparément et une politique assez simple pour déplacer les objets de l&rsquo;un à l&rsquo;autre.</p>
</div>

<footer>
<a href="classes-et-instances.html" class="next">
  Next Chapter: &ldquo;Classes et instances&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
