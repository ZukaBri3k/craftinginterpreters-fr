<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Héritage &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Héritage<small>13</small></a></h3>

<ul>
    <li><a href="#superclasses-et-sous-classes"><small>13.1</small> Superclasses et Sous-classes</a></li>
    <li><a href="#hériter-des-méthodes"><small>13.2</small> Hériter des Méthodes</a></li>
    <li><a href="#appeler-les-méthodes-de-superclasse"><small>13.3</small> Appeler les Méthodes de Superclasse</a></li>
    <li><a href="#conclusion"><small>13.4</small> Conclusion</a></li>
    <li><a href="#défis"><small>13.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="classes.html" title="Classes" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="classes.html" title="Classes" class="prev">←</a>
<a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Héritage<small>13</small></a></h3>

<ul>
    <li><a href="#superclasses-et-sous-classes"><small>13.1</small> Superclasses et Sous-classes</a></li>
    <li><a href="#hériter-des-méthodes"><small>13.2</small> Hériter des Méthodes</a></li>
    <li><a href="#appeler-les-méthodes-de-superclasse"><small>13.3</small> Appeler les Méthodes de Superclasse</a></li>
    <li><a href="#conclusion"><small>13.4</small> Conclusion</a></li>
    <li><a href="#défis"><small>13.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="classes.html" title="Classes" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">13</div>
  <h1>Héritage</h1>

<blockquote>
<p>Une fois nous étions des blobs dans la mer, et puis des poissons, et puis des lézards et des rats et
puis des singes, et des centaines de choses entre les deux. Cette main était autrefois une nageoire,
cette main avait autrefois des griffes ! Dans ma bouche humaine j&rsquo;ai les dents pointues d&rsquo;un loup
et les dents ciseaux d&rsquo;un lapin et les dents broyeuses d&rsquo;une vache ! Notre sang est
aussi salé que la mer dans laquelle nous avions l&rsquo;habitude de vivre ! Quand nous sommes effrayés, les poils sur notre
peau se dressent, juste comme ils le faisaient quand nous avions de la fourrure. Nous sommes l&rsquo;histoire ! Tout ce que
nous avons jamais été sur le chemin pour devenir nous, nous le sommes encore.</p>
<p><cite>Terry Pratchett, <em>Un chapeau de ciel</em></cite></p>
</blockquote>
<p>Pouvez-vous le croire ? Nous avons atteint le dernier chapitre de la <a href="une-promenade-dans-l-arbre.html">Partie II</a>. Nous avons presque fini avec notre premier interpréteur Lox. Le <a href="classes.html">chapitre précédent</a> était une grosse boule de fonctionnalités orientées objet entremêlées. Je ne pouvais pas les séparer les unes des autres, mais j&rsquo;ai réussi à démêler un morceau. Dans ce chapitre, nous finirons le support des classes de Lox en ajoutant l&rsquo;héritage.</p>
<p>L&rsquo;héritage apparaît dans les langages orientés objet tout le chemin en arrière jusqu&rsquo;au <span name="inherited">premier</span>, <a href="https://en.wikipedia.org/wiki/Simula">Simula</a>. Tôt au début, Kristen Nygaard et Ole-Johan Dahl ont remarqué des points communs à travers les classes dans les programmes de simulation qu&rsquo;ils écrivaient. L&rsquo;héritage leur a donné un moyen de réutiliser le code pour ces parties similaires.</p>
<aside name="inherited">
<p>Vous pourriez dire que tous ces autres langages l&rsquo;ont <em>hérité</em> de Simula. Hey-ooo !
Je vais, euh, sortir.</p>
</aside>
<h2><a href="#superclasses-et-sous-classes" id="superclasses-et-sous-classes"><small>13&#8202;.&#8202;1</small>Superclasses et Sous-classes</a></h2>
<p>Étant donné que le concept est &ldquo;héritage&rdquo;, vous espéreriez qu&rsquo;ils choisiraient une métaphore cohérente et les appelleraient classes &ldquo;parent&rdquo; et &ldquo;enfant&rdquo;, mais ce serait trop facile. Il y a longtemps, C. A. R. Hoare a inventé le terme &ldquo;<span name="subclass">sous-classe</span>&rdquo; pour faire référence à un type enregistrement qui raffine un autre type. Simula a emprunté ce terme pour faire référence à une <em>classe</em> qui hérite d&rsquo;une autre. Je ne pense pas que c&rsquo;était avant que Smalltalk arrive que quelqu&rsquo;un a retourné le préfixe Latin pour obtenir &ldquo;superclasse&rdquo; pour faire référence à l&rsquo;autre côté de la relation. Depuis C++, vous entendez aussi classes &ldquo;de base&rdquo; et &ldquo;dérivées&rdquo;. Je resterai principalement avec &ldquo;superclasse&rdquo; et &ldquo;sous-classe&rdquo;.</p>
<aside name="subclass">
<p>&ldquo;Super-&rdquo; et &ldquo;sub-&rdquo; signifient &ldquo;au-dessus&rdquo; et &ldquo;en dessous&rdquo; en Latin, respectivement. Imaginez un arbre d&rsquo;héritage comme un arbre généalogique avec la racine au sommet<span class="em">&mdash;</span>les sous-classes sont en dessous de leurs superclasses sur le diagramme. Plus généralement, &ldquo;sub-&rdquo; fait référence à des choses qui raffinent ou sont contenues par un concept plus général. En zoologie, une sous-classe est une catégorisation plus fine d&rsquo;une plus large classe de choses vivantes.</p>
<p>En théorie des ensembles, un sous-ensemble est contenu par un super-ensemble plus large qui a tous les éléments du sous-ensemble et possiblement plus. La théorie des ensembles et les langages de programmation se rencontrent en théorie des types. Là, vous avez des &ldquo;supertypes&rdquo; et des &ldquo;sous-types&rdquo;.</p>
<p>Dans les langages orientés objet typés statiquement, une sous-classe est aussi souvent un sous-type de sa superclasse. Disons que nous avons une superclasse Beignet et une sous-classe BostonCream. Chaque BostonCream est aussi une instance de Beignet, mais il peut y avoir des objets beignet qui ne sont pas des BostonCreams (comme des Crullers).</p>
<p>Pensez à un type comme l&rsquo;ensemble de toutes les valeurs de ce type. L&rsquo;ensemble de toutes les instances de Beignet contient l&rsquo;ensemble de toutes les instances de BostonCream puisque chaque BostonCream est aussi un Beignet. Donc BostonCream est une sous-classe, et un sous-type, et ses instances sont un sous-ensemble. Tout s&rsquo;aligne.</p><img src="image/inheritance/doughnuts.png" alt="Boston cream &lt;: doughnut." />
</aside>
<p>Notre première étape vers le support de l&rsquo;héritage dans Lox est un moyen de spécifier une superclasse lors de la déclaration d&rsquo;une classe. Il y a beaucoup de variété dans la syntaxe pour cela. C++ et C# placent un <code>:</code> après le nom de la sous-classe, suivi par le nom de la superclasse. Java utilise <code>extends</code> au lieu du deux-points. Python met la ou les superclasse(s) entre parenthèses après le nom de la classe. Simula met le nom de la superclasse <em>avant</em> le mot-clé <code>class</code>.</p>
<p>Si tard dans le jeu, je préférerais ne pas ajouter un nouveau mot réservé ou token au lexer. Nous n&rsquo;avons pas <code>extends</code> ou même <code>:</code>, donc nous suivrons Ruby et utiliserons un signe inférieur à (<code>&lt;</code>).</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Doughnut</span> {
  <span class="c">// Trucs généraux de beignet...</span>
}

<span class="k">class</span> <span class="t">BostonCream</span> &lt; <span class="t">Doughnut</span> {
  <span class="c">// Trucs spécifiques au Boston Cream...</span>
}
</pre></div>
<p>Pour faire entrer cela dans la grammaire, nous ajoutons une nouvelle clause optionnelle dans notre règle <code>classDecl</code> existante.</p>
<div class="codehilite"><pre><span class="i">classDecl</span>      → <span class="s">&quot;class&quot;</span> <span class="t">IDENTIFIER</span> ( <span class="s">&quot;&lt;&quot;</span> <span class="t">IDENTIFIER</span> )?
                 <span class="s">&quot;{&quot;</span> <span class="i">function</span>* <span class="s">&quot;}&quot;</span> ;
</pre></div>
<p>Après le nom de la classe, vous pouvez avoir un <code>&lt;</code> suivi par le nom de la superclasse. La clause de superclasse est optionnelle parce que vous n&rsquo;êtes pas <em>obligé</em> d&rsquo;avoir une superclasse. Contrairement à certains autres langages orientés objet comme Java, Lox n&rsquo;a pas de classe racine &ldquo;Object&rdquo; dont tout hérite, donc quand vous omettez la clause de superclasse, la classe n&rsquo;a <em>pas</em> de superclasse, pas même une implicite.</p>
<p>Nous voulons capturer cette nouvelle syntaxe dans le nœud AST de déclaration de classe.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Block      : List&lt;Stmt&gt; statements&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()<br>
replace 1 line</div>
<pre class="insert">      <span class="s">&quot;Class      : Token name, Expr.Variable superclass,&quot;</span> +
                  <span class="s">&quot; List&lt;Stmt.Function&gt; methods&quot;</span>,
</pre><pre class="insert-after">      &quot;Expression : Expr expression&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>(), replace 1 line</div>

<p>Vous pourriez être surpris que nous stockions le nom de la superclasse comme une Expr.Variable, pas un Token. La grammaire restreint la clause de superclasse à un identifieur unique, mais à l&rsquo;exécution, cet identifieur est évalué comme un accès variable. Envelopper le nom dans une Expr.Variable tôt dans le parseur nous donne un objet auquel le résolveur peut accrocher les informations de résolution.</p>
<p>Le nouveau code de parseur suit la grammaire directement.</p>
<div class="codehilite"><pre class="insert-before">    Token name = consume(IDENTIFIER, &quot;Expect class name.&quot;);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>classDeclaration</em>()</div>
<pre class="insert">

    <span class="t">Expr</span>.<span class="t">Variable</span> <span class="i">superclass</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">LESS</span>)) {
      <span class="i">consume</span>(<span class="i">IDENTIFIER</span>, <span class="s">&quot;Expect superclass name.&quot;</span>);
      <span class="i">superclass</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Variable</span>(<span class="i">previous</span>());
    }

</pre><pre class="insert-after">    consume(LEFT_BRACE, &quot;Expect '{' before class body.&quot;);
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>classDeclaration</em>()</div>

<p>Une fois que nous avons (possiblement) parsé une déclaration de superclasse, nous la stockons dans l&rsquo;AST.</p>
<div class="codehilite"><pre class="insert-before">    consume(RIGHT_BRACE, &quot;Expect '}' after class body.&quot;);

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>classDeclaration</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Class</span>(<span class="i">name</span>, <span class="i">superclass</span>, <span class="i">methods</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>classDeclaration</em>(), replace 1 line</div>

<p>Si nous n&rsquo;avons pas parsé de clause de superclasse, l&rsquo;expression superclasse sera <code>null</code>. Nous devrons nous assurer que les passes ultérieures vérifient cela. La première de celles-ci est le résolveur.</p>
<div class="codehilite"><pre class="insert-before">    define(stmt.name);
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">

    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">superclass</span> != <span class="k">null</span>) {
      <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">superclass</span>);
    }
</pre><pre class="insert-after">

    beginScope();
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>

<p>Le nœud AST de déclaration de classe a une nouvelle sous-expression, donc nous traversons dedans et résolvons cela. Puisque les classes sont habituellement déclarées au niveau supérieur, le nom de la superclasse sera très probablement une variable globale, donc cela ne fait habituellement rien d&rsquo;utile. Cependant, Lox permet les déclarations de classe même à l&rsquo;intérieur de blocs, donc il est possible que le nom de la superclasse fasse référence à une variable locale. Dans ce cas, nous devons nous assurer qu&rsquo;elle est résolue.</p>
<p>Parce que même des programmeurs bien intentionnés écrivent parfois du code bizarre, il y a un cas limite idiot dont nous devons nous soucier pendant que nous sommes ici. Jetez un œil à ceci :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Oops</span> &lt; <span class="t">Oops</span> {}
</pre></div>
<p>Il n&rsquo;y a aucun moyen que cela fasse quoi que ce soit d&rsquo;utile, et si nous laissons le runtime essayer d&rsquo;exécuter ceci, cela brisera l&rsquo;attente que l&rsquo;interpréteur a à propos du fait qu&rsquo;il n&rsquo;y ait pas de cycles dans la chaîne d&rsquo;héritage. La chose la plus sûre est de détecter ce cas statiquement et de le rapporter comme une erreur.</p>
<div class="codehilite"><pre class="insert-before">    define(stmt.name);

</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">superclass</span> != <span class="k">null</span> &amp;&amp;
        <span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>.<span class="i">equals</span>(<span class="i">stmt</span>.<span class="i">superclass</span>.<span class="i">name</span>.<span class="i">lexeme</span>)) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">stmt</span>.<span class="i">superclass</span>.<span class="i">name</span>,
          <span class="s">&quot;A class can&#39;t inherit from itself.&quot;</span>);
    }

</pre><pre class="insert-after">    if (stmt.superclass != null) {
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>

<p>En supposant que le code se résolve sans erreur, l&rsquo;AST voyage vers l&rsquo;interpréteur.</p>
<div class="codehilite"><pre class="insert-before">  public Void visitClassStmt(Stmt.Class stmt) {
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">    <span class="t">Object</span> <span class="i">superclass</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">superclass</span> != <span class="k">null</span>) {
      <span class="i">superclass</span> = <span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">superclass</span>);
      <span class="k">if</span> (!(<span class="i">superclass</span> <span class="k">instanceof</span> <span class="t">LoxClass</span>)) {
        <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">stmt</span>.<span class="i">superclass</span>.<span class="i">name</span>,
            <span class="s">&quot;Superclass must be a class.&quot;</span>);
      }
    }

</pre><pre class="insert-after">    environment.define(stmt.name.lexeme, null);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitClassStmt</em>()</div>

<p>Si la classe a une expression superclasse, nous l&rsquo;évaluons. Puisque cela pourrait potentiellement s&rsquo;évaluer en une autre sorte d&rsquo;objet, nous devons vérifier à l&rsquo;exécution que la chose que nous voulons être la superclasse est en fait une classe. De mauvaises choses arriveraient si nous permettions du code comme :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="t">NotAClass</span> = <span class="s">&quot;I am totally not a class&quot;</span>;

<span class="k">class</span> <span class="t">Subclass</span> &lt; <span class="t">NotAClass</span> {} <span class="c">// ?!</span>
</pre></div>
<p>En supposant que cette vérification passe, nous continuons. Exécuter une déclaration de classe transforme la représentation syntaxique d&rsquo;une classe<span class="em">&mdash;</span>son nœud AST<span class="em">&mdash;</span>en sa représentation à l&rsquo;exécution, un objet LoxClass. Nous devons tuyauter la superclasse à travers vers cela aussi. Nous passons la superclasse au constructeur.</p>
<div class="codehilite"><pre class="insert-before">      methods.put(method.name.lexeme, function);
    }

</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitClassStmt</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">LoxClass</span> <span class="i">klass</span> = <span class="k">new</span> <span class="t">LoxClass</span>(<span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>,
        (<span class="t">LoxClass</span>)<span class="i">superclass</span>, <span class="i">methods</span>);

</pre><pre class="insert-after">    environment.assign(stmt.name, klass);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitClassStmt</em>(), replace 1 line</div>

<p>Le constructeur la stocke dans un champ.</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxClass.java</em><br>
constructor <em>LoxClass</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">LoxClass</span>(<span class="t">String</span> <span class="i">name</span>, <span class="t">LoxClass</span> <span class="i">superclass</span>,
           <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">LoxFunction</span>&gt; <span class="i">methods</span>) {
    <span class="k">this</span>.<span class="i">superclass</span> = <span class="i">superclass</span>;
</pre><pre class="insert-after">    this.name = name;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, constructor <em>LoxClass</em>(), replace 1 line</div>

<p>Que nous déclarons ici :</p>
<div class="codehilite"><pre class="insert-before">  final String name;
</pre><div class="source-file"><em>lox/LoxClass.java</em><br>
in class <em>LoxClass</em></div>
<pre class="insert">  <span class="k">final</span> <span class="t">LoxClass</span> <span class="i">superclass</span>;
</pre><pre class="insert-after">  private final Map&lt;String, LoxFunction&gt; methods;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, in class <em>LoxClass</em></div>

<p>Avec cela, nous pouvons définir des classes qui sont des sous-classes d&rsquo;autres classes. Maintenant, qu&rsquo;est-ce que le fait d&rsquo;avoir une superclasse <em>fait</em> réellement ?</p>
<h2><a href="#hériter-des-méthodes" id="hériter-des-méthodes"><small>13&#8202;.&#8202;2</small>Hériter des Méthodes</a></h2>
<p>Hériter d&rsquo;une autre classe signifie que tout ce qui est <span name="liskov">vrai</span> de la superclasse devrait être vrai, plus ou moins, de la sous-classe. Dans les langages typés statiquement, cela porte beaucoup d&rsquo;implications. La sous-<em>classe</em> doit aussi être un sous-<em>type</em>, et la disposition de la mémoire est contrôlée pour que vous puissiez passer une instance d&rsquo;une sous-classe à une fonction attendant une superclasse et qu&rsquo;elle puisse toujours accéder aux champs hérités correctement.</p>
<aside name="liskov">
<p>Un nom plus chic pour cette directive vague est le <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle"><em>principe de substitution de Liskov</em></a>. Barbara Liskov l&rsquo;a introduit dans une conférence pendant la période formative de la programmation orientée objet.</p>
</aside>
<p>Lox est un langage typé dynamiquement, donc nos exigences sont beaucoup plus simples. Fondamentalement, cela signifie que si vous pouvez appeler une certaine méthode sur une instance de la superclasse, vous devriez être capable d&rsquo;appeler cette méthode quand on vous donne une instance de la sous-classe. En d&rsquo;autres termes, les méthodes sont héritées de la superclasse.</p>
<p>Cela s&rsquo;aligne avec l&rsquo;un des buts de l&rsquo;héritage<span class="em">&mdash;</span>donner aux utilisateurs un moyen de réutiliser du code à travers les classes. Implémenter cela dans notre interpréteur est étonnamment facile.</p>
<div class="codehilite"><pre class="insert-before">      return methods.get(name);
    }

</pre><div class="source-file"><em>lox/LoxClass.java</em><br>
in <em>findMethod</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">superclass</span> != <span class="k">null</span>) {
      <span class="k">return</span> <span class="i">superclass</span>.<span class="i">findMethod</span>(<span class="i">name</span>);
    }

</pre><pre class="insert-after">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, in <em>findMethod</em>()</div>

<p>C&rsquo;est littéralement tout ce qu&rsquo;il y a à faire. Quand nous cherchons une méthode sur une instance, si nous ne la trouvons pas sur la classe de l&rsquo;instance, nous récursons vers le haut à travers la chaîne de superclasses et cherchons là. Donnez-lui un essai :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">&quot;Fry until golden brown.&quot;</span>;
  }
}

<span class="k">class</span> <span class="t">BostonCream</span> &lt; <span class="t">Doughnut</span> {}

<span class="t">BostonCream</span>().<span class="i">cook</span>();
</pre></div>
<p>Et voilà, la moitié de nos fonctionnalités d&rsquo;héritage sont complètes avec seulement trois lignes de code Java.</p>
<h2><a href="#appeler-les-méthodes-de-superclasse" id="appeler-les-méthodes-de-superclasse"><small>13&#8202;.&#8202;3</small>Appeler les Méthodes de Superclasse</a></h2>
<p>Dans <code>findMethod()</code> nous cherchons une méthode sur la classe courante <em>avant</em> de marcher vers le haut de la chaîne de superclasses. Si une méthode avec le même nom existe à la fois dans la sous-classe et la superclasse, celle de la sous-classe prend la précédence ou <strong>redéfinit</strong> la méthode de la superclasse. Un peu comme comment les variables dans les portées internes masquent celles externes.</p>
<p>C&rsquo;est super si la sous-classe veut <em>remplacer</em> certain comportement de superclasse complètement. Mais, en pratique, les sous-classes veulent souvent <em>raffiner</em> le comportement de la superclasse. Elles veulent faire un peu de travail spécifique à la sous-classe, mais aussi exécuter le comportement original de la superclasse aussi.</p>
<p>Cependant, puisque la sous-classe a redéfini la méthode, il n&rsquo;y a aucun moyen de faire référence à celle originale. Si la méthode de sous-classe essaie de l&rsquo;appeler par nom, elle frappera juste récursivement sa propre redéfinition. Nous avons besoin d&rsquo;un moyen de dire &ldquo;Appelle cette méthode, mais cherche-la directement sur ma superclasse et ignore ma redéfinition&rdquo;. Java utilise <code>super</code> pour cela, et nous utiliserons cette même syntaxe dans Lox. Voici un exemple :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">&quot;Fry until golden brown.&quot;</span>;
  }
}

<span class="k">class</span> <span class="t">BostonCream</span> &lt; <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">super</span>.<span class="i">cook</span>();
    <span class="k">print</span> <span class="s">&quot;Pipe full of custard and coat with chocolate.&quot;</span>;
  }
}

<span class="t">BostonCream</span>().<span class="i">cook</span>();
</pre></div>
<p>Si vous lancez ceci, cela devrait imprimer :</p>
<div class="codehilite"><pre>Fry until golden brown.
Pipe full of custard and coat with chocolate.
</pre></div>
<p>Nous avons une nouvelle forme d&rsquo;expression. Le mot-clé <code>super</code>, suivi par un point et un identifieur, cherche une méthode avec ce nom. Contrairement aux appels sur <code>this</code>, la recherche commence à la superclasse.</p>
<h3><a href="#syntaxe" id="syntaxe"><small>13&#8202;.&#8202;3&#8202;.&#8202;1</small>Syntaxe</a></h3>
<p>Avec <code>this</code>, le mot-clé fonctionne un peu comme une variable magique, et l&rsquo;expression est ce token solitaire. Mais avec <code>super</code>, le <code>.</code> subséquent et le nom de propriété sont des parties inséparables de l&rsquo;expression <code>super</code>. Vous ne pouvez pas avoir un token <code>super</code> nu tout seul.</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="k">super</span>; <span class="c">// Erreur de syntaxe.</span>
</pre></div>
<p>Donc la nouvelle clause que nous ajoutons à la règle <code>primary</code> dans notre grammaire inclut l&rsquo;accès de propriété aussi.</p>
<div class="codehilite"><pre><span class="i">primary</span>        → <span class="s">&quot;true&quot;</span> | <span class="s">&quot;false&quot;</span> | <span class="s">&quot;nil&quot;</span> | <span class="s">&quot;this&quot;</span>
               | <span class="t">NUMBER</span> | <span class="t">STRING</span> | <span class="t">IDENTIFIER</span> | <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span>
               | <span class="s">&quot;super&quot;</span> <span class="s">&quot;.&quot;</span> <span class="t">IDENTIFIER</span> ;
</pre></div>
<p>Typiquement, une expression <code>super</code> est utilisée pour un appel de méthode, mais, comme avec les méthodes régulières, la liste d&rsquo;arguments ne fait <em>pas</em> partie de l&rsquo;expression. Au lieu de cela, un <em>appel</em> super est un <em>accès</em> super suivi par un appel de fonction. Comme les autres appels de méthode, vous pouvez obtenir une poignée vers une méthode de superclasse et l&rsquo;invoquer séparément.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">method</span> = <span class="k">super</span>.<span class="i">cook</span>;
<span class="i">method</span>();
</pre></div>
<p>Donc l&rsquo;expression <code>super</code> elle-même contient seulement le token pour le mot-clé <code>super</code> et le nom de la méthode étant cherchée. Le <span name="super-ast">nœud d&rsquo;arbre syntaxique</span> correspondant est ainsi :</p>
<div class="codehilite"><pre class="insert-before">      &quot;Set      : Expr object, Token name, Expr value&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Super    : Token keyword, Token method&quot;</span>,
</pre><pre class="insert-after">      &quot;This     : Token keyword&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="super-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#super-expression">Annexe II</a>.</p>
</aside>
<p>Suivant la grammaire, le nouveau code de parsing va à l&rsquo;intérieur de notre méthode <code>primary()</code> existante.</p>
<div class="codehilite"><pre class="insert-before">      return new Expr.Literal(previous().literal);
    }
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>primary</em>()</div>
<pre class="insert">

    <span class="k">if</span> (<span class="i">match</span>(<span class="i">SUPER</span>)) {
      <span class="t">Token</span> <span class="i">keyword</span> = <span class="i">previous</span>();
      <span class="i">consume</span>(<span class="i">DOT</span>, <span class="s">&quot;Expect &#39;.&#39; after &#39;super&#39;.&quot;</span>);
      <span class="t">Token</span> <span class="i">method</span> = <span class="i">consume</span>(<span class="i">IDENTIFIER</span>,
          <span class="s">&quot;Expect superclass method name.&quot;</span>);
      <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Super</span>(<span class="i">keyword</span>, <span class="i">method</span>);
    }
</pre><pre class="insert-after">

    if (match(THIS)) return new Expr.This(previous());
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>primary</em>()</div>

<p>Un mot-clé <code>super</code> en tête nous dit que nous avons frappé une expression <code>super</code>. Après cela nous consommons le <code>.</code> attendu et le nom de méthode.</p>
<h3><a href="#sémantique" id="sémantique"><small>13&#8202;.&#8202;3&#8202;.&#8202;2</small>Sémantique</a></h3>
<p>Plus tôt, j&rsquo;ai dit qu&rsquo;une expression <code>super</code> commence la recherche de méthode depuis &ldquo;la superclasse&rdquo;, mais <em>quelle</em> superclasse ? La réponse naïve est la superclasse de <code>this</code>, l&rsquo;objet sur lequel la méthode environnante a été appelée. Cela produit par coïncidence le bon comportement dans beaucoup de cas, mais ce n&rsquo;est pas réellement correct. Contemplez :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">A</span> {
  <span class="i">method</span>() {
    <span class="k">print</span> <span class="s">&quot;A method&quot;</span>;
  }
}

<span class="k">class</span> <span class="t">B</span> &lt; <span class="t">A</span> {
  <span class="i">method</span>() {
    <span class="k">print</span> <span class="s">&quot;B method&quot;</span>;
  }

  <span class="i">test</span>() {
    <span class="k">super</span>.<span class="i">method</span>();
  }
}

<span class="k">class</span> <span class="t">C</span> &lt; <span class="t">B</span> {}

<span class="t">C</span>().<span class="i">test</span>();
</pre></div>
<p>Traduisez ce programme en Java, C#, ou C++ et il imprimera &ldquo;A method&rdquo;, ce qui est ce que nous voulons que Lox fasse aussi. Quand ce programme s&rsquo;exécute, à l&rsquo;intérieur du corps de <code>test()</code>, <code>this</code> est une instance de C. La superclasse de C est B, mais ce n&rsquo;est <em>pas</em> là où la recherche devrait commencer. Si elle le faisait, nous frapperions la <code>method()</code> de B.</p>
<p>Au lieu de cela, la recherche devrait commencer sur la superclasse de <em>la classe contenant l&rsquo;expression <code>super</code></em>. Dans ce cas, puisque <code>test()</code> est défini à l&rsquo;intérieur de B, l&rsquo;expression <code>super</code> à l&rsquo;intérieur devrait commencer la recherche sur la superclasse de <em>B</em><span class="em">&mdash;</span>A.</p>
<p><span name="flow"></span></p><img src="image/inheritance/classes.png" alt="La chaîne d'appel s'écoulant à travers les classes." />
<aside name="flow">
<p>Le flux d&rsquo;exécution ressemble à quelque chose comme ceci :</p>
<ol>
<li>
<p>Nous appelons <code>test()</code> sur une instance de C.</p>
</li>
<li>
<p>Cela entre dans la méthode <code>test()</code> héritée de B. Cela appelle <code>super.method()</code>.</p>
</li>
<li>
<p>La superclasse de B est A, donc cela enchaîne vers <code>method()</code> sur A, et le programme imprime &ldquo;A method&rdquo;.</p>
</li>
</ol>
</aside>
<p>Ainsi, afin d&rsquo;évaluer une expression <code>super</code>, nous avons besoin de l&rsquo;accès à la superclasse de la définition de classe entourant l&rsquo;appel. Hélas, au point dans l&rsquo;interpréteur où nous exécutons une expression <code>super</code>, nous n&rsquo;avons pas cela facilement disponible.</p>
<p>Nous <em>pourrions</em> ajouter un champ à LoxFunction pour stocker une référence à la LoxClass qui possède cette méthode. L&rsquo;interpréteur garderait une référence à la LoxFunction s&rsquo;exécutant actuellement pour que nous puissions la chercher plus tard quand nous frappons une expression <code>super</code>. De là, nous obtiendrions la LoxClass de la méthode, puis sa superclasse.</p>
<p>C&rsquo;est beaucoup de tuyauterie. Dans le [dernier chapitre][], nous avions un problème similaire quand nous avions besoin d&rsquo;ajouter le support pour <code>this</code>. Dans ce cas, nous avons utilisé notre mécanisme existant d&rsquo;environnement et de fermeture pour stocker une référence à l&rsquo;objet courant. Pourrions-nous faire quelque chose de similaire pour stocker la superclasse <span name="rhetorical">?</span> Eh bien, je ne serais probablement pas en train d&rsquo;en parler si la réponse était non, donc<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>oui.</p>
<aside name="rhetorical">
<p>Est-ce que quelqu&rsquo;un aime même les questions rhétoriques ?</p>
</aside>
<p>Une différence importante est que nous lions <code>this</code> quand la méthode est <em>accédée</em>. La même méthode peut être appelée sur différentes instances et chacune a besoin de son propre <code>this</code>. Avec les expressions <code>super</code>, la superclasse est une propriété fixe de la <em>déclaration de classe elle-même</em>. Chaque fois que vous évaluez une certaine expression <code>super</code>, la superclasse est toujours la même.</p>
<p>Cela signifie que nous pouvons créer l&rsquo;environnement pour la superclasse une fois, quand la définition de classe est exécutée. Immédiatement avant que nous définissions les méthodes, nous faisons un nouvel environnement pour lier la superclasse de la classe au nom &ldquo;super&rdquo;.</p><img src="image/inheritance/superclass.png" alt="L'environnement de superclasse." />
<p>Quand nous créons la représentation d&rsquo;exécution LoxFunction pour chaque méthode, c&rsquo;est l&rsquo;environnement qu&rsquo;elles captureront dans leur fermeture. Plus tard, quand une méthode est invoquée et <code>this</code> est lié, l&rsquo;environnement de superclasse devient le parent pour l&rsquo;environnement de la méthode, comme ceci :</p><img src="image/inheritance/environments.png" alt="La chaîne d'environnement incluant l'environnement de superclasse." />
<p>C&rsquo;est beaucoup de machinerie, mais nous la traverserons une étape à la fois. Avant que nous puissions arriver à créer l&rsquo;environnement à l&rsquo;exécution, nous devons gérer la chaîne de portée correspondante dans le résolveur.</p>
<div class="codehilite"><pre class="insert-before">      resolve(stmt.superclass);
    }
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">

    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">superclass</span> != <span class="k">null</span>) {
      <span class="i">beginScope</span>();
      <span class="i">scopes</span>.<span class="i">peek</span>().<span class="i">put</span>(<span class="s">&quot;super&quot;</span>, <span class="k">true</span>);
    }
</pre><pre class="insert-after">

    beginScope();
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>

<p>Si la déclaration de classe a une superclasse, alors nous créons une nouvelle portée entourant toutes ses méthodes. Dans cette portée, nous définissons le nom &ldquo;super&rdquo;. Une fois que nous avons fini de résoudre les méthodes de la classe, nous jetons cette portée.</p>
<div class="codehilite"><pre class="insert-before">    endScope();

</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">superclass</span> != <span class="k">null</span>) <span class="i">endScope</span>();

</pre><pre class="insert-after">    currentClass = enclosingClass;
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>

<p>C&rsquo;est une optimisation mineure, mais nous créons seulement l&rsquo;environnement de superclasse si la classe a réellement <em>une</em> superclasse. Il n&rsquo;y a pas de but à le créer quand il n&rsquo;y a pas de superclasse puisqu&rsquo;il n&rsquo;y aurait pas de superclasse à stocker dedans de toute façon.</p>
<p>Avec &ldquo;super&rdquo; défini dans une chaîne de portée, nous sommes capables de résoudre l&rsquo;expression <code>super</code> elle-même.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitSetExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitSuperExpr</span>(<span class="t">Expr</span>.<span class="t">Super</span> <span class="i">expr</span>) {
    <span class="i">resolveLocal</span>(<span class="i">expr</span>, <span class="i">expr</span>.<span class="i">keyword</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitSetExpr</em>()</div>

<p>Nous résolvons le token <code>super</code> exactement comme si c&rsquo;était une variable. La résolution stocke le nombre de sauts le long de la chaîne d&rsquo;environnement que l&rsquo;interpréteur a besoin de marcher pour trouver l&rsquo;environnement où la superclasse est stockée.</p>
<p>Ce code est reflété dans l&rsquo;interpréteur. Quand nous évaluons une définition de sous-classe, nous créons un nouvel environnement.</p>
<div class="codehilite"><pre class="insert-before">        throw new RuntimeError(stmt.superclass.name,
            &quot;Superclass must be a class.&quot;);
      }
    }

    environment.define(stmt.name.lexeme, null);
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">

    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">superclass</span> != <span class="k">null</span>) {
      <span class="i">environment</span> = <span class="k">new</span> <span class="t">Environment</span>(<span class="i">environment</span>);
      <span class="i">environment</span>.<span class="i">define</span>(<span class="s">&quot;super&quot;</span>, <span class="i">superclass</span>);
    }
</pre><pre class="insert-after">

    Map&lt;String, LoxFunction&gt; methods = new HashMap&lt;&gt;();
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitClassStmt</em>()</div>

<p>À l&rsquo;intérieur de cet environnement, nous stockons une référence à la superclasse<span class="em">&mdash;</span>l&rsquo;objet LoxClass réel pour la superclasse que nous avons maintenant que nous sommes dans le runtime. Ensuite nous créons les LoxFunctions pour chaque méthode. Celles-ci vont capturer l&rsquo;environnement courant<span class="em">&mdash;</span>celui où nous venons de lier &ldquo;super&rdquo;<span class="em">&mdash;</span>comme leur fermeture, s&rsquo;accrochant à la superclasse comme nous en avons besoin. Une fois que c&rsquo;est fait, nous dépilons l&rsquo;environnement.</p>
<div class="codehilite"><pre class="insert-before">    LoxClass klass = new LoxClass(stmt.name.lexeme,
        (LoxClass)superclass, methods);
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">

    <span class="k">if</span> (<span class="i">superclass</span> != <span class="k">null</span>) {
      <span class="i">environment</span> = <span class="i">environment</span>.<span class="i">enclosing</span>;
    }
</pre><pre class="insert-after">

    environment.assign(stmt.name, klass);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitClassStmt</em>()</div>

<p>Nous sommes prêts à interpréter les expressions <code>super</code> elles-mêmes. Il y a quelques pièces mobiles, donc nous construirons cette méthode en morceaux.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitSetExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitSuperExpr</span>(<span class="t">Expr</span>.<span class="t">Super</span> <span class="i">expr</span>) {
    <span class="t">int</span> <span class="i">distance</span> = <span class="i">locals</span>.<span class="i">get</span>(<span class="i">expr</span>);
    <span class="t">LoxClass</span> <span class="i">superclass</span> = (<span class="t">LoxClass</span>)<span class="i">environment</span>.<span class="i">getAt</span>(
        <span class="i">distance</span>, <span class="s">&quot;super&quot;</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitSetExpr</em>()</div>

<p>D&rsquo;abord, le travail auquel nous avons mené. Nous cherchons la superclasse de la classe environnante en cherchant &ldquo;super&rdquo; dans l&rsquo;environnement approprié.</p>
<p>Quand nous accédons à une méthode, nous avons aussi besoin de lier <code>this</code> à l&rsquo;objet depuis lequel la méthode est accédée. Dans une expression comme <code>beignet.cook</code>, l&rsquo;objet est tout ce que nous obtenons de l&rsquo;évaluation de <code>beignet</code>. Dans une expression <code>super</code> comme <code>super.cook</code>, l&rsquo;objet courant est implicitement le <em>même</em> objet courant que nous utilisons. En d&rsquo;autres termes, <code>this</code>. Même si nous cherchons la <em>méthode</em> sur la superclasse, l&rsquo;<em>instance</em> est toujours <code>this</code>.</p>
<p>Malheureusement, à l&rsquo;intérieur de l&rsquo;expression <code>super</code>, nous n&rsquo;avons pas de nœud pratique auquel le résolveur peut accrocher le nombre de sauts vers <code>this</code>. Heureusement, nous contrôlons la disposition des chaînes d&rsquo;environnement. L&rsquo;environnement où &ldquo;this&rdquo; est lié est toujours juste à l&rsquo;intérieur de l&rsquo;environnement où nous stockons &ldquo;super&rdquo;.</p>
<div class="codehilite"><pre class="insert-before">    LoxClass superclass = (LoxClass)environment.getAt(
        distance, &quot;super&quot;);
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitSuperExpr</em>()</div>
<pre class="insert">

    <span class="t">LoxInstance</span> <span class="i">object</span> = (<span class="t">LoxInstance</span>)<span class="i">environment</span>.<span class="i">getAt</span>(
        <span class="i">distance</span> - <span class="n">1</span>, <span class="s">&quot;this&quot;</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitSuperExpr</em>()</div>

<p>Décaler la distance de un cherche &ldquo;this&rdquo; dans cet environnement interne. J&rsquo;admets que ce n&rsquo;est pas le code le plus <span name="elegant">élégant</span>, mais ça marche.</p>
<aside name="elegant">
<p>Écrire un livre qui inclut chaque ligne de code unique pour un programme signifie que je ne peux pas cacher les bidouilles en les laissant comme un &ldquo;exercice pour le lecteur&rdquo;.</p>
</aside>
<p>Maintenant nous sommes prêts à chercher et lier la méthode, en commençant à la superclasse.</p>
<div class="codehilite"><pre class="insert-before">    LoxInstance object = (LoxInstance)environment.getAt(
        distance - 1, &quot;this&quot;);
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitSuperExpr</em>()</div>
<pre class="insert">

    <span class="t">LoxFunction</span> <span class="i">method</span> = <span class="i">superclass</span>.<span class="i">findMethod</span>(<span class="i">expr</span>.<span class="i">method</span>.<span class="i">lexeme</span>);
    <span class="k">return</span> <span class="i">method</span>.<span class="i">bind</span>(<span class="i">object</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitSuperExpr</em>()</div>

<p>C&rsquo;est presque exactement comme le code pour chercher une méthode d&rsquo;une expression d&rsquo;accès, sauf que nous appelons <code>findMethod()</code> sur la superclasse au lieu de sur la classe de l&rsquo;objet courant.</p>
<p>C&rsquo;est fondamentalement ça. Sauf, bien sûr, que nous pourrions <em>échouer</em> à trouver la méthode. Donc nous vérifions cela aussi.</p>
<div class="codehilite"><pre class="insert-before">

    LoxFunction method = superclass.findMethod(expr.method.lexeme);
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitSuperExpr</em>()</div>
<pre class="insert">

    <span class="k">if</span> (<span class="i">method</span> == <span class="k">null</span>) {
      <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">expr</span>.<span class="i">method</span>,
          <span class="s">&quot;Undefined property &#39;&quot;</span> + <span class="i">expr</span>.<span class="i">method</span>.<span class="i">lexeme</span> + <span class="s">&quot;&#39;.&quot;</span>);
    }

</pre><pre class="insert-after">    return method.bind(object);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitSuperExpr</em>()</div>

<p>Vous l&rsquo;avez ! Prenez cet exemple BostonCream de tout à l&rsquo;heure et donnez-lui un essai. En supposant que vous et moi ayons tout fait correctement, cela devrait le frire d&rsquo;abord, puis le fourrer avec de la crème.</p>
<h3><a href="#usages-invalides-de-super" id="usages-invalides-de-super"><small>13&#8202;.&#8202;3&#8202;.&#8202;3</small>Usages invalides de super</a></h3>
<p>Comme avec les fonctionnalités de langage précédentes, notre implémentation fait la bonne chose quand l&rsquo;utilisateur écrit du code correct, mais nous n&rsquo;avons pas blindé l&rsquo;interpréteur contre le mauvais code. En particulier, considérez :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Eclair</span> {
  <span class="i">cook</span>() {
    <span class="k">super</span>.<span class="i">cook</span>();
    <span class="k">print</span> <span class="s">&quot;Pipe full of crème pâtissière.&quot;</span>;
  }
}
</pre></div>
<p>Cette classe a une expression <code>super</code>, mais pas de superclasse. À l&rsquo;exécution, le code pour évaluer les expressions <code>super</code> suppose que &ldquo;super&rdquo; a été résolu avec succès et sera trouvé dans l&rsquo;environnement. Cela va échouer ici parce qu&rsquo;il n&rsquo;y a pas d&rsquo;environnement environnant pour la superclasse puisqu&rsquo;il n&rsquo;y a pas de superclasse. La JVM lancera une exception et mettra notre interpréteur à genoux.</p>
<p>Zut, il y a même des utilisations cassées plus simples de super :</p>
<div class="codehilite"><pre><span class="k">super</span>.<span class="i">notEvenInAClass</span>();
</pre></div>
<p>Nous pourrions gérer des erreurs comme celles-ci à l&rsquo;exécution en vérifiant pour voir si la recherche de &ldquo;super&rdquo; a réussi. Mais nous pouvons dire statiquement<span class="em">&mdash;</span>juste en regardant le code source<span class="em">&mdash;</span>que Eclair n&rsquo;a pas de superclasse et ainsi aucune expression <code>super</code> ne marchera à l&rsquo;intérieur. De même, dans le second exemple, nous savons que l&rsquo;expression <code>super</code> n&rsquo;est même pas à l&rsquo;intérieur d&rsquo;un corps de méthode.</p>
<p>Même si Lox est typé dynamiquement, cela ne veut pas dire que nous voulons différer <em>tout</em> à l&rsquo;exécution. Si l&rsquo;utilisateur a fait une erreur, nous aimerions les aider à la trouver plus tôt plutôt que plus tard. Donc nous rapporterons ces erreurs statiquement, dans le résolveur.</p>
<p>D&rsquo;abord, nous ajoutons un nouveau cas à l&rsquo;enum que nous utilisons pour garder la trace de quel genre de classe entoure le code courant étant visité.</p>
<div class="codehilite"><pre class="insert-before">    NONE,
</pre><pre class="insert-before">    <span class="i">CLASS</span><span class="insert-comma">,</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in enum <em>ClassType</em><br>
add <em>&ldquo;,&rdquo;</em> to previous line</div>
<pre class="insert">    <span class="i">SUBCLASS</span>
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in enum <em>ClassType</em>, add <em>&ldquo;,&rdquo;</em> to previous line</div>

<p>Nous utiliserons cela pour distinguer quand nous sommes à l&rsquo;intérieur d&rsquo;une classe qui a une superclasse contre une qui n&rsquo;en a pas. Quand nous résolvons une déclaration de classe, nous définissons cela si la classe est une sous-classe.</p>
<div class="codehilite"><pre class="insert-before">    if (stmt.superclass != null) {
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">      <span class="i">currentClass</span> = <span class="t">ClassType</span>.<span class="i">SUBCLASS</span>;
</pre><pre class="insert-after">      resolve(stmt.superclass);
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>

<p>Ensuite, quand nous résolvons une expression <code>super</code>, nous vérifions pour voir que nous sommes actuellement à l&rsquo;intérieur d&rsquo;une portée où c&rsquo;est autorisé.</p>
<div class="codehilite"><pre class="insert-before">  public Void visitSuperExpr(Expr.Super expr) {
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitSuperExpr</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">currentClass</span> == <span class="t">ClassType</span>.<span class="i">NONE</span>) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">expr</span>.<span class="i">keyword</span>,
          <span class="s">&quot;Can&#39;t use &#39;super&#39; outside of a class.&quot;</span>);
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">currentClass</span> != <span class="t">ClassType</span>.<span class="i">SUBCLASS</span>) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">expr</span>.<span class="i">keyword</span>,
          <span class="s">&quot;Can&#39;t use &#39;super&#39; in a class with no superclass.&quot;</span>);
    }

</pre><pre class="insert-after">    resolveLocal(expr, expr.keyword);
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitSuperExpr</em>()</div>

<p>Si non<span class="em">&mdash;</span>oups !<span class="em">&mdash;</span>l&rsquo;utilisateur a fait une erreur.</p>
<h2><a href="#conclusion" id="conclusion"><small>13&#8202;.&#8202;4</small>Conclusion</a></h2>
<p>Nous l&rsquo;avons fait ! Ce dernier bout de gestion d&rsquo;erreur est le dernier morceau de code nécessaire pour compléter notre implémentation Java de Lox. C&rsquo;est un réel <span name="superhero">accomplissement</span> et un dont vous devriez être fier. Dans la douzaine de chapitres passés et un millier ou presque de lignes de code, nous avons appris et implémenté<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<ul>
<li><a href="analyse-lexicale.html">tokens et analyse lexicale</a>,</li>
<li><a href="représentation-du-code.html">arbres syntaxiques abstraits</a>,</li>
<li><a href="analyse-des-expressions.html">analyse récursive descendante</a>,</li>
<li>expressions préfixes et infixes,</li>
<li>représentation à l&rsquo;exécution des objets,</li>
<li><a href="évaluation-des-expressions.html">interprétation de code utilisant le pattern Visiteur</a>,</li>
<li><a href="instructions-et-état.html">portée lexicale</a>,</li>
<li>chaînes d&rsquo;environnement pour stocker les variables,</li>
<li><a href="contrôle-de-flux.html">contrôle de flux</a>,</li>
<li><a href="fonctions.html">fonctions avec paramètres</a>,</li>
<li>fermetures,</li>
<li><a href="résolution-et-liaison.html">résolution de variable statique et détection d&rsquo;erreur</a>,</li>
<li><a href="classes.html">classes</a>,</li>
<li>constructeurs,</li>
<li>champs,</li>
<li>méthodes, et finalement,</li>
<li>héritage.</li>
</ul>
<aside name="superhero"><img src="image/inheritance/superhero.png" alt="Vous, étant votre mauvais soi." />
</aside>
<p>Nous avons fait tout cela à partir de rien, avec aucune dépendance externe ou outils magiques. Juste vous et moi, nos éditeurs de texte respectifs, une paire de classes de collection de la bibliothèque standard Java, et le runtime JVM.</p>
<p>Cela marque la fin de la Partie II, mais pas la fin du livre. Prenez une pause. Peut-être écrivez quelques programmes Lox amusants et lancez-les dans votre interpréteur. (Vous pouvez vouloir ajouter quelques méthodes natives de plus pour des choses comme lire l&rsquo;entrée utilisateur.) Quand vous serez rafraîchi et prêt, nous embarquerons pour notre <a href="une-machine-virtuelle-a-bytecode.html">prochaine aventure</a>.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>13&#8202;.&#8202;5</small>Défis</a></h2>
<ol>
<li>
<p>Lox supporte seulement l&rsquo;<em>héritage simple</em><span class="em">&mdash;</span>une classe peut avoir une seule superclasse et c&rsquo;est le seul moyen de réutiliser des méthodes à travers les classes. D&rsquo;autres langages ont exploré une variété de façons de réutiliser et partager plus librement des capacités à travers les classes : mixins, traits, héritage multiple, héritage virtuel, méthodes d&rsquo;extension, etc.</p>
<p>Si vous deviez ajouter une certaine fonctionnalité le long de ces lignes à Lox, laquelle choisiriez-vous et pourquoi ? Si vous vous sentez courageux (et vous devriez l&rsquo;être à ce point), allez-y et ajoutez-la.</p>
</li>
<li>
<p>Dans Lox, comme dans la plupart des autres langages orientés objet, quand nous cherchons une méthode, nous commençons au bas de la hiérarchie de classe et travaillons notre chemin vers le haut<span class="em">&mdash;</span>une méthode de sous-classe est préférée sur celle d&rsquo;une superclasse. Afin d&rsquo;atteindre la méthode de superclasse depuis l&rsquo;intérieur d&rsquo;une méthode de redéfinition, vous utilisez <code>super</code>.</p>
<p>Le langage <a href="https://beta.cs.au.dk/">BETA</a> prend l&rsquo;<a href="http://journal.stuffwithstuff.com/2012/12/19/the-impoliteness-of-overriding-methods/">approche opposée</a>. Quand vous appelez une méthode, elle commence au <em>sommet</em> de la hiérarchie de classe et travaille vers le <em>bas</em>. Une méthode de superclasse gagne sur une méthode de sous-classe. Afin d&rsquo;atteindre la méthode de sous-classe, la méthode de superclasse peut appeler <code>inner</code>, qui est en quelque sorte comme l&rsquo;inverse de <code>super</code>. Cela enchaîne vers la prochaine méthode en bas de la hiérarchie.</p>
<p>La méthode de superclasse contrôle quand et où il est permis à la sous-classe de raffiner son comportement. Si la méthode de superclasse n&rsquo;appelle pas <code>inner</code> du tout, alors la sous-classe n&rsquo;a aucun moyen de redéfinir ou modifier le comportement de la superclasse.</p>
<p>Enlevez le comportement actuel de redéfinition et de <code>super</code> de Lox et remplacez-le avec la sémantique de BETA. En bref :</p>
<ul>
<li>
<p>Quand une méthode est appelée sur une classe, préférez la méthode <em>la plus haute</em> sur la chaîne d&rsquo;héritage de la classe.</p>
</li>
<li>
<p>À l&rsquo;intérieur du corps d&rsquo;une méthode, un appel à <code>inner</code> cherche une méthode avec le même nom dans la sous-classe la plus proche le long de la chaîne d&rsquo;héritage entre la classe contenant le <code>inner</code> et la classe de <code>this</code>. S&rsquo;il n&rsquo;y a pas de méthode correspondante, l&rsquo;appel <code>inner</code> ne fait rien.</p>
</li>
</ul>
<p>Par exemple :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">&quot;Fry until golden brown.&quot;</span>;
    <span class="i">inner</span>();
    <span class="k">print</span> <span class="s">&quot;Place in a nice box.&quot;</span>;
  }
}

<span class="k">class</span> <span class="t">BostonCream</span> &lt; <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">&quot;Pipe full of custard and coat with chocolate.&quot;</span>;
  }
}

<span class="t">BostonCream</span>().<span class="i">cook</span>();
</pre></div>
<p>Cela devrait imprimer :</p>
<div class="codehilite"><pre>Fry until golden brown.
Pipe full of custard and coat with chocolate.
Place in a nice box.
</pre></div>
</li>
<li>
<p>Dans le chapitre où j&rsquo;ai présenté Lox, <a href="le-langage-lox.html#defis">je vous ai mis au défi</a> d&rsquo;arriver avec une paire de fonctionnalités dont vous pensez que le langage manque. Maintenant que vous savez comment construire un interpréteur, implémentez l&rsquo;une de ces fonctionnalités.</p>
</li>
</ol>
</div>

<footer>
<a href="une-machine-virtuelle-à-bytecode.html" class="next">
  Next Part: &ldquo;Une machine virtuelle à bytecode&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
