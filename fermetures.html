<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Fermetures &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Fermetures<small>25</small></a></h3>

<ul>
    <li><a href="#objets-fermeture"><small>25.1</small> Objets Fermeture</a></li>
    <li><a href="#upvalues"><small>25.2</small> Upvalues</a></li>
    <li><a href="#objets-upvalue"><small>25.3</small> Objets Upvalue</a></li>
    <li><a href="#upvalues-fermées"><small>25.4</small> Upvalues fermées</a></li>
    <li><a href="#défis"><small>25.5</small> Défis</a></li>
    <li><a href="#note-de-conception--fermer-sur-la-variable-de-boucle"><small>25.6</small> Note de Conception : Fermer sur la Variable de Boucle</a></li>
</ul>


<div class="prev-next">
    <a href="appels-et-fonctions.html" title="Appels et fonctions" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="ramasse-miettes.html" title="Ramasse-miettes" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="appels-et-fonctions.html" title="Appels et fonctions" class="prev">←</a>
<a href="ramasse-miettes.html" title="Ramasse-miettes" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Fermetures<small>25</small></a></h3>

<ul>
    <li><a href="#objets-fermeture"><small>25.1</small> Objets Fermeture</a></li>
    <li><a href="#upvalues"><small>25.2</small> Upvalues</a></li>
    <li><a href="#objets-upvalue"><small>25.3</small> Objets Upvalue</a></li>
    <li><a href="#upvalues-fermées"><small>25.4</small> Upvalues fermées</a></li>
    <li><a href="#défis"><small>25.5</small> Défis</a></li>
    <li><a href="#note-de-conception--fermer-sur-la-variable-de-boucle"><small>25.6</small> Note de Conception : Fermer sur la Variable de Boucle</a></li>
</ul>


<div class="prev-next">
    <a href="appels-et-fonctions.html" title="Appels et fonctions" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="ramasse-miettes.html" title="Ramasse-miettes" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">25</div>
  <h1>Fermetures</h1>

<blockquote>
<p>Comme l&rsquo;homme l&rsquo;a dit, pour chaque problème complexe il y a une solution simple, et elle est fausse.</p>
<p><cite>Umberto Eco, <em>Le Pendule de Foucault</em></cite></p>
</blockquote>
<p>Grâce à notre travail diligent dans <a href="appels-et-fonctions.html">le dernier chapitre</a>, nous avons une machine virtuelle avec des fonctions fonctionnelles. Ce qui lui manque, ce sont les fermetures (closures). À part les variables globales, qui sont leur propre race d&rsquo;animal, une fonction n&rsquo;a aucun moyen de référencer une variable déclarée en dehors de son propre corps.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">x</span> = <span class="s">&quot;global&quot;</span>;
<span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="s">&quot;outer&quot;</span>;
  <span class="k">fun</span> <span class="i">inner</span>() {
    <span class="k">print</span> <span class="i">x</span>;
  }
  <span class="i">inner</span>();
}
<span class="i">outer</span>();
</pre></div>
<p>Exécutez cet exemple maintenant et il affiche &ldquo;global&rdquo;. Il est supposé afficher &ldquo;outer&rdquo;. Pour corriger cela, nous devons inclure la portée lexicale entière de toutes les fonctions environnantes lors de la résolution d&rsquo;une variable.</p>
<p>Ce problème est plus difficile dans clox qu&rsquo;il ne l&rsquo;était dans jlox parce que notre VM à bytecode stocke les locales sur une pile. Nous avons utilisé une pile parce que j&rsquo;ai prétendu que les locales ont une sémantique de pile<span class="em">&mdash;</span>les variables sont jetées dans l&rsquo;ordre inverse de leur création. Mais avec les fermetures, c&rsquo;est seulement <em>surtout</em> vrai.</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">makeClosure</span>() {
  <span class="k">var</span> <span class="i">local</span> = <span class="s">&quot;local&quot;</span>;
  <span class="k">fun</span> <span class="i">closure</span>() {
    <span class="k">print</span> <span class="i">local</span>;
  }
  <span class="k">return</span> <span class="i">closure</span>;
}

<span class="k">var</span> <span class="i">closure</span> = <span class="i">makeClosure</span>();
<span class="i">closure</span>();
</pre></div>
<p>La fonction extérieure <code>makeClosure()</code> déclare une variable, <code>local</code>. Elle crée aussi une fonction intérieure, <code>closure()</code> qui capture cette variable. Ensuite <code>makeClosure()</code> renvoie une référence à cette fonction. Puisque la fermeture <span name="flying">s&rsquo;échappe</span> tout en tenant la variable locale, <code>local</code> doit survivre à l&rsquo;appel de fonction où elle a été créée.</p>
<aside name="flying"><img src="image/closures/flying.png" class="above" alt="Une variable locale s'envolant de la pile."/>
<p>Oh non, elle s&rsquo;échappe !</p>
</aside>
<p>Nous pourrions résoudre ce problème en allouant dynamiquement la mémoire pour toutes les variables locales. C&rsquo;est ce que jlox fait en mettant tout dans ces objets Environment qui flottent dans le tas de Java. Mais nous ne voulons pas. Utiliser une <span name="stack">pile</span> est <em>vraiment</em> rapide. La plupart des variables locales ne sont <em>pas</em> capturées par des fermetures et ont bien une sémantique de pile. Cela craindrait de rendre toutes celles-là plus lentes pour le bénéfice de la rare locale qui est capturée.</p>
<aside name="stack">
<p>Il y a une raison pour laquelle C et Java utilisent la pile pour leurs variables locales, après tout.</p>
</aside>
<p>Cela signifie une approche plus complexe que celle que nous avons utilisée dans notre interpréteur Java. Parce que certaines locales ont des durées de vie très différentes, nous aurons deux stratégies d&rsquo;implémentation. Pour les locales qui ne sont pas utilisées dans des fermetures, nous les garderons juste comme elles sont sur la pile. Quand une locale est capturée par une fermeture, nous adopterons une autre solution qui les soulève sur le tas où elles peuvent vivre aussi longtemps que nécessaire.</p>
<p>Les fermetures sont là depuis les premiers jours de Lisp quand les octets de mémoire et les cycles CPU étaient plus précieux que des émeraudes. Au cours des décennies intermédiaires, les hackers ont conçu toute <span name="lambda">sorte</span> de moyens de compiler les fermetures vers des représentations runtime optimisées. Certaines sont plus efficaces mais requièrent un processus de compilation plus complexe que nous pourrions facilement adapter dans clox.</p>
<aside name="lambda">
<p>Cherchez &ldquo;closure conversion&rdquo; ou &ldquo;lambda lifting&rdquo; pour commencer à explorer.</p>
</aside>
<p>La technique que j&rsquo;explique ici vient de la conception de la VM Lua. Elle est rapide, parcimonieuse avec la mémoire, et implémentée avec relativement peu de code. Encore plus impressionnant, elle s&rsquo;adapte naturellement dans les compilateurs à une seule passe que clox et Lua utilisent tous deux. Elle est quelque peu complexe, cependant. Cela pourrait prendre un moment avant que toutes les pièces s&rsquo;emboîtent ensemble dans votre esprit. Nous les construirons une étape à la fois, et j&rsquo;essaierai d&rsquo;introduire les concepts par étapes.</p>
<h2><a href="#objets-fermeture" id="objets-fermeture"><small>25&#8202;.&#8202;1</small>Objets Fermeture</a></h2>
<p>Notre VM représente les fonctions à l&rsquo;exécution utilisant ObjFunction. Ces objets sont créés par le front end durant la compilation. À l&rsquo;exécution, tout ce que la VM fait est de charger l&rsquo;objet fonction depuis une table de constantes et le lier à un nom. Il n&rsquo;y a pas d&rsquo;opération pour &ldquo;créer&rdquo; une fonction à l&rsquo;exécution. Tout comme les <span name="literal">littéraux</span> chaînes et nombres, ce sont des constantes instanciées purement à la compilation.</p>
<aside name="literal">
<p>En d&rsquo;autres termes, une déclaration de fonction dans Lox <em>est</em> une sorte de littéral<span class="em">&mdash;</span>un morceau de syntaxe qui définit une valeur constante d&rsquo;un type intégré.</p>
</aside>
<p>Cela avait du sens parce que toutes les données qui composent une fonction sont connues à la compilation : le morceau de bytecode compilé depuis le corps de la fonction, et les constantes utilisées dans le corps. Une fois que nous introduisons les fermetures, cependant, cette représentation n&rsquo;est plus suffisante. Jetez un coup d&rsquo;œil à :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">makeClosure</span>(<span class="i">value</span>) {
  <span class="k">fun</span> <span class="i">closure</span>() {
    <span class="k">print</span> <span class="i">value</span>;
  }
  <span class="k">return</span> <span class="i">closure</span>;
}

<span class="k">var</span> <span class="i">doughnut</span> = <span class="i">makeClosure</span>(<span class="s">&quot;doughnut&quot;</span>);
<span class="k">var</span> <span class="i">bagel</span> = <span class="i">makeClosure</span>(<span class="s">&quot;bagel&quot;</span>);
<span class="i">doughnut</span>();
<span class="i">bagel</span>();
</pre></div>
<p>La fonction <code>makeClosure()</code> définit et renvoie une fonction. Nous l&rsquo;appelons deux fois et obtenons deux fermetures en retour. Elles sont créées par la même déclaration de fonction imbriquée, <code>closure</code>, mais ferment sur des valeurs différentes. Quand nous appelons les deux fermetures, chacune affiche une chaîne différente. Cela implique que nous avons besoin de quelque représentation runtime pour une fermeture qui capture les variables locales entourant la fonction telles qu&rsquo;elles existent quand la déclaration de fonction est <em>exécutée</em>, pas juste quand elle est compilée.</p>
<p>Nous travaillerons notre chemin jusqu&rsquo;à capturer les variables, mais une bonne première étape est de définir cette représentation objet. Notre type ObjFunction existant représente l&rsquo;état <span name="raw">&ldquo;brut&rdquo;</span> à la compilation d&rsquo;une déclaration de fonction, puisque toutes les fermetures créées depuis une seule déclaration partagent le même code et constantes. À l&rsquo;exécution, quand nous exécutons une déclaration de fonction, nous enveloppons l&rsquo;ObjFunction dans une nouvelle structure ObjClosure. Cette dernière a une référence vers la fonction nue sous-jacente avec l&rsquo;état runtime pour les variables sur lesquelles la fonction ferme.</p>
<aside name="raw">
<p>L&rsquo;implémentation Lua se réfère à l&rsquo;objet fonction brut contenant le bytecode comme un &ldquo;prototype&rdquo;, ce qui est un super mot pour décrire ceci, sauf que ce mot est aussi surchargé pour se référer à <a href="https://en.wikipedia.org/wiki/Prototype-based_programming">l&rsquo;héritage prototypal</a>.</p>
</aside><img src="image/closures/obj-closure.png" alt="Une ObjClosure avec une référence vers une ObjFunction."/>
<p>Nous envelopperons chaque fonction dans une ObjClosure, même si la fonction ne ferme pas réellement sur et capture aucune variable locale environnante. C&rsquo;est un peu &ldquo;gaspilleur&rdquo;, mais cela simplifie la VM parce que nous pouvons toujours supposer que la fonction que nous appelons est une ObjClosure. Cette nouvelle structure commence comme ceci :</p>
<div class="codehilite"><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjString</em></div>
<pre><span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">ObjFunction</span>* <span class="i">function</span>;
} <span class="t">ObjClosure</span>;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>

<p>Juste maintenant, elle pointe simplement vers une ObjFunction et ajoute les trucs d&rsquo;en-tête d&rsquo;objet nécessaires. Mèlant à travers la cérémonie habituelle pour ajouter un nouveau type d&rsquo;objet à clox, nous déclarons une fonction C pour créer une nouvelle fermeture.</p>
<div class="codehilite"><pre class="insert-before">} ObjClosure;

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClosure</em></div>
<pre class="insert"><span class="t">ObjClosure</span>* <span class="i">newClosure</span>(<span class="t">ObjFunction</span>* <span class="i">function</span>);
</pre><pre class="insert-after">ObjFunction* newFunction();
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClosure</em></div>

<p>Ensuite nous l&rsquo;implémentons ici :</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>allocateObject</em>()</div>
<pre><span class="t">ObjClosure</span>* <span class="i">newClosure</span>(<span class="t">ObjFunction</span>* <span class="i">function</span>) {
  <span class="t">ObjClosure</span>* <span class="i">closure</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjClosure</span>, <span class="a">OBJ_CLOSURE</span>);
  <span class="i">closure</span>-&gt;<span class="i">function</span> = <span class="i">function</span>;
  <span class="k">return</span> <span class="i">closure</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateObject</em>()</div>

<p>Elle prend un appel vers l&rsquo;ObjFunction qu&rsquo;elle enveloppe. Elle initialise aussi le champ type à un nouveau type.</p>
<div class="codehilite"><pre class="insert-before">typedef enum {
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_CLOSURE</span>,
</pre><pre class="insert-after">  OBJ_FUNCTION,
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>Et quand nous avons fini avec une fermeture, nous relâchons sa mémoire.</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_CLOSURE</span>: {
      <span class="a">FREE</span>(<span class="t">ObjClosure</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_FUNCTION: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>Nous libérons seulement l&rsquo;ObjClosure elle-même, pas l&rsquo;ObjFunction. C&rsquo;est parce que la fermeture ne <em>possède</em> pas la fonction. Il peut y avoir de multiples fermetures qui référencent toutes la même fonction, et aucune d&rsquo;elles ne réclame de privilège spécial sur elle. Nous ne pouvons pas libérer l&rsquo;ObjFunction jusqu&rsquo;à ce que <em>tous</em> les objets la référençant soient partis<span class="em">&mdash;</span>incluant même la fonction environnante dont la table de constantes la contient. Suivre cela semble délicat, et ça l&rsquo;est ! C&rsquo;est pourquoi nous écrirons un ramasse-miettes bientôt pour le gérer pour nous.</p>
<p>Nous avons aussi les <span name="macro">macros</span> habituelles pour vérifier le type d&rsquo;une valeur.</p>
<aside name="macro">
<p>Peut-être que j&rsquo;aurais dû définir une macro pour rendre plus facile de générer ces macros. Peut-être que ce serait un peu trop méta.</p>
</aside>
<div class="codehilite"><pre class="insert-before">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define IS_CLOSURE(value)      isObjType(value, OBJ_CLOSURE)</span>
</pre><pre class="insert-after">#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Et pour caster une valeur :</p>
<div class="codehilite"><pre class="insert-before">#define IS_STRING(value)       isObjType(value, OBJ_STRING)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define AS_CLOSURE(value)      ((ObjClosure*)AS_OBJ(value))</span>
</pre><pre class="insert-after">#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Les fermetures sont des objets de première classe, donc vous pouvez les afficher.</p>
<div class="codehilite"><pre class="insert-before">  switch (OBJ_TYPE(value)) {
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_CLOSURE</span>:
      <span class="i">printFunction</span>(<span class="a">AS_CLOSURE</span>(<span class="i">value</span>)-&gt;<span class="i">function</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_FUNCTION:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p>Elles s&rsquo;affichent exactement comme ObjFunction le fait. De la perspective de l&rsquo;utilisateur, la différence entre ObjFunction et ObjClosure est purement un détail d&rsquo;implémentation caché. Avec cela hors du chemin, nous avons une représentation fonctionnelle mais vide pour les fermetures.</p>
<h3><a href="#compiler-vers-des-objets-fermeture" id="compiler-vers-des-objets-fermeture"><small>25&#8202;.&#8202;1&#8202;.&#8202;1</small>Compiler vers des objets fermeture</a></h3>
<p>Nous avons des objets fermeture, mais notre VM ne les crée jamais. L&rsquo;étape suivante est d&rsquo;obtenir du compilateur qu&rsquo;il émette des instructions pour dire au runtime quand créer une nouvelle ObjClosure pour envelopper une ObjFunction donnée. Cela arrive juste à la fin d&rsquo;une déclaration de fonction.</p>
<div class="codehilite"><pre class="insert-before">  ObjFunction* function = endCompiler();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>function</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">emitBytes</span>(<span class="a">OP_CLOSURE</span>, <span class="i">makeConstant</span>(<span class="a">OBJ_VAL</span>(<span class="i">function</span>)));
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>function</em>(), replace 1 line</div>

<p>Avant, le bytecode final pour une déclaration de fonction était une seule instruction <code>OP_CONSTANT</code> pour charger la fonction compilée depuis la table de constantes de la fonction environnante et l&rsquo;empiler sur la pile. Maintenant nous avons une nouvelle instruction.</p>
<div class="codehilite"><pre class="insert-before">  OP_CALL,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_CLOSURE</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Comme <code>OP_CONSTANT</code>, elle prend un seul opérande qui représente un index de table de constantes pour la fonction. Mais quand nous arrivons à l&rsquo;implémentation runtime, nous faisons quelque chose de plus intéressant.</p>
<p>D&rsquo;abord, soyons des hackers de VM diligents et insérons le support du désassembleur pour l&rsquo;instruction.</p>
<div class="codehilite"><pre class="insert-before">    case OP_CALL:
      return byteInstruction(&quot;OP_CALL&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_CLOSURE</span>: {
      <span class="i">offset</span>++;
      <span class="t">uint8_t</span> <span class="i">constant</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span>++];
      <span class="i">printf</span>(<span class="s">&quot;%-16s %4d &quot;</span>, <span class="s">&quot;OP_CLOSURE&quot;</span>, <span class="i">constant</span>);
      <span class="i">printValue</span>(<span class="i">chunk</span>-&gt;<span class="i">constants</span>.<span class="i">values</span>[<span class="i">constant</span>]);
      <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
      <span class="k">return</span> <span class="i">offset</span>;
    }
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Il y a plus se passant ici que ce que nous avons habituellement dans le désassembleur. À la fin du chapitre, vous découvrirez que <code>OP_CLOSURE</code> est une instruction assez inhabituelle. C&rsquo;est direct pour l&rsquo;instant<span class="em">&mdash;</span>juste un opérande d&rsquo;un seul octet<span class="em">&mdash;</span>mais nous y ajouterons. Ce code ici anticipe ce futur.</p>
<h3><a href="#interpréter-les-déclarations-de-fonction" id="interpréter-les-déclarations-de-fonction"><small>25&#8202;.&#8202;1&#8202;.&#8202;2</small>Interpréter les déclarations de fonction</a></h3>
<p>La plupart du travail que nous avons besoin de faire est dans le runtime. Nous devons gérer la nouvelle instruction, naturellement. Mais nous avons aussi besoin de toucher chaque morceau de code dans la VM qui travaille avec ObjFunction et le changer pour utiliser ObjClosure à la place<span class="em">&mdash;</span>appels de fonction, cadres d&rsquo;appel, etc. Nous commencerons avec l&rsquo;instruction, cependant.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_CLOSURE</span>: {
        <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="a">AS_FUNCTION</span>(<span class="a">READ_CONSTANT</span>());
        <span class="t">ObjClosure</span>* <span class="i">closure</span> = <span class="i">newClosure</span>(<span class="i">function</span>);
        <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">closure</span>));
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Comme l&rsquo;instruction <code>OP_CONSTANT</code> que nous utilisions avant, d&rsquo;abord nous chargeons la fonction compilée depuis la table de constantes. La différence maintenant est que nous enveloppons cette fonction dans une nouvelle ObjClosure et empilons le résultat sur la pile.</p>
<p>Une fois que vous avez une fermeture, vous voudrez éventuellement l&rsquo;appeler.</p>
<div class="codehilite"><pre class="insert-before">    switch (OBJ_TYPE(callee)) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>callValue</em>()<br>
replace 2 lines</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OBJ_CLOSURE</span>:
        <span class="k">return</span> <span class="i">call</span>(<span class="a">AS_CLOSURE</span>(<span class="i">callee</span>), <span class="i">argCount</span>);
</pre><pre class="insert-after">      case OBJ_NATIVE: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>(), replace 2 lines</div>

<p>Nous retirons le code pour appeler les objets dont le type est <code>OBJ_FUNCTION</code>. Puisque nous enveloppons toutes les fonctions dans des ObjClosures, le runtime n&rsquo;essaiera jamais d&rsquo;invoquer une ObjFunction nue désormais. Ces objets vivent seulement dans les tables de constantes et sont immédiatement <span name="naked">enveloppés</span> dans des fermetures avant que quoi que ce soit d&rsquo;autre les voie.</p>
<aside name="naked">
<p>Nous ne voulons pas de fonctions nues errant autour de la VM ! Que diraient les voisins ?</p>
</aside>
<p>Nous remplaçons le vieux code avec un code très similaire pour appeler une fermeture à la place. La seule différence est le type d&rsquo;objet que nous passons à <code>call()</code>. Les vrais changements sont là-bas dans cette fonction. D&rsquo;abord, nous mettons à jour sa signature.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
function <em>call</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">bool</span> <span class="i">call</span>(<span class="t">ObjClosure</span>* <span class="i">closure</span>, <span class="t">int</span> <span class="i">argCount</span>) {
</pre><pre class="insert-after">  if (argCount != function-&gt;arity) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, function <em>call</em>(), replace 1 line</div>

<p>Ensuite, dans le corps, nous avons besoin de réparer tout ce qui référençait la fonction pour gérer le fait que nous avons introduit une couche d&rsquo;indirection. Nous commençons avec la vérification d&rsquo;arité :</p>
<div class="codehilite"><pre class="insert-before">static bool call(ObjClosure* closure, int argCount) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>call</em>()<br>
replace 3 lines</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">argCount</span> != <span class="i">closure</span>-&gt;<span class="i">function</span>-&gt;<span class="i">arity</span>) {
    <span class="i">runtimeError</span>(<span class="s">&quot;Expected %d arguments but got %d.&quot;</span>,
        <span class="i">closure</span>-&gt;<span class="i">function</span>-&gt;<span class="i">arity</span>, <span class="i">argCount</span>);
</pre><pre class="insert-after">    return false;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>call</em>(), replace 3 lines</div>

<p>Le seul changement est que nous déballons la fermeture pour obtenir la fonction sous-jacente. La prochaine chose que <code>call()</code> fait est de créer une nouvelle CallFrame. Nous changeons ce code pour stocker la fermeture dans la CallFrame et obtenir le pointeur de bytecode depuis la fonction de la fermeture.</p>
<div class="codehilite"><pre class="insert-before">  CallFrame* frame = &amp;vm.frames[vm.frameCount++];
</pre><div class="source-file"><em>vm.c</em><br>
in <em>call</em>()<br>
replace 2 lines</div>
<pre class="insert">  <span class="i">frame</span>-&gt;<span class="i">closure</span> = <span class="i">closure</span>;
  <span class="i">frame</span>-&gt;<span class="i">ip</span> = <span class="i">closure</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>;
</pre><pre class="insert-after">  frame-&gt;slots = vm.stackTop - argCount - 1;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>call</em>(), replace 2 lines</div>

<p>Cela nécessite de changer la déclaration de CallFrame aussi.</p>
<div class="codehilite"><pre class="insert-before">typedef struct {
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>CallFrame</em><br>
replace 1 line</div>
<pre class="insert">  <span class="t">ObjClosure</span>* <span class="i">closure</span>;
</pre><pre class="insert-after">  uint8_t* ip;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>CallFrame</em>, replace 1 line</div>

<p>Ce changement déclenche quelques autres changements en cascade. Chaque endroit dans la VM qui accédait à la fonction de CallFrame a besoin d&rsquo;utiliser une fermeture à la place. D&rsquo;abord, la macro pour lire une constante depuis la table de constantes de la fonction courante :</p>
<div class="codehilite"><pre class="insert-before">    (uint16_t)((frame-&gt;ip[-2] &lt;&lt; 8) | frame-&gt;ip[-1]))

</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 2 lines</div>
<pre class="insert"><span class="a">#define READ_CONSTANT() \</span>
<span class="a">    (frame-&gt;closure-&gt;function-&gt;chunk.constants.values[READ_BYTE()])</span>
</pre><pre class="insert-after">

#define READ_STRING() AS_STRING(READ_CONSTANT())
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>

<p>Quand <code>DEBUG_TRACE_EXECUTION</code> est activé, il a besoin d&rsquo;obtenir le morceau (chunk) depuis la fermeture.</p>
<div class="codehilite"><pre class="insert-before">    printf(&quot;\n&quot;);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 2 lines</div>
<pre class="insert">    <span class="i">disassembleInstruction</span>(&amp;<span class="i">frame</span>-&gt;<span class="i">closure</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>,
        (<span class="t">int</span>)(<span class="i">frame</span>-&gt;<span class="i">ip</span> - <span class="i">frame</span>-&gt;<span class="i">closure</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>));
</pre><pre class="insert-after">#endif
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>

<p>De même lors du rapport d&rsquo;une erreur d&rsquo;exécution :</p>
<div class="codehilite"><pre class="insert-before">    CallFrame* frame = &amp;vm.frames[i];
</pre><div class="source-file"><em>vm.c</em><br>
in <em>runtimeError</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">frame</span>-&gt;<span class="i">closure</span>-&gt;<span class="i">function</span>;
</pre><pre class="insert-after">    size_t instruction = frame-&gt;ip - function-&gt;chunk.code - 1;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>runtimeError</em>(), replace 1 line</div>

<p>Presque là. La dernière pièce est le blob de code qui configure la toute première CallFrame pour commencer à exécuter le code de niveau supérieur pour un script Lox.</p>
<div class="codehilite"><pre class="insert-before">  push(OBJ_VAL(function));
</pre><div class="source-file"><em>vm.c</em><br>
in <em>interpret</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">ObjClosure</span>* <span class="i">closure</span> = <span class="i">newClosure</span>(<span class="i">function</span>);
  <span class="i">pop</span>();
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">closure</span>));
  <span class="i">call</span>(<span class="i">closure</span>, <span class="n">0</span>);
</pre><pre class="insert-after">

  return run();
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 1 line</div>

<p><span name="pop">Le</span> compilateur renvoie toujours une ObjFunction brute lors de la compilation d&rsquo;un script. C&rsquo;est bien, mais cela signifie que nous devons l&rsquo;envelopper dans une ObjClosure ici, avant que la VM puisse l&rsquo;exécuter.</p>
<aside name="pop">
<p>Le code semble un peu bête parce que nous empilons toujours l&rsquo;ObjFunction originale sur la pile. Ensuite nous la dépilons après avoir créé la fermeture, seulement pour ensuite empiler la fermeture. Pourquoi mettre l&rsquo;ObjFunction là du tout ? Comme d&rsquo;habitude, quand vous voyez des trucs de pile bizarres se passer, c&rsquo;est pour garder le <a href="ramasse-miettes.html">futur ramasse-miettes</a> conscient de certains objets alloués sur le tas.</p>
</aside>
<p>Nous sommes de retour à un interpréteur fonctionnel. L&rsquo;<em>utilisateur</em> ne peut voir aucune différence, mais le compilateur génère maintenant du code disant à la VM de créer une fermeture pour chaque déclaration de fonction. Chaque fois que la VM exécute une déclaration de fonction, elle enveloppe l&rsquo;ObjFunction dans une nouvelle ObjClosure. Le reste de la VM gère maintenant ces ObjClosures flottant autour. C&rsquo;est le truc ennuyeux hors du chemin. Maintenant nous sommes prêts à faire que ces fermetures <em>fassent</em> réellement quelque chose.</p>
<h2><a href="#upvalues" id="upvalues"><small>25&#8202;.&#8202;2</small>Upvalues</a></h2>
<p>Nos instructions existantes pour lire et écrire les variables locales sont limitées à la fenêtre de pile d&rsquo;une seule fonction. Les locales d&rsquo;une fonction environnante sont en dehors de la fenêtre de la fonction intérieure. Nous allons avoir besoin de quelques nouvelles instructions.</p>
<p>L&rsquo;approche la plus facile pourrait être une instruction qui prend un décalage d&rsquo;emplacement de pile relatif qui peut atteindre <em>avant</em> la fenêtre de la fonction courante. Cela fonctionnerait si les variables fermées étaient toujours sur la pile. Mais comme nous l&rsquo;avons vu plus tôt, ces variables survivent parfois à la fonction où elles sont déclarées. Cela signifie qu&rsquo;elles ne seront pas toujours sur la pile.</p>
<p>L&rsquo;approche suivante la plus facile, alors, serait de prendre toute variable locale qui est fermée (closed over) et de l&rsquo;avoir toujours vivant sur le tas. Quand la déclaration de variable locale dans la fonction environnante est exécutée, la VM allouerait de la mémoire pour elle dynamiquement. De cette façon elle pourrait vivre aussi longtemps que nécessaire.</p>
<p>Ce serait une bonne approche si clox n&rsquo;avait pas un compilateur à une seule passe. Mais cette restriction que nous avons choisie dans notre implémentation rend les choses plus difficiles. Jetez un œil à cet exemple :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="n">1</span>;    <span class="c">// (1)</span>
  <span class="i">x</span> = <span class="n">2</span>;        <span class="c">// (2)</span>
  <span class="k">fun</span> <span class="i">inner</span>() { <span class="c">// (3)</span>
    <span class="k">print</span> <span class="i">x</span>;
  }
  <span class="i">inner</span>();
}
</pre></div>
<p>Ici, le compilateur compile la déclaration de <code>x</code> à <code>(1)</code> et émet du code pour l&rsquo;assignation à <code>(2)</code>. Il fait cela avant d&rsquo;atteindre la déclaration de <code>inner()</code> à <code>(3)</code> et de découvrir que <code>x</code> est en fait fermée. Nous n&rsquo;avons pas un moyen facile de revenir en arrière et corriger ce code déjà émis pour traiter <code>x</code> spécialement. Au lieu de cela, nous voulons une solution qui permet à une variable fermée de vivre sur la pile exactement comme une variable locale normale <em>jusqu&rsquo;au point qu&rsquo;elle soit fermée</em>.</p>
<p>Heureusement, grâce à l&rsquo;équipe de dev Lua, nous avons une solution. Nous utilisons un niveau d&rsquo;indirection qu&rsquo;ils appellent une <strong>upvalue</strong>. Une upvalue se réfère à une variable locale dans une fonction englobante. Chaque fermeture maintient un tableau d&rsquo;upvalues, une pour chaque variable locale environnante que la fermeture utilise.</p>
<p>L&rsquo;upvalue pointe en arrière dans la pile vers où la variable qu&rsquo;elle a capturée vit. Quand la fermeture a besoin d&rsquo;accéder à une variable fermée, elle passe par l&rsquo;upvalue correspondante pour l&rsquo;atteindre. Quand une déclaration de fonction est d&rsquo;abord exécutée et que nous créons une fermeture pour elle, la VM crée le tableau d&rsquo;upvalues et les câble pour &ldquo;capturer&rdquo; les variables locales environnantes dont la fermeture a besoin.</p>
<p>Par exemple, si nous jetons ce programme à clox,</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="n">3</span>;
  <span class="k">fun</span> <span class="i">f</span>() {
    <span class="k">print</span> <span class="i">a</span>;
  }
}
</pre></div>
<p>le compilateur et le runtime conspireront ensemble pour construire un ensemble d&rsquo;objets en mémoire comme ceci :</p><img src="image/closures/open-upvalue.png" alt="Le graphe d'objets de la pile, ObjClosure, ObjFunction, et tableau d'upvalues."/>
<p>Cela pourrait sembler écrasant, mais n&rsquo;ayez crainte. Nous travaillerons notre chemin à travers. La partie importante est que les upvalues servent comme la couche d&rsquo;indirection nécessaire pour continuer à trouver une variable locale capturée même après qu&rsquo;elle bouge hors de la pile. Mais avant que nous arrivions à tout ça, concentrons-nous sur la compilation des variables capturées.</p>
<h3><a href="#compiler-les-upvalues" id="compiler-les-upvalues"><small>25&#8202;.&#8202;2&#8202;.&#8202;1</small>Compiler les upvalues</a></h3>
<p>Comme d&rsquo;habitude, nous voulons faire autant de travail que possible durant la compilation pour garder l&rsquo;exécution simple et rapide. Puisque les variables locales sont lexicalement portées dans Lox, nous avons assez de connaissance à la compilation pour résoudre quelles variables locales environnantes une fonction accède et où ces locales sont déclarées. Cela, à son tour, signifie que nous savons <em>combien</em> d&rsquo;upvalues une fermeture a besoin, <em>quelles</em> variables elles capturent, et <em>quels emplacements de pile</em> contiennent ces variables dans la fenêtre de pile de la fonction déclaratrice.</p>
<p>Actuellement, quand le compilateur résout un identifiant, il marche les portées de bloc pour la fonction courante de la plus intérieure à la plus extérieure. Si nous ne trouvons pas la variable dans cette fonction, nous supposons que la variable doit être une globale. Nous ne considérons pas les portées locales des fonctions englobantes<span class="em">&mdash;</span>elles sont sautées juste au-dessus. Le premier changement, alors, est d&rsquo;insérer une étape de résolution pour ces portées locales extérieures.</p>
<div class="codehilite"><pre class="insert-before">  if (arg != -1) {
    getOp = OP_GET_LOCAL;
    setOp = OP_SET_LOCAL;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> ((<span class="i">arg</span> = <span class="i">resolveUpvalue</span>(<span class="i">current</span>, &amp;<span class="i">name</span>)) != -<span class="n">1</span>) {
    <span class="i">getOp</span> = <span class="a">OP_GET_UPVALUE</span>;
    <span class="i">setOp</span> = <span class="a">OP_SET_UPVALUE</span>;
</pre><pre class="insert-after">  } else {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>()</div>

<p>Cette nouvelle fonction <code>resolveUpvalue()</code> cherche une variable locale déclarée dans n&rsquo;importe laquelle des fonctions environnantes. Si elle en trouve une, elle renvoie un &ldquo;index d&rsquo;upvalue&rdquo; pour cette variable. (Nous entrerons dans ce que cela signifie plus tard.) Sinon, elle renvoie -1 pour indiquer que la variable n&rsquo;a pas été trouvée. Si elle a été trouvée, nous utilisons ces deux nouvelles instructions pour lire ou écrire à la variable à travers son upvalue :</p>
<div class="codehilite"><pre class="insert-before">  OP_SET_GLOBAL,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_GET_UPVALUE</span>,
  <span class="a">OP_SET_UPVALUE</span>,
</pre><pre class="insert-after">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Nous implémentons ce genre de haut en bas, donc je vous montrerai comment celles-ci fonctionnent à l&rsquo;exécution bientôt. La partie sur laquelle se concentrer maintenant est comment le compilateur résout réellement l&rsquo;identifiant.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>resolveLocal</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">resolveUpvalue</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>, <span class="t">Token</span>* <span class="i">name</span>) {
  <span class="k">if</span> (<span class="i">compiler</span>-&gt;<span class="i">enclosing</span> == <span class="a">NULL</span>) <span class="k">return</span> -<span class="n">1</span>;

  <span class="t">int</span> <span class="i">local</span> = <span class="i">resolveLocal</span>(<span class="i">compiler</span>-&gt;<span class="i">enclosing</span>, <span class="i">name</span>);
  <span class="k">if</span> (<span class="i">local</span> != -<span class="n">1</span>) {
    <span class="k">return</span> <span class="i">addUpvalue</span>(<span class="i">compiler</span>, (<span class="t">uint8_t</span>)<span class="i">local</span>, <span class="k">true</span>);
  }

  <span class="k">return</span> -<span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>resolveLocal</em>()</div>

<p>Nous appelons ceci après avoir échoué à résoudre une variable locale dans la portée de la fonction courante, donc nous savons que la variable n&rsquo;est pas dans le compilateur courant. Rappelez-vous que Compiler stocke un pointeur vers le Compiler pour la fonction englobante, et ces pointeurs forment une chaîne liée qui va tout le chemin au Compiler racine pour le code de niveau supérieur. Ainsi, si le Compiler englobant est <code>NULL</code>, nous savons que nous avons atteint la fonction la plus extérieure sans trouver une variable locale. La variable doit être <span name="undefined">globale</span>, donc nous renvoyons -1.</p>
<aside name="undefined">
<p>Elle pourrait finir par être une variable entièrement indéfinie et pas même globale. Mais dans Lox, nous ne détectons pas cette erreur jusqu&rsquo;à l&rsquo;exécution, donc de la perspective du compilateur, c&rsquo;est &ldquo;espérons-le globale&rdquo;.</p>
</aside>
<p>Sinon, nous essayons de résoudre l&rsquo;identifiant comme une variable <em>locale</em> dans le compilateur <em>englobant</em>. En d&rsquo;autres termes, nous la cherchons juste en dehors de la fonction courante. Par exemple :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="n">1</span>;
  <span class="k">fun</span> <span class="i">inner</span>() {
    <span class="k">print</span> <span class="i">x</span>; <span class="c">// (1)</span>
  }
  <span class="i">inner</span>();
}
</pre></div>
<p>Lors de la compilation de l&rsquo;expression identifiant à <code>(1)</code>, <code>resolveUpvalue()</code> cherche une variable locale <code>x</code> déclarée dans <code>outer()</code>. Si trouvée<span class="em">&mdash;</span>comme elle l&rsquo;est dans cet exemple<span class="em">&mdash;</span>alors nous avons résolu avec succès la variable. Nous créons une upvalue pour que la fonction intérieure puisse accéder à la variable à travers cela. L&rsquo;upvalue est créée ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>resolveLocal</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">addUpvalue</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>, <span class="t">uint8_t</span> <span class="i">index</span>,
                      <span class="t">bool</span> <span class="i">isLocal</span>) {
  <span class="t">int</span> <span class="i">upvalueCount</span> = <span class="i">compiler</span>-&gt;<span class="i">function</span>-&gt;<span class="i">upvalueCount</span>;
  <span class="i">compiler</span>-&gt;<span class="i">upvalues</span>[<span class="i">upvalueCount</span>].<span class="i">isLocal</span> = <span class="i">isLocal</span>;
  <span class="i">compiler</span>-&gt;<span class="i">upvalues</span>[<span class="i">upvalueCount</span>].<span class="i">index</span> = <span class="i">index</span>;
  <span class="k">return</span> <span class="i">compiler</span>-&gt;<span class="i">function</span>-&gt;<span class="i">upvalueCount</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>resolveLocal</em>()</div>

<p>Le compilateur garde un tableau de structures upvalue pour suivre les identifiants fermés qu&rsquo;il a résolus dans le corps de chaque fonction. Rappelez-vous comment le tableau <code>locals</code> du compilateur reflète les index d&rsquo;emplacement de pile où les locales vivent à l&rsquo;exécution ? Ce nouveau tableau d&rsquo;upvalues fonctionne de la même façon. Les index dans le tableau du compilateur correspondent aux index où les upvalues vivront dans l&rsquo;ObjClosure à l&rsquo;exécution.</p>
<p>Cette fonction ajoute une nouvelle upvalue à ce tableau. Elle garde aussi la trace du nombre d&rsquo;upvalues que la fonction utilise. Elle stocke ce compte directement dans l&rsquo;ObjFunction elle-même parce que nous aurons aussi <span name="bridge">besoin</span> de ce nombre pour l&rsquo;utiliser à l&rsquo;exécution.</p>
<aside name="bridge">
<p>Comme les constantes et l&rsquo;arité de fonction, le compte d&rsquo;upvalue est une autre de ces petites pièces de données qui forment le pont entre le compilateur et le runtime.</p>
</aside>
<p>Le champ <code>index</code> suit l&rsquo;index d&rsquo;emplacement de la variable locale fermée. De cette façon le compilateur sait <em>quelle</em> variable dans la fonction englobante a besoin d&rsquo;être capturée. Nous reviendrons à ce à quoi ce champ <code>isLocal</code> sert avant trop longtemps. Finalement, <code>addUpvalue()</code> renvoie l&rsquo;index de l&rsquo;upvalue créée dans la liste d&rsquo;upvalues de la fonction. Cet index devient l&rsquo;opérande aux instructions <code>OP_GET_UPVALUE</code> et <code>OP_SET_UPVALUE</code>.</p>
<p>C&rsquo;est l&rsquo;idée de base pour résoudre les upvalues, mais la fonction n&rsquo;est pas pleinement cuite. Une fermeture peut référencer la même variable dans une fonction environnante de multiples fois. Dans ce cas, nous ne voulons pas gaspiller du temps et de la mémoire à créer une upvalue séparée pour chaque expression identifiant. Pour corriger cela, avant que nous ajoutions une nouvelle upvalue, nous vérifions d&rsquo;abord pour voir si la fonction a déjà une upvalue qui ferme sur cette variable.</p>
<div class="codehilite"><pre class="insert-before">  int upvalueCount = compiler-&gt;function-&gt;upvalueCount;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>addUpvalue</em>()</div>
<pre class="insert">

  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">upvalueCount</span>; <span class="i">i</span>++) {
    <span class="t">Upvalue</span>* <span class="i">upvalue</span> = &amp;<span class="i">compiler</span>-&gt;<span class="i">upvalues</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">upvalue</span>-&gt;<span class="i">index</span> == <span class="i">index</span> &amp;&amp; <span class="i">upvalue</span>-&gt;<span class="i">isLocal</span> == <span class="i">isLocal</span>) {
      <span class="k">return</span> <span class="i">i</span>;
    }
  }

</pre><pre class="insert-after">  compiler-&gt;upvalues[upvalueCount].isLocal = isLocal;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addUpvalue</em>()</div>

<p>Si nous trouvons une upvalue dans le tableau dont l&rsquo;index d&rsquo;emplacement correspond à celui que nous ajoutons, nous retournons juste cet index d&rsquo;<em>upvalue</em> et le réutilisons. Sinon, nous tombons à travers et ajoutons la nouvelle upvalue.</p>
<p>Ces deux fonctions accèdent et modifient un tas de nouvel état, donc définissons cela. D&rsquo;abord, nous ajoutons le compte d&rsquo;upvalue à ObjFunction.</p>
<div class="codehilite"><pre class="insert-before">  int arity;
</pre><div class="source-file"><em>object.h</em><br>
in struct <em>ObjFunction</em></div>
<pre class="insert">  <span class="t">int</span> <span class="i">upvalueCount</span>;
</pre><pre class="insert-after">  Chunk chunk;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>ObjFunction</em></div>

<p>Nous sommes des programmeurs C consciencieux, donc nous initialisons cela à zéro quand une ObjFunction est d&rsquo;abord allouée.</p>
<div class="codehilite"><pre class="insert-before">  function-&gt;arity = 0;
</pre><div class="source-file"><em>object.c</em><br>
in <em>newFunction</em>()</div>
<pre class="insert">  <span class="i">function</span>-&gt;<span class="i">upvalueCount</span> = <span class="n">0</span>;
</pre><pre class="insert-after">  function-&gt;name = NULL;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>newFunction</em>()</div>

<p>Dans le compilateur, nous ajoutons un champ pour le tableau d&rsquo;upvalues.</p>
<div class="codehilite"><pre class="insert-before">  int localCount;
</pre><div class="source-file"><em>compiler.c</em><br>
in struct <em>Compiler</em></div>
<pre class="insert">  <span class="t">Upvalue</span> <span class="i">upvalues</span>[<span class="a">UINT8_COUNT</span>];
</pre><pre class="insert-after">  int scopeDepth;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Compiler</em></div>

<p>Pour la simplicité, je lui ai donné une taille fixe. Les instructions <code>OP_GET_UPVALUE</code> et <code>OP_SET_UPVALUE</code> encodent un index d&rsquo;upvalue utilisant un opérande d&rsquo;un seul octet, donc il y a une restriction sur combien d&rsquo;upvalues une fonction peut avoir<span class="em">&mdash;</span>combien de variables uniques elle peut fermer. Étant donné cela, nous pouvons nous permettre un tableau statique aussi grand. Nous devons aussi nous assurer que le compilateur ne déborde pas cette limite.</p>
<div class="codehilite"><pre class="insert-before">    if (upvalue-&gt;index == index &amp;&amp; upvalue-&gt;isLocal == isLocal) {
      return i;
    }
  }

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>addUpvalue</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">upvalueCount</span> == <span class="a">UINT8_COUNT</span>) {
    <span class="i">error</span>(<span class="s">&quot;Too many closure variables in function.&quot;</span>);
    <span class="k">return</span> <span class="n">0</span>;
  }

</pre><pre class="insert-after">  compiler-&gt;upvalues[upvalueCount].isLocal = isLocal;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addUpvalue</em>()</div>

<p>Finalement, le type struct Upvalue lui-même.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after struct <em>Local</em></div>
<pre><span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">uint8_t</span> <span class="i">index</span>;
  <span class="t">bool</span> <span class="i">isLocal</span>;
} <span class="t">Upvalue</span>;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>Local</em></div>

<p>Le champ <code>index</code> stocke quel emplacement local l&rsquo;upvalue capture. Le champ <code>isLocal</code> mérite sa propre section, à laquelle nous arriverons ensuite.</p>
<h3><a href="#aplatir-les-upvalues" id="aplatir-les-upvalues"><small>25&#8202;.&#8202;2&#8202;.&#8202;2</small>Aplatir les upvalues</a></h3>
<p>Dans l&rsquo;exemple que j&rsquo;ai montré avant, la fermeture accède à une variable déclarée dans la fonction immédiatement englobante. Lox supporte aussi d&rsquo;accéder aux variables locales déclarées dans <em>n&rsquo;importe quelle</em> portée englobante, comme dans :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="n">1</span>;
  <span class="k">fun</span> <span class="i">middle</span>() {
    <span class="k">fun</span> <span class="i">inner</span>() {
      <span class="k">print</span> <span class="i">x</span>;
    }
  }
}
</pre></div>
<p>Ici, nous accédons à <code>x</code> dans <code>inner()</code>. Cette variable est définie non pas dans <code>middle()</code>, mais tout là-bas dans <code>outer()</code>. Nous devons gérer des cas comme ceci aussi. Vous <em>pourriez</em> penser que ce n&rsquo;est pas beaucoup plus dur puisque la variable sera simplement quelque part plus bas sur la pile. Mais considérez cet exemple <span name="devious">sournois</span> :</p>
<aside name="devious">
<p>Si vous travaillez sur les langages de programmation assez longtemps, vous développerez une compétence finement aiguisée pour créer des programmes bizarres comme celui-ci qui sont techniquement valides mais susceptibles de faire trébucher une implémentation écrite par quelqu&rsquo;un avec une imagination moins perverse que vous.</p>
</aside>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="s">&quot;value&quot;</span>;
  <span class="k">fun</span> <span class="i">middle</span>() {
    <span class="k">fun</span> <span class="i">inner</span>() {
      <span class="k">print</span> <span class="i">x</span>;
    }

    <span class="k">print</span> <span class="s">&quot;create inner closure&quot;</span>;
    <span class="k">return</span> <span class="i">inner</span>;
  }

  <span class="k">print</span> <span class="s">&quot;return from outer&quot;</span>;
  <span class="k">return</span> <span class="i">middle</span>;
}

<span class="k">var</span> <span class="i">mid</span> = <span class="i">outer</span>();
<span class="k">var</span> <span class="i">in</span> = <span class="i">mid</span>();
<span class="i">in</span>();
</pre></div>
<p>Quand vous exécutez ceci, cela devrait afficher :</p>
<div class="codehilite"><pre>return from outer
create inner closure
value
</pre></div>
<p>Je sais, c&rsquo;est alambiqué. La partie importante est que <code>outer()</code><span class="em">&mdash;</span>où <code>x</code> est déclarée<span class="em">&mdash;</span>retourne et dépile toutes ses variables de la pile avant que la <em>déclaration</em> de <code>inner()</code> s&rsquo;exécute. Donc, au moment où nous créons la fermeture pour <code>inner()</code>, <code>x</code> est déjà hors de la pile.</p>
<p>Ici, j&rsquo;ai tracé le flux d&rsquo;exécution pour vous :</p><img src="image/closures/execution-flow.png" alt="Traçant à travers le programme exemple précédent."/>
<p>Voyez comment <code>x</code> est dépilée &#9312; avant qu&rsquo;elle soit capturée &#9313; et ensuite accédée plus tard &#9314; ? Nous avons vraiment deux problèmes :</p>
<ol>
<li>
<p>Nous devons résoudre les variables locales qui sont déclarées dans les fonctions environnantes au-delà de celle immédiatement englobante.</p>
</li>
<li>
<p>Nous devons être capables de capturer des variables qui ont déjà quitté la pile.</p>
</li>
</ol>
<p>Heureusement, nous sommes au milieu de l&rsquo;ajout des upvalues à la VM, et les upvalues sont explicitement conçues pour suivre les variables qui ont échappé la pile. Donc, dans un morceau intelligent d&rsquo;auto-référence, nous pouvons utiliser les upvalues pour permettre aux upvalues de capturer les variables déclarées en dehors de la fonction immédiatement environnante.</p>
<p>La solution est de permettre à une fermeture de capturer soit une variable locale ou <em>une upvalue existante</em> dans la fonction immédiatement englobante. Si une fonction profondément imbriquée référence une variable locale déclarée plusieurs sauts plus loin, nous l&rsquo;enfilerons à travers toutes les fonctions intermédiaires en ayant chaque fonction capturer une upvalue pour que la fonction suivante l&rsquo;attrape.</p><img src="image/closures/linked-upvalues.png" alt="Une upvalue dans inner() pointe vers une upvalue dans middle(), qui pointe vers une variable locale dans outer()."/>
<p>Dans l&rsquo;exemple ci-dessus, <code>middle()</code> capture la variable locale <code>x</code> dans la fonction immédiatement englobante <code>outer()</code> et la stocke dans sa propre upvalue. Elle fait cela même si <code>middle()</code> elle-même ne référence pas <code>x</code>. Ensuite, quand la déclaration de <code>inner()</code> s&rsquo;exécute, sa fermeture attrape l&rsquo;<em>upvalue</em> depuis l&rsquo;ObjClosure pour <code>middle()</code> qui a capturé <code>x</code>. Une fonction capture<span class="em">&mdash;</span>soit une locale ou une upvalue<span class="em">&mdash;</span><em>seulement</em> depuis la fonction immédiatement environnante, qui est garantie d&rsquo;être encore là au point que la déclaration de fonction intérieure s&rsquo;exécute.</p>
<p>Afin d&rsquo;implémenter cela, <code>resolveUpvalue()</code> devient récursive.</p>
<div class="codehilite"><pre class="insert-before">  if (local != -1) {
    return addUpvalue(compiler, (uint8_t)local, true);
  }

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>resolveUpvalue</em>()</div>
<pre class="insert">  <span class="t">int</span> <span class="i">upvalue</span> = <span class="i">resolveUpvalue</span>(<span class="i">compiler</span>-&gt;<span class="i">enclosing</span>, <span class="i">name</span>);
  <span class="k">if</span> (<span class="i">upvalue</span> != -<span class="n">1</span>) {
    <span class="k">return</span> <span class="i">addUpvalue</span>(<span class="i">compiler</span>, (<span class="t">uint8_t</span>)<span class="i">upvalue</span>, <span class="k">false</span>);
  }

</pre><pre class="insert-after">  return -1;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>resolveUpvalue</em>()</div>

<p>C&rsquo;est seulement trois autres lignes de code, mais j&rsquo;ai trouvé cette fonction vraiment difficile à avoir juste la première fois. Ceci en dépit du fait que je n&rsquo;inventais rien de nouveau, juste portais le concept depuis Lua. La plupart des fonctions récursives soit font tout leur travail avant l&rsquo;appel récursif (un <strong>parcours pré-ordre</strong>, ou &ldquo;sur la descente&rdquo;), ou elles font tout le travail après l&rsquo;appel récursif (un <strong>parcours post-ordre</strong>, ou &ldquo;sur la remontée&rdquo;). Cette fonction fait les deux. L&rsquo;appel récursif est juste au milieu.</p>
<p>Nous la parcourrons lentement. D&rsquo;abord, nous cherchons une variable locale correspondante dans la fonction englobante. Si nous en trouvons une, nous capturons cette locale et retournons. C&rsquo;est le cas de <span name="base">base</span>.</p>
<aside name="base">
<p>L&rsquo;autre cas de base, bien sûr, est s&rsquo;il n&rsquo;y a pas de fonction englobante. Dans ce cas, la variable ne peut pas être résolue lexicalement et est traitée comme globale.</p>
</aside>
<p>Sinon, nous cherchons une variable locale au-delà de la fonction immédiatement englobante. Nous faisons cela en appelant récursivement <code>resolveUpvalue()</code> sur le compilateur <em>englobant</em>, pas le courant. Cette série d&rsquo;appels <code>resolveUpvalue()</code> travaille son chemin le long de la chaîne de compilateurs imbriqués jusqu&rsquo;à ce qu&rsquo;elle frappe l&rsquo;un des cas de base<span class="em">&mdash;</span>soit elle trouve une variable locale réelle à capturer soit elle tombe à court de compilateurs.</p>
<p>Quand une variable locale est trouvée, l&rsquo;appel le plus profondément <span name="outer">imbriqué</span> à <code>resolveUpvalue()</code> la capture et renvoie l&rsquo;index d&rsquo;upvalue. Cela retourne à l&rsquo;appel suivant pour la déclaration de fonction intérieure. Cet appel capture l&rsquo;<em>upvalue</em> depuis la fonction environnante, et ainsi de suite. Comme chaque appel imbriqué à <code>resolveUpvalue()</code> retourne, nous forons de retour vers le bas dans la déclaration de fonction la plus intérieure où l&rsquo;identifiant que nous résolvons apparaît. À chaque étape le long du chemin, nous ajoutons une upvalue à la fonction intervenante et passons l&rsquo;index d&rsquo;upvalue résultant vers le bas au prochain appel.</p>
<aside name="outer">
<p>Chaque appel récursif à <code>resolveUpvalue()</code> marche <em>hors</em> d&rsquo;un niveau d&rsquo;imbrication de fonction. Donc un <em>appel récursif</em> intérieur se réfère à une déclaration imbriquée <em>extérieure</em>. L&rsquo;appel récursif le plus intérieur à <code>resolveUpvalue()</code> qui trouve la variable locale sera pour la fonction la plus <em>extérieure</em>, juste à l&rsquo;intérieur de la fonction englobante où cette variable est réellement déclarée.</p>
</aside>
<p>Cela pourrait aider de parcourir l&rsquo;exemple original lors de la résolution de <code>x</code> :</p><img src="image/closures/recursion.png" alt="Traçant à travers un appel récursif à resolveUpvalue()."/>
<p>Notez que le nouvel appel à <code>addUpvalue()</code> passe <code>false</code> pour le paramètre <code>isLocal</code>. Maintenant vous voyez que ce drapeau contrôle si la fermeture capture une variable locale ou une upvalue depuis la fonction environnante.</p>
<p>Au moment où le compilateur atteint la fin d&rsquo;une déclaration de fonction, chaque référence de variable a été résolue comme soit une locale, une upvalue, ou une globale. Chaque upvalue peut à son tour capturer une variable locale depuis la fonction environnante, ou une upvalue dans le cas de fermetures transitives. Nous avons enfin assez de données pour émettre du bytecode qui crée une fermeture à l&rsquo;exécution qui capture toutes les variables correctes.</p>
<div class="codehilite"><pre class="insert-before">  emitBytes(OP_CLOSURE, makeConstant(OBJ_VAL(function)));
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>function</em>()</div>
<pre class="insert">

  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">function</span>-&gt;<span class="i">upvalueCount</span>; <span class="i">i</span>++) {
    <span class="i">emitByte</span>(<span class="i">compiler</span>.<span class="i">upvalues</span>[<span class="i">i</span>].<span class="i">isLocal</span> ? <span class="n">1</span> : <span class="n">0</span>);
    <span class="i">emitByte</span>(<span class="i">compiler</span>.<span class="i">upvalues</span>[<span class="i">i</span>].<span class="i">index</span>);
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>function</em>()</div>

<p>L&rsquo;instruction <code>OP_CLOSURE</code> est unique en ce qu&rsquo;elle a un encodage de taille variable. Pour chaque upvalue que la fermeture capture, il y a deux opérandes d&rsquo;un seul octet. Chaque paire d&rsquo;opérandes spécifie ce que cette upvalue capture. Si le premier octet est un, elle capture une variable locale dans la fonction englobante. Si zéro, elle capture une des upvalues de la fonction. L&rsquo;octet suivant est l&rsquo;emplacement local ou l&rsquo;index d&rsquo;upvalue à capturer.</p>
<p>Cet encodage bizarre signifie que nous avons besoin de support sur mesure dans le code de désassemblage pour <code>OP_CLOSURE</code>.</p>
<div class="codehilite"><pre class="insert-before">      printf(&quot;\n&quot;);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">

      <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="a">AS_FUNCTION</span>(
          <span class="i">chunk</span>-&gt;<span class="i">constants</span>.<span class="i">values</span>[<span class="i">constant</span>]);
      <span class="k">for</span> (<span class="t">int</span> <span class="i">j</span> = <span class="n">0</span>; <span class="i">j</span> &lt; <span class="i">function</span>-&gt;<span class="i">upvalueCount</span>; <span class="i">j</span>++) {
        <span class="t">int</span> <span class="i">isLocal</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span>++];
        <span class="t">int</span> <span class="i">index</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span>++];
        <span class="i">printf</span>(<span class="s">&quot;%04d      |                     %s %d</span><span class="e">\n</span><span class="s">&quot;</span>,
               <span class="i">offset</span> - <span class="n">2</span>, <span class="i">isLocal</span> ? <span class="s">&quot;local&quot;</span> : <span class="s">&quot;upvalue&quot;</span>, <span class="i">index</span>);
      }

</pre><pre class="insert-after">      return offset;
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Par exemple, prenez ce script :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
  <span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
  <span class="k">fun</span> <span class="i">middle</span>() {
    <span class="k">var</span> <span class="i">c</span> = <span class="n">3</span>;
    <span class="k">var</span> <span class="i">d</span> = <span class="n">4</span>;
    <span class="k">fun</span> <span class="i">inner</span>() {
      <span class="k">print</span> <span class="i">a</span> + <span class="i">c</span> + <span class="i">b</span> + <span class="i">d</span>;
    }
  }
}
</pre></div>
<p>Si nous désassemblons l&rsquo;instruction qui crée la fermeture pour <code>inner()</code>, elle affiche ceci :</p>
<div class="codehilite"><pre>0004    9 OP_CLOSURE          2 &lt;fn inner&gt;
0006      |                     upvalue 0
0008      |                     local 1
0010      |                     upvalue 1
0012      |                     local 2
</pre></div>
<p>Nous avons deux autres instructions, plus simples, pour lesquelles ajouter le support du désassembleur.</p>
<div class="codehilite"><pre class="insert-before">    case OP_SET_GLOBAL:
      return constantInstruction(&quot;OP_SET_GLOBAL&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_GET_UPVALUE</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">&quot;OP_GET_UPVALUE&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SET_UPVALUE</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">&quot;OP_SET_UPVALUE&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Celles-ci ont toutes deux un opérande d&rsquo;un seul octet, donc il n&rsquo;y a rien d&rsquo;excitant se passant. Nous avons besoin d&rsquo;ajouter une inclusion pour que le module debug puisse accéder à <code>AS_FUNCTION()</code>.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;debug.h&quot;
</pre><div class="source-file"><em>debug.c</em></div>
<pre class="insert"><span class="a">#include &quot;object.h&quot;</span>
</pre><pre class="insert-after">#include &quot;value.h&quot;
</pre></div>
<div class="source-file-narrow"><em>debug.c</em></div>

<p>Avec ça, notre compilateur est où nous le voulons. Pour chaque déclaration de fonction, il sort une instruction <code>OP_CLOSURE</code> suivie par une série de paires d&rsquo;octets opérandes pour chaque upvalue qu&rsquo;il a besoin de capturer à l&rsquo;exécution. Il est temps de sauter de l&rsquo;autre côté vers la VM et de faire tourner les choses.</p>
<h2><a href="#objets-upvalue" id="objets-upvalue"><small>25&#8202;.&#8202;3</small>Objets Upvalue</a></h2>
<p>Chaque instruction <code>OP_CLOSURE</code> est maintenant suivie par la série d&rsquo;octets qui spécifient les upvalues que l&rsquo;ObjClosure devrait posséder. Avant que nous traitions ces opérandes, nous avons besoin d&rsquo;une représentation runtime pour les upvalues.</p>
<div class="codehilite"><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjString</em></div>
<pre><span class="k">typedef</span> <span class="k">struct</span> <span class="t">ObjUpvalue</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">Value</span>* <span class="i">location</span>;
} <span class="t">ObjUpvalue</span>;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>

<p>Nous savons que les upvalues doivent gérer des variables fermées qui ne vivent plus sur la pile, ce qui implique une certaine quantité d&rsquo;allocation dynamique. La façon la plus facile de faire cela dans notre VM est en construisant sur le système d&rsquo;objet que nous avons déjà. De cette façon, quand nous implémenterons un ramasse-miettes dans <a href="ramasse-miettes.html">le prochain chapitre</a>, le GC pourra gérer la mémoire pour les upvalues aussi.</p>
<p>Ainsi, notre structure upvalue runtime est une ObjUpvalue avec le champ d&rsquo;en-tête Obj typique. Suivant cela est un champ <code>location</code> qui pointe vers la variable fermée. Notez que c&rsquo;est un <em>pointeur</em> vers une Value, pas une Value elle-même. C&rsquo;est une référence vers une <em>variable</em>, pas une <em>valeur</em>. C&rsquo;est important parce que cela signifie que quand nous assignons à la variable que l&rsquo;upvalue capture, nous assignons à la variable réelle, pas une copie. Par exemple :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="s">&quot;before&quot;</span>;
  <span class="k">fun</span> <span class="i">inner</span>() {
    <span class="i">x</span> = <span class="s">&quot;assigned&quot;</span>;
  }
  <span class="i">inner</span>();
  <span class="k">print</span> <span class="i">x</span>;
}
<span class="i">outer</span>();
</pre></div>
<p>Ce programme devrait afficher &ldquo;assigned&rdquo; même si la fermeture assigne à <code>x</code> et la fonction environnante y accède.</p>
<p>Parce que les upvalues sont des objets, nous avons toute la machinerie objet habituelle, commençant avec une fonction type constructeur :</p>
<div class="codehilite"><pre class="insert-before">ObjString* copyString(const char* chars, int length);
</pre><div class="source-file"><em>object.h</em><br>
add after <em>copyString</em>()</div>
<pre class="insert"><span class="t">ObjUpvalue</span>* <span class="i">newUpvalue</span>(<span class="t">Value</span>* <span class="i">slot</span>);
</pre><pre class="insert-after">void printObject(Value value);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after <em>copyString</em>()</div>

<p>Elle prend l&rsquo;adresse de l&rsquo;emplacement où vit la variable fermée. Voici l&rsquo;implémentation :</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>copyString</em>()</div>
<pre><span class="t">ObjUpvalue</span>* <span class="i">newUpvalue</span>(<span class="t">Value</span>* <span class="i">slot</span>) {
  <span class="t">ObjUpvalue</span>* <span class="i">upvalue</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjUpvalue</span>, <span class="a">OBJ_UPVALUE</span>);
  <span class="i">upvalue</span>-&gt;<span class="i">location</span> = <span class="i">slot</span>;
  <span class="k">return</span> <span class="i">upvalue</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>copyString</em>()</div>

<p>Nous initialisons simplement l&rsquo;objet et stockons le pointeur. Cela requiert un nouveau type d&rsquo;objet.</p>
<div class="codehilite"><pre class="insert-before">  OBJ_STRING,
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_UPVALUE</span>
</pre><pre class="insert-after">} ObjType;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>Et sur le côté arrière, une fonction type destructeur :</p>
<div class="codehilite"><pre class="insert-before">      FREE(ObjString, object);
      break;
    }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_UPVALUE</span>:
      <span class="a">FREE</span>(<span class="t">ObjUpvalue</span>, <span class="i">object</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>De multiples fermetures peuvent fermer sur la même variable, donc ObjUpvalue ne possède pas la variable qu&rsquo;elle référence. Ainsi, la seule chose à libérer est l&rsquo;ObjUpvalue elle-même.</p>
<p>Et, finalement, pour afficher :</p>
<div class="codehilite"><pre class="insert-before">    case OBJ_STRING:
      printf(&quot;%s&quot;, AS_CSTRING(value));
      break;
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_UPVALUE</span>:
      <span class="i">printf</span>(<span class="s">&quot;upvalue&quot;</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p>Afficher n&rsquo;est pas utile aux utilisateurs finaux. Les upvalues sont des objets seulement pour que nous puissions prendre avantage de la gestion de mémoire de la VM. Ce ne sont pas des valeurs de première classe qu&rsquo;un utilisateur Lox peut directement accéder dans un programme. Donc ce code ne s&rsquo;exécutera jamais réellement<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>mais il empêche le compilateur de nous crier dessus à propos d&rsquo;un switch case non géré, donc nous y voilà.</p>
<h3><a href="#upvalues-dans-les-fermetures" id="upvalues-dans-les-fermetures"><small>25&#8202;.&#8202;3&#8202;.&#8202;1</small>Upvalues dans les fermetures</a></h3>
<p>Quand j&rsquo;ai d&rsquo;abord introduit les upvalues, j&rsquo;ai dit que chaque fermeture en a un tableau. Nous avons finalement travaillé notre chemin de retour pour implémenter cela.</p>
<div class="codehilite"><pre class="insert-before">  ObjFunction* function;
</pre><div class="source-file"><em>object.h</em><br>
in struct <em>ObjClosure</em></div>
<pre class="insert">  <span class="t">ObjUpvalue</span>** <span class="i">upvalues</span>;
  <span class="t">int</span> <span class="i">upvalueCount</span>;
</pre><pre class="insert-after">} ObjClosure;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>ObjClosure</em></div>

<p><span name="count">Différentes</span> fermetures peuvent avoir différents nombres d&rsquo;upvalues, donc nous avons besoin d&rsquo;un tableau dynamique. Les upvalues elles-mêmes sont allouées dynamiquement aussi, donc nous finissons avec un double pointeur<span class="em">&mdash;</span>un pointeur vers un tableau alloué dynamiquement de pointeurs vers des upvalues. Nous stockons aussi le nombre d&rsquo;éléments dans le tableau.</p>
<aside name="count">
<p>Stocker le compte d&rsquo;upvalue dans la fermeture est redondant parce que l&rsquo;ObjFunction que l&rsquo;ObjClosure référence garde aussi ce compte. Comme d&rsquo;habitude, ce code bizarre est pour apaiser le GC. Le collecteur peut avoir besoin de connaître la taille du tableau d&rsquo;upvalue d&rsquo;une ObjClosure après que l&rsquo;ObjFunction correspondante de la fermeture a déjà été libérée.</p>
</aside>
<p>Quand nous créons une ObjClosure, nous allouons un tableau d&rsquo;upvalue de la taille propre, que nous avons déterminée à la compilation et stockée dans l&rsquo;ObjFunction.</p>
<div class="codehilite"><pre class="insert-before">ObjClosure* newClosure(ObjFunction* function) {
</pre><div class="source-file"><em>object.c</em><br>
in <em>newClosure</em>()</div>
<pre class="insert">  <span class="t">ObjUpvalue</span>** <span class="i">upvalues</span> = <span class="a">ALLOCATE</span>(<span class="t">ObjUpvalue</span>*,
                                   <span class="i">function</span>-&gt;<span class="i">upvalueCount</span>);
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">function</span>-&gt;<span class="i">upvalueCount</span>; <span class="i">i</span>++) {
    <span class="i">upvalues</span>[<span class="i">i</span>] = <span class="a">NULL</span>;
  }

</pre><pre class="insert-after">  ObjClosure* closure = ALLOCATE_OBJ(ObjClosure, OBJ_CLOSURE);
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>newClosure</em>()</div>

<p>Avant de créer l&rsquo;objet fermeture lui-même, nous allouons le tableau d&rsquo;upvalues et les initialisons toutes à <code>NULL</code>. Cette cérémonie bizarre autour de la mémoire est une danse prudente pour plaire aux (futures) déités du ramasse-miettes. Cela assure que le gestionnaire de mémoire ne voit jamais de mémoire non initialisée.</p>
<p>Ensuite nous stockons le tableau dans la nouvelle fermeture, aussi bien que copions le compte depuis l&rsquo;ObjFunction.</p>
<div class="codehilite"><pre class="insert-before">  closure-&gt;function = function;
</pre><div class="source-file"><em>object.c</em><br>
in <em>newClosure</em>()</div>
<pre class="insert">  <span class="i">closure</span>-&gt;<span class="i">upvalues</span> = <span class="i">upvalues</span>;
  <span class="i">closure</span>-&gt;<span class="i">upvalueCount</span> = <span class="i">function</span>-&gt;<span class="i">upvalueCount</span>;
</pre><pre class="insert-after">  return closure;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>newClosure</em>()</div>

<p>Quand nous libérons une ObjClosure, nous libérons aussi le tableau d&rsquo;upvalue.</p>
<div class="codehilite"><pre class="insert-before">    case OBJ_CLOSURE: {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">      <span class="t">ObjClosure</span>* <span class="i">closure</span> = (<span class="t">ObjClosure</span>*)<span class="i">object</span>;
      <span class="a">FREE_ARRAY</span>(<span class="t">ObjUpvalue</span>*, <span class="i">closure</span>-&gt;<span class="i">upvalues</span>,
                 <span class="i">closure</span>-&gt;<span class="i">upvalueCount</span>);
</pre><pre class="insert-after">      FREE(ObjClosure, object);
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>ObjClosure ne possède pas les objets ObjUpvalue eux-mêmes, mais elle possède bien <em>le tableau</em> contenant les pointeurs vers ces upvalues.</p>
<p>Nous remplissons le tableau d&rsquo;upvalue là-bas dans l&rsquo;interpréteur quand il crée une fermeture. C&rsquo;est où nous marchons à travers tous les opérandes après <code>OP_CLOSURE</code> pour voir quel genre d&rsquo;upvalue chaque emplacement capture.</p>
<div class="codehilite"><pre class="insert-before">        push(OBJ_VAL(closure));
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">closure</span>-&gt;<span class="i">upvalueCount</span>; <span class="i">i</span>++) {
          <span class="t">uint8_t</span> <span class="i">isLocal</span> = <span class="a">READ_BYTE</span>();
          <span class="t">uint8_t</span> <span class="i">index</span> = <span class="a">READ_BYTE</span>();
          <span class="k">if</span> (<span class="i">isLocal</span>) {
            <span class="i">closure</span>-&gt;<span class="i">upvalues</span>[<span class="i">i</span>] =
                <span class="i">captureUpvalue</span>(<span class="i">frame</span>-&gt;<span class="i">slots</span> + <span class="i">index</span>);
          } <span class="k">else</span> {
            <span class="i">closure</span>-&gt;<span class="i">upvalues</span>[<span class="i">i</span>] = <span class="i">frame</span>-&gt;<span class="i">closure</span>-&gt;<span class="i">upvalues</span>[<span class="i">index</span>];
          }
        }
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Ce code est le moment magique où une fermeture prend vie. Nous itérons sur chaque upvalue que la fermeture attend. Pour chacune, nous lisons une paire d&rsquo;octets opérandes. Si l&rsquo;upvalue ferme sur une variable locale dans la fonction englobante, nous laissons <code>captureUpvalue()</code> faire le travail.</p>
<p>Sinon, nous capturons une upvalue depuis la fonction environnante. Une instruction <code>OP_CLOSURE</code> est émise à la fin d&rsquo;une déclaration de fonction. Au moment que nous exécutons cette déclaration, la fonction <em>courante</em> est celle environnante. Cela signifie que la fermeture de la fonction courante est stockée dans la CallFrame au sommet de la pile d&rsquo;appels. Donc, pour attraper une upvalue depuis la fonction englobante, nous pouvons la lire juste depuis la variable locale <code>frame</code>, qui cache une référence vers cette CallFrame.</p>
<p>Fermer sur une variable locale est plus intéressant. La plupart du travail se passe dans une fonction séparée, mais d&rsquo;abord nous calculons l&rsquo;argument à lui passer. Nous avons besoin d&rsquo;attraper un pointeur vers l&rsquo;emplacement de la locale capturée dans la fenêtre de pile de la fonction environnante. Cette fenêtre commence à <code>frame-&gt;slots</code>, qui pointe vers l&rsquo;emplacement zéro. Ajouter <code>index</code> décale cela vers l&rsquo;emplacement local que nous voulons capturer. Nous passons ce pointeur ici :</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>callValue</em>()</div>
<pre><span class="k">static</span> <span class="t">ObjUpvalue</span>* <span class="i">captureUpvalue</span>(<span class="t">Value</span>* <span class="i">local</span>) {
  <span class="t">ObjUpvalue</span>* <span class="i">createdUpvalue</span> = <span class="i">newUpvalue</span>(<span class="i">local</span>);
  <span class="k">return</span> <span class="i">createdUpvalue</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>callValue</em>()</div>

<p>Cela semble un peu bête. Tout ce qu&rsquo;elle fait est de créer une nouvelle ObjUpvalue qui capture l&rsquo;emplacement de pile donné et la renvoie. Avions-nous besoin d&rsquo;une fonction séparée pour cela ? Eh bien, non, pas <em>encore</em>. Mais vous savez que nous allons finir par coller plus de code ici.</p>
<p>D&rsquo;abord, emballons ce sur quoi nous travaillons. De retour dans le code de l&rsquo;interpréteur pour gérer <code>OP_CLOSURE</code>, nous finissons éventuellement d&rsquo;itérer à travers le tableau d&rsquo;upvalue et initialisons chacune. Quand cela compléte, nous avons une nouvelle fermeture avec un tableau plein d&rsquo;upvalues pointant vers des variables.</p>
<p>Avec cela en main, nous pouvons implémenter les instructions qui travaillent avec ces upvalues.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GET_UPVALUE</span>: {
        <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="a">READ_BYTE</span>();
        <span class="i">push</span>(*<span class="i">frame</span>-&gt;<span class="i">closure</span>-&gt;<span class="i">upvalues</span>[<span class="i">slot</span>]-&gt;<span class="i">location</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>L&rsquo;opérande est l&rsquo;index dans le tableau d&rsquo;upvalue de la fonction courante. Donc nous cherchons simplement l&rsquo;upvalue correspondante et déréférençons son pointeur de location pour lire la valeur dans cet emplacement. Régler une variable est similaire.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_SET_UPVALUE</span>: {
        <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="a">READ_BYTE</span>();
        *<span class="i">frame</span>-&gt;<span class="i">closure</span>-&gt;<span class="i">upvalues</span>[<span class="i">slot</span>]-&gt;<span class="i">location</span> = <span class="i">peek</span>(<span class="n">0</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nous <span name="assign">prenons</span> la valeur au sommet de la pile et la stockons dans l&rsquo;emplacement pointé par l&rsquo;upvalue choisie. Juste comme avec les instructions pour les variables locales, il est important que ces instructions soient rapides. Les programmes utilisateur lisent et écrivent constamment des variables, donc si c&rsquo;est lent, tout est lent. Et, comme d&rsquo;habitude, la façon dont nous les rendons rapides est en les gardant simples. Ces deux nouvelles instructions sont assez bonnes : pas de flux de contrôle, pas d&rsquo;arithmétique complexe, juste une paire d&rsquo;indirections de pointeur et un <code>push()</code>.</p>
<aside name="assign">
<p>L&rsquo;instruction set ne <em>dépile</em> pas la valeur de la pile parce que, rappelez-vous, l&rsquo;assignation est une expression dans Lox. Donc le résultat de l&rsquo;assignation<span class="em">&mdash;</span>la valeur assignée<span class="em">&mdash;</span>a besoin de rester sur la pile pour l&rsquo;expression environnante.</p>
</aside>
<p>C&rsquo;est un jalon. Tant que toutes les variables restent sur la pile, nous avons des fermetures fonctionnelles. Essayez ceci :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="s">&quot;outside&quot;</span>;
  <span class="k">fun</span> <span class="i">inner</span>() {
    <span class="k">print</span> <span class="i">x</span>;
  }
  <span class="i">inner</span>();
}
<span class="i">outer</span>();
</pre></div>
<p>Exécutez ceci, et cela affiche correctement &ldquo;outside&rdquo;.</p>
<h2><a href="#upvalues-fermées" id="upvalues-fermées"><small>25&#8202;.&#8202;4</small>Upvalues fermées</a></h2>
<p>Bien sûr, une fonctionnalité clé des fermetures est qu&rsquo;elles tiennent la variable aussi longtemps que nécessaire, même après que la fonction qui déclare la variable a retourné. Voici un autre exemple qui <em>devrait</em> fonctionner :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="s">&quot;outside&quot;</span>;
  <span class="k">fun</span> <span class="i">inner</span>() {
    <span class="k">print</span> <span class="i">x</span>;
  }

  <span class="k">return</span> <span class="i">inner</span>;
}

<span class="k">var</span> <span class="i">closure</span> = <span class="i">outer</span>();
<span class="i">closure</span>();
</pre></div>
<p>Mais si vous l&rsquo;exécutez juste maintenant<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>qui sait ce qu&rsquo;elle fait ? À l&rsquo;exécution, elle finira par lire depuis un emplacement de pile qui ne contient plus la variable fermée. Comme je l&rsquo;ai mentionné quelques fois, le crux du problème est que les variables dans les fermetures n&rsquo;ont pas de sémantique de pile. Cela signifie que nous devons les hisser hors de la pile quand la fonction où elles ont été déclarées retourne. Cette section finale du chapitre fait cela.</p>
<h3><a href="#valeurs-et-variables" id="valeurs-et-variables"><small>25&#8202;.&#8202;4&#8202;.&#8202;1</small>Valeurs et variables</a></h3>
<p>Avant que nous n&rsquo;arrivions à écrire du code, je veux creuser dans un point sémantique important. Est-ce qu&rsquo;une fermeture ferme sur une <em>valeur</em> ou une <em>variable ?</em> Ce n&rsquo;est pas purement une question <span name="academic">académique</span>. Je ne suis pas juste en train de couper les cheveux en quatre. Considérez :</p>
<aside name="academic">
<p>Si Lox ne permettait pas l&rsquo;assignation, ce <em>serait</em> une question académique.</p>
</aside>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">globalSet</span>;
<span class="k">var</span> <span class="i">globalGet</span>;

<span class="k">fun</span> <span class="i">main</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;initial&quot;</span>;

  <span class="k">fun</span> <span class="i">set</span>() { <span class="i">a</span> = <span class="s">&quot;updated&quot;</span>; }
  <span class="k">fun</span> <span class="i">get</span>() { <span class="k">print</span> <span class="i">a</span>; }

  <span class="i">globalSet</span> = <span class="i">set</span>;
  <span class="i">globalGet</span> = <span class="i">get</span>;
}

<span class="i">main</span>();
<span class="i">globalSet</span>();
<span class="i">globalGet</span>();
</pre></div>
<p>La fonction extérieure <code>main()</code> crée deux fermetures et les stocke dans des variables <span name="global">globales</span> pour qu&rsquo;elles survivent à l&rsquo;exécution de <code>main()</code> elle-même. Ces deux fermetures capturent la même variable. La première fermeture lui assigne une nouvelle valeur et la seconde fermeture lit la variable.</p>
<aside name="global">
<p>Le fait que j&rsquo;utilise une couple de variables globales n&rsquo;est pas significatif. J&rsquo;avais besoin de quelque moyen de retourner deux valeurs d&rsquo;une fonction, et sans aucune sorte de type collection dans Lox, mes options étaient limitées.</p>
</aside>
<p>Qu&rsquo;est-ce que l&rsquo;appel à <code>globalGet()</code> affiche ? Si les fermetures capturent des <em>valeurs</em> alors chaque fermeture obtient sa propre copie de <code>a</code> avec la valeur que <code>a</code> avait au point dans le temps que la déclaration de fonction de la fermeture a exécuté. L&rsquo;appel à <code>globalSet()</code> modifiera la copie de <code>set()</code> de <code>a</code>, mais la copie de <code>get()</code> sera inaffectée. Ainsi, l&rsquo;appel à <code>globalGet()</code> affichera &ldquo;initial&rdquo;.</p>
<p>Si les fermetures ferment sur des variables, alors <code>get()</code> et <code>set()</code> captureront toutes deux<span class="em">&mdash;</span>référenceront<span class="em">&mdash;</span>la <em>même variable mutable</em>. Quand <code>set()</code> change <code>a</code>, elle change le même <code>a</code> que <code>get()</code> lit. Il n&rsquo;y a qu&rsquo;un seul <code>a</code>. Cela, à son tour, implique que l&rsquo;appel à <code>globalGet()</code> affichera &ldquo;updated&rdquo;.</p>
<p>Lequel est-ce ? La réponse pour Lox et la plupart des autres langages que je connais avec des fermetures est la dernière. Les fermetures capturent des variables. Vous pouvez penser à elles comme capturant <em>l&rsquo;endroit où la valeur vit</em>. C&rsquo;est important à garder à l&rsquo;esprit alors que nous traitons avec les variables fermées qui ne sont plus sur la pile. Quand une variable bouge vers le tas, nous avons besoin de nous assurer que toutes les fermetures capturant cette variable retiennent une référence à son <em>seul</em> nouvel emplacement. De cette façon, quand la variable est mutée, toutes les fermetures voient le changement.</p>
<h3><a href="#fermer-les-upvalues" id="fermer-les-upvalues"><small>25&#8202;.&#8202;4&#8202;.&#8202;2</small>Fermer les upvalues</a></h3>
<p>Nous savons que les variables locales commencent toujours sur la pile. C&rsquo;est plus rapide, et laisse notre compilateur à une seule passe émettre du code avant qu&rsquo;il découvre que la variable a été capturée. Nous savons aussi que les variables fermées ont besoin de bouger vers le tas si la fermeture survit à la fonction où la variable capturée est déclarée.</p>
<p>Suivant Lua, nous utiliserons <strong>upvalue ouverte</strong> pour nous référer à une upvalue qui pointe vers une variable locale encore sur la pile. Quand une variable bouge vers le tas, nous <em>fermons</em> l&rsquo;upvalue et le résultat est, naturellement, une <strong>upvalue fermée</strong>. Les deux questions auxquelles nous avons besoin de répondre sont :</p>
<ol>
<li>
<p>Où sur le tas va la variable fermée ?</p>
</li>
<li>
<p>Quand fermons-nous l&rsquo;upvalue ?</p>
</li>
</ol>
<p>La réponse à la première question est facile. Nous avons déjà un objet pratique sur le tas qui représente une référence à une variable<span class="em">&mdash;</span>ObjUpvalue elle-même. La variable fermée bougera dans un nouveau champ juste à l&rsquo;intérieur de la structure ObjUpvalue. De cette façon nous n&rsquo;avons pas besoin de faire d&rsquo;allocation de tas supplémentaire pour fermer une upvalue.</p>
<p>La seconde question est directe aussi. Tant que la variable est sur la pile, il peut y avoir du code qui s&rsquo;y réfère là, et ce code doit fonctionner correctement. Donc le moment logique pour hisser la variable vers le tas est aussi tard que possible. Si nous bougeons la variable locale juste quand elle sort de portée, nous sommes certains qu&rsquo;aucun code après ce point n&rsquo;essaiera d&rsquo;y accéder depuis la pile. <span name="after">Après</span> que la variable est hors de portée, le compilateur aura rapporté une erreur si n&rsquo;importe quel code essayait de l&rsquo;utiliser.</p>
<aside name="after">
<p>Par &ldquo;après&rdquo; ici, je veux dire dans le sens lexical ou textuel<span class="em">&mdash;</span>code passé le <code>}</code> pour le bloc contenant la déclaration de la variable fermée.</p>
</aside>
<p>Le compilateur émet déjà une instruction <code>OP_POP</code> quand une variable locale sort de portée. Si une variable est capturée par une fermeture, nous émettrons à la place une instruction différente pour hisser cette variable hors de la pile et dans son upvalue correspondante. Pour faire cela, le compilateur a besoin de savoir quelles <span name="param">locales</span> sont fermées.</p>
<aside name="param">
<p>Le compilateur ne dépile pas les paramètres et les locales déclarés immédiatement à l&rsquo;intérieur du corps d&rsquo;une fonction. Nous gérerons ceux-là aussi, dans le runtime.</p>
</aside>
<p>Le compilateur maintient déjà un tableau de structures Upvalue pour chaque variable locale dans la fonction pour suivre exactement cet état. Ce tableau est bon pour répondre &ldquo;Quelles variables cette fermeture utilise-t-elle ?&rdquo; Mais il est pauvrement adapté pour répondre, &ldquo;Est-ce que <em>n&rsquo;importe quelle</em> fonction capture cette variable locale ?&rdquo; En particulier, une fois que le Compiler pour quelque fermeture a fini, le Compiler pour la fonction englobante dont la variable a été capturée n&rsquo;a plus accès à aucun des états d&rsquo;upvalue.</p>
<p>En d&rsquo;autres termes, le compilateur maintient des pointeurs depuis les upvalues vers les locales qu&rsquo;elles capturent, mais pas dans l&rsquo;autre direction. Donc nous avons d&rsquo;abord besoin d&rsquo;ajouter un suivi supplémentaire à l&rsquo;intérieur de la structure Local existante pour que nous puissions dire si une locale donnée est capturée par une fermeture.</p>
<div class="codehilite"><pre class="insert-before">  int depth;
</pre><div class="source-file"><em>compiler.c</em><br>
in struct <em>Local</em></div>
<pre class="insert">  <span class="t">bool</span> <span class="i">isCaptured</span>;
</pre><pre class="insert-after">} Local;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Local</em></div>

<p>Ce champ est <code>true</code> si la locale est capturée par n&rsquo;importe quelle déclaration de fonction imbriquée ultérieure. Initialement, toutes les locales ne sont pas capturées.</p>
<div class="codehilite"><pre class="insert-before">  local-&gt;depth = -1;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>addLocal</em>()</div>
<pre class="insert">  <span class="i">local</span>-&gt;<span class="i">isCaptured</span> = <span class="k">false</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addLocal</em>()</div>

<p><span name="zero">De même</span>, la &ldquo;locale d&rsquo;emplacement zéro&rdquo; spéciale que le compilateur déclare implicitement n&rsquo;est pas capturée.</p>
<aside name="zero">
<p>Plus tard dans le livre, il deviendra possible pour un utilisateur de capturer cette variable. Juste construisant un peu d&rsquo;anticipation ici.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  local-&gt;depth = 0;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>initCompiler</em>()</div>
<pre class="insert">  <span class="i">local</span>-&gt;<span class="i">isCaptured</span> = <span class="k">false</span>;
</pre><pre class="insert-after">  local-&gt;name.start = &quot;&quot;;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>

<p>Lors de la résolution d&rsquo;un identifiant, si nous finissons par créer une upvalue pour une variable locale, nous la marquons comme capturée.</p>
<div class="codehilite"><pre class="insert-before">  if (local != -1) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>resolveUpvalue</em>()</div>
<pre class="insert">    <span class="i">compiler</span>-&gt;<span class="i">enclosing</span>-&gt;<span class="i">locals</span>[<span class="i">local</span>].<span class="i">isCaptured</span> = <span class="k">true</span>;
</pre><pre class="insert-after">    return addUpvalue(compiler, (uint8_t)local, true);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>resolveUpvalue</em>()</div>

<p>Maintenant, à la fin d&rsquo;une portée de bloc quand le compilateur émet du code pour libérer les emplacements de pile pour les locales, nous pouvons dire lesquelles ont besoin d&rsquo;être hissées sur le tas. Nous utiliserons une nouvelle instruction pour cela.</p>
<div class="codehilite"><pre class="insert-before">  while (current-&gt;localCount &gt; 0 &amp;&amp;
         current-&gt;locals[current-&gt;localCount - 1].depth &gt;
            current-&gt;scopeDepth) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endScope</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>].<span class="i">isCaptured</span>) {
      <span class="i">emitByte</span>(<span class="a">OP_CLOSE_UPVALUE</span>);
    } <span class="k">else</span> {
      <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
    }
</pre><pre class="insert-after">    current-&gt;localCount--;
  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endScope</em>(), replace 1 line</div>

<p>L&rsquo;instruction ne requiert pas d&rsquo;opérande. Nous savons que la variable sera toujours juste au sommet de la pile au point que cette instruction s&rsquo;exécute. Nous déclarons l&rsquo;instruction.</p>
<div class="codehilite"><pre class="insert-before">  OP_CLOSURE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_CLOSE_UPVALUE</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Et ajoutons le support trivial du désassembleur pour elle :</p>
<div class="codehilite"><pre class="insert-before">    }
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_CLOSE_UPVALUE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_CLOSE_UPVALUE&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Excellent. Maintenant le bytecode généré dit au runtime exactement quand chaque variable locale capturée doit bouger vers le tas. Mieux, il le fait seulement pour les locales qui <em>sont</em> utilisées par une fermeture et ont besoin de ce traitement spécial. Cela s&rsquo;aligne avec notre but de performance général que nous voulons que les utilisateurs paient seulement pour la fonctionnalité qu&rsquo;ils utilisent. Les variables qui ne sont pas utilisées par des fermetures vivent et meurent entièrement sur la pile juste comme elles le faisaient avant.</p>
<h3><a href="#suivre-les-upvalues-ouvertes" id="suivre-les-upvalues-ouvertes"><small>25&#8202;.&#8202;4&#8202;.&#8202;3</small>Suivre les upvalues ouvertes</a></h3>
<p>Bougeons de l&rsquo;autre côté vers le runtime. Avant que nous puissions interpréter les instructions <code>OP_CLOSE_UPVALUE</code>, nous avons un problème à résoudre. Plus tôt, quand j&rsquo;ai parlé de savoir si les fermetures capturent des variables ou des valeurs, j&rsquo;ai dit qu&rsquo;il était important que si de multiples fermetures accèdent à la même variable qu&rsquo;elles finissent avec une référence vers le même emplacement de stockage exact en mémoire. De cette façon si une fermeture écrit à la variable, l&rsquo;autre fermeture voit le changement.</p>
<p>Juste maintenant, si deux fermetures capturent la même variable <span name="indirect">locale</span>, la VM crée une Upvalue séparée pour chacune. Le partage nécessaire est manquant. Quand nous bougeons la variable hors de la pile, si nous la bougeons dans seulement une des upvalues, l&rsquo;autre upvalue aura une valeur orpheline.</p>
<aside name="indirect">
<p>La VM partage <em>bien</em> les upvalues si une fermeture capture une <em>upvalue</em> depuis une fonction environnante. Le cas imbriqué fonctionne correctement. Mais si deux fermetures <em>soeurs</em> capturent la même variable locale, elles créent chacune une ObjUpvalue séparée.</p>
</aside>
<p>Pour corriger cela, chaque fois que la VM a besoin d&rsquo;une upvalue qui capture un emplacement de variable locale particulier, nous chercherons d&rsquo;abord une upvalue existante pointant vers cet emplacement. Si trouvée, nous réutilisons celle-là. Le défi est que toutes les upvalues précédemment créées sont écureuillées à l&rsquo;intérieur des tableaux d&rsquo;upvalue des diverses fermetures. Ces fermetures pourraient être n&rsquo;importe où dans la mémoire de la VM.</p>
<p>La première étape est de donner à la VM sa propre liste de toutes les upvalues ouvertes qui pointent vers des variables encore sur la pile. Chercher une liste chaque fois que la VM a besoin d&rsquo;une upvalue semble que cela pourrait être lent, mais en pratique, ce n&rsquo;est pas mauvais. Le nombre de variables sur la pile qui sont réellement fermées tend à être petit. Et les déclarations de fonction qui <span name="create">créent</span> des fermetures sont rarement sur des chemins d&rsquo;exécution critiques pour la performance dans le programme de l&rsquo;utilisateur.</p>
<aside name="create">
<p>Les fermetures sont fréquemment <em>invoquées</em> à l&rsquo;intérieur de boucles chaudes. Pensez aux fermetures passées aux fonctions d&rsquo;ordre supérieur typiques sur les collections comme <a href="https://en.wikipedia.org/wiki/Map_(higher-order_function)"><code>map()</code></a> et <a href="https://en.wikipedia.org/wiki/Filter_(higher-order_function)"><code>filter()</code></a>. Cela devrait être rapide. Mais la déclaration de fonction qui <em>crée</em> la fermeture arrive seulement une fois et est habituellement en dehors de la boucle.</p>
</aside>
<p>Encore mieux, nous pouvons ordonner la liste d&rsquo;upvalues ouvertes par l&rsquo;index d&rsquo;emplacement de pile vers lequel elles pointent. Le cas commun est qu&rsquo;un emplacement n&rsquo;a <em>pas</em> déjà été capturé<span class="em">&mdash;</span>partager des variables entre des fermetures est peu commun<span class="em">&mdash;</span>et les fermetures tendent à capturer des locales près du sommet de la pile. Si nous stockons le tableau d&rsquo;upvalues ouvertes dans l&rsquo;ordre des emplacements de pile, aussitôt que nous passons l&rsquo;emplacement où la locale que nous capturons vit, nous savons qu&rsquo;elle ne sera pas trouvée. Quand cette locale est près du sommet de la pile, nous pouvons sortir de la boucle assez tôt.</p>
<p>Maintenir une liste triée requiert d&rsquo;insérer des éléments au milieu efficacement. Cela suggère utiliser une liste chaînée au lieu d&rsquo;un tableau dynamique. Puisque nous avons défini la structure ObjUpvalue nous-mêmes, l&rsquo;implémentation la plus facile est une liste intrusive qui met le pointeur suivant juste à l&rsquo;intérieur de la structure ObjUpvalue elle-même.</p>
<div class="codehilite"><pre class="insert-before">  Value* location;
</pre><div class="source-file"><em>object.h</em><br>
in struct <em>ObjUpvalue</em></div>
<pre class="insert">  <span class="k">struct</span> <span class="t">ObjUpvalue</span>* <span class="i">next</span>;
</pre><pre class="insert-after">} ObjUpvalue;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>ObjUpvalue</em></div>

<p>Quand nous allouons une upvalue, elle n&rsquo;est pas attachée à aucune liste encore donc le lien est <code>NULL</code>.</p>
<div class="codehilite"><pre class="insert-before">  upvalue-&gt;location = slot;
</pre><div class="source-file"><em>object.c</em><br>
in <em>newUpvalue</em>()</div>
<pre class="insert">  <span class="i">upvalue</span>-&gt;<span class="i">next</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">  return upvalue;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>newUpvalue</em>()</div>

<p>La VM possède la liste, donc le pointeur de tête va juste à l&rsquo;intérieur de la structure VM principale.</p>
<div class="codehilite"><pre class="insert-before">  Table strings;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">ObjUpvalue</span>* <span class="i">openUpvalues</span>;
</pre><pre class="insert-after">  Obj* objects;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>La liste commence vide.</p>
<div class="codehilite"><pre class="insert-before">  vm.frameCount = 0;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>resetStack</em>()</div>
<pre class="insert">  <span class="i">vm</span>.<span class="i">openUpvalues</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>resetStack</em>()</div>

<p>Commençant avec la première upvalue pointée par la VM, chaque upvalue ouverte pointe vers la prochaine upvalue ouverte qui référence une variable locale plus bas sur la pile. Ce script, par exemple,</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
  <span class="k">fun</span> <span class="i">f</span>() {
    <span class="k">print</span> <span class="i">a</span>;
  }
  <span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
  <span class="k">fun</span> <span class="i">g</span>() {
    <span class="k">print</span> <span class="i">b</span>;
  }
  <span class="k">var</span> <span class="i">c</span> = <span class="n">3</span>;
  <span class="k">fun</span> <span class="i">h</span>() {
    <span class="k">print</span> <span class="i">c</span>;
  }
}
</pre></div>
<p>devrait produire une série d&rsquo;upvalues liées comme ceci :</p><img src="image/closures/linked-list.png" alt="Trois upvalues dans une liste chaînée."/>
<p>Chaque fois que nous fermons sur une variable locale, avant de créer une nouvelle upvalue, nous cherchons une existante dans la liste.</p>
<div class="codehilite"><pre class="insert-before">static ObjUpvalue* captureUpvalue(Value* local) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>captureUpvalue</em>()</div>
<pre class="insert">  <span class="t">ObjUpvalue</span>* <span class="i">prevUpvalue</span> = <span class="a">NULL</span>;
  <span class="t">ObjUpvalue</span>* <span class="i">upvalue</span> = <span class="i">vm</span>.<span class="i">openUpvalues</span>;
  <span class="k">while</span> (<span class="i">upvalue</span> != <span class="a">NULL</span> &amp;&amp; <span class="i">upvalue</span>-&gt;<span class="i">location</span> &gt; <span class="i">local</span>) {
    <span class="i">prevUpvalue</span> = <span class="i">upvalue</span>;
    <span class="i">upvalue</span> = <span class="i">upvalue</span>-&gt;<span class="i">next</span>;
  }

  <span class="k">if</span> (<span class="i">upvalue</span> != <span class="a">NULL</span> &amp;&amp; <span class="i">upvalue</span>-&gt;<span class="i">location</span> == <span class="i">local</span>) {
    <span class="k">return</span> <span class="i">upvalue</span>;
  }

</pre><pre class="insert-after">  ObjUpvalue* createdUpvalue = newUpvalue(local);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>captureUpvalue</em>()</div>

<p>Nous commençons à la <span name="head">tête</span> de la liste, qui est l&rsquo;upvalue la plus proche du sommet de la pile. Nous parcourons la liste, utilisant une petite comparaison de pointeur pour itérer passé chaque upvalue pointant vers des emplacements au-dessus de celui que nous cherchons. Pendant que nous faisons cela, nous gardons la trace de l&rsquo;upvalue précédente sur la liste. Nous aurons besoin de mettre à jour le pointeur <code>next</code> de ce nœud si nous finissons par insérer un nœud après lui.</p>
<aside name="head">
<p>C&rsquo;est une liste simplement chaînée. Ce n&rsquo;est pas comme si nous avions d&rsquo;autre choix que de commencer à la tête et aller vers l&rsquo;avant depuis là.</p>
</aside>
<p>Il y a trois raisons pour lesquelles nous pouvons sortir de la boucle :</p>
<ol>
<li>
<p><strong>L&rsquo;emplacement local auquel nous nous sommes arrêtés <em>est</em> l&rsquo;emplacement que nous cherchons.</strong> Nous avons trouvé une upvalue existante capturant la variable, donc nous réutilisons cette upvalue.</p>
</li>
<li>
<p><strong>Nous sommes tombés à court d&rsquo;upvalues à chercher.</strong> Quand <code>upvalue</code> est <code>NULL</code>, cela signifie que chaque upvalue ouverte dans la liste pointe vers des locales au-dessus de l&rsquo;emplacement que nous cherchons, ou (plus probablement) la liste d&rsquo;upvalues est vide. Dans les deux cas, nous n&rsquo;avons pas trouvé une upvalue pour notre emplacement.</p>
</li>
<li>
<p><strong>Nous avons trouvé une upvalue dont l&rsquo;emplacement local est <em>en dessous</em> de celui que nous cherchons.</strong> Puisque la liste est triée, cela signifie que nous sommes passés au-delà de l&rsquo;emplacement sur lequel nous fermons, et donc il ne doit pas y avoir d&rsquo;upvalue existante pour lui.</p>
</li>
</ol>
<p>Dans le premier cas, nous avons fini et nous avons retourné. Sinon, nous créons une nouvelle upvalue pour notre emplacement local et l&rsquo;insérons dans la liste au bon endroit.</p>
<div class="codehilite"><pre class="insert-before">  ObjUpvalue* createdUpvalue = newUpvalue(local);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>captureUpvalue</em>()</div>
<pre class="insert">  <span class="i">createdUpvalue</span>-&gt;<span class="i">next</span> = <span class="i">upvalue</span>;

  <span class="k">if</span> (<span class="i">prevUpvalue</span> == <span class="a">NULL</span>) {
    <span class="i">vm</span>.<span class="i">openUpvalues</span> = <span class="i">createdUpvalue</span>;
  } <span class="k">else</span> {
    <span class="i">prevUpvalue</span>-&gt;<span class="i">next</span> = <span class="i">createdUpvalue</span>;
  }

</pre><pre class="insert-after">  return createdUpvalue;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>captureUpvalue</em>()</div>

<p>L&rsquo;incarnation courante de cette fonction crée déjà l&rsquo;upvalue, donc nous avons seulement besoin d&rsquo;ajouter du code pour insérer l&rsquo;upvalue dans la liste. Nous sommes sortis de la traversée de liste soit en allant après la fin de la liste, soit en s&rsquo;arrêtant sur la première upvalue dont l&rsquo;emplacement de pile est en dessous de celui que nous cherchons. Dans les deux cas, cela signifie que nous devons insérer la nouvelle upvalue <em>avant</em> l&rsquo;objet pointé par <code>upvalue</code> (qui peut être <code>NULL</code> si nous avons frappé la fin de la liste).</p>
<p>Comme vous pouvez l&rsquo;avoir appris dans Structures de Données 101, pour insérer un nœud dans une liste chaînée, vous réglez le pointeur <code>next</code> du nœud précédent pour pointer vers votre nouveau. Nous avons commodément gardé la trace de ce nœud précédent alors que nous marchions la liste. Nous avons aussi besoin de gérer le cas <span name="double">spécial</span> où nous insérons une nouvelle upvalue à la tête de la liste, auquel cas le pointeur &ldquo;next&rdquo; est le pointeur de tête de la VM.</p>
<aside name="double">
<p>Il y a une implémentation plus courte qui gère la mise à jour soit du pointeur de tête ou du pointeur <code>next</code> de l&rsquo;upvalue précédente uniformément en utilisant un pointeur vers un pointeur, mais ce genre de code déroute presque tout le monde qui n&rsquo;a pas atteint quelque niveau maître Zen d&rsquo;expertise pointeur. Je suis allé avec l&rsquo;approche basique instruction <code>if</code>.</p>
</aside>
<p>Avec cette fonction mise à jour, la VM assure maintenant qu&rsquo;il y a seulement toujours une seule ObjUpvalue pour n&rsquo;importe quel emplacement local donné. Si deux fermetures capturent la même variable, elles obtiendront la même upvalue. Nous sommes prêts à bouger ces upvalues hors de la pile maintenant.</p>
<h3><a href="#fermer-les-upvalues-&agrave;-lexécution" id="fermer-les-upvalues-&agrave;-lexécution"><small>25&#8202;.&#8202;4&#8202;.&#8202;4</small>Fermer les upvalues &agrave; l&rsquo;exécution</a></h3>
<p>Le compilateur émet utilement une instruction <code>OP_CLOSE_UPVALUE</code> pour dire à la VM exactement quand une variable locale devrait être hissée sur le tas. Exécuter cette instruction est la responsabilité de l&rsquo;interpréteur.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_CLOSE_UPVALUE</span>:
        <span class="i">closeUpvalues</span>(<span class="i">vm</span>.<span class="i">stackTop</span> - <span class="n">1</span>);
        <span class="i">pop</span>();
        <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Quand nous atteignons l&rsquo;instruction, la variable que nous hissons est juste au sommet de la pile. Nous appelons une fonction aide, passant l&rsquo;adresse de cet emplacement de pile. Cette fonction est responsable de fermer l&rsquo;upvalue et bouger la locale de la pile vers le tas. Après cela, la VM est libre de jeter l&rsquo;emplacement de pile, ce qu&rsquo;elle fait en appelant <code>pop()</code>.</p>
<p>Le truc amusant se passe ici :</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>captureUpvalue</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">closeUpvalues</span>(<span class="t">Value</span>* <span class="i">last</span>) {
  <span class="k">while</span> (<span class="i">vm</span>.<span class="i">openUpvalues</span> != <span class="a">NULL</span> &amp;&amp;
         <span class="i">vm</span>.<span class="i">openUpvalues</span>-&gt;<span class="i">location</span> &gt;= <span class="i">last</span>) {
    <span class="t">ObjUpvalue</span>* <span class="i">upvalue</span> = <span class="i">vm</span>.<span class="i">openUpvalues</span>;
    <span class="i">upvalue</span>-&gt;<span class="i">closed</span> = *<span class="i">upvalue</span>-&gt;<span class="i">location</span>;
    <span class="i">upvalue</span>-&gt;<span class="i">location</span> = &amp;<span class="i">upvalue</span>-&gt;<span class="i">closed</span>;
    <span class="i">vm</span>.<span class="i">openUpvalues</span> = <span class="i">upvalue</span>-&gt;<span class="i">next</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>captureUpvalue</em>()</div>

<p>Cette fonction prend un pointeur vers un emplacement de pile. Elle ferme chaque upvalue ouverte qu&rsquo;elle peut trouver qui pointe vers cet emplacement ou n&rsquo;importe quel emplacement au-dessus de lui sur la pile. Juste maintenant, nous passons un pointeur seulement vers l&rsquo;emplacement du sommet sur la pile, donc la partie &ldquo;ou au-dessus&rdquo; n&rsquo;entre pas en jeu, mais elle le fera bientôt.</p>
<p>Pour faire cela, nous marchons la liste des upvalues ouvertes de la VM, encore de haut en bas. Si l&rsquo;emplacement d&rsquo;une upvalue pointe dans la plage d&rsquo;emplacements que nous fermons, nous fermons l&rsquo;upvalue. Sinon, une fois que nous atteignons une upvalue en dehors de la plage, nous savons que le reste le sera aussi, donc nous arrêtons d&rsquo;itérer.</p>
<p>La façon dont une upvalue devient fermée est assez <span name="cool">cool</span>. D&rsquo;abord, nous copions la valeur de la variable dans le champ <code>closed</code> dans l&rsquo;ObjUpvalue. C&rsquo;est où les variables fermées vivent sur le tas. Les instructions <code>OP_GET_UPVALUE</code> et <code>OP_SET_UPVALUE</code> ont besoin de chercher la variable là après qu&rsquo;elle a été bougée. Nous pourrions ajouter quelque logique conditionnelle dans le code de l&rsquo;interpréteur pour ces instructions pour vérifier quelque drapeau pour si l&rsquo;upvalue est ouverte ou fermée.</p>
<p>Mais il y a déjà un niveau d&rsquo;indirection en jeu<span class="em">&mdash;</span>ces instructions déréférencent le pointeur <code>location</code> pour arriver à la valeur de la variable. Quand la variable bouge de la pile au champ <code>closed</code>, nous mettons simplement à jour cette <code>location</code> à l&rsquo;adresse du <em>propre</em> champ <code>closed</code> de l&rsquo;ObjUpvalue.</p>
<aside name="cool">
<p>Je ne fais pas mon propre éloge ici. C&rsquo;est toute l&rsquo;innovation de l&rsquo;équipe de dev Lua.</p>
</aside><img src="image/closures/closing.png" alt="Bouger une valeur de la pile au champ 'closed' de l'upvalue et ensuite pointer le champ 'location' vers lui."/>
<p>Nous n&rsquo;avons pas besoin de changer comment <code>OP_GET_UPVALUE</code> et <code>OP_SET_UPVALUE</code> sont interprétées du tout. Cela les garde simples, ce qui à son tour les garde rapides. Nous avons besoin d&rsquo;ajouter le nouveau champ à ObjUpvalue, cependant.</p>
<div class="codehilite"><pre class="insert-before">  Value* location;
</pre><div class="source-file"><em>object.h</em><br>
in struct <em>ObjUpvalue</em></div>
<pre class="insert">  <span class="t">Value</span> <span class="i">closed</span>;
</pre><pre class="insert-after">  struct ObjUpvalue* next;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>ObjUpvalue</em></div>

<p>Et nous devrions le mettre à zéro quand nous créons une ObjUpvalue pour qu&rsquo;il n&rsquo;y ait pas de mémoire non initialisée flottant autour.</p>
<div class="codehilite"><pre class="insert-before">  ObjUpvalue* upvalue = ALLOCATE_OBJ(ObjUpvalue, OBJ_UPVALUE);
</pre><div class="source-file"><em>object.c</em><br>
in <em>newUpvalue</em>()</div>
<pre class="insert">  <span class="i">upvalue</span>-&gt;<span class="i">closed</span> = <span class="a">NIL_VAL</span>;
</pre><pre class="insert-after">  upvalue-&gt;location = slot;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>newUpvalue</em>()</div>

<p>Chaque fois que le compilateur atteint la fin d&rsquo;un bloc, il se débarrasse de toutes les variables locales dans ce bloc et émet une <code>OP_CLOSE_UPVALUE</code> pour chaque variable locale qui a été fermée. Le compilateur <span name="close">n&rsquo;émet</span> <em>pas</em> d&rsquo;instructions à la fin de la portée de bloc la plus extérieure qui définit un corps de fonction. Cette portée contient les paramètres de la fonction et toutes locales déclarées immédiatement à l&rsquo;intérieur de la fonction. Celles-là ont besoin d&rsquo;être fermées aussi.</p>
<aside name="close">
<p>Il n&rsquo;y a rien qui nous <em>empêche</em> de fermer la portée de fonction la plus extérieure dans le compilateur et d&rsquo;émettre des instructions <code>OP_POP</code> et <code>OP_CLOSE_UPVALUE</code>. Faire ainsi est juste inutile parce que le runtime jette tous les emplacements de pile utilisés par la fonction implicitement quand il dépile le cadre d&rsquo;appel.</p>
</aside>
<p>C&rsquo;est la raison pour laquelle <code>closeUpvalues()</code> accepte un pointeur vers un emplacement de pile. Quand une fonction retourne, nous appelons cette même aide et passons le premier emplacement de pile possédé par la fonction.</p>
<div class="codehilite"><pre class="insert-before">        Value result = pop();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="i">closeUpvalues</span>(<span class="i">frame</span>-&gt;<span class="i">slots</span>);
</pre><pre class="insert-after">        vm.frameCount--;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>En passant le premier emplacement dans la fenêtre de pile de la fonction, nous fermons chaque upvalue ouverte restante possédée par la fonction retournante. Et avec ça, nous avons maintenant une implémentation de fermeture pleinement fonctionnelle. Les variables fermées vivent aussi longtemps qu&rsquo;elles sont nécessaires par les fonctions qui les capturent.</p>
<p>C&rsquo;était beaucoup de travail ! Dans jlox, les fermetures tombaient naturellement de notre représentation d&rsquo;environnement. Dans clox, nous avons dû ajouter beaucoup de code<span class="em">&mdash;</span>de nouvelles instructions bytecode, plus de structures de données dans le compilateur, et de nouveaux objets runtime. La VM traite vraiment les variables dans les fermetures différemment des autres variables.</p>
<p>Il y a une rationalité pour cela. En termes de complexité d&rsquo;implémentation, jlox nous a donné les fermetures &ldquo;pour gratuit&rdquo;. Mais en termes de <em>performance</em>, les fermetures de jlox sont tout sauf. En allouant <em>tous</em> les environnements sur le tas, jlox paie un prix de performance significatif pour <em>toutes</em> les variables locales, même la majorité qui ne sont jamais capturées par des fermetures.</p>
<p>Avec clox, nous avons un système plus complexe, mais qui nous permet d&rsquo;adapter l&rsquo;implémentation pour correspondre aux deux patrons d&rsquo;utilisation que nous observons pour les variables locales. Pour la plupart des variables qui ont bien une sémantique de pile, nous les allouons entièrement sur la pile ce qui est simple et rapide. Ensuite, pour les quelques variables locales où cela ne fonctionne pas, nous avons un second chemin plus lent auquel nous pouvons opter comme nécessaire.</p>
<p>Heureusement, les utilisateurs ne perçoivent pas la complexité. De leur perspective, les variables locales dans Lox sont simples et uniformes. Le <em>langage lui-même</em> est aussi simple que l&rsquo;implémentation de jlox. Mais sous le capot, clox regarde ce que l&rsquo;utilisateur fait et optimise pour ses usages spécifiques. Comme vos implémentations de langage grandissent en sophistication, vous vous trouverez à faire cela plus. Une grande fraction de l&rsquo;&ldquo;optimisation&rdquo; est à propos d&rsquo;ajouter du code pour des cas spéciaux qui détecte certains usages et fournit un chemin sur mesure, plus rapide pour le code qui correspond à ce patron.</p>
<p>Nous avons la portée lexicale pleinement fonctionnelle dans clox maintenant, ce qui est un jalon majeur. Et, maintenant que nous avons des fonctions et des variables avec des durées de vie complexes, nous avons aussi <em>beaucoup</em> d&rsquo;objets flottant dans le tas de clox, avec une toile de pointeurs les liant ensemble. L&rsquo;<a href="ramasse-miettes.html">étape suivante</a> est de comprendre comment gérer cette mémoire pour que nous puissions libérer certains de ces objets quand ils ne sont plus nécessaires.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>25&#8202;.&#8202;5</small>Défis</a></h2>
<ol>
<li>
<p>Envelopper chaque ObjFunction dans une ObjClosure introduit un niveau d&rsquo;indirection qui a un coût de performance. Ce coût n&rsquo;est pas nécessaire pour les fonctions qui ne ferment sur aucune variable, mais il laisse le runtime traiter tous les appels uniformément.</p>
<p>Changez clox pour envelopper seulement les fonctions dans des ObjClosures qui ont besoin d&rsquo;upvalues. Comment la complexité du code et la performance se comparent-elles à toujours envelopper les fonctions ? Prenez soin de benchmarker des programmes qui utilisent et n&rsquo;utilisent pas de fermetures. Comment devriez-vous pondérer l&rsquo;importance de chaque benchmark ? Si l&rsquo;un devient plus lent et l&rsquo;autre plus rapide, comment décidez-vous quel compromis faire pour choisir une stratégie d&rsquo;implémentation ?</p>
</li>
<li>
<p>Lisez la note de conception ci-dessous. J&rsquo;attendrai. Maintenant, comment pensez-vous que Lox <em>devrait</em> se comporter ? Changez l&rsquo;implémentation pour créer une nouvelle variable pour chaque itération de boucle.</p>
</li>
<li>
<p>Un <a href="http://wiki.c2.com/?ClosuresAndObjectsAreEquivalent">koan célèbre</a> nous enseigne que &ldquo;les objets sont la fermeture du pauvre&rdquo; (et vice versa). Notre VM ne supporte pas les objets encore, mais maintenant que nous avons des fermetures nous pouvons les approximer. Utilisant des fermetures, écrivez un programme Lox qui modélise des &ldquo;objets&rdquo; vecteur à deux dimensions. Il devrait :</p>
<ul>
<li>
<p>Définir une fonction &ldquo;constructeur&rdquo; pour créer un nouveau vecteur avec les coordonnées <em>x</em> et <em>y</em> données.</p>
</li>
<li>
<p>Fournir des &ldquo;méthodes&rdquo; pour accéder aux coordonnées <em>x</em> et <em>y</em> des valeurs renvoyées par ce constructeur.</p>
</li>
<li>
<p>Définir une &ldquo;méthode&rdquo; addition qui ajoute deux vecteurs et produit un troisième.</p>
</li>
</ul>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--fermer-sur-la-variable-de-boucle" id="note-de-conception--fermer-sur-la-variable-de-boucle"><small>25&#8202;.&#8202;6</small>Note de Conception : Fermer sur la Variable de Boucle</a></h2>
<p>Les fermetures capturent des variables. Quand deux fermetures capturent la même variable, elles partagent une référence au même emplacement de stockage sous-jacent. Ce fait est visible quand de nouvelles valeurs sont assignées à la variable. Évidemment, si deux fermetures capturent des variables <em>différentes</em>, il n&rsquo;y a pas de partage.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">globalOne</span>;
<span class="k">var</span> <span class="i">globalTwo</span>;

<span class="k">fun</span> <span class="i">main</span>() {
  {
    <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;one&quot;</span>;
    <span class="k">fun</span> <span class="i">one</span>() {
      <span class="k">print</span> <span class="i">a</span>;
    }
    <span class="i">globalOne</span> = <span class="i">one</span>;
  }

  {
    <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;two&quot;</span>;
    <span class="k">fun</span> <span class="i">two</span>() {
      <span class="k">print</span> <span class="i">a</span>;
    }
    <span class="i">globalTwo</span> = <span class="i">two</span>;
  }
}

<span class="i">main</span>();
<span class="i">globalOne</span>();
<span class="i">globalTwo</span>();
</pre></div>
<p>Ceci affiche &ldquo;one&rdquo; puis &ldquo;two&rdquo;. Dans cet exemple, il est assez clair que les deux variables <code>a</code> sont différentes. Mais ce n&rsquo;est pas toujours si évident. Considérez :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">globalOne</span>;
<span class="k">var</span> <span class="i">globalTwo</span>;

<span class="k">fun</span> <span class="i">main</span>() {
  <span class="k">for</span> (<span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>; <span class="i">a</span> &lt;= <span class="n">2</span>; <span class="i">a</span> = <span class="i">a</span> + <span class="n">1</span>) {
    <span class="k">fun</span> <span class="i">closure</span>() {
      <span class="k">print</span> <span class="i">a</span>;
    }
    <span class="k">if</span> (<span class="i">globalOne</span> == <span class="k">nil</span>) {
      <span class="i">globalOne</span> = <span class="i">closure</span>;
    } <span class="k">else</span> {
      <span class="i">globalTwo</span> = <span class="i">closure</span>;
    }
  }
}

<span class="i">main</span>();
<span class="i">globalOne</span>();
<span class="i">globalTwo</span>();
</pre></div>
<p>Le code est alambiqué parce que Lox n&rsquo;a pas de types collection. La partie importante est que la fonction <code>main()</code> fait deux itérations d&rsquo;une boucle <code>for</code>. Chaque fois à travers la boucle, elle crée une fermeture qui capture la variable de boucle. Elle stocke la première fermeture dans <code>globalOne</code> et la seconde dans <code>globalTwo</code>.</p>
<p>Il y a définitivement deux fermetures différentes. Fermet-elles sur deux variables différentes ? Y a-t-il seulement un <code>a</code> pour la durée entière de la boucle, ou chaque itération obtient-elle sa propre variable <code>a</code> distincte ?</p>
<p>Le script ici est étrange et artificiel, mais cela apparaît dans le vrai code dans des langages qui ne sont pas aussi minimaux que clox. Voici un exemple JavaScript :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">closures</span> = [];
<span class="k">for</span> (<span class="k">var</span> <span class="i">i</span> = <span class="n">1</span>; <span class="i">i</span> &lt;= <span class="n">2</span>; <span class="i">i</span>++) {
    <span class="i">closures</span>.<span class="i">push</span>(<span class="k">function</span> () {
        <span class="i">console</span>.<span class="i">log</span>(<span class="i">i</span>);
    });
}

<span class="i">closures</span>[<span class="n">0</span>]();
<span class="i">closures</span>[<span class="n">1</span>]();
</pre></div>
<p>Est-ce que cela affiche &ldquo;1&rdquo; puis &ldquo;2&rdquo;, ou est-ce que cela affiche <span name="three">&ldquo;3&rdquo;</span> deux fois ? Vous pouvez être surpris d&rsquo;entendre que cela affiche &ldquo;3&rdquo; deux fois. Dans ce programme JavaScript, il y a seulement une seule variable <code>i</code> dont la durée de vie inclut toutes les itérations de la boucle, incluant la sortie finale.</p>
<aside name="three">
<p>Vous vous demandez comment <em>trois</em> entre en scène ? Après la seconde itération, <code>i++</code> est exécuté, ce qui incrémente <code>i</code> à trois. C&rsquo;est ce qui cause <code>i &lt;= 2</code> à évaluer à faux et terminer la boucle. Si <code>i</code> n&rsquo;atteignait jamais trois, la boucle courrait pour toujours.</p>
</aside>
<p>Si vous êtes familier avec JavaScript, vous savez probablement que les variables déclarées utilisant <code>var</code> sont implicitement <em>hissées</em> à la fonction environnante ou portée de niveau supérieur. C&rsquo;est comme si vous aviez réellement écrit ceci :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">closures</span> = [];
<span class="k">var</span> <span class="i">i</span>;
<span class="k">for</span> (<span class="i">i</span> = <span class="n">1</span>; <span class="i">i</span> &lt;= <span class="n">2</span>; <span class="i">i</span>++) {
    <span class="i">closures</span>.<span class="i">push</span>(<span class="k">function</span> () {
        <span class="i">console</span>.<span class="i">log</span>(<span class="i">i</span>);
    });
}

<span class="i">closures</span>[<span class="n">0</span>]();
<span class="i">closures</span>[<span class="n">1</span>]();
</pre></div>
<p>À ce point, il est plus clair qu&rsquo;il n&rsquo;y a qu&rsquo;un seul <code>i</code>. Maintenant considérez si vous changez le programme pour utiliser le mot-clé <code>let</code> plus récent :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">closures</span> = [];
<span class="k">for</span> (<span class="k">let</span> <span class="i">i</span> = <span class="n">1</span>; <span class="i">i</span> &lt;= <span class="n">2</span>; <span class="i">i</span>++) {
    <span class="i">closures</span>.<span class="i">push</span>(<span class="k">function</span> () {
        <span class="i">console</span>.<span class="i">log</span>(<span class="i">i</span>);
    });
}

<span class="i">closures</span>[<span class="n">0</span>]();
<span class="i">closures</span>[<span class="n">1</span>]();
</pre></div>
<p>Est-ce que ce nouveau programme se comporte de même ? Non. Dans ce cas, il affiche &ldquo;1&rdquo; puis &ldquo;2&rdquo;. Chaque fermeture obtient sa propre <code>i</code>. C&rsquo;est sorte d&rsquo;étrange quand vous y pensez. Le clause d&rsquo;incrément est <code>i++</code>. Cela ressemble beaucoup comme si c&rsquo;était assigner à et muter une variable existante, pas en créer une nouvelle.</p>
<p>Essayons quelques autres langages. Voici Python :</p>
<div class="codehilite"><pre><span class="i">closures</span> = []
<span class="k">for</span> <span class="i">i</span> <span class="k">in</span> <span class="k">range</span>(<span class="n">1</span>, <span class="n">3</span>):
  <span class="i">closures</span>.<span class="i">append</span>(<span class="k">lambda</span>: <span class="k">print</span>(<span class="i">i</span>))

<span class="i">closures</span>[<span class="n">0</span>]()
<span class="i">closures</span>[<span class="n">1</span>]()
</pre></div>
<p>Python n&rsquo;a pas vraiment de portée de bloc. Les variables sont implicitement déclarées et sont automatiquement portées à la fonction environnante. Sorte de comme le hissage dans JS, maintenant que j&rsquo;y pense. Donc les deux fermetures capturent la même variable. Contrairement au C, cependant, nous ne sortons pas de la boucle en incrémentant <code>i</code> <em>passé</em> la dernière valeur, donc ceci affiche &ldquo;2&rdquo; deux fois.</p>
<p>Qu&rsquo;en est-il de Ruby ? Ruby a deux façons typiques d&rsquo;itérer numériquement. Voici le style impératif classique :</p>
<div class="codehilite"><pre><span class="i">closures</span> = []
<span class="k">for</span> <span class="i">i</span> <span class="k">in</span> <span class="n">1</span>..<span class="n">2</span> <span class="k">do</span>
  <span class="i">closures</span> &lt;&lt; <span class="k">lambda</span> { <span class="i">puts</span> <span class="i">i</span> }
<span class="k">end</span>

<span class="i">closures</span>[<span class="n">0</span>].<span class="i">call</span>
<span class="i">closures</span>[<span class="n">1</span>].<span class="i">call</span>
</pre></div>
<p>Ceci, comme Python, affiche &ldquo;2&rdquo; deux fois. Mais le style Ruby plus idiomatique utilise une méthode d&rsquo;ordre supérieur <code>each()</code> sur des objets plage :</p>
<div class="codehilite"><pre><span class="i">closures</span> = []
(<span class="n">1</span>..<span class="n">2</span>).<span class="i">each</span> <span class="k">do</span> |<span class="i">i</span>|
  <span class="i">closures</span> &lt;&lt; <span class="k">lambda</span> { <span class="i">puts</span> <span class="i">i</span> }
<span class="k">end</span>

<span class="i">closures</span>[<span class="n">0</span>].<span class="i">call</span>
<span class="i">closures</span>[<span class="n">1</span>].<span class="i">call</span>
</pre></div>
<p>Si vous n&rsquo;êtes pas familier avec Ruby, la partie <code>do |i| ... end</code> est basiquement une fermeture qui est créée et passée à la méthode <code>each()</code>. Le <code>|i|</code> est la signature de paramètre pour la fermeture. La méthode <code>each()</code> invoque cette fermeture deux fois, passant 1 pour <code>i</code> la première fois et 2 la seconde fois.</p>
<p>Dans ce cas, la &ldquo;variable de boucle&rdquo; est réellement un paramètre de fonction. Et, puisque chaque itération de la boucle est une invocation séparée de la fonction, ce sont définitivement des variables séparées pour chaque appel. Donc ceci affiche &ldquo;1&rdquo; puis &ldquo;2&rdquo;.</p>
<p>Si un langage a une structure de boucle basée-itérateur de plus haut niveau comme <code>foreach</code> en C#, le &ldquo;enhanced for&rdquo; de Java, <code>for-of</code> en JavaScript, <code>for-in</code> en Dart, etc., alors je pense qu&rsquo;il est naturel pour le lecteur d&rsquo;avoir chaque itération créer une nouvelle variable. Le code <em>ressemble</em> à une nouvelle variable parce que l&rsquo;en-tête de boucle ressemble à une déclaration de variable. Et il n&rsquo;y a pas d&rsquo;expression d&rsquo;incrément qui ressemble à ce qu&rsquo;elle mute cette variable pour avancer à l&rsquo;étape suivante.</p>
<p>Si vous creusez autour de StackOverflow et d&rsquo;autres endroits, vous trouvez des preuves que c&rsquo;est ce que les utilisateurs attendent, parce qu&rsquo;ils sont très surpris quand ils ne l&rsquo;obtiennent <em>pas</em>. En particulier, C# à l&rsquo;origine ne créait <em>pas</em> une nouvelle variable de boucle pour chaque itération d&rsquo;une boucle <code>foreach</code>. C&rsquo;était une source si fréquente de confusion utilisateur qu&rsquo;ils ont pris l&rsquo;étape très rare de livrer un changement cassant au langage. Dans C# 5, chaque itération crée une variable fraîche.</p>
<p>Les vieilles boucles <code>for</code> style C sont plus dures. La clause d&rsquo;incrément ressemble vraiment bien à une mutation. Cela implique qu&rsquo;il y a une seule variable qui est mise à jour à chaque étape. Mais il est presque jamais <em>utile</em> pour chaque itération de partager une variable de boucle. Le seul moment où vous pouvez même détecter cela est quand des fermetures la capturent. Et c&rsquo;est rarement utile d&rsquo;avoir une fermeture qui référence une variable dont la valeur est n&rsquo;importe quelle valeur qui vous a causé de sortir de la boucle.</p>
<p>La réponse pragmatiquement utile est probablement de faire ce que JavaScript fait avec <code>let</code> dans les boucles <code>for</code>. Faites-le ressembler à de la mutation mais créez réellement une nouvelle variable chaque fois, parce que c&rsquo;est ce que les utilisateurs veulent. C&rsquo;est un peu bizarre quand vous y pensez, cependant.</p>
</div>

<footer>
<a href="ramasse-miettes.html" class="next">
  Next Chapter: &ldquo;Ramasse-miettes&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
