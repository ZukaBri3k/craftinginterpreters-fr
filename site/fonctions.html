<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Fonctions &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Fonctions<small>10</small></a></h3>

<ul>
    <li><a href="#appels-de-fonctions"><small>10.1</small> Appels de Fonctions</a></li>
    <li><a href="#fonctions-natives"><small>10.2</small> Fonctions Natives</a></li>
    <li><a href="#déclarations-de-fonction"><small>10.3</small> Déclarations de Fonction</a></li>
    <li><a href="#objets-fonction"><small>10.4</small> Objets Fonction</a></li>
    <li><a href="#instructions-return"><small>10.5</small> Instructions Return</a></li>
    <li><a href="#fonctions-locales-et-fermetures"><small>10.6</small> Fonctions Locales et Fermetures</a></li>
    <li><a href="#défis"><small>10.7</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="contrôle-de-flux.html" title="Contrôle de flux" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="résolution-et-liaison.html" title="Résolution et liaison" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="contrôle-de-flux.html" title="Contrôle de flux" class="prev">←</a>
<a href="résolution-et-liaison.html" title="Résolution et liaison" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Fonctions<small>10</small></a></h3>

<ul>
    <li><a href="#appels-de-fonctions"><small>10.1</small> Appels de Fonctions</a></li>
    <li><a href="#fonctions-natives"><small>10.2</small> Fonctions Natives</a></li>
    <li><a href="#déclarations-de-fonction"><small>10.3</small> Déclarations de Fonction</a></li>
    <li><a href="#objets-fonction"><small>10.4</small> Objets Fonction</a></li>
    <li><a href="#instructions-return"><small>10.5</small> Instructions Return</a></li>
    <li><a href="#fonctions-locales-et-fermetures"><small>10.6</small> Fonctions Locales et Fermetures</a></li>
    <li><a href="#défis"><small>10.7</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="contrôle-de-flux.html" title="Contrôle de flux" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="résolution-et-liaison.html" title="Résolution et liaison" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">10</div>
  <h1>Fonctions</h1>

<blockquote>
<p>Et c&rsquo;est aussi ainsi que l&rsquo;esprit humain fonctionne<span class="em">&mdash;</span>par la composition de vieilles
idées en de nouvelles structures qui deviennent de nouvelles idées qui peuvent elles-mêmes être utilisées dans
des composés, et en rond et encore en rond sans fin, grandissant toujours plus loin de
l&rsquo;imagerie terrestre de base qui est le sol de chaque langage.</p>
<p><cite>Douglas R. Hofstadter, <em>Je suis une boucle étrange</em></cite></p>
</blockquote>
<p>Ce chapitre marque l&rsquo;aboutissement de beaucoup de travail difficile. Les chapitres précédents ajoutent des fonctionnalités utiles de leur propre droit, mais chacun fournit aussi une pièce d&rsquo;un <span name="lambda">puzzle</span>. Nous prendrons ces pièces<span class="em">&mdash;</span>expressions, instructions, variables, contrôle de flux, et portée lexicale<span class="em">&mdash;</span>ajouterons une paire de plus, et assemblerons tout cela pour le support de de vraies fonctions définies par l&rsquo;utilisateur et des appels de fonctions.</p>
<aside name="lambda"><img src="image/functions/lambda.png" alt="Un puzzle lambda." />
</aside>
<h2><a href="#appels-de-fonctions" id="appels-de-fonctions"><small>10&#8202;.&#8202;1</small>Appels de Fonctions</a></h2>
<p>Vous êtes certainement familier avec la syntaxe d&rsquo;appel de fonction de style C, mais la grammaire est plus subtile que vous pouvez le réaliser. Les appels sont typiquement vers des fonctions nommées comme :</p>
<div class="codehilite"><pre><span class="i">average</span>(<span class="n">1</span>, <span class="n">2</span>);
</pre></div>
<p>Mais le <span name="pascal">nom</span> de la fonction appelée ne fait pas en fait partie de la syntaxe d&rsquo;appel. La chose appelée<span class="em">&mdash;</span>l&rsquo;<strong>appelé</strong><span class="em">&mdash;</span>peut être n&rsquo;importe quelle expression qui s&rsquo;évalue en une fonction. (Bon, elle doit être une expression à <em>haute précédence</em>, mais les parenthèses s&rsquo;occupent de ça.) Par exemple :</p>
<aside name="pascal">
<p>Le nom <em>fait</em> partie de la syntaxe d&rsquo;appel en Pascal. Vous ne pouvez appeler que des fonctions nommées ou des fonctions stockées directement dans des variables.</p>
</aside>
<div class="codehilite"><pre><span class="i">getCallback</span>()();
</pre></div>
<p>Il y a deux expressions d&rsquo;appel ici. La première paire de parenthèses a <code>getCallback</code> comme son appelé. Mais le second appel a l&rsquo;expression entière <code>getCallback()</code> comme son appelé. Ce sont les parenthèses suivant une expression qui indiquent un appel de fonction. Vous pouvez penser à un appel comme une sorte d&rsquo;opérateur postfixe qui commence par <code>(</code>.</p>
<p>Cet &ldquo;opérateur&rdquo; a une plus haute précédence que n&rsquo;importe quel autre opérateur, même les unaires. Donc nous le glissons dans la grammaire en faisant remonter la règle <code>unary</code> vers une nouvelle règle <code>call</code>.</p>
<p><span name="curry"></span></p>
<div class="codehilite"><pre><span class="i">unary</span>          → ( <span class="s">&quot;!&quot;</span> | <span class="s">&quot;-&quot;</span> ) <span class="i">unary</span> | <span class="i">call</span> ;
<span class="i">call</span>           → <span class="i">primary</span> ( <span class="s">&quot;(&quot;</span> <span class="i">arguments</span>? <span class="s">&quot;)&quot;</span> )* ;
</pre></div>
<p>Cette règle matche une expression primaire suivie par zéro ou plusieurs appels de fonctions. S&rsquo;il n&rsquo;y a pas de parenthèses, cela parse une expression primaire nue. Sinon, chaque appel est reconnu par une paire de parenthèses avec une liste optionnelle d&rsquo;arguments à l&rsquo;intérieur. La grammaire de la liste d&rsquo;arguments est :</p>
<aside name="curry">
<p>La règle utilise <code>*</code> pour permettre de matcher une série d&rsquo;appels comme <code>fn(1)(2)(3)</code>. Le code comme ça n&rsquo;est pas courant dans les langages de style C, mais il l&rsquo;est dans la famille des langages dérivés de ML. Là, la façon normale de définir une fonction qui prend plusieurs arguments est comme une série de fonctions imbriquées. Chaque fonction prend un argument et renvoie une nouvelle fonction. Cette fonction consomme l&rsquo;argument suivant, renvoie encore une autre fonction, et ainsi de suite. Finalement, une fois tous les arguments consommés, la dernière fonction complète l&rsquo;opération.</p>
<p>Ce style, appelé <strong>currying</strong> (curryfication), d&rsquo;après Haskell Curry (le même gars dont le prénom orne cet <em>autre</em> langage fonctionnel bien connu), est cuit directement dans la syntaxe du langage donc ce n&rsquo;est pas aussi bizarre à regarder que ce le serait ici.</p>
</aside>
<div class="codehilite"><pre><span class="i">arguments</span>      → <span class="i">expression</span> ( <span class="s">&quot;,&quot;</span> <span class="i">expression</span> )* ;
</pre></div>
<p>Cette règle exige au moins une expression d&rsquo;argument, suivie par zéro ou plusieurs autres expressions, chacune précédée par une virgule. Pour gérer les appels à zéro argument, la règle <code>call</code> elle-même considère la production <code>arguments</code> entière comme optionnelle.</p>
<p>J&rsquo;admets, cela semble plus grammaticalement maladroit que vous ne l&rsquo;attendriez pour le motif incroyablement courant &ldquo;zéro ou plusieurs choses séparées par des virgules&rdquo;. Il y a des métasyntaxes sophistiquées qui gèrent cela mieux, mais dans notre BNF et dans beaucoup de spécifications de langages que j&rsquo;ai vues, c&rsquo;est aussi encombrant.</p>
<p>Là-bas dans notre générateur d&rsquo;arbre syntaxique, nous ajoutons un <span name="call-ast">nouveau nœud</span>.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Binary   : Expr left, Token operator, Expr right&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Call     : Expr callee, Token paren, List&lt;Expr&gt; arguments&quot;</span>,
</pre><pre class="insert-after">      &quot;Grouping : Expr expression&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="call-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#call-expression">Annexe II</a>.</p>
</aside>
<p>Il stocke l&rsquo;expression de l&rsquo;appelé et une liste d&rsquo;expressions pour les arguments. Il stocke aussi le token pour la parenthèse fermante. Nous utiliserons l&rsquo;emplacement de ce token quand nous rapporterons une erreur d&rsquo;exécution causée par un appel de fonction.</p>
<p>Ouvrez le parseur. Là où <code>unary()</code> avait l&rsquo;habitude de sauter directement à <code>primary()</code>, changez-le pour appeler, eh bien, <code>call()</code>.</p>
<div class="codehilite"><pre class="insert-before">      return new Expr.Unary(operator, right);
    }

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>unary</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="k">return</span> <span class="i">call</span>();
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>unary</em>(), replace 1 line</div>

<p>Sa définition est :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>unary</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">call</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">primary</span>();

    <span class="k">while</span> (<span class="k">true</span>) {<span name="while-true"> </span>
      <span class="k">if</span> (<span class="i">match</span>(<span class="i">LEFT_PAREN</span>)) {
        <span class="i">expr</span> = <span class="i">finishCall</span>(<span class="i">expr</span>);
      } <span class="k">else</span> {
        <span class="k">break</span>;
      }
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>unary</em>()</div>

<p>Le code ici ne s&rsquo;aligne pas tout à fait avec les règles de grammaire. J&rsquo;ai déplacé quelques choses pour rendre le code plus propre<span class="em">&mdash;</span>l&rsquo;un des luxes que nous avons avec un parseur écrit à la main. Mais c&rsquo;est grossièrement similaire à comment nous parsons les opérateurs infixes. D&rsquo;abord, nous parsons une expression primaire, l&rsquo;&ldquo;opérande gauche&rdquo; de l&rsquo;appel. Ensuite, chaque fois que nous voyons une <code>(</code>, nous appelons <code>finishCall()</code> pour parser l&rsquo;expression d&rsquo;appel en utilisant l&rsquo;expression analysée précédemment comme l&rsquo;appelé. L&rsquo;expression renvoyée devient la nouvelle <code>expr</code> et nous bouclons pour voir si le résultat est lui-même appelé.</p>
<aside name="while-true">
<p>Ce code serait plus simple comme <code>while (match(LEFT_PAREN))</code> au lieu du stupide <code>while (true)</code> et <code>break</code>. Ne vous inquiétez pas, cela aura du sens quand nous étendrons le parseur plus tard pour gérer les propriétés sur les objets.</p>
</aside>
<p>Le code pour parser la liste d&rsquo;arguments est dans cet assistant :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>unary</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">finishCall</span>(<span class="t">Expr</span> <span class="i">callee</span>) {
    <span class="t">List</span>&lt;<span class="t">Expr</span>&gt; <span class="i">arguments</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">RIGHT_PAREN</span>)) {
      <span class="k">do</span> {
        <span class="i">arguments</span>.<span class="i">add</span>(<span class="i">expression</span>());
      } <span class="k">while</span> (<span class="i">match</span>(<span class="i">COMMA</span>));
    }

    <span class="t">Token</span> <span class="i">paren</span> = <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>,
                          <span class="s">&quot;Expect &#39;)&#39; after arguments.&quot;</span>);

    <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Call</span>(<span class="i">callee</span>, <span class="i">paren</span>, <span class="i">arguments</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>unary</em>()</div>

<p>C&rsquo;est plus ou moins la règle de grammaire <code>arguments</code> traduite en code, sauf que nous gérons aussi le cas zéro-argument. Nous vérifions ce cas d&rsquo;abord en voyant si le prochain token est <code>)</code>. Si c&rsquo;est le cas, nous n&rsquo;essayons de parser aucun argument.</p>
<p>Sinon, nous parsons une expression, puis cherchons une virgule indiquant qu&rsquo;il y a un autre argument après cela. Nous continuons à faire cela tant que nous trouvons des virgules après chaque expression. Quand nous ne trouvons pas de virgule, alors la liste d&rsquo;arguments doit être finie et nous consommons la parenthèse fermante attendue. Finalement, nous enveloppons l&rsquo;appelé et ces arguments dans un nœud AST d&rsquo;appel.</p>
<h3><a href="#comptes-darguments-maximum" id="comptes-darguments-maximum"><small>10&#8202;.&#8202;1&#8202;.&#8202;1</small>Comptes d&rsquo;arguments maximum</a></h3>
<p>Pour l&rsquo;instant, la boucle où nous parsons les arguments n&rsquo;a pas de borne. Si vous voulez appeler une fonction et lui passer un million d&rsquo;arguments, le parseur n&rsquo;aurait aucun problème avec ça. Voulons-nous limiter cela ?</p>
<p>D&rsquo;autres langages ont diverses approches. Le standard C dit qu&rsquo;une implémentation conforme doit supporter <em>au moins</em> 127 arguments à une fonction, mais ne dit pas qu&rsquo;il y a une limite supérieure. La spécification Java dit qu&rsquo;une méthode ne peut accepter <em>pas plus de</em> <span name="254">255</span> arguments.</p>
<aside name="254">
<p>La limite est 25<em>4</em> arguments si la méthode est une méthode d&rsquo;instance. C&rsquo;est parce que <code>this</code><span class="em">&mdash;</span>le receveur de la méthode<span class="em">&mdash;</span>fonctionne comme un argument qui est implicitement passé à la méthode, donc il réclame l&rsquo;un des emplacements.</p>
</aside>
<p>Notre interpréteur Java pour Lox n&rsquo;a pas vraiment besoin d&rsquo;une limite, mais avoir un nombre maximum d&rsquo;arguments simplifiera notre interpréteur bytecode dans la [Partie III][]. Nous voulons que nos deux interpréteurs soient compatibles l&rsquo;un avec l&rsquo;autre, même dans des cas limites bizarres comme celui-ci, donc nous ajouterons la même limite à jlox.</p>
<div class="codehilite"><pre class="insert-before">      do {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>finishCall</em>()</div>
<pre class="insert">        <span class="k">if</span> (<span class="i">arguments</span>.<span class="i">size</span>() &gt;= <span class="n">255</span>) {
          <span class="i">error</span>(<span class="i">peek</span>(), <span class="s">&quot;Can&#39;t have more than 255 arguments.&quot;</span>);
        }
</pre><pre class="insert-after">        arguments.add(expression());
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>finishCall</em>()</div>

<p>Notez que le code ici <em>rapporte</em> une erreur s&rsquo;il rencontre trop d&rsquo;arguments, mais il ne <em>lance</em> pas l&rsquo;erreur. Lancer est comment nous passons en mode panique qui est ce que nous voulons si le parseur est dans un état confus et ne sait plus où il est dans la grammaire. Mais ici, le parseur est encore dans un état parfaitement valide<span class="em">&mdash;</span>il a juste trouvé trop d&rsquo;arguments. Donc il rapporte l&rsquo;erreur et continue son bonhomme de chemin.</p>
<h3><a href="#interpréter-des-appels-de-fonction" id="interpréter-des-appels-de-fonction"><small>10&#8202;.&#8202;1&#8202;.&#8202;2</small>Interpréter des appels de fonction</a></h3>
<p>Nous n&rsquo;avons aucune fonction que nous pouvons appeler, donc cela semble bizarre de commencer à implémenter les appels d&rsquo;abord, mais nous nous inquiéterons de cela quand nous y arriverons. D&rsquo;abord, notre interpréteur a besoin d&rsquo;un nouvel import.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em></div>
<pre class="insert"><span class="k">import</span> <span class="i">java.util.ArrayList</span>;
</pre><pre class="insert-after">import java.util.List;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em></div>

<p>Comme toujours, l&rsquo;interprétation commence avec une nouvelle méthode visit pour notre nœud d&rsquo;expression d&rsquo;appel.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitBinaryExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitCallExpr</span>(<span class="t">Expr</span>.<span class="t">Call</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">callee</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">callee</span>);

    <span class="t">List</span>&lt;<span class="t">Object</span>&gt; <span class="i">arguments</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();
    <span class="k">for</span> (<span class="t">Expr</span> <span class="i">argument</span> : <span class="i">expr</span>.<span class="i">arguments</span>) {<span name="in-order"> </span>
      <span class="i">arguments</span>.<span class="i">add</span>(<span class="i">evaluate</span>(<span class="i">argument</span>));
    }

    <span class="t">LoxCallable</span> <span class="i">function</span> = (<span class="t">LoxCallable</span>)<span class="i">callee</span>;
    <span class="k">return</span> <span class="i">function</span>.<span class="i">call</span>(<span class="k">this</span>, <span class="i">arguments</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitBinaryExpr</em>()</div>

<p>D&rsquo;abord, nous évaluons l&rsquo;expression pour l&rsquo;appelé. Typiquement, cette expression est juste un identifieur qui cherche la fonction par son nom, mais ça pourrait être n&rsquo;importe quoi. Ensuite nous évaluons chacune des expressions d&rsquo;argument dans l&rsquo;ordre et stockons les valeurs résultantes dans une liste.</p>
<aside name="in-order">
<p>Ceci est un autre de ces choix sémantiques subtils. Puisque les expressions d&rsquo;argument peuvent avoir des effets de bord, l&rsquo;ordre dans lequel elles sont évaluées pourrait être visible par l&rsquo;utilisateur. Même ainsi, certains langages comme Scheme et C ne spécifient pas un ordre. Cela donne aux compilateurs la liberté de les réordonner pour l&rsquo;efficacité, mais signifie que les utilisateurs peuvent être désagréablement surpris si les arguments ne sont pas évalués dans l&rsquo;ordre qu&rsquo;ils attendent.</p>
</aside>
<p>Une fois que nous avons l&rsquo;appelé et les arguments prêts, tout ce qui reste est d&rsquo;effectuer l&rsquo;appel. Nous faisons cela en castant l&rsquo;appelé vers un <span name="callable">LoxCallable</span> et ensuite en invoquant une méthode <code>call()</code> dessus. La représentation Java de n&rsquo;importe quel objet Lox qui peut être appelé comme une fonction implémentera cette interface. Cela inclut les fonctions définies par l&rsquo;utilisateur, naturellement, mais aussi les objets classe puisque les classes sont &ldquo;appelées&rdquo; pour construire de nouvelles instances. Nous l&rsquo;utiliserons aussi pour un autre but bientôt.</p>
<aside name="callable">
<p>J&rsquo;ai collé &ldquo;Lox&rdquo; devant le nom pour le distinguer de l&rsquo;interface Callable propre à la bibliothèque standard Java. Hélas, tous les bons noms simples sont déjà pris.</p>
</aside>
<p>Il n&rsquo;y a pas grand-chose dans cette nouvelle interface.</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxCallable.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.List</span>;

<span class="k">interface</span> <span class="t">LoxCallable</span> {
  <span class="t">Object</span> <span class="i">call</span>(<span class="t">Interpreter</span> <span class="i">interpreter</span>, <span class="t">List</span>&lt;<span class="t">Object</span>&gt; <span class="i">arguments</span>);
}
</pre></div>
<div class="source-file-narrow"><em>lox/LoxCallable.java</em>, create new file</div>

<p>Nous passons l&rsquo;interpréteur au cas où la classe implémentant <code>call()</code> en a besoin. Nous lui donnons aussi la liste des valeurs d&rsquo;argument évaluées. Le travail de l&rsquo;implémenteur est alors de renvoyer la valeur que l&rsquo;expression d&rsquo;appel produit.</p>
<h3><a href="#erreurs-de-type-dappel" id="erreurs-de-type-dappel"><small>10&#8202;.&#8202;1&#8202;.&#8202;3</small>Erreurs de type d&rsquo;appel</a></h3>
<p>Avant que nous arrivions à implémenter LoxCallable, nous avons besoin de rendre la méthode visit un peu plus robuste. Elle ignore actuellement une paire de modes d&rsquo;échec dont nous ne pouvons pas prétendre qu&rsquo;ils ne se produiront pas. D&rsquo;abord, qu&rsquo;arrive-t-il si l&rsquo;appelé n&rsquo;est pas réellement quelque chose que vous pouvez appeler ? Et si vous essayez de faire ceci :</p>
<div class="codehilite"><pre><span class="s">&quot;totalement pas une fonction&quot;</span>();
</pre></div>
<p>Les chaînes ne sont pas appelables dans Lox. La représentation à l&rsquo;exécution d&rsquo;une chaîne Lox est une chaîne Java, donc quand nous castons cela vers LoxCallable, la JVM lancera une ClassCastException. Nous ne voulons pas que notre interpréteur vomisse une méchante trace de pile Java et meure. Au lieu de cela, nous avons besoin de vérifier le type nous-mêmes d&rsquo;abord.</p>
<div class="codehilite"><pre class="insert-before">    }

</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitCallExpr</em>()</div>
<pre class="insert">    <span class="k">if</span> (!(<span class="i">callee</span> <span class="k">instanceof</span> <span class="t">LoxCallable</span>)) {
      <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">expr</span>.<span class="i">paren</span>,
          <span class="s">&quot;Can only call functions and classes.&quot;</span>);
    }

</pre><pre class="insert-after">    LoxCallable function = (LoxCallable)callee;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitCallExpr</em>()</div>

<p>Nous lançons toujours une exception, mais maintenant nous lançons notre propre type d&rsquo;exception, un que l&rsquo;interpréteur sait attraper et rapporter gracieusement.</p>
<h3><a href="#vérifier-larité" id="vérifier-larité"><small>10&#8202;.&#8202;1&#8202;.&#8202;4</small>Vérifier l&rsquo;arité</a></h3>
<p>L&rsquo;autre problème se rapporte à l&rsquo;<strong>arité</strong> de la fonction. Arité est le terme fantaisie pour le nombre d&rsquo;arguments qu&rsquo;une fonction ou opération attend. Les opérateurs unaires ont une arité de un, les opérateurs binaires deux, etc. Avec les fonctions, l&rsquo;arité est déterminée par le nombre de paramètres qu&rsquo;elle déclare.</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">add</span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>) {
  <span class="k">print</span> <span class="i">a</span> + <span class="i">b</span> + <span class="i">c</span>;
}
</pre></div>
<p>Cette fonction définit trois paramètres, <code>a</code>, <code>b</code>, et <code>c</code>, donc son arité est trois et elle attend trois arguments. Donc et si vous essayez de l&rsquo;appeler comme ceci :</p>
<div class="codehilite"><pre><span class="i">add</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="n">3</span>, <span class="n">4</span>); <span class="c">// Trop.</span>
<span class="i">add</span>(<span class="n">1</span>, <span class="n">2</span>);       <span class="c">// Trop peu.</span>
</pre></div>
<p>Différents langages prennent différentes approches à ce problème. Bien sûr, la plupart des langages typés statiquement vérifient cela au temps de compilation et refusent de compiler le code si le compte d&rsquo;arguments ne correspond pas à l&rsquo;arité de la fonction. JavaScript rejette tous les arguments supplémentaires que vous passez. Si vous n&rsquo;en passez pas assez, il remplit les paramètres manquants avec la valeur magique <code>undefined</code> sorte-de-comme-null-mais-pas-vraiment. Python est plus strict. Il lève une erreur d&rsquo;exécution si la liste d&rsquo;arguments est trop courte ou trop longue.</p>
<p>Je pense que cette dernière est une meilleure approche. Passer le mauvais nombre d&rsquo;arguments est presque toujours un bug, et c&rsquo;est une erreur que je fais en pratique. Étant donné cela, le plus tôt l&rsquo;implémentation atire mon attention dessus, le mieux. Donc pour Lox, nous prendrons l&rsquo;approche de Python. Avant d&rsquo;invoquer l&rsquo;appelable, nous vérifions pour voir si la longueur de la liste d&rsquo;arguments correspond à l&rsquo;arité de l&rsquo;appelable.</p>
<div class="codehilite"><pre class="insert-before">    LoxCallable function = (LoxCallable)callee;
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitCallExpr</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">arguments</span>.<span class="i">size</span>() != <span class="i">function</span>.<span class="i">arity</span>()) {
      <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">expr</span>.<span class="i">paren</span>, <span class="s">&quot;Expected &quot;</span> +
          <span class="i">function</span>.<span class="i">arity</span>() + <span class="s">&quot; arguments but got &quot;</span> +
          <span class="i">arguments</span>.<span class="i">size</span>() + <span class="s">&quot;.&quot;</span>);
    }

</pre><pre class="insert-after">    return function.call(this, arguments);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitCallExpr</em>()</div>

<p>Cela exige une nouvelle méthode sur l&rsquo;interface LoxCallable pour lui demander son arité.</p>
<div class="codehilite"><pre class="insert-before">interface LoxCallable {
</pre><div class="source-file"><em>lox/LoxCallable.java</em><br>
in interface <em>LoxCallable</em></div>
<pre class="insert">  <span class="t">int</span> <span class="i">arity</span>();
</pre><pre class="insert-after">  Object call(Interpreter interpreter, List&lt;Object&gt; arguments);
</pre></div>
<div class="source-file-narrow"><em>lox/LoxCallable.java</em>, in interface <em>LoxCallable</em></div>

<p>Nous <em>pourrions</em> pousser la vérification d&rsquo;arité dans l&rsquo;implémentation concrète de <code>call()</code>. Mais, puisque nous aurons plusieurs classes implémentant LoxCallable, cela finirait avec une validation redondante étalée à travers quelques classes. Le hisser dans la méthode visit nous laisse le faire à un seul endroit.</p>
<h2><a href="#fonctions-natives" id="fonctions-natives"><small>10&#8202;.&#8202;2</small>Fonctions Natives</a></h2>
<p>Nous pouvons théoriquement appeler des fonctions, mais nous n&rsquo;avons aucune fonction à appeler encore. Avant que nous arrivions aux fonctions définies par l&rsquo;utilisateur, maintenant est un bon moment pour introduire une facette vitale mais souvent négligée des implémentations de langage<span class="em">&mdash;</span>les <span name="native"><strong>fonctions natives</strong></span>. Ce sont des fonctions que l&rsquo;interpréteur expose au code utilisateur mais qui sont implémentées dans le langage hôte (dans notre cas Java), pas le langage étant implémenté (Lox).</p>
<p>Parfois celles-ci sont appelées <strong>primitives</strong>, <strong>fonctions externes</strong>, ou <strong>foreign functions</strong> (fonctions étrangères). Puisque ces fonctions peuvent être appelées pendant que le programme de l&rsquo;utilisateur tourne, elles font partie de l&rsquo;exécution de l&rsquo;implémentation. Beaucoup de livres de langages de programmation glissent sur celles-ci parce qu&rsquo;elles ne sont pas conceptuellement intéressantes. C&rsquo;est surtout du gros œuvre.</p>
<aside name="native">
<p>Curieusement, deux noms pour ces fonctions<span class="em">&mdash;</span>&ldquo;native&rdquo; et &ldquo;foreign&rdquo;<span class="em">&mdash;</span>sont des antonymes. Peut-être que cela dépend de la perspective de la personne choisissant le terme. Si vous pensez à vous-même comme &ldquo;vivant&rdquo; à l&rsquo;intérieur de l&rsquo;implémentation de l&rsquo;exécution (dans notre cas, Java) alors les fonctions écrites là-dedans sont &ldquo;natives&rdquo;. Mais si vous avez l&rsquo;état d&rsquo;esprit d&rsquo;un <em>utilisateur</em> de votre langage, alors l&rsquo;exécution est implémentée dans un certain autre langage &ldquo;étranger&rdquo;.</p>
<p>Ou il se peut que &ldquo;native&rdquo; fasse référence au langage code machine du matériel sous-jacent. En Java, les méthodes &ldquo;natives&rdquo; sont celles implémentées en C ou C++ et compilées en code machine natif.</p><img src="image/functions/foreign.png" class="above" alt="Tout est une question de perspective." />
</aside>
<p>Mais quand il s&rsquo;agit de rendre votre langage réellement bon à faire des trucs utiles, les fonctions natives que votre implémentation fournit sont clés. Elles fournissent l&rsquo;accès aux services fondamentaux en termes desquels tous les programmes sont définis. Si vous ne fournissez pas de fonctions natives pour accéder au système de fichiers, un utilisateur va avoir un mal de chien à écrire un programme qui lit et <span name="print">affiche</span> un fichier.</p>
<aside name="print">
<p>Une fonction native classique que presque chaque langage fournit est une pour imprimer du texte vers stdout. Dans Lox, j&rsquo;ai fait de <code>print</code> une instruction intégrée pour que nous puissions obtenir des trucs à l&rsquo;écran dans les chapitres avant celui-ci.</p>
<p>Une fois que nous avons des fonctions, nous pourrions simplifier le langage en arrachant la vieille syntaxe print et en la remplaçant par une fonction native. Mais cela signifierait que les exemples tôt dans le livre ne tourneraient pas sur l&rsquo;interpréteur de plus tard et vice versa. Donc, pour le livre, je vais laisser ça tranquille.</p>
<p>Si vous construisez un interpréteur pour votre <em>propre</em> langage, cependant, vous pourriez vouloir le considérer.</p>
</aside>
<p>Beaucoup de langages permettent aussi aux utilisateurs de fournir leurs propres fonctions natives. Le mécanisme pour faire cela est appelé une <strong>interface de fonction étrangère</strong> (<strong>FFI</strong>), <strong>extension native</strong>, <strong>interface native</strong>, ou quelque chose dans ces lignes. Celles-ci sont sympas parce qu&rsquo;elles libèrent l&rsquo;implémenteur du langage de fournir l&rsquo;accès à chaque capacité unique que la plateforme sous-jacente supporte. Nous ne définirons pas une FFI pour jlox, mais nous ajouterons une fonction native pour vous donner une idée de quoi cela a l&rsquo;air.</p>
<h3><a href="#dire-lheure" id="dire-lheure"><small>10&#8202;.&#8202;2&#8202;.&#8202;1</small>Dire l&rsquo;heure</a></h3>
<p>Quand nous arriverons à la [Partie III][] et commencerons à travailler sur une implémentation beaucoup plus efficace de Lox, nous allons nous soucier profondément de la performance. Le travail de performance exige de la mesure, et cela à son tour signifie des <strong>benchmarks</strong>. Ce sont des programmes qui mesurent le temps que cela prend pour exercer un certain coin de l&rsquo;interpréteur.</p>
<p>Nous pourrions mesurer le temps que cela prend pour démarrer l&rsquo;interpréteur, exécuter le benchmark, et sortir, mais cela ajoute beaucoup de surcharge<span class="em">&mdash;</span>temps de démarrage de la JVM, manigances de l&rsquo;OS, etc. Ce truc compte, bien sûr, mais si vous essayez juste de valider une optimisation sur une certaine pièce de l&rsquo;interpréteur, vous ne voulez pas que cette surcharge obscurcisse vos résultats.</p>
<p>Une solution plus jolie est d&rsquo;avoir le script de benchmark lui-même mesurer le temps écoulé entre deux points dans le code. Pour faire cela, un programme Lox a besoin d&rsquo;être capable de dire l&rsquo;heure. Il n&rsquo;y a aucun moyen de faire cela maintenant<span class="em">&mdash;</span>vous ne pouvez pas implémenter une horloge utile &ldquo;from scratch&rdquo; sans accès à l&rsquo;horloge sous-jacente sur l&rsquo;ordinateur.</p>
<p>Donc nous ajouterons <code>clock()</code>, une fonction native qui renvoie le nombre de secondes qui sont passées depuis un certain point fixe dans le temps. La différence entre deux invocations successives vous dit combien de temps s&rsquo;est écoulé entre les deux appels. Cette fonction est définie dans la portée globale, donc assurons-nous que l&rsquo;interpréteur a accès à cela.</p>
<div class="codehilite"><pre class="insert-before">class Interpreter implements Expr.Visitor&lt;Object&gt;,
                             Stmt.Visitor&lt;Void&gt; {
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in class <em>Interpreter</em><br>
replace 1 line</div>
<pre class="insert">  <span class="k">final</span> <span class="t">Environment</span> <span class="i">globals</span> = <span class="k">new</span> <span class="t">Environment</span>();
  <span class="k">private</span> <span class="t">Environment</span> <span class="i">environment</span> = <span class="i">globals</span>;
</pre><pre class="insert-after">

  void interpret(List&lt;Stmt&gt; statements) {
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in class <em>Interpreter</em>, replace 1 line</div>

<p>Le champ <code>environment</code> dans l&rsquo;interpréteur change quand nous entrons et sortons des portées locales. Il suit l&rsquo;environnement <em>courant</em>. Ce nouveau champ <code>globals</code> détient une référence fixe vers l&rsquo;environnement global le plus externe.</p>
<p>Quand nous instancions un Interpreter, nous bourrons la fonction native dans cette portée globale.</p>
<div class="codehilite"><pre class="insert-before">  private Environment environment = globals;

</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in class <em>Interpreter</em></div>
<pre class="insert">  <span class="t">Interpreter</span>() {
    <span class="i">globals</span>.<span class="i">define</span>(<span class="s">&quot;clock&quot;</span>, <span class="k">new</span> <span class="t">LoxCallable</span>() {
      <span class="a">@Override</span>
      <span class="k">public</span> <span class="t">int</span> <span class="i">arity</span>() { <span class="k">return</span> <span class="n">0</span>; }

      <span class="a">@Override</span>
      <span class="k">public</span> <span class="t">Object</span> <span class="i">call</span>(<span class="t">Interpreter</span> <span class="i">interpreter</span>,
                         <span class="t">List</span>&lt;<span class="t">Object</span>&gt; <span class="i">arguments</span>) {
        <span class="k">return</span> (<span class="t">double</span>)<span class="t">System</span>.<span class="i">currentTimeMillis</span>() / <span class="n">1000.0</span>;
      }

      <span class="a">@Override</span>
      <span class="k">public</span> <span class="t">String</span> <span class="i">toString</span>() { <span class="k">return</span> <span class="s">&quot;&lt;native fn&gt;&quot;</span>; }
    });
  }

</pre><pre class="insert-after">  void interpret(List&lt;Stmt&gt; statements) {
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in class <em>Interpreter</em></div>

<p>Ceci définit une <span name="lisp-1">variable</span> nommée &ldquo;clock&rdquo;. Sa valeur est une classe anonyme Java qui implémente LoxCallable. La fonction <code>clock()</code> ne prend pas d&rsquo;arguments, donc son arité est zéro. L&rsquo;implémentation de <code>call()</code> appelle la fonction Java correspondante et convertit le résultat en une valeur double en secondes.</p>
<aside name="lisp-1">
<p>Dans Lox, les fonctions et variables occupent le même espace de noms. En Common Lisp, les deux vivent dans leurs propres mondes. Une fonction et une variable avec le même nom n&rsquo;entrent pas en collision. Si vous appelez le nom, il cherche la fonction. Si vous y faites référence, il cherche la variable. Cela exige effectivement de sauter à travers quelques cerceaux quand vous voulez faire référence à une fonction comme une valeur de première classe.</p>
<p>Richard P. Gabriel et Kent Pitman ont inventé les termes &ldquo;Lisp-1&rdquo; par référence aux langages comme Scheme qui mettent fonctions et variables dans le même espace de noms, et &ldquo;Lisp-2&rdquo; pour les langages comme Common Lisp qui les partitionnent. Bien qu&rsquo;étant totalement opaques, ces noms sont restés depuis. Lox est un Lisp-1.</p>
</aside>
<p>Si nous voulions ajouter d&rsquo;autres fonctions natives<span class="em">&mdash;</span>lire l&rsquo;entrée de l&rsquo;utilisateur, travailler avec des fichiers, etc.<span class="em">&mdash;</span>nous pourrions les ajouter chacune comme leur propre classe anonyme qui implémente LoxCallable. Mais pour le livre, celle-ci est vraiment tout ce dont nous avons besoin.</p>
<p>Sortons-nous du business de définir des fonctions et laissons nos utilisateurs prendre le relais<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h2><a href="#déclarations-de-fonction" id="déclarations-de-fonction"><small>10&#8202;.&#8202;3</small>Déclarations de Fonction</a></h2>
<p>Nous arrivons enfin à ajouter une nouvelle production à la règle <code>declaration</code> que nous avons introduite au moment où nous avons ajouté les variables. Les déclarations de fonction, comme les variables, lient un nouveau <span name="name">nom</span>. Cela signifie qu&rsquo;elles sont autorisées uniquement aux endroits où une déclaration est permise.</p>
<aside name="name">
<p>Une déclaration de fonction nommée n&rsquo;est pas vraiment une opération primitive unique. C&rsquo;est du sucre syntaxique pour deux étapes distinctes : (1) créer un nouvel objet fonction, et (2) lier une nouvelle variable à celui-ci. Si Lox avait une syntaxe pour les fonctions anonymes, nous n&rsquo;aurions pas besoin d&rsquo;instructions de déclaration de fonction. Vous pourriez juste faire :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">add</span> = <span class="k">fun</span> (<span class="i">a</span>, <span class="i">b</span>) {
  <span class="k">print</span> <span class="i">a</span> + <span class="i">b</span>;
};
</pre></div>
<p>Cependant, puisque les fonctions nommées sont le cas courant, je suis allé de l&rsquo;avant et ai donné à Lox une syntaxe agréable pour elles.</p>
</aside>
<div class="codehilite"><pre><span class="i">declaration</span>    → <span class="i">funDecl</span>
               | <span class="i">varDecl</span>
               | <span class="i">statement</span> ;
</pre></div>
<p>La règle <code>declaration</code> mise à jour fait référence à cette nouvelle règle :</p>
<div class="codehilite"><pre><span class="i">funDecl</span>        → <span class="s">&quot;fun&quot;</span> <span class="i">function</span> ;
<span class="i">function</span>       → <span class="t">IDENTIFIER</span> <span class="s">&quot;(&quot;</span> <span class="i">parameters</span>? <span class="s">&quot;)&quot;</span> <span class="i">block</span> ;
</pre></div>
<p>La règle principale <code>funDecl</code> utilise une règle assistante séparée <code>function</code>. Une <em>instruction de déclaration</em> de fonction est le mot-clé <code>fun</code> suivi par le truc fonction-nesque réel. Quand nous arriverons aux classes, nous réutiliserons cette règle <code>function</code> pour déclarer des méthodes. Celles-ci ressemblent aux déclarations de fonction, mais ne sont pas précédées par <span name="fun"><code>fun</code></span>.</p>
<aside name="fun">
<p>Les méthodes sont trop classes pour avoir du fun/s&rsquo;amuser.</p>
</aside>
<p>La fonction elle-même est un nom suivi par la liste de paramètres parenthésée et le corps. Le corps est toujours un bloc entre accolades, utilisant la même règle de grammaire que les instructions de bloc utilisent. La liste de paramètres utilise cette règle :</p>
<div class="codehilite"><pre><span class="i">parameters</span>     → <span class="t">IDENTIFIER</span> ( <span class="s">&quot;,&quot;</span> <span class="t">IDENTIFIER</span> )* ;
</pre></div>
<p>C&rsquo;est comme la règle <code>arguments</code> antérieure, sauf que chaque paramètre est un identifieur, pas une expression. C&rsquo;est beaucoup de nouvelle syntaxe à mâcher pour le parseur, mais le <span name="fun-ast">nœud</span> AST résultant n&rsquo;est pas trop mauvais.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Expression : Expr expression&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Function   : Token name, List&lt;Token&gt; params,&quot;</span> +
                  <span class="s">&quot; List&lt;Stmt&gt; body&quot;</span>,
</pre><pre class="insert-after">      &quot;If         : Expr condition, Stmt thenBranch,&quot; +
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="fun-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#function-statement">Annexe II</a>.</p>
</aside>
<p>Un nœud de fonction a un nom, une liste de paramètres (leurs noms), et ensuite le corps. Nous stockons le corps comme la liste d&rsquo;instructions contenues à l&rsquo;intérieur des accolades.</p>
<p>Là-bas dans le parseur, nous tissons la nouvelle déclaration.</p>
<div class="codehilite"><pre class="insert-before">    try {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>declaration</em>()</div>
<pre class="insert">      <span class="k">if</span> (<span class="i">match</span>(<span class="i">FUN</span>)) <span class="k">return</span> <span class="i">function</span>(<span class="s">&quot;function&quot;</span>);
</pre><pre class="insert-after">      if (match(VAR)) return varDeclaration();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>declaration</em>()</div>

<p>Comme d&rsquo;autres instructions, une fonction est reconnue par le mot-clé de tête. Quand nous rencontrons <code>fun</code>, nous appelons <code>function</code>. Cela correspond à la règle de grammaire <code>function</code> puisque nous avons déjà matché et consommé le mot-clé <code>fun</code>. Nous construirons la méthode un morceau à la fois, en commençant par ceci :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>expressionStatement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">function</span>(<span class="t">String</span> <span class="i">kind</span>) {
    <span class="t">Token</span> <span class="i">name</span> = <span class="i">consume</span>(<span class="i">IDENTIFIER</span>, <span class="s">&quot;Expect &quot;</span> + <span class="i">kind</span> + <span class="s">&quot; name.&quot;</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>expressionStatement</em>()</div>

<p>Pour l&rsquo;instant, cela consomme uniquement le token identifieur pour le nom de la fonction. Vous pourriez vous demander à propos de ce petit paramètre drôle <code>kind</code>. Tout comme nous réutilisons la règle de grammaire, nous réutiliserons la méthode <code>function()</code> plus tard pour parser les méthodes à l&rsquo;intérieur des classes. Quand nous ferons cela, nous passerons &ldquo;method&rdquo; pour <code>kind</code> pour que les messages d&rsquo;erreur soient spécifiques au type de déclaration étant parsée.</p>
<p>Ensuite, nous parsons la liste de paramètres et la paire de parenthèses enveloppée autour.</p>
<div class="codehilite"><pre class="insert-before">    Token name = consume(IDENTIFIER, &quot;Expect &quot; + kind + &quot; name.&quot;);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>function</em>()</div>
<pre class="insert">    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &quot;</span> + <span class="i">kind</span> + <span class="s">&quot; name.&quot;</span>);
    <span class="t">List</span>&lt;<span class="t">Token</span>&gt; <span class="i">parameters</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">RIGHT_PAREN</span>)) {
      <span class="k">do</span> {
        <span class="k">if</span> (<span class="i">parameters</span>.<span class="i">size</span>() &gt;= <span class="n">255</span>) {
          <span class="i">error</span>(<span class="i">peek</span>(), <span class="s">&quot;Can&#39;t have more than 255 parameters.&quot;</span>);
        }

        <span class="i">parameters</span>.<span class="i">add</span>(
            <span class="i">consume</span>(<span class="i">IDENTIFIER</span>, <span class="s">&quot;Expect parameter name.&quot;</span>));
      } <span class="k">while</span> (<span class="i">match</span>(<span class="i">COMMA</span>));
    }
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after parameters.&quot;</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>function</em>()</div>

<p>C&rsquo;est comme le code pour gérer les arguments dans un appel, sauf non séparé dans une méthode assistante. L&rsquo;instruction <code>if</code> externe gère le cas zéro paramètre, et la boucle <code>while</code> interne parse les paramètres tant que nous trouvons des virgules pour les séparer. Le résultat est la liste de tokens pour le nom de chaque paramètre.</p>
<p>Tout comme nous faisons avec les arguments aux appels de fonction, nous validons au moment du parsing que vous n&rsquo;excédez pas le nombre maximum de paramètres qu&rsquo;une fonction est autorisée à avoir.</p>
<p>Finalement, nous parsons le corps et enveloppons tout cela dans un nœud de fonction.</p>
<div class="codehilite"><pre class="insert-before">    consume(RIGHT_PAREN, &quot;Expect ')' after parameters.&quot;);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>function</em>()</div>
<pre class="insert">

    <span class="i">consume</span>(<span class="i">LEFT_BRACE</span>, <span class="s">&quot;Expect &#39;{&#39; before &quot;</span> + <span class="i">kind</span> + <span class="s">&quot; body.&quot;</span>);
    <span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">body</span> = <span class="i">block</span>();
    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Function</span>(<span class="i">name</span>, <span class="i">parameters</span>, <span class="i">body</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>function</em>()</div>

<p>Notez que nous consommons le <code>{</code> au début du corps ici avant d&rsquo;appeler <code>block()</code>. C&rsquo;est parce que <code>block()</code> suppose que le token accolade a déjà été matché. Le consommer ici nous laisse rapporter un message d&rsquo;erreur plus précis si le <code>{</code> n&rsquo;est pas trouvé puisque nous savons que c&rsquo;est dans le contexte d&rsquo;une déclaration de fonction.</p>
<h2><a href="#objets-fonction" id="objets-fonction"><small>10&#8202;.&#8202;4</small>Objets Fonction</a></h2>
<p>Nous avons une certaine syntaxe parsée donc nous sommes habituellement prêts à interpréter, mais d&rsquo;abord nous avons besoin de penser à comment représenter une fonction Lox en Java. Nous avons besoin de garder une trace des paramètres pour que nous puissions les lier aux valeurs d&rsquo;argument quand la fonction est appelée. Et, bien sûr, nous avons besoin de garder le code pour le corps de la fonction pour que nous puissions l&rsquo;exécuter.</p>
<p>C&rsquo;est fondamentalement ce qu&rsquo;est la classe Stmt.Function. Pourrions-nous juste utiliser celle-là ? Presque, mais pas tout à fait. Nous avons aussi besoin d&rsquo;une classe qui implémente LoxCallable pour que nous puissions l&rsquo;appeler. Nous ne voulons pas que la phase d&rsquo;exécution de l&rsquo;interpréteur saigne dans les classes de syntaxe du front end donc nous ne voulons pas que Stmt.Function elle-même implémente cela. Au lieu de cela, nous l&rsquo;enveloppons dans une nouvelle classe.</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxFunction.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.List</span>;

<span class="k">class</span> <span class="t">LoxFunction</span> <span class="k">implements</span> <span class="t">LoxCallable</span> {
  <span class="k">private</span> <span class="k">final</span> <span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">declaration</span>;
  <span class="t">LoxFunction</span>(<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">declaration</span>) {
    <span class="k">this</span>.<span class="i">declaration</span> = <span class="i">declaration</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, create new file</div>

<p>Nous implémentons le <code>call()</code> de LoxCallable comme ceci :</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxFunction.java</em><br>
add after <em>LoxFunction</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">call</span>(<span class="t">Interpreter</span> <span class="i">interpreter</span>,
                     <span class="t">List</span>&lt;<span class="t">Object</span>&gt; <span class="i">arguments</span>) {
    <span class="t">Environment</span> <span class="i">environment</span> = <span class="k">new</span> <span class="t">Environment</span>(<span class="i">interpreter</span>.<span class="i">globals</span>);
    <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">declaration</span>.<span class="i">params</span>.<span class="i">size</span>(); <span class="i">i</span>++) {
      <span class="i">environment</span>.<span class="i">define</span>(<span class="i">declaration</span>.<span class="i">params</span>.<span class="i">get</span>(<span class="i">i</span>).<span class="i">lexeme</span>,
          <span class="i">arguments</span>.<span class="i">get</span>(<span class="i">i</span>));
    }

    <span class="i">interpreter</span>.<span class="i">executeBlock</span>(<span class="i">declaration</span>.<span class="i">body</span>, <span class="i">environment</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, add after <em>LoxFunction</em>()</div>

<p>Cette poignée de lignes de code est une des pièces les plus fondamentales, puissantes de notre interpréteur. Comme nous avons vu dans <a href="statements-and-state.html">le chapitre sur les instructions et l&rsquo;<span name="env">état</span></a>, gérer les environnements de noms est une partie centrale d&rsquo;une implémentation de langage. Les fonctions sont profondément liées à cela.</p>
<aside name="env">
<p>Nous creuserons encore plus profond dans les environnements dans le [prochain chapitre][].</p>
</aside>
<p>Les paramètres sont centraux aux fonctions, particulièrement le fait qu&rsquo;une fonction <em>encapsule</em> ses paramètres<span class="em">&mdash;</span>aucun autre code en dehors de la fonction ne peut les voir. Cela signifie que chaque fonction obtient son propre environnement où elle stocke ces variables.</p>
<p>De plus, cet environnement doit être créé dynamiquement. Chaque <em>appel</em> de fonction obtient son propre environnement. Sinon, la récursion casserait. S&rsquo;il y a plusieurs appels à la même fonction en jeu en même temps, chacun a besoin de son <em>propre</em> environnement, même s&rsquo;ils sont tous des appels à la même fonction.</p>
<p>Par exemple, voici une façon alambiquée de compter jusqu&rsquo;à trois :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">count</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> &gt; <span class="n">1</span>) <span class="i">count</span>(<span class="i">n</span> - <span class="n">1</span>);
  <span class="k">print</span> <span class="i">n</span>;
}

<span class="i">count</span>(<span class="n">3</span>);
</pre></div>
<p>Imaginez que nous mettons en pause l&rsquo;interpréteur juste au point main où il est sur le point d&rsquo;imprimer 1 dans l&rsquo;appel imbriqué le plus interne. Les appels externes pour imprimer 2 et 3 n&rsquo;ont pas encore imprimé leurs valeurs, donc il doit y avoir des environnements quelque part en mémoire qui stockent encore le fait que <code>n</code> est lié à 3 dans un contexte, 2 dans un autre, et 1 dans le plus interne, comme :</p><img src="image/functions/recursion.png" alt="Un environnement séparé pour chaque appel récursif." />
<p>C&rsquo;est pourquoi nous créons un nouvel environnement à chaque <em>appel</em>, pas à la <em>déclaration</em> de fonction. La méthode <code>call()</code> que nous avons vue plus tôt fait cela. Au début de l&rsquo;appel, elle crée un nouvel environnement. Ensuite elle parcourt les listes de paramètre et d&rsquo;argument au pas. Pour chaque paire, elle crée une nouvelle variable avec le nom du paramètre et la lie à la valeur de l&rsquo;argument.</p>
<p>Donc, pour un programme comme celui-ci :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">add</span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>) {
  <span class="k">print</span> <span class="i">a</span> + <span class="i">b</span> + <span class="i">c</span>;
}

<span class="i">add</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="n">3</span>);
</pre></div>
<p>Au point de l&rsquo;appel à <code>add()</code>, l&rsquo;interpréteur crée quelque chose comme ceci :</p><img src="image/functions/binding.png" alt="Lier des arguments à leurs paramètres." />
<p>Ensuite <code>call()</code> dit à l&rsquo;interpréteur d&rsquo;exécuter le corps de la fonction dans ce nouvel environnement local à la fonction. Jusqu&rsquo;à maintenant, l&rsquo;environnement courant était l&rsquo;environnement où la fonction était appelée. Maintenant, nous nous téléportons de là à l&rsquo;intérieur du nouvel espace de paramètre que nous avons créé pour la fonction.</p>
<p>C&rsquo;est tout ce qui est requis pour passer des données dans la fonction. En utilisant différents environnements quand nous exécutons le corps, les appels à la même fonction avec le même code peuvent produire différents résultats.</p>
<p>Une fois que le corps de la fonction a fini d&rsquo;exécuter, <code>executeBlock()</code> jette cet environnement local à la fonction et restaure le précédent qui était actif à l&rsquo;appel. Finalement, <code>call()</code> renvoie <code>null</code>, ce qui renvoie <code>nil</code> à l&rsquo;appelant. (Nous ajouterons les valeurs de retour plus tard.)</p>
<p>Mécaniquement, le code est assez simple. Parcourir une paire de listes. Lier quelques nouvelles variables. Appeler une méthode. Mais c&rsquo;est là où le <em>code</em> cristallin de la déclaration de fonction devient une <em>invocation</em> vivante, qui respire. C&rsquo;est l&rsquo;un de mes snippets favoris dans ce livre entier. Sentez-vous libre de prendre un moment pour méditer dessus si vous êtes ainsi incliné.</p>
<p>Fini ? OK. Notez quand nous lions les paramètres, nous supposons que les listes de paramètre et d&rsquo;argument ont la même longueur. C&rsquo;est sûr parce que <code>visitCallExpr()</code> vérifie l&rsquo;arité avant d&rsquo;appeler <code>call()</code>. Il compte sur la fonction rapportant son arité pour faire cela.</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxFunction.java</em><br>
add after <em>LoxFunction</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">int</span> <span class="i">arity</span>() {
    <span class="k">return</span> <span class="i">declaration</span>.<span class="i">params</span>.<span class="i">size</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, add after <em>LoxFunction</em>()</div>

<p>C&rsquo;est la majeure partie de notre représentation objet. Pendant que nous sommes ici, nous pourrions aussi bien implémenter <code>toString()</code>.</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxFunction.java</em><br>
add after <em>LoxFunction</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">toString</span>() {
    <span class="k">return</span> <span class="s">&quot;&lt;fn &quot;</span> + <span class="i">declaration</span>.<span class="i">name</span>.<span class="i">lexeme</span> + <span class="s">&quot;&gt;&quot;</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, add after <em>LoxFunction</em>()</div>

<p>Cela donne une sortie plus jolie si un utilisateur décide d&rsquo;imprimer une valeur de fonction.</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">add</span>(<span class="i">a</span>, <span class="i">b</span>) {
  <span class="k">print</span> <span class="i">a</span> + <span class="i">b</span>;
}

<span class="k">print</span> <span class="i">add</span>; <span class="c">// &quot;&lt;fn add&gt;&quot;.</span>
</pre></div>
<h3><a href="#interpréter-des-déclarations-de-fonction" id="interpréter-des-déclarations-de-fonction"><small>10&#8202;.&#8202;4&#8202;.&#8202;1</small>Interpréter des déclarations de fonction</a></h3>
<p>Nous reviendrons et raffinerons LoxFunction bientôt, mais c&rsquo;est assez pour commencer. Maintenant nous pouvons visiter une déclaration de fonction.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitExpressionStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitFunctionStmt</span>(<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">stmt</span>) {
    <span class="t">LoxFunction</span> <span class="i">function</span> = <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">stmt</span>);
    <span class="i">environment</span>.<span class="i">define</span>(<span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">function</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitExpressionStmt</em>()</div>

<p>C&rsquo;est similaire à comment nous interprétons d&rsquo;autres expressions littérales. Nous prenons un <em>nœud de syntaxe</em> de fonction<span class="em">&mdash;</span>une représentation compilation-time de la fonction<span class="em">&mdash;</span>et le convertissons en sa représentation exécution. Ici, c&rsquo;est une LoxFunction qui enveloppe le nœud de syntaxe.</p>
<p>Les déclarations de fonction sont différentes des autres nœuds littéraux en cela que la déclaration lie <em>aussi</em> l&rsquo;objet résultant à une nouvelle variable. Donc, après avoir créé la LoxFunction, nous créons une nouvelle liaison dans l&rsquo;environnement courant et stockons une référence à celui-ci là.</p>
<p>Avec cela, nous pouvons définir et appeler nos propres fonctions tout à l&rsquo;intérieur de Lox. Essayez :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">sayHi</span>(<span class="i">first</span>, <span class="i">last</span>) {
  <span class="k">print</span> <span class="s">&quot;Salut, &quot;</span> + <span class="i">first</span> + <span class="s">&quot; &quot;</span> + <span class="i">last</span> + <span class="s">&quot; !&quot;</span>;
}

<span class="i">sayHi</span>(<span class="s">&quot;Cher&quot;</span>, <span class="s">&quot;Lecteur&quot;</span>);
</pre></div>
<p>Je ne sais pas pour vous, mais cela ressemble à un langage de programmation honnête pour moi.</p>
<h2><a href="#instructions-return" id="instructions-return"><small>10&#8202;.&#8202;5</small>Instructions Return</a></h2>
<p>Nous pouvons obtenir des données dans les fonctions en passant des paramètres, mais nous n&rsquo;avons aucun moyen d&rsquo;obtenir des résultats en <span name="hotel"><em>sortie</em></span>. Si Lox était un langage orienté expression comme Ruby ou Scheme, le corps serait une expression dont la valeur est implicitement le résultat de la fonction. Mais dans Lox, le corps d&rsquo;une fonction est une liste d&rsquo;instructions qui ne produisent pas de valeurs, donc nous avons besoin d&rsquo;une syntaxe dédiée pour émettre un résultat. En d&rsquo;autres termes, des instructions <code>return</code>. Je suis sûr que vous pouvez deviner la grammaire déjà.</p>
<aside name="hotel">
<p>L&rsquo;Hôtel California des données.</p>
</aside>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">forStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">returnStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;

<span class="i">returnStmt</span>     → <span class="s">&quot;return&quot;</span> <span class="i">expression</span>? <span class="s">&quot;;&quot;</span> ;
</pre></div>
<p>Nous en avons une de plus<span class="em">&mdash;</span>la finale, en fait<span class="em">&mdash;</span>production sous la vénérable règle <code>statement</code>. Une instruction <code>return</code> est le mot-clé <code>return</code> suivi par une expression optionnelle et terminé avec un point-virgule.</p>
<p>La valeur de retour est optionnelle pour supporter de sortir tôt d&rsquo;une fonction qui ne renvoie pas une valeur utile. Dans les langages typés statiquement, les fonctions &ldquo;void&rdquo; ne renvoient pas une valeur et les non-void le font. Puisque Lox est typé dynamiquement, il n&rsquo;y a pas de vraies fonctions void. Le compilateur n&rsquo;a aucun moyen de vous empêcher de prendre la valeur résultat d&rsquo;un appel à une fonction qui ne contient pas d&rsquo;instruction <code>return</code>.</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">procedure</span>() {
  <span class="k">print</span> <span class="s">&quot;ne renvoie rien&quot;</span>;
}

<span class="k">var</span> <span class="i">result</span> = <span class="i">procedure</span>();
<span class="k">print</span> <span class="i">result</span>; <span class="c">// ?</span>
</pre></div>
<p>Cela signifie que chaque fonction Lox doit renvoyer <em>quelque chose</em>, même si elle ne contient aucune instruction <code>return</code> du tout. Nous utilisons <code>nil</code> pour cela, ce qui est pourquoi l&rsquo;implémentation de <code>call()</code> de LoxFunction renvoie <code>null</code> à la fin. Dans la même veine, si vous omettez la valeur dans une instruction <code>return</code>, nous la traitons simplement comme équivalente à :</p>
<div class="codehilite"><pre><span class="k">return</span> <span class="k">nil</span>;
</pre></div>
<p>Là-bas dans notre générateur AST, nous ajoutons un <span name="return-ast">nouveau nœud</span>.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Print      : Expr expression&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Return     : Token keyword, Expr value&quot;</span>,
</pre><pre class="insert-after">      &quot;Var        : Token name, Expr initializer&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="return-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#return-statement">Annexe II</a>.</p>
</aside>
<p>Il garde le token de mot-clé <code>return</code> pour que nous puissions utiliser son emplacement pour le rapport d&rsquo;erreur, et la valeur étant renvoyée, s&rsquo;il y en a. Nous le parsons comme d&rsquo;autres instructions, d&rsquo;abord en reconnaissant le mot-clé initial.</p>
<div class="codehilite"><pre class="insert-before">    if (match(PRINT)) return printStatement();
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">RETURN</span>)) <span class="k">return</span> <span class="i">returnStatement</span>();
</pre><pre class="insert-after">    if (match(WHILE)) return whileStatement();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>

<p>Cela branche vers :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>printStatement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">returnStatement</span>() {
    <span class="t">Token</span> <span class="i">keyword</span> = <span class="i">previous</span>();
    <span class="t">Expr</span> <span class="i">value</span> = <span class="k">null</span>;
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">SEMICOLON</span>)) {
      <span class="i">value</span> = <span class="i">expression</span>();
    }

    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after return value.&quot;</span>);
    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Return</span>(<span class="i">keyword</span>, <span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>printStatement</em>()</div>

<p>Après avoir attrapé le mot-clé <code>return</code> consommé précédemment, nous cherchons une expression de valeur. Puisque beaucoup de tokens différents peuvent potentiellement commencer une expression, il est difficile de dire si une valeur de retour est <em>présente</em>. Au lieu de cela, nous vérifions si elle est <em>absente</em>. Puisqu&rsquo;un point-virgule ne peut pas commencer une expression, si le prochain token est celui-là, nous savons qu&rsquo;il ne doit pas y avoir une valeur.</p>
<h3><a href="#revenir-des-appels" id="revenir-des-appels"><small>10&#8202;.&#8202;5&#8202;.&#8202;1</small>Revenir des appels</a></h3>
<p>Interpréter une instruction <code>return</code> est délicat. Vous pouvez retourner de n&rsquo;importe où à l&rsquo;intérieur du corps d&rsquo;une fonction, même profondément imbriqué à l&rsquo;intérieur d&rsquo;autres instructions. Quand le return est exécuté, l&rsquo;interpréteur a besoin de sauter tout le chemin hors de n&rsquo;importe quel contexte dans lequel il est actuellement et causer la complétion de l&rsquo;appel de fonction, comme une sorte de construction de contrôle de flux dopée.</p>
<p>Par exemple, disons que nous exécutons ce programme et nous sommes sur le point d&rsquo;exécuter l&rsquo;instruction <code>return</code> :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">count</span>(<span class="i">n</span>) {
  <span class="k">while</span> (<span class="i">n</span> &lt; <span class="n">100</span>) {
    <span class="k">if</span> (<span class="i">n</span> == <span class="n">3</span>) <span class="k">return</span> <span class="i">n</span>; <span class="c">// &lt;--</span>
    <span class="k">print</span> <span class="i">n</span>;
    <span class="i">n</span> = <span class="i">n</span> + <span class="n">1</span>;
  }
}

<span class="i">count</span>(<span class="n">1</span>);
</pre></div>
<p>La pile d&rsquo;appels Java ressemble actuellement grossièrement à ceci :</p>
<div class="codehilite"><pre>Interpreter.visitReturnStmt()
Interpreter.visitIfStmt()
Interpreter.executeBlock()
Interpreter.visitBlockStmt()
Interpreter.visitWhileStmt()
Interpreter.executeBlock()
LoxFunction.call()
Interpreter.visitCallExpr()
</pre></div>
<p>Nous avons besoin d&rsquo;aller du haut de la pile tout le chemin en arrière à <code>call()</code>. Je ne sais pas pour vous, mais pour moi ça sonne comme des exceptions. Quand nous exécutons une instruction <code>return</code>, nous utiliserons une exception pour dérouler l&rsquo;interpréteur au-delà des méthodes visit de toutes les instructions contenantes jusqu&rsquo;au code qui a commencé à exécuter le corps.</p>
<p>La méthode visit pour notre nouveau nœud AST ressemble à ceci :</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitPrintStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitReturnStmt</span>(<span class="t">Stmt</span>.<span class="t">Return</span> <span class="i">stmt</span>) {
    <span class="t">Object</span> <span class="i">value</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">value</span> != <span class="k">null</span>) <span class="i">value</span> = <span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">value</span>);

    <span class="k">throw</span> <span class="k">new</span> <span class="t">Return</span>(<span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitPrintStmt</em>()</div>

<p>Si nous avons une valeur de retour, nous l&rsquo;évaluons, sinon, nous utilisons <code>nil</code>. Ensuite nous prenons cette valeur et l&rsquo;enveloppons dans une classe d&rsquo;exception personnalisée et la lançons.</p>
<div class="codehilite"><div class="source-file"><em>lox/Return.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">class</span> <span class="t">Return</span> <span class="k">extends</span> <span class="t">RuntimeException</span> {
  <span class="k">final</span> <span class="t">Object</span> <span class="i">value</span>;

  <span class="t">Return</span>(<span class="t">Object</span> <span class="i">value</span>) {
    <span class="k">super</span>(<span class="k">null</span>, <span class="k">null</span>, <span class="k">false</span>, <span class="k">false</span>);
    <span class="k">this</span>.<span class="i">value</span> = <span class="i">value</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/Return.java</em>, create new file</div>

<p>Cette classe enveloppe la valeur de retour avec les accessoires que Java exige pour une classe d&rsquo;exception runtime. L&rsquo;appel bizarre au constructeur super avec ces arguments <code>null</code> et <code>false</code> désactive une certaine machinerie JVM dont nous n&rsquo;avons pas besoin. Puisque nous utilisons notre classe d&rsquo;exception pour le <span name="exception">contrôle de flux</span> et pas la gestion d&rsquo;erreur réelle, nous n&rsquo;avons pas besoin de surcharge comme les traces de pile.</p>
<aside name="exception">
<p>Pour mémoire, je ne suis généralement pas un fan d&rsquo;utiliser des exceptions pour le contrôle de flux. Mais à l&rsquo;intérieur d&rsquo;un interpréteur à parcours d&rsquo;arbre lourdement récursif, c&rsquo;est la voie à suivre. Puisque notre propre évaluation d&rsquo;arbre syntaxique est si lourdement liée à la pile d&rsquo;appels Java, nous sommes pressés de faire une certaine manipulation de pile d&rsquo;appels poids lourd occasionnellement, et les exceptions sont un outil pratique pour cela.</p>
</aside>
<p>Nous voulons que cela déroule tout le chemin jusqu&rsquo;à où l&rsquo;appel de fonction a commencé, la méthode <code>call()</code> dans LoxFunction.</p>
<div class="codehilite"><pre class="insert-before">          arguments.get(i));
    }

</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in <em>call</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="k">try</span> {
      <span class="i">interpreter</span>.<span class="i">executeBlock</span>(<span class="i">declaration</span>.<span class="i">body</span>, <span class="i">environment</span>);
    } <span class="k">catch</span> (<span class="t">Return</span> <span class="i">returnValue</span>) {
      <span class="k">return</span> <span class="i">returnValue</span>.<span class="i">value</span>;
    }
</pre><pre class="insert-after">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in <em>call</em>(), replace 1 line</div>

<p>Nous enveloppons l&rsquo;appel à <code>executeBlock()</code> dans un bloc try-catch. Quand il attrape une exception de retour, il sort la valeur et en fait la valeur de retour de <code>call()</code>. S&rsquo;il n&rsquo;attrape jamais une de ces exceptions, cela signifie que la fonction a atteint la fin de son corps sans frapper une instruction <code>return</code>. Dans ce cas, elle renvoie implicitement <code>nil</code>.</p>
<p>Essayons-le. Nous avons enfin assez de puissance pour supporter cet exemple classique<span class="em">&mdash;</span>une fonction récursive pour calculer les nombres de Fibonacci :</p>
<p><span name="slow"></span></p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">fib</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> &lt;= <span class="n">1</span>) <span class="k">return</span> <span class="i">n</span>;
  <span class="k">return</span> <span class="i">fib</span>(<span class="i">n</span> - <span class="n">2</span>) + <span class="i">fib</span>(<span class="i">n</span> - <span class="n">1</span>);
}

<span class="k">for</span> (<span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="n">20</span>; <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>) {
  <span class="k">print</span> <span class="i">fib</span>(<span class="i">i</span>);
}
</pre></div>
<p>Ce programme minuscule exerce presque chaque fonctionnalité de langage que nous avons passé les nombreux derniers chapitres à implémenter<span class="em">&mdash;</span>expressions, arithmétique, branchement, bouclage, variables, fonctions, appels de fonction, liaison de paramètre, et retours.</p>
<aside name="slow">
<p>Vous pourriez remarquer que c&rsquo;est assez lent. Évidemment, la récursion n&rsquo;est pas le moyen le plus efficace de calculer les nombres de Fibonacci, mais comme microbenchmark, cela fait un bon travail de stress test de combien vite notre interpréteur implémente les appels de fonction.</p>
<p>Comme vous pouvez le voir, la réponse est &ldquo;pas très vite&rdquo;. C&rsquo;est OK. Notre interpréteur C sera plus rapide.</p>
</aside>
<h2><a href="#fonctions-locales-et-fermetures" id="fonctions-locales-et-fermetures"><small>10&#8202;.&#8202;6</small>Fonctions Locales et Fermetures</a></h2>
<p>Nos fonctions sont assez complètes en fonctionnalités, mais il y a un trou à combler. En fait, c&rsquo;est un écart assez grand pour que nous passions la plupart du [prochain chapitre][] à le sceller, mais nous pouvons commencer ici.</p>
<p>L&rsquo;implémentation de <code>call()</code> de LoxFunction crée un nouvel environnement où elle lie les paramètres de la fonction. Quand je vous ai montré ce code, j&rsquo;ai glissé sur un point important : Quel est le <em>parent</em> de cet environnement ?</p>
<p>Pour l&rsquo;instant, c&rsquo;est toujours <code>globals</code>, l&rsquo;environnement global de niveau supérieur. De cette façon, si un identifieur n&rsquo;est pas défini à l&rsquo;intérieur du corps de la fonction lui-même, l&rsquo;interpréteur peut regarder à l&rsquo;extérieur de la fonction dans la portée globale pour le trouver. Dans l&rsquo;exemple Fibonacci, c&rsquo;est comment l&rsquo;interpréteur est capable de chercher l&rsquo;appel récursif à <code>fib</code> à l&rsquo;intérieur du propre corps de la fonction<span class="em">&mdash;</span><code>fib</code> est une variable globale.</p>
<p>Mais rappelez-vous que dans Lox, les déclarations de fonction sont autorisées <em>n&rsquo;importe où</em> un nom peut être lié. Cela inclut le niveau supérieur d&rsquo;un script Lox, mais aussi l&rsquo;intérieur de blocs ou d&rsquo;autres fonctions. Lox supporte les <strong>fonctions locales</strong> qui sont définies à l&rsquo;intérieur d&rsquo;une autre fonction, ou imbriquées à l&rsquo;intérieur d&rsquo;un bloc.</p>
<p>Considérez cet exemple classique :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">makeCounter</span>() {
  <span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>;
  <span class="k">fun</span> <span class="i">count</span>() {
    <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>;
    <span class="k">print</span> <span class="i">i</span>;
  }

  <span class="k">return</span> <span class="i">count</span>;
}

<span class="k">var</span> <span class="i">counter</span> = <span class="i">makeCounter</span>();
<span class="i">counter</span>(); <span class="c">// &quot;1&quot;.</span>
<span class="i">counter</span>(); <span class="c">// &quot;2&quot;.</span>
</pre></div>
<p>Ici, <code>count()</code> utilise <code>i</code>, qui est déclaré à l&rsquo;extérieur d&rsquo;elle-même dans la fonction contenante <code>makeCounter()</code>. <code>makeCounter()</code> renvoie une référence à la fonction <code>count()</code> et ensuite son propre corps finit d&rsquo;exécuter complètement.</p>
<p>Pendant ce temps, le code de niveau supérieur invoque la fonction <code>count()</code> renvoyée. Cela exécute le corps de <code>count()</code>, qui assigne à et lit <code>i</code>, même si la fonction où <code>i</code> était définie est déjà sortie.</p>
<p>Si vous n&rsquo;avez jamais rencontré un langage avec des fonctions imbriquées avant, cela pourrait sembler fou, mais les utilisateurs s&rsquo;attendent bien à ce que ça marche. Hélas, si vous le lancez maintenant, vous obtenez une erreur de variable indéfinie dans l&rsquo;appel à <code>counter()</code> quand le corps de <code>count()</code> essaie de chercher <code>i</code>. C&rsquo;est parce que la chaîne d&rsquo;environnement en effet ressemble à ceci :</p><img src="image/functions/global.png" alt="La chaîne d'environnement du corps de count() à la portée globale." />
<p>Quand nous appelons <code>count()</code> (à travers la référence à celle-ci stockée dans <code>counter</code>), nous créons un nouvel environnement vide pour le corps de la fonction. Le parent de celui-ci est l&rsquo;environnement global. Nous avons perdu l&rsquo;environnement pour <code>makeCounter()</code> où <code>i</code> est lié.</p>
<p>Retournons en arrière dans le temps un peu. Voici à quoi ressemblait la chaîne d&rsquo;environnement juste au moment où nous déclarions <code>count()</code> à l&rsquo;intérieur du corps de <code>makeCounter()</code> :</p><img src="image/functions/body.png" alt="La chaîne d'environnement à l'intérieur du corps de makeCounter()." />
<p>Donc au point où la fonction est déclarée, nous pouvons voir <code>i</code>. Mais quand nous revenons de <code>makeCounter()</code> et sortons de son corps, l&rsquo;interpréteur jette cet environnement. Puisque l&rsquo;interpréteur ne garde pas l&rsquo;environnement entourant <code>count()</code> dans les parages, c&rsquo;est à l&rsquo;objet fonction lui-même de s&rsquo;y accrocher.</p>
<p>Cette structure de données est appelée une <span name="closure"><strong>fermeture</strong></span> (closure) parce qu&rsquo;elle &ldquo;ferme sur&rdquo; et s&rsquo;accroche aux variables environnantes où la fonction est déclarée. Les fermetures existent depuis les premiers jours de Lisp, et les hackers de langage sont arrivés avec toutes sortes de façons de les implémenter. Pour jlox, nous ferons la chose la plus simple qui marche. Dans LoxFunction, nous ajoutons un champ pour stocker un environnement.</p>
<aside name="closure">
<p>&ldquo;Closure&rdquo; est encore un autre terme inventé par Peter J. Landin. Je suppose qu&rsquo;avant qu&rsquo;il n&rsquo;arrive les informaticiens communiquaient les uns avec les autres en utilisant seulement des grognements primitifs et des gestes de la main.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  private final Stmt.Function declaration;
</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in class <em>LoxFunction</em></div>
<pre class="insert">  <span class="k">private</span> <span class="k">final</span> <span class="t">Environment</span> <span class="i">closure</span>;

</pre><pre class="insert-after">  LoxFunction(Stmt.Function declaration) {
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in class <em>LoxFunction</em></div>

<p>Nous initialisons cela dans le constructeur.</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxFunction.java</em><br>
constructor <em>LoxFunction</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">LoxFunction</span>(<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">declaration</span>, <span class="t">Environment</span> <span class="i">closure</span>) {
    <span class="k">this</span>.<span class="i">closure</span> = <span class="i">closure</span>;
</pre><pre class="insert-after">    this.declaration = declaration;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, constructor <em>LoxFunction</em>(), replace 1 line</div>

<p>Quand nous créons une LoxFunction, nous capturons l&rsquo;environnement courant.</p>
<div class="codehilite"><pre class="insert-before">  public Void visitFunctionStmt(Stmt.Function stmt) {
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitFunctionStmt</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">LoxFunction</span> <span class="i">function</span> = <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">stmt</span>, <span class="i">environment</span>);
</pre><pre class="insert-after">    environment.define(stmt.name.lexeme, function);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitFunctionStmt</em>(), replace 1 line</div>

<p>C&rsquo;est l&rsquo;environnement qui est actif quand la fonction est <em>déclarée</em> pas quand elle est <em>appelée</em>, qui est ce que nous voulons. Il représente la portée lexicale entourant la déclaration de fonction. Finalement, quand nous appelons la fonction, nous utilisons cet environnement comme parent de l&rsquo;appel au lieu d&rsquo;aller directement à <code>globals</code>.</p>
<div class="codehilite"><pre class="insert-before">                     List&lt;Object&gt; arguments) {
</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in <em>call</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">Environment</span> <span class="i">environment</span> = <span class="k">new</span> <span class="t">Environment</span>(<span class="i">closure</span>);
</pre><pre class="insert-after">    for (int i = 0; i &lt; declaration.params.size(); i++) {
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in <em>call</em>(), replace 1 line</div>

<p>Cela crée une chaîne d&rsquo;environnement qui va du corps de la fonction vers l&rsquo;extérieur à travers les environnements où la fonction est déclarée, tout le chemin vers l&rsquo;extérieur jusqu&rsquo;à la portée globale. La chaîne d&rsquo;environnement d&rsquo;exécution correspond à l&rsquo;imbrication textuelle du code source comme nous voulons. Le résultat final quand nous appelons cette fonction ressemble à ceci :</p><img src="image/functions/closure.png" alt="La chaîne d'environnement avec la fermeture." />
<p>Maintenant, comme vous pouvez le voir, l&rsquo;interpréteur peut encore trouver <code>i</code> quand il en a besoin parce qu&rsquo;il est au milieu de la chaîne d&rsquo;environnement. Essayez de lancer cet exemple <code>makeCounter()</code> maintenant. Ça marche !</p>
<p>Les fonctions nous permettent d&rsquo;abstraire, réutiliser, et composer du code. Lox est beaucoup plus puissant que la calculatrice arithmétique rudimentaire qu&rsquo;il était. Hélas, dans notre hâte de bourrer les fermetures dedans, nous avons laissé un tout petit peu de portée dynamique fuiter dans l&rsquo;interpréteur. Dans le [prochain chapitre][], nous explorerons plus profondément dans la portée lexicale et fermerons ce trou.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>10&#8202;.&#8202;7</small>Défis</a></h2>
<ol>
<li>
<p>Notre interpréteur vérifie soigneusement que le nombre d&rsquo;arguments passés à une fonction correspond au nombre de paramètres qu&rsquo;elle attend. Puisque cette vérification est faite à l&rsquo;exécution sur chaque appel, elle a un coût de performance. Les implémentations Smalltalk n&rsquo;ont pas ce problème. Pourquoi pas ?</p>
</li>
<li>
<p>La syntaxe de déclaration de fonction de Lox effectue deux opérations indépendantes. Elle crée une fonction et la lie aussi à un nom. Cela améliore l&rsquo;utilisabilité pour le cas courant où vous voulez associer un nom à la fonction. Mais dans le code de style fonctionnel, vous voulez souvent créer une fonction pour la passer immédiatement à une autre fonction ou la renvoyer. Dans ce cas, elle n&rsquo;a pas besoin d&rsquo;un nom.</p>
<p>Les langages qui encouragent un style fonctionnel supportent habituellement les <strong>fonctions anonymes</strong> ou <strong>lambdas</strong><span class="em">&mdash;</span>une syntaxe d&rsquo;expression qui crée une fonction sans la lier à un nom. Ajoutez la syntaxe de fonction anonyme à Lox pour que cela marche :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">thrice</span>(<span class="i">fn</span>) {
  <span class="k">for</span> (<span class="k">var</span> <span class="i">i</span> = <span class="n">1</span>; <span class="i">i</span> &lt;= <span class="n">3</span>; <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>) {
    <span class="i">fn</span>(<span class="i">i</span>);
  }
}

<span class="i">thrice</span>(<span class="k">fun</span> (<span class="i">a</span>) {
  <span class="k">print</span> <span class="i">a</span>;
});
<span class="c">// &quot;1&quot;.</span>
<span class="c">// &quot;2&quot;.</span>
<span class="c">// &quot;3&quot;.</span>
</pre></div>
<p>Comment gérez-vous le cas délicat d&rsquo;une expression de fonction anonyme se produisant dans une instruction d&rsquo;expression :</p>
<div class="codehilite"><pre><span class="k">fun</span> () {};
</pre></div>
</li>
<li>
<p>Est-ce que ce programme est valide ?</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">scope</span>(<span class="i">a</span>) {
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;local&quot;</span>;
}
</pre></div>
<p>En d&rsquo;autres termes, est-ce que les paramètres d&rsquo;une fonction sont dans la <em>même</em> portée que ses variables locales, ou dans une portée externe ? Que fait Lox ? Et à propos d&rsquo;autres langages avec lesquels vous êtes familier ? Que pensez-vous qu&rsquo;un langage <em>devrait</em> faire ?</p>
</li>
</ol>
</div>

<footer>
<a href="résolution-et-liaison.html" class="next">
  Next Chapter: &ldquo;Résolution et liaison&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
