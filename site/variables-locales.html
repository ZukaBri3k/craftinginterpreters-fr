<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Variables locales &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Variables locales<small>22</small></a></h3>

<ul>
    <li><a href="#représenter-les-variables-locales"><small>22.1</small> Représenter les Variables Locales</a></li>
    <li><a href="#instructions-de-bloc"><small>22.2</small> Instructions de Bloc</a></li>
    <li><a href="#déclarer-des-variables-locales"><small>22.3</small> Déclarer des Variables Locales</a></li>
    <li><a href="#utiliser-les-locales"><small>22.4</small> Utiliser les Locales</a></li>
    <li><a href="#défis"><small>22.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="variables-globales.html" title="Variables globales" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="sauts-avant-et-arrière.html" title="Sauts avant et arrière" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="variables-globales.html" title="Variables globales" class="prev">←</a>
<a href="sauts-avant-et-arrière.html" title="Sauts avant et arrière" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Variables locales<small>22</small></a></h3>

<ul>
    <li><a href="#représenter-les-variables-locales"><small>22.1</small> Représenter les Variables Locales</a></li>
    <li><a href="#instructions-de-bloc"><small>22.2</small> Instructions de Bloc</a></li>
    <li><a href="#déclarer-des-variables-locales"><small>22.3</small> Déclarer des Variables Locales</a></li>
    <li><a href="#utiliser-les-locales"><small>22.4</small> Utiliser les Locales</a></li>
    <li><a href="#défis"><small>22.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="variables-globales.html" title="Variables globales" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="sauts-avant-et-arrière.html" title="Sauts avant et arrière" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">22</div>
  <h1>Variables locales</h1>

<blockquote>
<p>Et comme l&rsquo;imagination donne corps<br />
Aux formes de choses inconnues, la plume du poète<br />
Les transforme en figures et donne à ce rien aérien<br />
Une habitation locale et un nom.</p>
<p><cite>William Shakespeare, <em>Le Songe d&rsquo;une nuit d&rsquo;été</em></cite></p>
</blockquote>
<p>Le <a href="variables-globales.html">chapitre précédent</a> a introduit les variables dans clox, mais seulement de la variété <span name="global">globale</span>. Dans ce chapitre, nous étendrons cela pour supporter les blocs, la portée de bloc, et les variables locales. Dans jlox, nous avons réussi à empaqueter tout ça et les globales dans un seul chapitre. Pour clox, c&rsquo;est deux chapitres de travail partiellement parce que, franchement, tout prend plus d&rsquo;efforts en C.</p>
<aside name="global">
<p>Il y a probablement une blague bête &ldquo;penser globalement, agir localement&rdquo; ici, mais je lutte pour la trouver.</p>
</aside>
<p>Mais une raison encore plus importante est que notre approche des variables locales sera tout à fait différente de comment nous avons implémenté les globales. Les variables globales sont liées tardivement dans Lox. &ldquo;Tard&rdquo; dans ce contexte signifie &ldquo;résolues après le moment de la compilation&rdquo;. C&rsquo;est bon pour garder le compilateur simple, mais pas génial pour la performance. Les variables locales sont une des <span name="params">parties</span> les plus utilisées d&rsquo;un langage. Si les locales sont lentes, <em>tout</em> est lent. Donc nous voulons une stratégie pour les variables locales qui soit aussi efficace que possible.</p>
<aside name="params">
<p>Les paramètres de fonction sont aussi lourdement utilisés. Ils fonctionnent comme des variables locales aussi, donc nous utiliserons la même technique d&rsquo;implémentation pour eux.</p>
</aside>
<p>Heureusement, la portée lexicale est là pour nous aider. Comme le nom l&rsquo;implique, la portée lexicale signifie que nous pouvons résoudre une variable locale juste en regardant le texte du programme<span class="em">&mdash;</span>les locales ne sont <em>pas</em> liées tardivement. Tout travail de traitement que nous faisons dans le compilateur est du travail que nous <em>n&rsquo;avons pas</em> à faire à l&rsquo;exécution, donc notre implémentation de variables locales s&rsquo;appuiera lourdement sur le compilateur.</p>
<h2><a href="#représenter-les-variables-locales" id="représenter-les-variables-locales"><small>22&#8202;.&#8202;1</small>Représenter les Variables Locales</a></h2>
<p>La chose sympa à propos de bidouiller sur un langage de programmation dans les temps modernes est qu&rsquo;il y a une longue lignée d&rsquo;autres langages desquels apprendre. Alors comment C et Java gèrent-ils leurs variables locales ? Eh bien, sur la pile, bien sûr ! Ils utilisent typiquement les mécanismes de pile natifs supportés par la puce et l&rsquo;OS. C&rsquo;est un peu trop bas niveau pour nous, mais à l&rsquo;intérieur du monde virtuel de clox, nous avons notre propre pile que nous pouvons utiliser.</p>
<p>Juste maintenant, nous l&rsquo;utilisons seulement pour tenir des <strong>temporaires</strong><span class="em">&mdash;</span>des blobs de données à courte vie dont nous avons besoin de nous souvenir pendant le calcul d&rsquo;une expression. Tant que nous ne nous mettons pas en travers de ceux-là, nous pouvons fourrer nos variables locales sur la pile aussi. C&rsquo;est génial pour la performance. Allouer de l&rsquo;espace pour une nouvelle locale exige seulement d&rsquo;incrémenter le pointeur <code>stackTop</code>, et libérer est de même un décrément. Accéder à une variable depuis un emplacement de pile connu est une recherche indexée de tableau.</p>
<p>Nous devons faire attention, cependant. La VM attend que la pile se comporte comme, eh bien, une pile. Nous devons être OK avec l&rsquo;allocation de nouvelles locales seulement au sommet de la pile, et nous devons accepter que nous pouvons jeter une locale seulement quand rien n&rsquo;est au-dessus d&rsquo;elle sur la pile. Aussi, nous devons nous assurer que les temporaires n&rsquo;interfèrent pas.</p>
<p>Commode, la conception de Lox est en <span name="harmony">harmonie</span> avec ces contraintes. Les nouvelles locales sont toujours créées par des instructions de déclaration. Les instructions ne se nichent pas à l&rsquo;intérieur d&rsquo;expressions, donc il n&rsquo;y a jamais de temporaires sur la pile quand une instruction commence à s&rsquo;exécuter. Les blocs sont strictement imbriqués. Quand un bloc finit, il emmène toujours avec lui les locales déclarées le plus récemment, les plus intérieures. Puisque celles-ci sont aussi les locales qui sont entrées dans la portée en dernier, elles devraient être au sommet de la pile là où nous avons besoin d&rsquo;elles.</p>
<aside name="harmony">
<p>Cet alignement n&rsquo;est évidemment pas une coïncidence. J&rsquo;ai conçu Lox pour être susceptible à la compilation à une passe vers un bytecode basé sur la pile. Mais je n&rsquo;ai pas eu à régler le langage trop pour qu&rsquo;il tienne dans ces restrictions. La plupart de sa conception devrait sembler assez naturelle.</p>
<p>C&rsquo;est en grande partie parce que l&rsquo;histoire des langages est profondément liée à la compilation à une passe et<span class="em">&mdash;</span>à un degré moindre<span class="em">&mdash;</span>aux architectures basées sur la pile. La portée de bloc de Lox suit une tradition s&rsquo;étendant jusqu&rsquo;à BCPL. En tant que programmeurs, notre intuition de ce qui est &ldquo;normal&rdquo; dans un langage est informée même aujourd&rsquo;hui par les limitations matérielles d&rsquo;antan.</p>
</aside>
<p>Marchez à travers cet exemple de programme et regardez comment les variables locales entrent et sortent de la portée :</p><img src="image/local-variables/scopes.png" alt="Une série de variables locales entrent et sortent de la portée d'une manière semblable à une pile." />
<p>Voyez comment elles s&rsquo;ajustent à une pile parfaitement ? Il semble que la pile fonctionnera pour stocker les locales à l&rsquo;exécution. Mais nous pouvons aller plus loin que ça. Non seulement savons-nous <em>qu</em>&rsquo;elles seront sur la pile, mais nous pouvons même épingler précisément <em>où</em> elles seront sur la pile. Puisque le compilateur sait exactement quelles variables locales sont dans la portée à n&rsquo;importe quel point dans le temps, il peut effectivement simuler la pile pendant la compilation et noter <span name="fn">où</span> dans la pile chaque variable vit.</p>
<p>Nous tirerons avantage de cela en utilisant ces décalages de pile comme opérandes pour les instructions bytecode qui lisent et stockent les variables locales. Cela rend le travail avec les locales délicieusement rapide<span class="em">&mdash;</span>aussi simple qu&rsquo;indexer dans un tableau.</p>
<aside name="fn">
<p>Dans ce chapitre, les locales commencent au bas du tableau de pile de la VM et sont indexées depuis là. Quand nous ajouterons les [fonctions][], ce schéma deviendra un peu plus complexe. Chaque fonction a besoin de sa propre région de la pile pour ses paramètres et variables locales. Mais, comme nous le verrons, cela n&rsquo;ajoute pas autant de complexité que vous pourriez vous y attendre.</p>
</aside>
<p>Il y a beaucoup d&rsquo;état que nous avons besoin de suivre dans le compilateur pour faire marcher toute cette chose, donc commençons là. Dans jlox, nous avons utilisé une chaîne liée de HashMaps d&rsquo;&ldquo;environnement&rdquo; pour suivre quelles variables locales étaient actuellement dans la portée. C&rsquo;est en quelque sorte la façon classique, scolaire de représenter la portée lexicale. Pour clox, comme d&rsquo;habitude, nous allons un peu plus près du métal. Tout l&rsquo;état vit dans une nouvelle struct.</p>
<div class="codehilite"><pre class="insert-before">} ParseRule;
</pre><div class="source-file"><em>compiler.c</em><br>
add after struct <em>ParseRule</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Local</span> <span class="i">locals</span>[<span class="a">UINT8_COUNT</span>];
  <span class="t">int</span> <span class="i">localCount</span>;
  <span class="t">int</span> <span class="i">scopeDepth</span>;
} <span class="t">Compiler</span>;
</pre><pre class="insert-after">

Parser parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>ParseRule</em></div>

<p>Nous avons un tableau simple, plat de toutes les locales qui sont dans la portée pendant chaque point dans le processus de compilation. Elles sont <span name="order">ordonnées</span> dans le tableau dans l&rsquo;ordre où leurs déclarations apparaissent dans le code. Puisque l&rsquo;opérande d&rsquo;instruction que nous utiliserons pour encoder une locale est un octet unique, notre VM a une limite dure sur le nombre de locales qui peuvent être dans la portée à la fois. Cela signifie que nous pouvons aussi donner au tableau de locales une taille fixe.</p>
<aside name="order">
<p>Nous écrivons un compilateur à une passe, donc ce n&rsquo;est pas comme si nous avions <em>trop</em> d&rsquo;autres options pour comment les ordonner dans le tableau.</p>
</aside>
<div class="codehilite"><pre class="insert-before">#define DEBUG_TRACE_EXECUTION
</pre><div class="source-file"><em>common.h</em></div>
<pre class="insert">

<span class="a">#define UINT8_COUNT (UINT8_MAX + 1)</span>
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>

<p>De retour dans la struct Compiler, le champ <code>localCount</code> suit combien de locales sont dans la portée<span class="em">&mdash;</span>combien de ces emplacements de tableau sont utilisés. Nous suivons aussi la &ldquo;profondeur de portée&rdquo;. C&rsquo;est le nombre de blocs entourant le petit bout de code actuel que nous compilons.</p>
<p>Notre interpréteur Java utilisait une chaîne de maps pour garder les variables de chaque bloc séparées de celles des autres blocs. Cette fois, nous numéroterons simplement les variables avec le niveau d&rsquo;imbrication où elles apparaissent. Zéro est la portée globale, un est le premier bloc de niveau supérieur, deux est à l&rsquo;intérieur de ça, vous voyez l&rsquo;idée. Nous utilisons ceci pour suivre à quel bloc chaque locale appartient afin que nous sachions quelles locales jeter quand un bloc finit.</p>
<p>Chaque locale dans le tableau est une de celles-ci :</p>
<div class="codehilite"><pre class="insert-before">} ParseRule;
</pre><div class="source-file"><em>compiler.c</em><br>
add after struct <em>ParseRule</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Token</span> <span class="i">name</span>;
  <span class="t">int</span> <span class="i">depth</span>;
} <span class="t">Local</span>;
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>ParseRule</em></div>

<p>Nous stockons le nom de la variable. Quand nous résolvons un identifiant, nous comparons le léxème de l&rsquo;identifiant avec le nom de chaque locale pour trouver une correspondance. Il est assez dur de résoudre une variable si vous ne connaissez pas son nom. Le champ <code>depth</code> enregistre la profondeur de portée du bloc où la variable locale a été déclarée. C&rsquo;est tout l&rsquo;état dont nous avons besoin pour l&rsquo;instant.</p>
<p>C&rsquo;est une représentation très différente de ce que nous avions dans jlox, mais elle nous laisse toujours répondre à toutes les mêmes questions que notre compilateur a besoin de poser à l&rsquo;environnement lexical. L&rsquo;étape suivante est de comprendre comment le compilateur <em>obtient</em> cet état. Si nous étions des ingénieurs avec des <span name="thread">principes</span>, nous donnerions à chaque fonction dans le front end un paramètre qui accepte un pointeur vers un Compiler. Nous créerions un Compiler au début et l&rsquo;enfilerions soigneusement à travers chaque appel de fonction<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>mais cela signifierait beaucoup de changements ennuyeux au code que nous avons déjà écrit, donc voici une variable globale au lieu de cela :</p>
<aside name="thread">
<p>En particulier, si nous voulons jamais utiliser notre compilateur dans une application multi-threadée, possiblement avec de multiples compilateurs tournant en parallèle, alors utiliser une variable globale est une <em>mauvaise</em> idée.</p>
</aside>
<div class="codehilite"><pre class="insert-before">Parser parser;
</pre><div class="source-file"><em>compiler.c</em><br>
add after variable <em>parser</em></div>
<pre class="insert"><span class="t">Compiler</span>* <span class="i">current</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">Chunk* compilingChunk;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>

<p>Voici une petite fonction pour initialiser le compilateur :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">initCompiler</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>) {
  <span class="i">compiler</span>-&gt;<span class="i">localCount</span> = <span class="n">0</span>;
  <span class="i">compiler</span>-&gt;<span class="i">scopeDepth</span> = <span class="n">0</span>;
  <span class="i">current</span> = <span class="i">compiler</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitConstant</em>()</div>

<p>Quand nous démarrons d&rsquo;abord la VM, nous l&rsquo;appelons pour tout mettre dans un état propre.</p>
<div class="codehilite"><pre class="insert-before">  initScanner(source);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">  <span class="t">Compiler</span> <span class="i">compiler</span>;
  <span class="i">initCompiler</span>(&amp;<span class="i">compiler</span>);
</pre><pre class="insert-after">  compilingChunk = chunk;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<p>Notre compilateur a les données dont il a besoin, mais pas les opérations sur ces données. Il n&rsquo;y a pas de moyen de créer et détruire des portées, ou ajouter et résoudre des variables. Nous ajouterons celles-ci au fur et à mesure que nous en aurons besoin. D&rsquo;abord, commençons à construire quelques fonctionnalités de langage.</p>
<h2><a href="#instructions-de-bloc" id="instructions-de-bloc"><small>22&#8202;.&#8202;2</small>Instructions de Bloc</a></h2>
<p>Avant que nous puissions avoir des variables locales, nous avons besoin de quelques portées locales. Celles-ci viennent de deux choses : les corps de fonction et les <span name="block">blocs</span>. Les fonctions sont un gros morceau de travail auquel nous nous attaquerons dans <a href="appels-et-fonctions.html">un chapitre ultérieur</a>, donc pour l&rsquo;instant nous allons seulement faire les blocs. Comme d&rsquo;habitude, nous commençons avec la syntaxe. La nouvelle grammaire que nous introduirons est :</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">block</span> ;

<span class="i">block</span>          → <span class="s">&quot;{&quot;</span> <span class="i">declaration</span>* <span class="s">&quot;}&quot;</span> ;
</pre></div>
<aside name="block">
<p>Quand vous y pensez, &ldquo;bloc&rdquo; est un nom bizarre. Utilisé métaphoriquement, &ldquo;bloc&rdquo; signifie habituellement une petite unité indivisible, mais pour une raison quelconque, le comité Algol 60 a décidé de l&rsquo;utiliser pour faire référence à une structure <em>composée</em><span class="em">&mdash;</span>une série d&rsquo;instructions. Cela pourrait être pire, je suppose. Algol 58 appelait <code>begin</code> et <code>end</code> des &ldquo;parenthèses d&rsquo;instruction&rdquo;.</p><img src="image/local-variables/block.png" alt="Un parpaing (cinder block)." class="above" />
</aside>
<p>Les blocs sont une sorte d&rsquo;instruction, donc la règle pour eux va dans la production <code>statement</code>. Le code correspondant pour en compiler un ressemble à ceci :</p>
<div class="codehilite"><pre class="insert-before">  if (match(TOKEN_PRINT)) {
    printStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_LEFT_BRACE</span>)) {
    <span class="i">beginScope</span>();
    <span class="i">block</span>();
    <span class="i">endScope</span>();
</pre><pre class="insert-after">  } else {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>Après avoir <span name="helper">analysé</span> l&rsquo;accolade initiale, nous utilisons cette fonction aide pour compiler le reste du bloc :</p>
<aside name="helper">
<p>Cette fonction deviendra pratique plus tard pour compiler les corps de fonction.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">block</span>() {
  <span class="k">while</span> (!<span class="i">check</span>(<span class="a">TOKEN_RIGHT_BRACE</span>) &amp;&amp; !<span class="i">check</span>(<span class="a">TOKEN_EOF</span>)) {
    <span class="i">declaration</span>();
  }

  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_BRACE</span>, <span class="s">&quot;Expect &#39;}&#39; after block.&quot;</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<p>Elle continue d&rsquo;analyser les déclarations et les instructions jusqu&rsquo;à ce qu&rsquo;elle touche l&rsquo;accolade fermante. Comme nous le faisons avec n&rsquo;importe quelle boucle dans l&rsquo;analyseur, nous vérifions aussi la fin du flux de jetons. De cette façon, s&rsquo;il y a un programme malformé avec une accolade fermante manquante, le compilateur ne reste pas coincé dans une boucle.</p>
<p>Exécuter un bloc signifie simplement exécuter les instructions qu&rsquo;il contient, l&rsquo;une après l&rsquo;autre, donc il n&rsquo;y a pas grand-chose à leur compilation. La chose sémantiquement intéressante que les blocs font est de créer des portées. Avant que nous compilions le corps d&rsquo;un bloc, nous appelons cette fonction pour entrer dans une nouvelle portée locale :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">beginScope</span>() {
  <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>Afin de &ldquo;créer&rdquo; une portée, tout ce que nous faisons est d&rsquo;incrémenter la profondeur courante. C&rsquo;est certainement beaucoup plus rapide que jlox, qui allouait une HashMap entièrement nouvelle pour chacune. Étant donné <code>beginScope()</code>, vous pouvez probablement deviner ce que <code>endScope()</code> fait.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>beginScope</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">endScope</span>() {
  <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>--;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>beginScope</em>()</div>

<p>C&rsquo;est ça pour les blocs et les portées<span class="em">&mdash;</span>plus ou moins<span class="em">&mdash;</span>donc nous sommes prêts à fourrer quelques variables dedans.</p>
<h2><a href="#déclarer-des-variables-locales" id="déclarer-des-variables-locales"><small>22&#8202;.&#8202;3</small>Déclarer des Variables Locales</a></h2>
<p>Habituellement nous commençons avec l&rsquo;analyse ici, mais notre compilateur supporte déjà l&rsquo;analyse et la compilation des déclarations de variable. Nous avons des instructions <code>var</code>, des expressions identifiants et l&rsquo;affectation là-dedans maintenant. C&rsquo;est juste que le compilateur suppose que toutes les variables sont globales. Donc nous n&rsquo;avons besoin d&rsquo;aucun nouveau support d&rsquo;analyse, nous avons juste besoin d&rsquo;accrocher la nouvelle sémantique de portée au code existant.</p><img src="image/local-variables/declaration.png" alt="Le flux de code à l'intérieur de varDeclaration()." />
<p>L&rsquo;analyse de déclaration de variable commence dans <code>varDeclaration()</code> et repose sur une couple d&rsquo;autres fonctions. D&rsquo;abord, <code>parseVariable()</code> consomme le jeton identifiant pour le nom de variable, ajoute son léxème à la table des constantes du fragment comme une chaîne, et renvoie ensuite l&rsquo;index de table constante où il a été ajouté. Ensuite, après que <code>varDeclaration()</code> compile l&rsquo;initialisateur, elle appelle <code>defineVariable()</code> pour émettre le bytecode pour stocker la valeur de la variable dans la table de hachage des variables globales.</p>
<p>Ces deux aides ont besoin de quelques changements pour supporter les variables locales. Dans <code>parseVariable()</code>, nous ajoutons :</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_IDENTIFIER, errorMessage);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parseVariable</em>()</div>
<pre class="insert">

  <span class="i">declareVariable</span>();
  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> &gt; <span class="n">0</span>) <span class="k">return</span> <span class="n">0</span>;

</pre><pre class="insert-after">  return identifierConstant(&amp;parser.previous);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parseVariable</em>()</div>

<p>D&rsquo;abord, nous &ldquo;déclarons&rdquo; la variable. J&rsquo;arriverai à ce que ça signifie dans une seconde. Après cela, nous sortons de la fonction si nous sommes dans une portée locale. À l&rsquo;exécution, les locales ne sont pas cherchées par nom. Il n&rsquo;y a pas besoin de fourrer le nom de la variable dans la table des constantes, donc si la déclaration est à l&rsquo;intérieur d&rsquo;une portée locale, nous renvoyons un index de table factice au lieu de cela.</p>
<p>Là-bas dans <code>defineVariable()</code>, nous avons besoin d&rsquo;émettre le code pour stocker une variable locale si nous sommes dans une portée locale. Cela ressemble à ceci :</p>
<div class="codehilite"><pre class="insert-before">static void defineVariable(uint8_t global) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>defineVariable</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> &gt; <span class="n">0</span>) {
    <span class="k">return</span>;
  }

</pre><pre class="insert-after">  emitBytes(OP_DEFINE_GLOBAL, global);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>defineVariable</em>()</div>

<p>Attends, quoi ? Ouaip. C&rsquo;est tout. Il n&rsquo;y a pas de code pour créer une variable locale à l&rsquo;exécution. Pensez à dans quel état est la VM. Elle a déjà exécuté le code pour l&rsquo;initialisateur de la variable (ou le <code>nil</code> implicite si l&rsquo;utilisateur a omis un initialisateur), et cette valeur est assise juste au sommet de la pile comme le seul temporaire restant. Nous savons aussi que les nouvelles locales sont allouées au sommet de la pile<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>juste là où cette valeur est déjà. Ainsi, il n&rsquo;y a rien à faire. Le temporaire <em>devient</em> simplement la variable locale. Ça ne devient pas beaucoup plus efficace que ça.</p>
<p><span name="locals"></span></p><img src="image/local-variables/local-slots.png" alt="Marchant à travers l'exécution bytecode montrant que chaque résultat d'initialisateur finit dans l'emplacement de la locale." />
<aside name="locals">
<p>Le code sur la gauche compile vers la séquence d&rsquo;instructions sur la droite.</p>
</aside>
<p>OK, donc de quoi s&rsquo;agit-il avec &ldquo;déclarer&rdquo; ? Voici ce que cela fait :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifierConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">declareVariable</span>() {
  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> == <span class="n">0</span>) <span class="k">return</span>;

  <span class="t">Token</span>* <span class="i">name</span> = &amp;<span class="i">parser</span>.<span class="i">previous</span>;
  <span class="i">addLocal</span>(*<span class="i">name</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifierConstant</em>()</div>

<p>C&rsquo;est le point où le compilateur enregistre l&rsquo;existence de la variable. Nous faisons cela seulement pour les locales, donc si nous sommes dans la portée globale de niveau supérieur, nous abandonnons juste. Parce que les variables globales sont liées tardivement, le compilateur ne garde pas trace de quelles déclarations pour elles il a vues.</p>
<p>Mais pour les variables locales, le compilateur a bien besoin de se souvenir que la variable existe. C&rsquo;est ce que la déclarer fait<span class="em">&mdash;</span>cela l&rsquo;ajoute à la liste de variables du compilateur dans la portée courante. Nous implémentons cela en utilisant une autre nouvelle fonction.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifierConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">addLocal</span>(<span class="t">Token</span> <span class="i">name</span>) {
  <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span>++];
  <span class="i">local</span>-&gt;<span class="i">name</span> = <span class="i">name</span>;
  <span class="i">local</span>-&gt;<span class="i">depth</span> = <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifierConstant</em>()</div>

<p>Ceci initialise la prochaine Local disponible dans le tableau de variables du compilateur. Cela stocke le <span name="lexeme">nom</span> de la variable et la profondeur de la portée qui possède la variable.</p>
<aside name="lexeme">
<p>Inquiet à propos de la durée de vie de la chaîne pour le nom de la variable ? La Local stocke directement une copie de la struct Token pour l&rsquo;identifiant. Les Tokens stockent un pointeur vers le premier caractère de leur léxème et la longueur du léxème. Ce pointeur pointe dans la chaîne source originale pour le script ou l&rsquo;entrée REPL étant compilés.</p>
<p>Tant que cette chaîne reste autour pendant le processus de compilation entier<span class="em">&mdash;</span>ce qu&rsquo;elle doit puisque, vous savez, nous la compilons<span class="em">&mdash;</span>alors tous les jetons pointant dedans sont bons.</p>
</aside>
<p>Notre implémentation est bien pour un programme Lox correct, mais quoi à propos du code invalide ? Visons à être robustes. La première erreur à gérer n&rsquo;est pas vraiment la faute de l&rsquo;utilisateur, mais plus une limitation de la VM. Les instructions pour travailler avec les variables locales font référence à elles par index d&rsquo;emplacement. Cet index est stocké dans un opérande d&rsquo;un octet unique, ce qui signifie que la VM supporte seulement jusqu&rsquo;à 256 variables locales dans la portée à la fois.</p>
<p>Si nous essayons d&rsquo;aller au-dessus de ça, non seulement ne pourrions-nous pas nous y référer à l&rsquo;exécution, mais le compilateur écraserait son propre tableau de locales, aussi. Empêchons cela.</p>
<div class="codehilite"><pre class="insert-before">static void addLocal(Token name) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>addLocal</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">localCount</span> == <span class="a">UINT8_COUNT</span>) {
    <span class="i">error</span>(<span class="s">&quot;Too many local variables in function.&quot;</span>);
    <span class="k">return</span>;
  }

</pre><pre class="insert-after">  Local* local = &amp;current-&gt;locals[current-&gt;localCount++];
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addLocal</em>()</div>

<p>Le cas suivant est plus délicat. Considérez :</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;first&quot;</span>;
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;second&quot;</span>;
}
</pre></div>
<p>Au niveau supérieur, Lox permet de redéclarer une variable avec le même nom qu&rsquo;une déclaration précédente parce que c&rsquo;est utile pour le REPL. Mais à l&rsquo;intérieur d&rsquo;une portée locale, c&rsquo;est une chose assez <span name="rust">bizarre</span> à faire. C&rsquo;est susceptible d&rsquo;être une erreur, et beaucoup de langages, incluant notre propre Lox, consacrent cette supposition en faisant de ceci une erreur.</p>
<aside name="rust">
<p>Intéressamment, le langage de programmation Rust <em>permet</em> bien ceci, et le code idiomatique repose dessus.</p>
</aside>
<p>Notez que le programme ci-dessus est différent de celui-ci :</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;outer&quot;</span>;
  {
    <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;inner&quot;</span>;
  }
}
</pre></div>
<p>C&rsquo;est OK d&rsquo;avoir deux variables avec le même nom dans des portées <em>différentes</em>, même quand les portées se chevauchent de telle sorte que les deux sont visibles en même temps. C&rsquo;est le masquage (shadowing), et Lox permet bien cela. C&rsquo;est seulement une erreur d&rsquo;avoir deux variables avec le même nom dans la <em>même</em> portée locale.</p>
<p>Nous détectons cette erreur comme ceci :</p>
<div class="codehilite"><pre class="insert-before">  Token* name = &amp;parser.previous;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declareVariable</em>()</div>
<pre class="insert">  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
    <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">local</span>-&gt;<span class="i">depth</span> != -<span class="n">1</span> &amp;&amp; <span class="i">local</span>-&gt;<span class="i">depth</span> &lt; <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>) {
      <span class="k">break</span>;<span name="negative"> </span>
    }

    <span class="k">if</span> (<span class="i">identifiersEqual</span>(<span class="i">name</span>, &amp;<span class="i">local</span>-&gt;<span class="i">name</span>)) {
      <span class="i">error</span>(<span class="s">&quot;Already a variable with this name in this scope.&quot;</span>);
    }
  }

</pre><pre class="insert-after">  addLocal(*name);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declareVariable</em>()</div>

<aside name="negative">
<p>Ne vous inquiétez pas à propos de cette partie bizarre <code>depth != -1</code> encore. Nous arriverons à de quoi il s&rsquo;agit plus tard.</p>
</aside>
<p>Les variables locales sont ajoutées au tableau quand elles sont déclarées, ce qui signifie que la portée courante est toujours à la fin du tableau. Quand nous déclarons une nouvelle variable, nous commençons à la fin et travaillons en arrière, cherchant une variable existante avec le même nom. Si nous en trouvons une dans la portée courante, nous rapportons l&rsquo;erreur. Sinon, si nous atteignons le début du tableau ou une variable possédée par une autre portée, alors nous savons que nous avons vérifié toutes les variables existantes dans la portée.</p>
<p>Pour voir si deux identifiants sont les mêmes, nous utilisons ceci :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifierConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">identifiersEqual</span>(<span class="t">Token</span>* <span class="i">a</span>, <span class="t">Token</span>* <span class="i">b</span>) {
  <span class="k">if</span> (<span class="i">a</span>-&gt;<span class="i">length</span> != <span class="i">b</span>-&gt;<span class="i">length</span>) <span class="k">return</span> <span class="k">false</span>;
  <span class="k">return</span> <span class="i">memcmp</span>(<span class="i">a</span>-&gt;<span class="i">start</span>, <span class="i">b</span>-&gt;<span class="i">start</span>, <span class="i">a</span>-&gt;<span class="i">length</span>) == <span class="n">0</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifierConstant</em>()</div>

<p>Puisque nous connaissons les longueurs des deux léxèmes, nous vérifions cela d&rsquo;abord. Cela échouera rapidement pour beaucoup de chaînes non-égales. Si les <span name="hash">longueurs</span> sont les mêmes, nous vérifions les caractères en utilisant <code>memcmp()</code>. Pour accéder à <code>memcmp()</code>, nous avons besoin d&rsquo;un include.</p>
<aside name="hash">
<p>Ce serait une petite optimisation sympa si nous pouvions vérifier leurs hachages, mais les jetons ne sont pas des LoxStrings complètes, donc nous n&rsquo;avons pas calculé leurs hachages encore.</p>
</aside>
<div class="codehilite"><pre class="insert-before">#include &lt;stdlib.h&gt;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert"><span class="a">#include &lt;string.h&gt;</span>
</pre><pre class="insert-after">

#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>Avec ceci, nous sommes capables d&rsquo;amener des variables à l&rsquo;existence. Mais, comme des fantômes, elles s&rsquo;attardent au-delà de la portée où elles sont déclarées. Quand un bloc finit, nous avons besoin de les mettre au repos.</p>
<div class="codehilite"><pre class="insert-before">  current-&gt;scopeDepth--;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endScope</em>()</div>
<pre class="insert">

  <span class="k">while</span> (<span class="i">current</span>-&gt;<span class="i">localCount</span> &gt; <span class="n">0</span> &amp;&amp;
         <span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>].<span class="i">depth</span> &gt;
            <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>) {
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
    <span class="i">current</span>-&gt;<span class="i">localCount</span>--;
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endScope</em>()</div>

<p>Quand nous dépilons une portée, nous marchons en arrière à travers le tableau local cherchant toutes variables déclarées à la profondeur de portée que nous venons de quitter. Nous les jetons en décrémentant simplement la longueur du tableau.</p>
<p>Il y a un composant d&rsquo;exécution à ceci aussi. Les variables locales occupent des emplacements sur la pile. Quand une variable locale sort de la portée, cet emplacement n&rsquo;est plus nécessaire et devrait être libéré. Donc, pour chaque variable que nous jetons, nous émettons aussi une <span name="pop">instruction</span> <code>OP_POP</code> pour la dépiler de la pile.</p>
<aside name="pop">
<p>Quand de multiples variables locales sortent de la portée à la fois, vous obtenez une série d&rsquo;instructions <code>OP_POP</code> qui sont interprétées une à la fois. Une optimisation simple que vous pourriez ajouter à votre implémentation Lox est une instruction <code>OP_POPN</code> spécialisée qui prend un opérande pour le nombre d&rsquo;emplacements à dépiler et les dépile tous à la fois.</p>
</aside>
<h2><a href="#utiliser-les-locales" id="utiliser-les-locales"><small>22&#8202;.&#8202;4</small>Utiliser les Locales</a></h2>
<p>Nous pouvons maintenant compiler et exécuter des déclarations de variable locale. À l&rsquo;exécution, leurs valeurs sont assises là où elles devraient être sur la pile. Commençons à les utiliser. Nous ferons à la fois l&rsquo;accès variable et l&rsquo;affectation en même temps puisqu&rsquo;ils touchent les mêmes fonctions dans le compilateur.</p>
<p>Nous avons déjà du code pour obtenir et définir les variables globales, et<span class="em">&mdash;</span>comme de bons petits ingénieurs logiciels<span class="em">&mdash;</span>nous voulons réutiliser autant de ce code existant que nous le pouvons. Quelque chose comme ceci :</p>
<div class="codehilite"><pre class="insert-before">static void namedVariable(Token name, bool canAssign) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">uint8_t</span> <span class="i">getOp</span>, <span class="i">setOp</span>;
  <span class="t">int</span> <span class="i">arg</span> = <span class="i">resolveLocal</span>(<span class="i">current</span>, &amp;<span class="i">name</span>);
  <span class="k">if</span> (<span class="i">arg</span> != -<span class="n">1</span>) {
    <span class="i">getOp</span> = <span class="a">OP_GET_LOCAL</span>;
    <span class="i">setOp</span> = <span class="a">OP_SET_LOCAL</span>;
  } <span class="k">else</span> {
    <span class="i">arg</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">name</span>);
    <span class="i">getOp</span> = <span class="a">OP_GET_GLOBAL</span>;
    <span class="i">setOp</span> = <span class="a">OP_SET_GLOBAL</span>;
  }
</pre><pre class="insert-after">

  if (canAssign &amp;&amp; match(TOKEN_EQUAL)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>Au lieu de coder en dur les instructions bytecode émises pour l&rsquo;accès variable et l&rsquo;affectation, nous utilisons une couple de variables C. D&rsquo;abord, nous essayons de trouver une variable locale avec le nom donné. Si nous en trouvons une, nous utilisons les instructions pour travailler avec les locales. Sinon, nous supposons que c&rsquo;est une variable globale et utilisons les instructions bytecode existantes pour les globales.</p>
<p>Un peu plus bas, nous utilisons ces variables pour émettre les bonnes instructions. Pour l&rsquo;affectation :</p>
<div class="codehilite"><pre class="insert-before">  if (canAssign &amp;&amp; match(TOKEN_EQUAL)) {
    expression();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">emitBytes</span>(<span class="i">setOp</span>, (<span class="t">uint8_t</span>)<span class="i">arg</span>);
</pre><pre class="insert-after">  } else {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>Et pour l&rsquo;accès :</p>
<div class="codehilite"><pre class="insert-before">    emitBytes(setOp, (uint8_t)arg);
  } else {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">emitBytes</span>(<span class="i">getOp</span>, (<span class="t">uint8_t</span>)<span class="i">arg</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>Le vrai cœur de ce chapitre, la partie où nous résolvons une variable locale, est ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifiersEqual</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">resolveLocal</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>, <span class="t">Token</span>* <span class="i">name</span>) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">compiler</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
    <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">compiler</span>-&gt;<span class="i">locals</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">identifiersEqual</span>(<span class="i">name</span>, &amp;<span class="i">local</span>-&gt;<span class="i">name</span>)) {
      <span class="k">return</span> <span class="i">i</span>;
    }
  }

  <span class="k">return</span> -<span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifiersEqual</em>()</div>

<p>Pour tout ça, c&rsquo;est direct. Nous marchons la liste des locales qui sont actuellement dans la portée. Si l&rsquo;une a le même nom que le jeton identifiant, l&rsquo;identifiant doit faire référence à cette variable. Nous l&rsquo;avons trouvée ! Nous marchons le tableau en arrière pour que nous trouvions la <em>dernière</em> variable déclarée avec l&rsquo;identifiant. Cela assure que les variables locales intérieures masquent correctement les locales avec le même nom dans les portées environnantes.</p>
<p>À l&rsquo;exécution, nous chargeons et stockons les locales en utilisant l&rsquo;index d&rsquo;emplacement de pile, donc c&rsquo;est ce que le compilateur a besoin de calculer après qu&rsquo;il a résolu la variable. Chaque fois qu&rsquo;une variable est déclarée, nous l&rsquo;ajoutons au tableau de locales dans Compiler. Cela signifie que la première variable locale est à l&rsquo;index zéro, la suivante est à l&rsquo;index un, et ainsi de suite. En d&rsquo;autres termes, le tableau de locales dans le compilateur a la <em>mëme</em> disposition exacte que la pile de la VM aura à l&rsquo;exécution. L&rsquo;index de la variable dans le tableau de locales est le même que son emplacement de pile. Comme c&rsquo;est commode !</p>
<p>Si nous traversons le tableau entier sans trouver une variable avec le nom donné, ce ne doit pas être une locale. Dans ce cas, nous renvoyons <code>-1</code> pour signaler que ça n&rsquo;a pas été trouvé et devrait être supposé être une variable globale à la place.</p>
<h3><a href="#interpréter-les-variables-locales" id="interpréter-les-variables-locales"><small>22&#8202;.&#8202;4&#8202;.&#8202;1</small>Interpréter les variables locales</a></h3>
<p>Notre compilateur émet deux nouvelles instructions, donc mettons-les en marche. D&rsquo;abord est le chargement d&rsquo;une variable locale :</p>
<div class="codehilite"><pre class="insert-before">  OP_POP,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_GET_LOCAL</span>,
</pre><pre class="insert-after">  OP_GET_GLOBAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Et son implémentation :</p>
<div class="codehilite"><pre class="insert-before">      case OP_POP: pop(); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GET_LOCAL</span>: {
        <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="a">READ_BYTE</span>();
        <span class="i">push</span>(<span class="i">vm</span>.<span class="i">stack</span>[<span class="i">slot</span>]);<span name="slot"> </span>
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_GET_GLOBAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Elle prend un opérande d&rsquo;un octet unique pour l&rsquo;emplacement de pile où la locale vit. Elle charge la valeur depuis cet index et la pousse ensuite au sommet de la pile où les instructions ultérieures peuvent la trouver.</p>
<aside name="slot">
<p>Il semble redondant de pousser la valeur de la locale sur la pile puisqu&rsquo;elle est déjà sur la pile plus bas quelque part. Le problème est que les autres instructions bytecode cherchent seulement les données au <em>sommet</em> de la pile. C&rsquo;est l&rsquo;aspect central qui rend notre jeu d&rsquo;instructions bytecode basé sur la <em>pile</em>. Les jeux d&rsquo;instructions bytecode <a href="machine-virtuelle.html#note-de-conception">basés sur des registres</a> évitent cette jonglerie de pile au coût d&rsquo;avoir des instructions plus grandes avec plus d&rsquo;opérandes.</p>
</aside>
<p>Ensuite est l&rsquo;affectation :</p>
<div class="codehilite"><pre class="insert-before">  OP_GET_LOCAL,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_SET_LOCAL</span>,
</pre><pre class="insert-after">  OP_GET_GLOBAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Vous pouvez probablement prédire l&rsquo;implémentation.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_SET_LOCAL</span>: {
        <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="a">READ_BYTE</span>();
        <span class="i">vm</span>.<span class="i">stack</span>[<span class="i">slot</span>] = <span class="i">peek</span>(<span class="n">0</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_GET_GLOBAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Elle prend la valeur affectée du sommet de la pile et la stocke dans l&rsquo;emplacement de pile correspondant à la variable locale. Notez qu&rsquo;elle ne dépile pas la valeur de la pile. Rappelez-vous, l&rsquo;affectation est une expression, et chaque expression produit une valeur. La valeur d&rsquo;une expression d&rsquo;affectation est la valeur affectée elle-même, donc la VM laisse juste la valeur sur la pile.</p>
<p>Notre désassembleur est incomplet sans support pour ces deux nouvelles instructions.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_POP&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_GET_LOCAL</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">&quot;OP_GET_LOCAL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SET_LOCAL</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">&quot;OP_SET_LOCAL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_GET_GLOBAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Le compilateur compile les variables locales vers un accès direct par emplacement. Le nom de la variable locale ne quitte jamais le compilateur pour entrer dans le fragment du tout. C&rsquo;est génial pour la performance, mais pas si génial pour l&rsquo;introspection. Quand nous désassemblons ces instructions, nous ne pouvons pas montrer le nom de la variable comme nous le pouvions avec les globales. Au lieu de cela, nous montrons juste le numéro d&rsquo;emplacement.</p>
<aside name="debug">
<p>Effacer les noms de variables locales dans le compilateur est un vrai problème si nous voulons jamais implémenter un débogueur pour notre VM. Quand les utilisateurs marchent à travers le code, ils s&rsquo;attendent à voir les valeurs des variables locales organisées par leurs noms. Pour supporter cela, nous aurions besoin de sortir quelque information supplémentaire qui suit le nom de chaque variable locale à chaque emplacement de pile.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>debug.c</em><br>
add after <em>simpleInstruction</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">byteInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>,
                           <span class="t">int</span> <span class="i">offset</span>) {
  <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>];
  <span class="i">printf</span>(<span class="s">&quot;%-16s %4d</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">name</span>, <span class="i">slot</span>);
  <span class="k">return</span> <span class="i">offset</span> + <span class="n">2</span>;<span name="debug"> </span>
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>simpleInstruction</em>()</div>

<h3><a href="#un-autre-cas-limite-de-portée" id="un-autre-cas-limite-de-portée"><small>22&#8202;.&#8202;4&#8202;.&#8202;2</small>Un autre cas limite de portée</a></h3>
<p>Nous avons déjà investi du temps à gérer une couple de cas limites bizarres autour des portées. Nous nous sommes assurés que le masquage fonctionne correctement. Nous rapportons une erreur si deux variables dans la même portée locale ont le même nom. Pour des raisons qui ne sont pas entièrement claires pour moi, la portée variable semble avoir beaucoup de ces rides. Je n&rsquo;ai jamais vu un langage où cela semble complètement <span name="elegant">élégant</span>.</p>
<aside name="elegant">
<p>Non, pas même Scheme.</p>
</aside>
<p>Nous avons un cas limite de plus à traiter avant que nous finissions ce chapitre. Rappelez-vous cette étrange bête que nous avons rencontrée pour la première fois dans <a href="résolution-et-liaison.html#résoudre-les-déclarations-de-variables">l&rsquo;implémentation de jlox de la résolution de variable</a> :</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;outer&quot;</span>;
  {
    <span class="k">var</span> <span class="i">a</span> = <span class="i">a</span>;
  }
}
</pre></div>
<p>Nous l&rsquo;avons tuée alors en séparant la déclaration d&rsquo;une variable en deux phases, et nous ferons cela ici encore :</p><img src="image/local-variables/phases.png" alt="Un exemple de déclaration de variable marqué 'déclaré non initialisé' avant le nom de variable et 'prêt à l'emploi' après l'initialisateur." />
<p>Dès que la déclaration de variable commence<span class="em">&mdash;</span>en d&rsquo;autres termes, avant son initialisateur<span class="em">&mdash;</span>le nom est déclaré dans la portée courante. La variable existe, mais dans un état spécial &ldquo;non initialisé&rdquo;. Ensuite nous compilons l&rsquo;initialisateur. Si à n&rsquo;importe quel point dans cette expression nous résolvons un identifiant qui pointe vers cette variable, nous verrons qu&rsquo;elle n&rsquo;est pas initialisée encore et rapporterons une erreur. Après que nous finissons de compiler l&rsquo;initialisateur, nous marquons la variable comme initialisée et prête à l&rsquo;emploi.</p>
<p>Pour implémenter cela, quand nous déclarons une locale, nous avons besoin d&rsquo;indiquer l&rsquo;état &ldquo;non initialisé&rdquo; d&rsquo;une manière ou d&rsquo;une autre. Nous pourrions ajouter un nouveau champ à Local, mais soyons un peu plus parcimonieux avec la mémoire. Au lieu de cela, nous réglerons la profondeur de portée de la variable à une valeur sentinelle spéciale, <code>-1</code>.</p>
<div class="codehilite"><pre class="insert-before">  local-&gt;name = name;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>addLocal</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">local</span>-&gt;<span class="i">depth</span> = -<span class="n">1</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addLocal</em>(), replace 1 line</div>

<p>Plus tard, une fois que l&rsquo;initialisateur de la variable a été compilé, nous la marquons initialisée.</p>
<div class="codehilite"><pre class="insert-before">  if (current-&gt;scopeDepth &gt; 0) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>defineVariable</em>()</div>
<pre class="insert">    <span class="i">markInitialized</span>();
</pre><pre class="insert-after">    return;
  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>defineVariable</em>()</div>

<p>Cela est implémenté comme ceci :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>parseVariable</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">markInitialized</span>() {
  <span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>].<span class="i">depth</span> =
      <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parseVariable</em>()</div>

<p>Donc c&rsquo;est <em>vraiment</em> ce que &ldquo;déclarer&rdquo; et &ldquo;définir&rdquo; une variable signifie dans le compilateur. &ldquo;Déclarer&rdquo; est quand la variable est ajoutée à la portée, et &ldquo;définir&rdquo; est quand elle devient disponible à l&rsquo;utilisation.</p>
<p>Quand nous résolvons une référence à une variable locale, nous vérifions la profondeur de portée pour voir si elle est complètement définie.</p>
<div class="codehilite"><pre class="insert-before">    if (identifiersEqual(name, &amp;local-&gt;name)) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>resolveLocal</em>()</div>
<pre class="insert">      <span class="k">if</span> (<span class="i">local</span>-&gt;<span class="i">depth</span> == -<span class="n">1</span>) {
        <span class="i">error</span>(<span class="s">&quot;Can&#39;t read local variable in its own initializer.&quot;</span>);
      }
</pre><pre class="insert-after">      return i;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>resolveLocal</em>()</div>

<p>Si la variable a la profondeur sentinelle, ce doit être une référence à une variable dans son propre initialisateur, et nous rapportons cela comme une erreur.</p>
<p>C&rsquo;est tout pour ce chapitre ! Nous avons ajouté des blocs, des variables locales, et une vraie portée lexicale pour de vrai. Étant donné que nous avons introduit une représentation d&rsquo;exécution entièrement différente pour les variables, nous n&rsquo;avons pas eu à écrire beaucoup de code. L&rsquo;implémentation a fini par être assez propre et efficace.</p>
<p>Vous noterez que presque tout le code que nous avons écrit est dans le compilateur. Là-bas dans le runtime, c&rsquo;est juste deux petites instructions. Vous verrez ceci comme une <span name="static">tendance</span> continue dans clox comparé à jlox. Un des plus gros marteaux dans la boîte à outils de l&rsquo;optimiseur est de tirer le travail vers l&rsquo;avant dans le compilateur pour que vous n&rsquo;ayez pas à le faire à l&rsquo;exécution. Dans ce chapitre, cela signifiait résoudre exactement quel emplacement de pile chaque variable locale occupe. De cette façon, à l&rsquo;exécution, aucune recherche ou résolution n&rsquo;a besoin d&rsquo;arriver.</p>
<aside name="static">
<p>Vous pouvez regarder les types statiques comme un exemple extrême de cette tendance. Un langage typé statiquement prend toute l&rsquo;analyse de type et la gestion d&rsquo;erreur de type et trie tout ça pendant la compilation. Ensuite le runtime n&rsquo;a pas à gaspiller de temps à vérifier que les valeurs ont le type propre pour leur opération. En fait, dans certains langages typés statiquement comme C, vous ne <em>connaissez</em> même pas le type à l&rsquo;exécution. Le compilateur efface complètement toute représentation du type d&rsquo;une valeur laissant juste les bits nus.</p>
</aside>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>22&#8202;.&#8202;5</small>Défis</a></h2>
<ol>
<li>
<p>Notre simple tableau local rend facile le calcul de l&rsquo;emplacement de pile de chaque variable locale. Mais cela signifie que quand le compilateur résout une référence à une variable, nous devons faire un scan linéaire à travers le tableau.</p>
<p>Trouvez quelque chose de plus efficace. Pensez-vous que la complexité supplémentaire en vaut la peine ?</p>
</li>
<li>
<p>Comment d&rsquo;autres langages gèrent-ils le code comme ceci :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="i">a</span>;
</pre></div>
<p>Que feriez-vous si c&rsquo;était votre langage ? Pourquoi ?</p>
</li>
<li>
<p>Beaucoup de langages font une distinction entre des variables qui peuvent être réassignées et celles qui ne le peuvent pas. En Java, le modificateur <code>final</code> vous empêche d&rsquo;assigner à une variable. En JavaScript, une variable déclarée avec <code>let</code> peut être assignée, mais une déclarée utilisant <code>const</code> ne le peut pas. Swift traite <code>let</code> comme assignation unique et utilise <code>var</code> pour les variables assignables. Scala et Kotlin utilisent <code>val</code> et <code>var</code>.</p>
<p>Choisissez un mot-clé pour une forme de variable à assignation unique à ajouter à Lox. Justifiez votre choix, puis implémentez-le. Une tentative d&rsquo;assigner à une variable déclarée en utilisant votre nouveau mot-clé devrait causer une erreur de compilation.</p>
</li>
<li>
<p>Étendez clox pour permettre à plus de 256 variables locales d&rsquo;être dans la portée à la fois.</p>
</li>
</ol>
</div>

<footer>
<a href="sauts-avant-et-arrière.html" class="next">
  Next Chapter: &ldquo;Sauts avant et arrière&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
