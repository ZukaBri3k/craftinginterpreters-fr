<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Instructions et état &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Instructions et état<small>8</small></a></h3>

<ul>
    <li><a href="#instructions"><small>8.1</small> Instructions</a></li>
    <li><a href="#variables-globales"><small>8.2</small> Variables Globales</a></li>
    <li><a href="#environnements"><small>8.3</small> Environnements</a></li>
    <li><a href="#affectation"><small>8.4</small> Affectation</a></li>
    <li><a href="#portée"><small>8.5</small> Portée</a></li>
    <li><a href="#défis"><small>8.6</small> Défis</a></li>
    <li><a href="#note-de-conception--déclaration-de-variable-implicite"><small>8.7</small> Note de Conception : Déclaration de Variable Implicite</a></li>
</ul>


<div class="prev-next">
    <a href="évaluation-des-expressions.html" title="Évaluation des expressions" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="contrôle-de-flux.html" title="Contrôle de flux" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="évaluation-des-expressions.html" title="Évaluation des expressions" class="prev">←</a>
<a href="contrôle-de-flux.html" title="Contrôle de flux" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Instructions et état<small>8</small></a></h3>

<ul>
    <li><a href="#instructions"><small>8.1</small> Instructions</a></li>
    <li><a href="#variables-globales"><small>8.2</small> Variables Globales</a></li>
    <li><a href="#environnements"><small>8.3</small> Environnements</a></li>
    <li><a href="#affectation"><small>8.4</small> Affectation</a></li>
    <li><a href="#portée"><small>8.5</small> Portée</a></li>
    <li><a href="#défis"><small>8.6</small> Défis</a></li>
    <li><a href="#note-de-conception--déclaration-de-variable-implicite"><small>8.7</small> Note de Conception : Déclaration de Variable Implicite</a></li>
</ul>


<div class="prev-next">
    <a href="évaluation-des-expressions.html" title="Évaluation des expressions" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="contrôle-de-flux.html" title="Contrôle de flux" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">8</div>
  <h1>Instructions et état</h1>

<blockquote>
<p>Toute ma vie, mon cœur a aspiré à une chose que je ne peux nommer.
<cite>André Breton, <em>L&rsquo;Amour fou</em></cite></p>
</blockquote>
<p>L&rsquo;interpréteur que nous avons jusqu&rsquo;ici ressemble moins à la programmation d&rsquo;un vrai langage et plus à tapoter des boutons sur une calculatrice. &ldquo;Programmer&rdquo; pour moi signifie construire un système à partir de plus petits morceaux. Nous ne pouvons pas encore faire cela car nous n&rsquo;avons aucun moyen de lier un nom à une donnée ou une fonction. Nous ne pouvons pas composer de logiciel sans un moyen de faire référence aux morceaux.</p>
<p>Pour supporter les liaisons (bindings), notre interpréteur a besoin d&rsquo;un état interne. Quand vous définissez une variable au début du programme et l&rsquo;utilisez à la fin, l&rsquo;interpréteur doit conserver la valeur de cette variable entre-temps. Donc dans ce chapitre, nous allons donner à notre interpréteur un cerveau qui peut non seulement traiter, mais <em>se souvenir</em>.</p><img src="image/statements-and-state/brain.png" alt="Un cerveau, se souvenant probablement de trucs." />
<p>L&rsquo;état et les <span name="expr">instructions</span> (statements) vont main dans la main. Puisque les instructions, par définition, ne s&rsquo;évaluent pas en une valeur, elles doivent faire quelque chose d&rsquo;autre pour être utiles. Ce quelque chose est appelé un <strong>effet de bord</strong>. Cela peut signifier produire une sortie visible par l&rsquo;utilisateur ou modifier un état dans l&rsquo;interpréteur qui pourra être détecté plus tard. Ce dernier en fait un excellent candidat pour définir des variables ou d&rsquo;autres entités nommées.</p>
<aside name="expr">
<p>Vous pourriez faire un langage qui traite les déclarations de variables comme des expressions qui créent à la fois une liaison et produisent une valeur. Le seul langage que je connaisse qui fait cela est Tcl. Scheme semble être un candidat, mais notez qu&rsquo;après qu&rsquo;une expression <code>let</code> soit évaluée, la variable qu&rsquo;elle liait est oubliée. La syntaxe <code>define</code> n&rsquo;est pas une expression.</p>
</aside>
<p>Dans ce chapitre, nous allons faire tout cela. Nous définirons des instructions qui produisent une sortie (<code>print</code>) et créent un état (<code>var</code>). Nous ajouterons des expressions pour accéder aux variables et leur assigner une valeur. Enfin, nous ajouterons les blocs et la portée locale. C&rsquo;est beaucoup à bourrer dans un seul chapitre, mais nous allons mâcher tout cela une bouchée à la fois.</p>
<h2><a href="#instructions" id="instructions"><small>8&#8202;.&#8202;1</small>Instructions</a></h2>
<p>Nous commençons par étendre la grammaire de Lox avec des instructions. Elles ne sont pas très différentes des expressions. Nous commençons avec les deux types les plus simples :</p>
<ol>
<li>
<p>Une <strong>instruction d&rsquo;expression</strong> vous permet de placer une expression là où une instruction est attendue. Elles existent pour évaluer des expressions qui ont des effets de bord. Vous ne les remarquez peut-être pas, mais vous les utilisez tout le temps en <span name="expr-stmt">C</span>, Java, et d&rsquo;autres langages. Chaque fois que vous voyez un appel de fonction ou de méthode suivi d&rsquo;un <code>;</code>, vous regardez une instruction d&rsquo;expression.</p>
<aside name="expr-stmt">
<p>Pascal est un cas à part. Il distingue entre <em>procédures</em> et <em>fonctions</em>. Les fonctions renvoient des valeurs, mais les procédures ne le peuvent pas. Il y a une forme d&rsquo;instruction pour appeler une procédure, mais les fonctions peuvent seulement être appelées là où une expression est attendue. Il n&rsquo;y a pas d&rsquo;instructions d&rsquo;expression en Pascal.</p>
</aside></li>
<li>
<p>Une <strong>instruction <code>print</code></strong> évalue une expression et affiche le résultat à l&rsquo;utilisateur. J&rsquo;admets que c&rsquo;est bizarre d&rsquo;intégrer l&rsquo;impression directement dans le langage au lieu d&rsquo;en faire une fonction de bibliothèque. Faire ainsi est une concession au fait que nous construisons cet interpréteur un chapitre à la fois et voulons être capables de jouer avec avant qu&rsquo;il ne soit tout fini. Pour faire de print une fonction de bibliothèque, nous devrions attendre jusqu&rsquo;à ce que nous ayons toute la machinerie pour définir et appeler des fonctions <span name="print">avant</span> que nous puissions témoigner du moindre effet de bord.</p>
<aside name="print">
<p>Je noterai avec seulement un soupçon de défensive que BASIC et Python ont des instructions <code>print</code> dédiées et ce sont de vrais langages. C&rsquo;est vrai, Python a retiré son instruction <code>print</code> en 3.0<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
</aside></li>
</ol>
<p>Une nouvelle syntaxe signifie de nouvelles règles de grammaire. Dans ce chapitre, nous gagnons enfin la capacité de parser un script Lox entier. Puisque Lox est un langage impératif, typé dynamiquement, le &ldquo;niveau supérieur&rdquo; d&rsquo;un script est simplement une liste d&rsquo;instructions. Les nouvelles règles sont :</p>
<div class="codehilite"><pre><span class="i">program</span>        → <span class="i">statement</span>* <span class="t">EOF</span> ;

<span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span> ;

<span class="i">exprStmt</span>       → <span class="i">expression</span> <span class="s">&quot;;&quot;</span> ;
<span class="i">printStmt</span>      → <span class="s">&quot;print&quot;</span> <span class="i">expression</span> <span class="s">&quot;;&quot;</span> ;
</pre></div>
<p>La première règle est maintenant <code>program</code>, qui est le point de départ pour la grammaire et représente un script Lox complet ou une entrée REPL. Un programme est une liste d&rsquo;instructions suivie par le token spécial &ldquo;fin de fichier&rdquo; (EOF). Le token de fin obligatoire assure que le parseur consomme l&rsquo;entrée entière et n&rsquo;ignore pas silencieusement des tokens non consommés erronés à la fin d&rsquo;un script.</p>
<p>Pour l&rsquo;instant, <code>statement</code> a seulement deux cas pour les deux types d&rsquo;instructions que nous avons décrits. Nous en remplirons plus plus tard dans ce chapitre et dans les suivants. L&rsquo;étape suivante est de transformer cette grammaire en quelque chose que nous pouvons stocker en mémoire<span class="em">&mdash;</span>des arbres syntaxiques.</p>
<h3><a href="#arbres-syntaxiques-dinstruction" id="arbres-syntaxiques-dinstruction"><small>8&#8202;.&#8202;1&#8202;.&#8202;1</small>Arbres syntaxiques d&rsquo;instruction</a></h3>
<p>Il n&rsquo;y a aucun endroit dans la grammaire où à la fois une expression et une instruction sont autorisées. Les opérandes de, disons, <code>+</code> sont toujours des expressions, jamais des instructions. Le corps d&rsquo;une boucle <code>while</code> est toujours une instruction.</p>
<p>Puisque les deux syntaxes sont disjointes, nous n&rsquo;avons pas besoin d&rsquo;une seule classe de base dont elles héritent toutes. Séparer les expressions et les instructions dans des hiérarchies de classes séparées permet au compilateur Java de nous aider à trouver des erreurs bêtes comme passer une instruction à une méthode Java qui attend une expression.</p>
<p>Cela signifie une nouvelle classe de base pour les instructions. Comme nos aînés l&rsquo;ont fait avant nous, nous utiliserons le nom cryptique &ldquo;Stmt&rdquo;. Avec une grande <span name="foresight">prévoyance</span>, j&rsquo;ai conçu notre petit script de métaprogrammation AST en anticipation de cela. C&rsquo;est pourquoi nous avons passé &ldquo;Expr&rdquo; comme paramètre à <code>defineAst()</code>. Maintenant nous ajoutons un autre appel pour définir Stmt et ses <span name="stmt-ast">sous-classes</span>.</p>
<aside name="foresight">
<p>Pas vraiment de la prévoyance : j&rsquo;ai écrit tout le code pour le livre avant de le découper en chapitres.</p>
</aside>
<div class="codehilite"><pre class="insert-before">      &quot;Unary    : Token operator, Expr right&quot;
    ));
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">

    <span class="i">defineAst</span>(<span class="i">outputDir</span>, <span class="s">&quot;Stmt&quot;</span>, <span class="t">Arrays</span>.<span class="i">asList</span>(
      <span class="s">&quot;Expression : Expr expression&quot;</span>,
      <span class="s">&quot;Print      : Expr expression&quot;</span>
    ));
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="stmt-ast">
<p>Le code généré pour les nouveaux nœuds est dans l&rsquo;<a href="appendix-ii.html">Annexe II</a> : <a href="appendix-ii.html#expression-statement">Instruction d&rsquo;expression</a>, <a href="appendix-ii.html#print-statement">Instruction print</a>.</p>
</aside>
<p>Exécutez le script générateur d&rsquo;AST et contemplez le fichier &ldquo;Stmt.java&rdquo; résultant avec les classes d&rsquo;arbre syntaxique dont nous avons besoin pour l&rsquo;expression et les instructions <code>print</code>. N&rsquo;oubliez pas d&rsquo;ajouter le fichier à votre projet IDE ou makefile ou peu importe.</p>
<h3><a href="#parser-les-instructions" id="parser-les-instructions"><small>8&#8202;.&#8202;1&#8202;.&#8202;2</small>Parser les instructions</a></h3>
<p>La méthode <code>parse()</code> du parseur qui parse et renvoie une seule expression était un hack temporaire pour avoir le dernier chapitre opérationnel. Maintenant que notre grammaire a la règle de départ correcte, <code>program</code>, nous pouvons transformer <code>parse()</code> en la vraie affaire.</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
method <em>parse</em>()<br>
replace 7 lines</div>
<pre>  <span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">parse</span>() {
    <span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">statements</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();
    <span class="k">while</span> (!<span class="i">isAtEnd</span>()) {
      <span class="i">statements</span>.<span class="i">add</span>(<span class="i">statement</span>());
    }

    <span class="k">return</span> <span class="i">statements</span>;<span name="parse-error-handling"> </span>
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, method <em>parse</em>(), replace 7 lines</div>

<aside name="parse-error-handling">
<p>Qu&rsquo;en est-il du code que nous avions ici pour attraper les exceptions <code>ParseError</code> ? Nous mettrons une meilleure gestion d&rsquo;erreur de parsing en place bientôt quand nous ajouterons le support pour des types d&rsquo;instruction supplémentaires.</p>
</aside>
<p>Ceci parse une série d&rsquo;instructions, autant qu&rsquo;il peut en trouver jusqu&rsquo;à ce qu&rsquo;il frappe la fin de l&rsquo;entrée. C&rsquo;est une traduction assez directe de la règle <code>program</code> en style descente récursive. Nous devons aussi chanter une prière mineure aux dieux de la verbosité Java puisque nous utilisons ArrayList maintenant.</p>
<div class="codehilite"><pre class="insert-before">package com.craftinginterpreters.lox;

</pre><div class="source-file"><em>lox/Parser.java</em></div>
<pre class="insert"><span class="k">import</span> <span class="i">java.util.ArrayList</span>;
</pre><pre class="insert-after">import java.util.List;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em></div>

<p>Un programme est une liste d&rsquo;instructions, et nous parsons une de ces instructions en utilisant cette méthode :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>expression</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">statement</span>() {
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">PRINT</span>)) <span class="k">return</span> <span class="i">printStatement</span>();

    <span class="k">return</span> <span class="i">expressionStatement</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>expression</em>()</div>

<p>Un peu squelettique, mais nous le remplirons avec plus de types d&rsquo;instruction plus tard. Nous déterminons quelle règle d&rsquo;instruction spécifique est matchée en regardant le token courant. Un token <code>print</code> signifie que c&rsquo;est évidemment une instruction <code>print</code>.</p>
<p>Si le prochain token ne ressemble à aucun type connu d&rsquo;instruction, nous supposons que ce doit être une instruction d&rsquo;expression. C&rsquo;est le cas par défaut typique final lors du parsing d&rsquo;une instruction, puisqu&rsquo;il est difficile de reconnaître proactivement une expression à partir de son premier token.</p>
<p>Chaque type d&rsquo;instruction obtient sa propre méthode. D&rsquo;abord <code>print</code> :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>statement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">printStatement</span>() {
    <span class="t">Expr</span> <span class="i">value</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after value.&quot;</span>);
    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Print</span>(<span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>statement</em>()</div>

<p>Puisque nous avons déjà matché et consommé le token <code>print</code> lui-même, nous n&rsquo;avons pas besoin de faire cela ici. Nous parsons l&rsquo;expression subséquente, consommons le point-virgule terminal, et émettons l&rsquo;arbre syntaxique.</p>
<p>Si nous n&rsquo;avons pas matché une instruction <code>print</code>, nous devons avoir une de celles-ci :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>printStatement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">expressionStatement</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after expression.&quot;</span>);
    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Expression</span>(<span class="i">expr</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>printStatement</em>()</div>

<p>Similaire à la méthode précédente, nous parsons une expression suivie par un point-virgule. Nous enveloppons cette Expr dans une Stmt du bon type et la renvoyons.</p>
<h3><a href="#exécuter-les-instructions" id="exécuter-les-instructions"><small>8&#8202;.&#8202;1&#8202;.&#8202;3</small>Exécuter les instructions</a></h3>
<p>Nous parcourons les quelques chapitres précédents en microcosme, en faisant notre chemin à travers le front end. Notre parseur peut maintenant produire des arbres syntaxiques d&rsquo;instruction, donc la prochaine et dernière étape est de les interpréter. Comme dans les expressions, nous utilisons le patron Visiteur, mais nous avons une nouvelle interface visiteur, Stmt.Visitor, à implémenter puisque les instructions ont leur propre classe de base.</p>
<p>Nous ajoutons cela à la liste des interfaces que Interpreter implémente.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
replace 1 line</div>
<pre class="insert"><span class="k">class</span> <span class="t">Interpreter</span> <span class="k">implements</span> <span class="t">Expr</span>.<span class="t">Visitor</span>&lt;<span class="t">Object</span>&gt;,
                             <span class="t">Stmt</span>.<span class="t">Visitor</span>&lt;<span class="t">Void</span>&gt; {
</pre><pre class="insert-after">  void interpret(Expr expression) {<span name="void"> </span>
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, replace 1 line</div>

<aside name="void">
<p>Java ne vous laisse pas utiliser le &ldquo;void&rdquo; minuscule comme argument de type générique pour des raisons obscures ayant à voir avec l&rsquo;effacement de type (type erasure) et la pile. Au lieu de cela, il y a un type &ldquo;Void&rdquo; séparé spécifiquement pour cet usage. Sorte de &ldquo;void boxé&rdquo;, comme &ldquo;Integer&rdquo; l&rsquo;est pour &ldquo;int&rdquo;.</p>
</aside>
<p>Contrairement aux expressions, les instructions ne produisent aucune valeur, donc le type de retour des méthodes visit est Void, pas Object. Nous avons deux types d&rsquo;instruction, et nous avons besoin d&rsquo;une méthode visit pour chaque. La plus facile est les instructions d&rsquo;expression.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>evaluate</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitExpressionStmt</span>(<span class="t">Stmt</span>.<span class="t">Expression</span> <span class="i">stmt</span>) {
    <span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">expression</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>evaluate</em>()</div>

<p>Nous évaluons l&rsquo;expression interne en utilisant notre méthode <code>evaluate()</code> existante et <span name="discard">rejetons</span> la valeur. Ensuite nous renvoyons <code>null</code>. Java exige cela pour satisfaire le type de retour spécial Void avec majuscule. Bizarre, mais que pouvez-vous faire ?</p>
<aside name="discard">
<p>De manière assez appropriée, nous rejetons la valeur renvoyée par <code>evaluate()</code> en plaçant cet appel à l&rsquo;intérieur d&rsquo;une instruction d&rsquo;expression <em>Java</em>.</p>
</aside>
<p>La méthode visit de l&rsquo;instruction <code>print</code> n&rsquo;est pas très différente.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitExpressionStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitPrintStmt</span>(<span class="t">Stmt</span>.<span class="t">Print</span> <span class="i">stmt</span>) {
    <span class="t">Object</span> <span class="i">value</span> = <span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">expression</span>);
    <span class="t">System</span>.<span class="i">out</span>.<span class="i">println</span>(<span class="i">stringify</span>(<span class="i">value</span>));
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitExpressionStmt</em>()</div>

<p>Avant de rejeter la valeur de l&rsquo;expression, nous la convertissons en une chaîne en utilisant la méthode <code>stringify()</code> que nous avons introduite dans le dernier chapitre et ensuite la déversons sur la sortie standard (stdout).</p>
<p>Notre interpréteur est capable de visiter des instructions maintenant, mais nous avons un peu de travail à faire pour les lui donner à manger. D&rsquo;abord, modifiez la vieille méthode <code>interpret()</code> dans la classe Interpreter pour accepter une liste d&rsquo;instructions<span class="em">&mdash;</span>en d&rsquo;autres termes, un programme.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
method <em>interpret</em>()<br>
replace 8 lines</div>
<pre>  <span class="t">void</span> <span class="i">interpret</span>(<span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">statements</span>) {
    <span class="k">try</span> {
      <span class="k">for</span> (<span class="t">Stmt</span> <span class="i">statement</span> : <span class="i">statements</span>) {
        <span class="i">execute</span>(<span class="i">statement</span>);
      }
    } <span class="k">catch</span> (<span class="t">RuntimeError</span> <span class="i">error</span>) {
      <span class="t">Lox</span>.<span class="i">runtimeError</span>(<span class="i">error</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, method <em>interpret</em>(), replace 8 lines</div>

<p>Ceci remplace l&rsquo;ancien code qui prenait une seule expression. Le nouveau code repose sur cette minuscule méthode d&rsquo;aide :</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>evaluate</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">execute</span>(<span class="t">Stmt</span> <span class="i">stmt</span>) {
    <span class="i">stmt</span>.<span class="i">accept</span>(<span class="k">this</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>evaluate</em>()</div>

<p>C&rsquo;est l&rsquo;analogue pour l&rsquo;instruction de la méthode <code>evaluate()</code> que nous avons pour les expressions. Puisque nous travaillons avec des listes maintenant, nous avons besoin de le faire savoir à Java.</p>
<div class="codehilite"><pre class="insert-before">package com.craftinginterpreters.lox;
</pre><div class="source-file"><em>lox/Interpreter.java</em></div>
<pre class="insert">

<span class="k">import</span> <span class="i">java.util.List</span>;
</pre><pre class="insert-after">

class Interpreter implements Expr.Visitor&lt;Object&gt;,
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em></div>

<p>La classe principale Lox essaie toujours de parser une seule expression et de la passer à l&rsquo;interpréteur. Nous corrigeons la ligne de parsing comme ceci :</p>
<div class="codehilite"><pre class="insert-before">    Parser parser = new Parser(tokens);
</pre><div class="source-file"><em>lox/Lox.java</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">statements</span> = <span class="i">parser</span>.<span class="i">parse</span>();
</pre><pre class="insert-after">

    // Stop if there was a syntax error.
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>run</em>(), replace 1 line</div>

<p>Et ensuite remplaçons l&rsquo;appel à l&rsquo;interpréteur par ceci :</p>
<div class="codehilite"><pre class="insert-before">    if (hadError) return;

</pre><div class="source-file"><em>lox/Lox.java</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">interpreter</span>.<span class="i">interpret</span>(<span class="i">statements</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>run</em>(), replace 1 line</div>

<p>Fondamentalement juste faire passer la nouvelle syntaxe dans la tuyauterie. OK, démarrez l&rsquo;interpréteur et donnez-lui un essai. À ce stade, cela vaut la peine d&rsquo;esquisser un petit programme Lox dans un fichier texte pour l&rsquo;exécuter comme un script. Quelque chose comme :</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="s">&quot;un&quot;</span>;
<span class="k">print</span> <span class="k">true</span>;
<span class="k">print</span> <span class="n">2</span> + <span class="n">1</span>;
</pre></div>
<p>Cela ressemble presque à un vrai programme ! Notez que le REPL, aussi, exige maintenant que vous entriez une instruction complète au lieu d&rsquo;une simple expression. N&rsquo;oubliez pas vos points-virgules.</p>
<h2><a href="#variables-globales" id="variables-globales"><small>8&#8202;.&#8202;2</small>Variables Globales</a></h2>
<p>Maintenant que nous avons des instructions, nous pouvons commencer à travailler sur l&rsquo;état. Avant que nous entrions dans toute la complexité de la portée lexicale, nous commencerons avec le type le plus facile de variables<span class="em">&mdash;</span>les <span name="globals">globales</span>. Nous avons besoin de deux nouvelles constructions.</p>
<ol>
<li>
<p>Une instruction de <strong>déclaration de variable</strong> amène une nouvelle variable au monde.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">beverage</span> = <span class="s">&quot;espresso&quot;</span>;
</pre></div>
<p>Ceci crée une nouvelle liaison qui associe un nom (ici &ldquo;beverage&rdquo;) avec une valeur (ici, la chaîne <code>"espresso"</code>).</p>
</li>
<li>
<p>Une fois que c&rsquo;est fait, une <strong>expression de variable</strong> accède à cette liaison. Quand l&rsquo;identifiant &ldquo;beverage&rdquo; est utilisé comme une expression, il cherche la valeur liée à ce nom et la renvoie.</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="i">beverage</span>; <span class="c">// &quot;espresso&quot;.</span>
</pre></div>
</li>
</ol>
<p>Plus tard, nous ajouterons l&rsquo;affectation et la portée de bloc, mais c&rsquo;est assez pour commencer à bouger.</p>
<aside name="globals">
<p>L&rsquo;état global a mauvaise réputation. Bien sûr, beaucoup d&rsquo;état global<span class="em">&mdash;</span>surtout l&rsquo;état <em>mutable</em><span class="em">&mdash;</span>rend difficile la maintenance de gros programmes. C&rsquo;est une bonne ingénierie logicielle de minimiser combien vous en utilisez.</p>
<p>Mais quand vous bricolez un langage de programmation simple ou, zut, même apprenez votre premier langage, la simplicité plate des variables globales aide. Mon premier langage était le BASIC et, bien que je l&rsquo;ai dépassé finalement, c&rsquo;était agréable que je n&rsquo;aie pas à me prendre la tête avec les règles de portée avant que je puisse faire faire des trucs amusants à un ordinateur.</p>
</aside>
<h3><a href="#syntaxe-de-variable" id="syntaxe-de-variable"><small>8&#8202;.&#8202;2&#8202;.&#8202;1</small>Syntaxe de variable</a></h3>
<p>Comme avant, nous travaillerons à travers l&rsquo;implémentation de l&rsquo;avant vers l&rsquo;arrière, en commençant par la syntaxe. Les déclarations de variable sont des instructions, mais elles sont différentes des autres instructions, et nous allons diviser la grammaire des instructions en deux pour les gérer. C&rsquo;est parce que la grammaire restreint où certains types d&rsquo;instructions sont autorisés.</p>
<p>Les clauses dans les instructions de contrôle de flux<span class="em">&mdash;</span>pensez aux branches then et else d&rsquo;une instruction <code>if</code> ou le corps d&rsquo;un <code>while</code><span class="em">&mdash;</span>sont chacune une instruction unique. Mais cette instruction n&rsquo;est pas autorisée à être une qui déclare un nom. Ceci est OK :</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">monday</span>) <span class="k">print</span> <span class="s">&quot;Ugh, déjà ?&quot;</span>;
</pre></div>
<p>Mais ceci ne l&rsquo;est pas :</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">monday</span>) <span class="k">var</span> <span class="i">beverage</span> = <span class="s">&quot;espresso&quot;</span>;
</pre></div>
<p>Nous <em>pourrions</em> autoriser ce dernier, mais c&rsquo;est confus. Quelle est la portée de cette variable <code>beverage</code> ? Persiste-t-elle après l&rsquo;instruction <code>if</code> ? Si oui, quelle est sa valeur les jours autres que lundi ? La variable existe-t-elle tout court ces jours-là ?</p>
<p>Du code comme celui-ci est bizarre, donc C, Java, et consorts l&rsquo;interdisent tous. C&rsquo;est comme s&rsquo;il y avait deux niveaux de <span name="brace">&ldquo;précédence&rdquo;</span> pour les instructions. Certains endroits où une instruction est autorisée<span class="em">&mdash;</span>comme à l&rsquo;intérieur d&rsquo;un bloc ou au niveau supérieur<span class="em">&mdash;</span>autorisent n&rsquo;importe quel type d&rsquo;instruction, y compris les déclarations. D&rsquo;autres autorisent seulement les instructions de &ldquo;plus haute&rdquo; précédence qui ne déclarent pas de noms.</p>
<aside name="brace">
<p>Dans cette analogie, les instructions de bloc fonctionnent un peu comme les parenthèses pour les expressions. Un bloc est lui-même dans le niveau de précédence &ldquo;plus haut&rdquo; et peut être utilisé n&rsquo;importe où, comme dans les clauses d&rsquo;une instruction <code>if</code>. Mais les instructions qu&rsquo;il <em>contient</em> peuvent être de plus basse précédence. Vous êtes autorisé à déclarer des variables et d&rsquo;autres noms à l&rsquo;intérieur du bloc. Les accolades vous laissent vous échapper de nouveau vers la grammaire d&rsquo;instructions complète depuis un endroit où seules certaines instructions sont autorisées.</p>
</aside>
<p>Pour accommoder la distinction, nous ajoutons une autre règle pour les types d&rsquo;instructions qui déclarent des noms.</p>
<div class="codehilite"><pre><span class="i">program</span>        → <span class="i">declaration</span>* <span class="t">EOF</span> ;

<span class="i">declaration</span>    → <span class="i">varDecl</span>
               | <span class="i">statement</span> ;

<span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span> ;
</pre></div>
<p>Les instructions de déclaration vont sous la nouvelle règle <code>declaration</code>. Pour l&rsquo;instant, c&rsquo;est seulement les variables, mais plus tard cela inclura les fonctions et les classes. N&rsquo;importe quel endroit où une déclaration est autorisée permet aussi les instructions non-déclarantes, donc la règle <code>declaration</code> tombe vers <code>statement</code>. Évidemment, vous pouvez déclarer des trucs au niveau supérieur d&rsquo;un script, donc <code>program</code> route vers la nouvelle règle.</p>
<p>La règle pour déclarer une variable ressemble à :</p>
<div class="codehilite"><pre><span class="i">varDecl</span>        → <span class="s">&quot;var&quot;</span> <span class="t">IDENTIFIER</span> ( <span class="s">&quot;=&quot;</span> <span class="i">expression</span> )? <span class="s">&quot;;&quot;</span> ;
</pre></div>
<p>Comme la plupart des instructions, elle commence par un mot-clé de tête. Dans ce cas, <code>var</code>. Ensuite un token identifiant pour le nom de la variable étant déclarée, suivi par une expression d&rsquo;initialisation optionnelle. Finalement, nous mettons un nœud dessus avec le point-virgule.</p>
<p>Pour accéder à une variable, nous définissons un nouveau type d&rsquo;expression primaire.</p>
<div class="codehilite"><pre><span class="i">primary</span>        → <span class="s">&quot;true&quot;</span> | <span class="s">&quot;false&quot;</span> | <span class="s">&quot;nil&quot;</span>
               | <span class="t">NUMBER</span> | <span class="t">STRING</span>
               | <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span>
               | <span class="t">IDENTIFIER</span> ;
</pre></div>
<p>Cette clause <code>IDENTIFIER</code> matche un seul token identifiant, qui est compris comme être le nom de la variable à laquelle on accède.</p>
<p>Ces nouvelles règles de grammaire obtiennent leurs arbres syntaxiques correspondants. Là-bas dans le générateur d&rsquo;AST, nous ajoutons un <span name="var-stmt-ast">nouveau nœud d&rsquo;instruction</span> pour une déclaration de variable.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Expression : Expr expression&quot;,
</pre><pre class="insert-before">      <span class="s">&quot;Print      : Expr expression&quot;</span><span class="insert-comma">,</span>
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()<br>
add <em>&ldquo;,&rdquo;</em> to previous line</div>
<pre class="insert">      <span class="s">&quot;Var        : Token name, Expr initializer&quot;</span>
</pre><pre class="insert-after">    ));
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>(), add <em>&ldquo;,&rdquo;</em> to previous line</div>

<aside name="var-stmt-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#variable-statement">Annexe II</a>.</p>
</aside>
<p>Il stocke le token de nom pour que nous sachions ce qu&rsquo;il déclare, avec l&rsquo;expression d&rsquo;initialisation. (S&rsquo;il n&rsquo;y a pas d&rsquo;initialiseur, ce champ est <code>null</code>.)</p>
<p>Puis nous ajoutons un nœud d&rsquo;expression pour accéder à une variable.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Literal  : Object value&quot;,
</pre><pre class="insert-before">      <span class="s">&quot;Unary    : Token operator, Expr right&quot;</span><span class="insert-comma">,</span>
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()<br>
add <em>&ldquo;,&rdquo;</em> to previous line</div>
<pre class="insert">      <span class="s">&quot;Variable : Token name&quot;</span>
</pre><pre class="insert-after">    ));
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>(), add <em>&ldquo;,&rdquo;</em> to previous line</div>

<p><span name="var-expr-ast">C&rsquo;est</span> simplement une enveloppe autour du token pour le nom de la variable. C&rsquo;est tout. Comme toujours, n&rsquo;oubliez pas d&rsquo;exécuter le script générateur d&rsquo;AST pour que vous obteniez des fichiers &ldquo;Expr.java&rdquo; et &ldquo;Stmt.java&rdquo; mis à jour.</p>
<aside name="var-expr-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#variable-expression">Annexe II</a>.</p>
</aside>
<h3><a href="#parser-les-variables" id="parser-les-variables"><small>8&#8202;.&#8202;2&#8202;.&#8202;2</small>Parser les variables</a></h3>
<p>Avant de parser les instructions de variable, nous avons besoin de bouger un peu de code pour faire de la place pour la nouvelle règle <code>declaration</code> dans la grammaire. Le niveau supérieur d&rsquo;un programme est maintenant une liste de déclarations, donc la méthode point d&rsquo;entrée vers le parseur change.</p>
<div class="codehilite"><pre class="insert-before">  List&lt;Stmt&gt; parse() {
    List&lt;Stmt&gt; statements = new ArrayList&lt;&gt;();
    while (!isAtEnd()) {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>parse</em>()<br>
replace 1 line</div>
<pre class="insert">      <span class="i">statements</span>.<span class="i">add</span>(<span class="i">declaration</span>());
</pre><pre class="insert-after">    }

    return statements;<span name="parse-error-handling"> </span>
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>parse</em>(), replace 1 line</div>

<p>Cela appelle cette nouvelle méthode :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>expression</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">declaration</span>() {
    <span class="k">try</span> {
      <span class="k">if</span> (<span class="i">match</span>(<span class="i">VAR</span>)) <span class="k">return</span> <span class="i">varDeclaration</span>();

      <span class="k">return</span> <span class="i">statement</span>();
    } <span class="k">catch</span> (<span class="t">ParseError</span> <span class="i">error</span>) {
      <span class="i">synchronize</span>();
      <span class="k">return</span> <span class="k">null</span>;
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>expression</em>()</div>

<p>Hé, vous souvenez-vous loin en arrière dans ce <a href="parsing-expressions.html">chapitre précédent</a> quand nous avons mis l&rsquo;infrastructure en place pour faire la récupération d&rsquo;erreur ? Nous sommes enfin prêts à brancher cela.</p>
<p>Cette méthode <code>declaration()</code> est la méthode que nous appelons de manière répétée lors du parsing d&rsquo;une série d&rsquo;instructions dans un bloc ou un script, donc c&rsquo;est le bon endroit pour synchroniser quand le parseur entre en mode panique. Tout le corps de cette méthode est enveloppé dans un bloc try pour attraper l&rsquo;exception lancée quand le parseur commence la récupération d&rsquo;erreur. Cela le ramène à essayer de parser le début de l&rsquo;instruction ou déclaration suivante.</p>
<p>Le vrai parsing se passe à l&rsquo;intérieur du bloc try. D&rsquo;abord, il regarde pour voir si nous sommes à une déclaration de variable en cherchant le mot-clé <code>var</code> de tête. Si non, il tombe dans la méthode <code>statement()</code> existante qui parse <code>print</code> et les instructions d&rsquo;expression.</p>
<p>Rappelez-vous comment <code>statement()</code> essaie de parser une instruction d&rsquo;expression si aucune autre instruction ne matche ? Et <code>expression()</code> rapporte une erreur de syntaxe si elle ne peut pas parser une expression au token courant ? Cette chaîne d&rsquo;appels assure que nous rapportons une erreur si une déclaration ou instruction valide n&rsquo;est pas parsée.</p>
<p>Quand le parseur matche un token <code>var</code>, il branche vers :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>printStatement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">varDeclaration</span>() {
    <span class="t">Token</span> <span class="i">name</span> = <span class="i">consume</span>(<span class="i">IDENTIFIER</span>, <span class="s">&quot;Expect variable name.&quot;</span>);

    <span class="t">Expr</span> <span class="i">initializer</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">EQUAL</span>)) {
      <span class="i">initializer</span> = <span class="i">expression</span>();
    }

    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after variable declaration.&quot;</span>);
    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Var</span>(<span class="i">name</span>, <span class="i">initializer</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>printStatement</em>()</div>

<p>Comme toujours, le code de descente récursive suit la règle de grammaire. Le parseur a déjà matché le token <code>var</code>, donc ensuite il exige et consomme un token identifiant pour le nom de la variable.</p>
<p>Puis, s&rsquo;il voit un token <code>=</code>, il sait qu&rsquo;il y a une expression d&rsquo;initialisation et la parse. Sinon, il laisse l&rsquo;initialiseur à <code>null</code>. Finalement, il consomme le point-virgule requis à la fin de l&rsquo;instruction. Tout cela est enveloppé dans un nœud d&rsquo;arbre syntaxique Stmt.Var et nous sommes groovy.</p>
<p>Parser une expression de variable est encore plus facile. Dans <code>primary()</code>, nous cherchons un token identifiant.</p>
<div class="codehilite"><pre class="insert-before">      return new Expr.Literal(previous().literal);
    }
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>primary</em>()</div>
<pre class="insert">

    <span class="k">if</span> (<span class="i">match</span>(<span class="i">IDENTIFIER</span>)) {
      <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Variable</span>(<span class="i">previous</span>());
    }
</pre><pre class="insert-after">

    if (match(LEFT_PAREN)) {
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>primary</em>()</div>

<p>Cela nous donne un front end fonctionnel pour déclarer et utiliser des variables. Tout ce qui reste est de le donner à manger à l&rsquo;interpréteur. Avant que nous arrivions à cela, nous devons parler de l&rsquo;endroit où les variables vivent en mémoire.</p>
<h2><a href="#environnements" id="environnements"><small>8&#8202;.&#8202;3</small>Environnements</a></h2>
<p>Les liaisons qui associent des variables à des valeurs ont besoin d&rsquo;être stockées quelque part. Depuis que les gens de Lisp ont inventé les parenthèses, cette structure de données a été appelée un <span name="env"><strong>environnement</strong></span>.</p><img src="image/statements-and-state/environment.png" alt="Un environnement contenant deux liaisons." />
<aside name="env">
<p>J&rsquo;aime imaginer l&rsquo;environnement littéralement, comme un pays des merveilles sylvestre où les variables et les valeurs gambadent.</p>
</aside>
<p>Vous pouvez penser à cela comme une <span name="map">map</span> où les clés sont les noms de variables et les valeurs sont les valeurs de la variable, euh, valeurs. En fait, c&rsquo;est comme ça que nous l&rsquo;implémenterons en Java. Nous pourrions fourrer cette map et le code pour la gérer directement dans Interpreter, mais puisqu&rsquo;elle forme un concept joliment délimité, nous la sortirons dans sa propre classe.</p>
<p>Commencez un nouveau fichier et ajoutez :</p>
<aside name="map">
<p>Java les appelle <strong>maps</strong> ou <strong>hashmaps</strong>. D&rsquo;autres langages les appellent <strong>tables de hachage</strong>, <strong>dictionnaires</strong> (Python et C#), <strong>hashes</strong> (Ruby et Perl), <strong>tables</strong> (Lua), ou <strong>tableaux associatifs</strong> (PHP). Très loin dans le temps, elles étaient connues comme <strong>scatter tables</strong> (tables de dispersion).</p>
</aside>
<div class="codehilite"><div class="source-file"><em>lox/Environment.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.HashMap</span>;
<span class="k">import</span> <span class="i">java.util.Map</span>;

<span class="k">class</span> <span class="t">Environment</span> {
  <span class="k">private</span> <span class="k">final</span> <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">Object</span>&gt; <span class="i">values</span> = <span class="k">new</span> <span class="t">HashMap</span>&lt;&gt;();
}
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, create new file</div>

<p>Il y a une Map Java là-dedans pour stocker les liaisons. Elle utilise des chaînes nues pour les clés, pas des tokens. Un token représente une unité de code à un endroit spécifique dans le texte source, mais quand il s&rsquo;agit de chercher des variables, tous les tokens identifiants avec le même nom devraient se référer à la même variable (en ignorant la portée pour l&rsquo;instant). Utiliser la chaîne brute assure que tous ces tokens se réfèrent à la même clé de map.</p>
<p>Il y a deux opérations que nous devons supporter. D&rsquo;abord, une définition de variable lie un nouveau nom à une valeur.</p>
<div class="codehilite"><div class="source-file"><em>lox/Environment.java</em><br>
in class <em>Environment</em></div>
<pre>  <span class="t">void</span> <span class="i">define</span>(<span class="t">String</span> <span class="i">name</span>, <span class="t">Object</span> <span class="i">value</span>) {
    <span class="i">values</span>.<span class="i">put</span>(<span class="i">name</span>, <span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, in class <em>Environment</em></div>

<p>Pas exactement de la chirurgie du cerveau, mais nous avons fait un choix sémantique intéressant. Quand nous ajoutons la clé à la map, nous ne vérifions pas pour voir si elle est déjà présente. Cela signifie que ce programme fonctionne :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;avant&quot;</span>;
<span class="k">print</span> <span class="i">a</span>; <span class="c">// &quot;avant&quot;.</span>
<span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;après&quot;</span>;
<span class="k">print</span> <span class="i">a</span>; <span class="c">// &quot;après&quot;.</span>
</pre></div>
<p>Une instruction de variable ne définit pas juste une <em>nouvelle</em> variable, elle peut aussi être utilisée pour <em>re</em>définir une variable existante. Nous pourrions <span name="scheme">choisir</span> de faire de cela une erreur à la place. L&rsquo;utilisateur peut ne pas avoir l&rsquo;intention de redéfinir une variable existante. (S&rsquo;ils le voulaient, ils auraient probablement utilisé l&rsquo;affectation, pas <code>var</code>.) Faire de la redéfinition une erreur les aiderait à trouver ce bug.</p>
<p>Cependant, faire ainsi interagit mal avec le REPL. Au milieu d&rsquo;une session REPL, c&rsquo;est agréable de ne pas avoir à suivre mentalement quelles variables vous avez déjà définies. Nous pourrions autoriser la redéfinition dans le REPL mais pas dans les scripts, mais alors les utilisateurs devraient apprendre deux ensembles de règles, et le code copié et collé d&rsquo;une forme à l&rsquo;autre pourrait ne pas fonctionner.</p>
<aside name="scheme">
<p>Ma règle à propos des variables et de la portée est, &ldquo;Dans le doute, fais ce que Scheme fait&rdquo;. Les gens de Scheme ont probablement passé plus de temps à penser à la portée des variables que nous ne le ferons jamais<span class="em">&mdash;</span>l&rsquo;un des buts principaux de Scheme était d&rsquo;introduire la portée lexicale au monde<span class="em">&mdash;</span>donc il est difficile de se tromper si vous suivez leurs traces.</p>
<p>Scheme autorise la redéfinition de variables au niveau supérieur.</p>
</aside>
<p>Donc, pour garder les deux modes cohérents, nous l&rsquo;autoriserons<span class="em">&mdash;</span>au moins pour les variables globales. Une fois qu&rsquo;une variable existe, nous avons besoin d&rsquo;un moyen de la chercher.</p>
<div class="codehilite"><pre class="insert-before">class Environment {
  private final Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
</pre><div class="source-file"><em>lox/Environment.java</em><br>
in class <em>Environment</em></div>
<pre class="insert">

  <span class="t">Object</span> <span class="i">get</span>(<span class="t">Token</span> <span class="i">name</span>) {
    <span class="k">if</span> (<span class="i">values</span>.<span class="i">containsKey</span>(<span class="i">name</span>.<span class="i">lexeme</span>)) {
      <span class="k">return</span> <span class="i">values</span>.<span class="i">get</span>(<span class="i">name</span>.<span class="i">lexeme</span>);
    }

    <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">name</span>,
        <span class="s">&quot;Undefined variable &#39;&quot;</span> + <span class="i">name</span>.<span class="i">lexeme</span> + <span class="s">&quot;&#39;.&quot;</span>);
  }

</pre><pre class="insert-after">  void define(String name, Object value) {
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, in class <em>Environment</em></div>

<p>Ceci est un peu plus sémantiquement intéressant. Si la variable est trouvée, elle renvoie simplement la valeur liée à elle. Mais qu&rsquo;en est-il si elle ne l&rsquo;est pas ? Encore une fois, nous avons un choix :</p>
<ul>
<li>
<p>En faire une erreur de syntaxe.</p>
</li>
<li>
<p>En faire une erreur d&rsquo;exécution.</p>
</li>
<li>
<p>L&rsquo;autoriser et renvoyer une certaine valeur par défaut comme <code>nil</code>.</p>
</li>
</ul>
<p>Lox est assez laxiste, mais la dernière option est un peu <em>trop</em> permissive pour moi. En faire une erreur de syntaxe<span class="em">&mdash;</span>une erreur à la compilation<span class="em">&mdash;</span>semble être un choix intelligent. Utiliser une variable indéfinie est un bug, et plus tôt vous détectez l&rsquo;erreur, mieux c&rsquo;est.</p>
<p>Le problème est qu&rsquo;<em>utiliser</em> une variable n&rsquo;est pas la même chose que s&rsquo;y <em>référer</em>. Vous pouvez vous référer à une variable dans un morceau de code sans l&rsquo;évaluer immédiatement si ce morceau de code est enveloppé à l&rsquo;intérieur d&rsquo;une fonction. Si nous en faisons une erreur statique de <em>mentionner</em> une variable avant qu&rsquo;elle ait été déclarée, cela devient beaucoup plus difficile de définir des fonctions récursives.</p>
<p>Nous pourrions accommoder la récursion simple<span class="em">&mdash;</span>une fonction qui s&rsquo;appelle elle-même<span class="em">&mdash;</span>en déclarant le propre nom de la fonction avant que nous examinions son corps. Mais cela n&rsquo;aide pas avec les procédures mutuellement récursives qui s&rsquo;appellent l&rsquo;une l&rsquo;autre. Considérez :</p>
<p><span name="contrived"></span></p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">isOdd</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> == <span class="n">0</span>) <span class="k">return</span> <span class="k">false</span>;
  <span class="k">return</span> <span class="i">isEven</span>(<span class="i">n</span> - <span class="n">1</span>);
}

<span class="k">fun</span> <span class="i">isEven</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> == <span class="n">0</span>) <span class="k">return</span> <span class="k">true</span>;
  <span class="k">return</span> <span class="i">isOdd</span>(<span class="i">n</span> - <span class="n">1</span>);
}
</pre></div>
<aside name="contrived">
<p>Il est vrai que ce n&rsquo;est probablement pas la façon la plus efficace de dire si un nombre est pair ou impair (sans mentionner les mauvaises choses qui arrivent si vous leur passez un non-entier ou un nombre négatif). Soyez indulgents avec moi.</p>
</aside>
<p>La fonction <code>isEven()</code> n&rsquo;est pas définie au <span name="declare">moment</span> où nous regardons le corps de <code>isOdd()</code> où elle est appelée. Si nous échangeons l&rsquo;ordre des deux fonctions, alors <code>isOdd()</code> n&rsquo;est pas définie quand nous regardons le corps de <code>isEven()</code>.</p>
<aside name="declare">
<p>Certains langages typés statiquement comme Java et C# résolvent cela en spécifiant que le niveau supérieur d&rsquo;un programme n&rsquo;est pas une séquence d&rsquo;instructions impératives. Au lieu de cela, un programme est un ensemble de déclarations qui viennent toutes à l&rsquo;existence simultanément. L&rsquo;implémentation déclare <em>tous</em> les noms avant de regarder les corps de <em>n&rsquo;importe quelle</em> fonction.</p>
<p>Des langages plus vieux comme C et Pascal ne fonctionnent pas comme ça. Au lieu de cela, ils vous forcent à ajouter des <em>déclarations anticipées</em> (forward declarations) explicites pour déclarer un nom avant qu&rsquo;il soit entièrement défini. C&rsquo;était une concession à la puissance de calcul limitée à l&rsquo;époque. Ils voulaient être capables de compiler un fichier source en une seule passe à travers le texte, donc ces compilateurs ne pouvaient pas rassembler toutes les déclarations d&rsquo;abord avant de traiter les corps de fonction.</p>
</aside>
<p>Puisque en faire une erreur <em>statique</em> rend les déclarations récursives trop difficiles, nous différerons l&rsquo;erreur à l&rsquo;exécution. C&rsquo;est OK de se référer à une variable avant qu&rsquo;elle soit définie tant que vous n&rsquo;<em>évaluez</em> pas la référence. Cela laisse le programme pour les nombres pairs et impairs fonctionner, mais vous obtiendriez une erreur d&rsquo;exécution dans :</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="i">a</span>;
<span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;trop tard !&quot;</span>;
</pre></div>
<p>Comme avec les erreurs de type dans le code d&rsquo;évaluation d&rsquo;expression, nous rapportons une erreur d&rsquo;exécution en lançant une exception. L&rsquo;exception contient le token de la variable pour que nous puissions dire à l&rsquo;utilisateur où dans son code il a fait une erreur.</p>
<h3><a href="#interpréter-les-variables-globales" id="interpréter-les-variables-globales"><small>8&#8202;.&#8202;3&#8202;.&#8202;1</small>Interpréter les variables globales</a></h3>
<p>La classe Interpreter obtient une instance de la nouvelle classe Environment.</p>
<div class="codehilite"><pre class="insert-before">class Interpreter implements Expr.Visitor&lt;Object&gt;,
                             Stmt.Visitor&lt;Void&gt; {
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in class <em>Interpreter</em></div>
<pre class="insert">  <span class="k">private</span> <span class="t">Environment</span> <span class="i">environment</span> = <span class="k">new</span> <span class="t">Environment</span>();

</pre><pre class="insert-after">  void interpret(List&lt;Stmt&gt; statements) {
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in class <em>Interpreter</em></div>

<p>Nous la stockons comme un champ directement dans Interpreter pour que les variables restent en mémoire tant que l&rsquo;interpréteur est encore en cours d&rsquo;exécution.</p>
<p>Nous avons deux nouveaux arbres syntaxiques, donc c&rsquo;est deux nouvelles méthodes visit. La première est pour les instructions de déclaration.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitPrintStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitVarStmt</span>(<span class="t">Stmt</span>.<span class="t">Var</span> <span class="i">stmt</span>) {
    <span class="t">Object</span> <span class="i">value</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">initializer</span> != <span class="k">null</span>) {
      <span class="i">value</span> = <span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">initializer</span>);
    }

    <span class="i">environment</span>.<span class="i">define</span>(<span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">value</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitPrintStmt</em>()</div>

<p>Si la variable a un initialiseur, nous l&rsquo;évaluons. Si non, nous avons un autre choix à faire. Nous aurions pu en faire une erreur de syntaxe dans le parseur en <em>exigeant</em> un initialiseur. La plupart des langages ne le font pas, cependant, donc cela semble un peu dur de le faire dans Lox.</p>
<p>Nous pourrions en faire une erreur d&rsquo;exécution. Nous vous laisserions définir une variable non initialisée, mais si vous y accédiez avant de lui assigner quelque chose, une erreur d&rsquo;exécution se produirait. Ce n&rsquo;est pas une mauvaise idée, mais la plupart des langages typés dynamiquement ne font pas ça. Au lieu de cela, nous garderons les choses simples et dirons que Lox définit une variable à <code>nil</code> si elle n&rsquo;est pas explicitement initialisée.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span>;
<span class="k">print</span> <span class="i">a</span>; <span class="c">// &quot;nil&quot;.</span>
</pre></div>
<p>Ainsi, s&rsquo;il n&rsquo;y a pas d&rsquo;initialiseur, nous définissons la valeur à <code>null</code>, qui est la représentation Java de la valeur <code>nil</code> de Lox. Puis nous disons à l&rsquo;environnement de lier la variable à cette valeur.</p>
<p>Ensuite, nous évaluons une expression de variable.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitUnaryExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitVariableExpr</span>(<span class="t">Expr</span>.<span class="t">Variable</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">environment</span>.<span class="i">get</span>(<span class="i">expr</span>.<span class="i">name</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitUnaryExpr</em>()</div>

<p>Ceci transmet simplement à l&rsquo;environnement qui fait le gros du travail pour s&rsquo;assurer que la variable est définie. Avec cela, nous avons des variables rudimentaires qui fonctionnent. Essayez ceci :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
<span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
<span class="k">print</span> <span class="i">a</span> + <span class="i">b</span>;
</pre></div>
<p>Nous ne pouvons pas encore réutiliser de <em>code</em>, mais nous pouvons commencer à construire des programmes qui réutilisent des <em>données</em>.</p>
<h2><a href="#affectation" id="affectation"><small>8&#8202;.&#8202;4</small>Affectation</a></h2>
<p>Il est possible de créer un langage qui a des variables mais ne vous laisse pas les réassigner<span class="em">&mdash;</span>ou les <strong>muter</strong>. Haskell est un exemple. SML supporte seulement les références mutables et les tableaux<span class="em">&mdash;</span>les variables ne peuvent pas être réassignées. Rust vous éloigne de la mutation en exigeant un modificateur <code>mut</code> pour activer l&rsquo;affectation.</p>
<p>Muter une variable est un effet de bord et, comme le nom le suggère, certains gens des langages pensent que les effets de bord sont <span name="pure">sales</span> ou inélégants. Le code devrait être des mathématiques pures qui produisent des valeurs<span class="em">&mdash;</span>cristallines, inchangeables<span class="em">&mdash;</span>comme un acte de création divine. Pas un automate crasseux qui bat des paquets de données pour leur donner forme, un grognement impératif à la fois.</p>
<aside name="pure">
<p>Je trouve délicieux que le même groupe de personnes qui sont fières de leur logique impartiale sont aussi celles qui ne peuvent pas résister aux termes chargés émotionnellement pour leur travail : &ldquo;pur&rdquo;, &ldquo;effet de bord&rdquo;, &ldquo;paresseux&rdquo;, &ldquo;persistant&rdquo;, &ldquo;de première classe&rdquo;, &ldquo;d&rsquo;ordre supérieur&rdquo;.</p>
</aside>
<p>Lox n&rsquo;est pas si austère. Lox est un langage impératif, et la mutation vient avec le territoire. Ajouter le support pour l&rsquo;affectation (assignation) ne nécessite pas beaucoup de travail. Les variables globales supportent déjà la redéfinition, donc la plupart de la machinerie est là maintenant. Principalement, il nous manque une notation d&rsquo;affectation explicite.</p>
<h3><a href="#syntaxe-daffectation" id="syntaxe-daffectation"><small>8&#8202;.&#8202;4&#8202;.&#8202;1</small>Syntaxe d&rsquo;affectation</a></h3>
<p>Cette petite syntaxe <code>=</code> est plus complexe qu&rsquo;elle pourrait le sembler. Comme la plupart des langages dérivés du C, l&rsquo;affectation est une <span name="assign">expression</span> et non une instruction. Comme en C, c&rsquo;est la forme d&rsquo;expression de plus basse précédence. Cela signifie que la règle se glisse entre <code>expression</code> et <code>equality</code> (la prochaine expression de plus basse précédence).</p>
<aside name="assign">
<p>Dans certains autres langages, comme Pascal, Python, et Go, l&rsquo;affectation est une instruction.</p>
</aside>
<div class="codehilite"><pre><span class="i">expression</span>     → <span class="i">assignment</span> ;
<span class="i">assignment</span>     → <span class="t">IDENTIFIER</span> <span class="s">&quot;=&quot;</span> <span class="i">assignment</span>
               | <span class="i">equality</span> ;
</pre></div>
<p>Ceci dit qu&rsquo;une <code>assignment</code> (affectation) est soit un identifiant suivi par un <code>=</code> et une expression pour la valeur, ou une expression <code>equality</code> (et ainsi n&rsquo;importe quelle autre). Plus tard, <code>assignment</code> deviendra plus complexe quand nous ajouterons les setters de propriété sur les objets, comme :</p>
<div class="codehilite"><pre><span class="i">instance</span>.<span class="i">field</span> = <span class="s">&quot;valeur&quot;</span>;
</pre></div>
<p>La partie facile est d&rsquo;ajouter le <span name="assign-ast">nouveau nœud d&rsquo;arbre syntaxique</span>.</p>
<div class="codehilite"><pre class="insert-before">    defineAst(outputDir, &quot;Expr&quot;, Arrays.asList(
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Assign   : Token name, Expr value&quot;</span>,
</pre><pre class="insert-after">      &quot;Binary   : Expr left, Token operator, Expr right&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="assign-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#assign-expression">Annexe II</a>.</p>
</aside>
<p>Il a un token pour la variable à laquelle on assigne, et une expression pour la nouvelle valeur. Après que vous exécutiez le générateur AST pour obtenir la nouvelle classe Expr.Assign, échangez le corps de la méthode <code>expression()</code> existante du parseur pour correspondre à la règle mise à jour.</p>
<div class="codehilite"><pre class="insert-before">  private Expr expression() {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>expression</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="k">return</span> <span class="i">assignment</span>();
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>expression</em>(), replace 1 line</div>

<p>C&rsquo;est ici que ça devient délicat. Un parseur à descente récursive avec un seul token de lookahead ne peut pas voir assez loin pour dire qu&rsquo;il est en train de parser une affectation avant qu&rsquo;il ait traversé le côté gauche et trébuché sur le <code>=</code>. Vous pourriez vous demander pourquoi il a même besoin de le savoir. Après tout, nous ne savons pas que nous parsons une expression <code>+</code> avant que nous ayons fini de parser l&rsquo;opérande gauche.</p>
<p>La différence est que le côté gauche d&rsquo;une affectation n&rsquo;est pas une expression qui s&rsquo;évalue en une valeur. C&rsquo;est une sorte de pseudo-expression qui s&rsquo;évalue en une &ldquo;chose&rdquo; à laquelle vous pouvez assigner. Considérez :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;avant&quot;</span>;
<span class="i">a</span> = <span class="s">&quot;valeur&quot;</span>;
</pre></div>
<p>Sur la seconde ligne, nous n&rsquo;<em>évaluons</em> pas <code>a</code> (ce qui renverrait la chaîne &ldquo;avant&rdquo;). Nous comprenons à quelle variable <code>a</code> se réfère pour savoir où stocker la valeur de l&rsquo;expression du côté droit. Les <a href="https://en.wikipedia.org/wiki/Value_(computer_science)#lrvalue">termes classiques</a> pour ces deux <span name="l-value">constructions</span> sont <strong>l-value</strong> et <strong>r-value</strong>. Toutes les expressions que nous avons vues jusqu&rsquo;ici qui produisent des valeurs sont des r-values. Une l-value &ldquo;s&rsquo;évalue&rdquo; en un emplacement de stockage dans lequel vous pouvez assigner.</p>
<aside name="l-value">
<p>En fait, les noms viennent des expressions d&rsquo;affectation : les <em>l</em>-values apparaissent sur le côté <em>gauche</em> (left) du <code>=</code> dans une affectation, et les <em>r</em>-values sur la <em>droite</em> (right).</p>
</aside>
<p>Nous voulons que l&rsquo;arbre syntaxique reflète qu&rsquo;une l-value n&rsquo;est pas évaluée comme une expression normale. C&rsquo;est pourquoi le nœud Expr.Assign a un <em>Token</em> pour le côté gauche, pas une Expr. Le problème est que le parseur ne sait pas qu&rsquo;il parse une l-value jusqu&rsquo;à ce qu&rsquo;il frappe le <code>=</code>. Dans une l-value complexe, cela peut se produire <span name="many">de nombreux</span> tokens plus tard.</p>
<div class="codehilite"><pre><span class="i">makeList</span>().<span class="i">head</span>.<span class="i">next</span> = <span class="i">node</span>;
</pre></div>
<aside name="many">
<p>Puisque le receveur d&rsquo;une affectation de champ peut être n&rsquo;importe quelle expression, et que les expressions peuvent être aussi longues que vous voulez les faire, cela peut prendre un nombre <em>illimité</em> de tokens de lookahead pour trouver le <code>=</code>.</p>
</aside>
<p>Nous avons seulement un token de lookahead, donc que faisons-nous ? Nous utilisons une petite astuce, et cela ressemble à ceci :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>expressionStatement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">assignment</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">equality</span>();

    <span class="k">if</span> (<span class="i">match</span>(<span class="i">EQUAL</span>)) {
      <span class="t">Token</span> <span class="i">equals</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">value</span> = <span class="i">assignment</span>();

      <span class="k">if</span> (<span class="i">expr</span> <span class="k">instanceof</span> <span class="t">Expr</span>.<span class="t">Variable</span>) {
        <span class="t">Token</span> <span class="i">name</span> = ((<span class="t">Expr</span>.<span class="t">Variable</span>)<span class="i">expr</span>).<span class="i">name</span>;
        <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Assign</span>(<span class="i">name</span>, <span class="i">value</span>);
      }

      <span class="i">error</span>(<span class="i">equals</span>, <span class="s">&quot;Invalid assignment target.&quot;</span>);<span name="no-throw"> </span>
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>expressionStatement</em>()</div>

<p>La plupart du code pour parser une expression d&rsquo;affectation ressemble à celui des autres opérateurs binaires comme <code>+</code>. Nous parsons le côté gauche, qui peut être n&rsquo;importe quelle expression de plus haute précédence. Si nous trouvons un <code>=</code>, nous parsons le côté droit et ensuite enveloppons le tout dans un nœud d&rsquo;arbre d&rsquo;expression d&rsquo;affectation.</p>
<aside name="no-throw">
<p>Nous <em>rapportons</em> une erreur si le côté gauche n&rsquo;est pas une cible d&rsquo;affectation valide, mais nous ne la <em>lançons</em> pas parce que le parseur n&rsquo;est pas dans un état confus où nous avons besoin d&rsquo;aller en mode panique et de synchroniser.</p>
</aside>
<p>Une légère différence avec les opérateurs binaires est que nous ne bouclons pas pour construire une séquence du même opérateur. Puisque l&rsquo;affectation est associative à droite, nous appelons à la place récursivement <code>assignment()</code> pour parser le côté droit.</p>
<p>L&rsquo;astuce est que juste avant que nous créions le nœud d&rsquo;expression d&rsquo;affectation, nous regardons l&rsquo;expression du côté gauche et comprenons quel type de cible d&rsquo;affectation c&rsquo;est. Nous convertissons le nœud d&rsquo;expression r-value en une représentation l-value.</p>
<p>Cette conversion fonctionne parce qu&rsquo;il s&rsquo;avère que chaque cible d&rsquo;affectation valide se trouve être aussi une <span name="converse">syntaxe valide</span> comme expression normale. Considérez une affectation de champ complexe comme :</p>
<aside name="converse">
<p>Vous pouvez toujours utiliser cette astuce même s&rsquo;il y a des cibles d&rsquo;affectation qui ne sont pas des expressions valides. Définissez une <strong>grammaire de couverture</strong>, une grammaire plus lâche qui accepte toutes les syntaxes valides d&rsquo;expression <em>et</em> de cible d&rsquo;affectation. Quand vous frappez un <code>=</code>, rapportez une erreur si le côté gauche n&rsquo;est pas à l&rsquo;intérieur de la grammaire de cible d&rsquo;affectation valide. Inversement, si vous ne frappez <em>pas</em> un <code>=</code>, rapportez une erreur si le côté gauche n&rsquo;est pas une <em>expression</em> valide.</p>
</aside>
<div class="codehilite"><pre><span class="i">newPoint</span>(<span class="i">x</span> + <span class="n">2</span>, <span class="n">0</span>).<span class="i">y</span> = <span class="n">3</span>;
</pre></div>
<p>Le côté gauche de cette affectation pourrait aussi fonctionner comme une expression valide.</p>
<div class="codehilite"><pre><span class="i">newPoint</span>(<span class="i">x</span> + <span class="n">2</span>, <span class="n">0</span>).<span class="i">y</span>;
</pre></div>
<p>Le premier exemple définit le champ, le second l&rsquo;obtient.</p>
<p>Cela signifie que nous pouvons parser le côté gauche <em>comme si c&rsquo;était</em> une expression et ensuite après coup produire un arbre syntaxique qui le transforme en une cible d&rsquo;affectation. Si l&rsquo;expression du côté gauche n&rsquo;est pas une cible d&rsquo;affectation <span name="paren">valide</span>, nous échouons avec une erreur de syntaxe. Cela assure que nous rapportons une erreur sur du code comme ceci :</p>
<div class="codehilite"><pre><span class="i">a</span> + <span class="i">b</span> = <span class="i">c</span>;
</pre></div>
<aside name="paren">
<p>Loin en arrière dans le chapitre sur le parsing, j&rsquo;ai dit que nous représentions les expressions parenthésées dans l&rsquo;arbre syntaxique parce que nous en aurions besoin plus tard. C&rsquo;est pourquoi. Nous devons être capables de distinguer ces cas :</p>
<div class="codehilite"><pre><span class="i">a</span> = <span class="n">3</span>;   <span class="c">// OK.</span>
(<span class="i">a</span>) = <span class="n">3</span>; <span class="c">// Erreur.</span>
</pre></div>
</aside>
<p>Pour l&rsquo;instant, la seule cible valide est une simple expression de variable, mais nous ajouterons les champs plus tard. Le résultat final de cette astuce est un nœud d&rsquo;arbre d&rsquo;expression d&rsquo;affectation qui sait à quoi il assigne et a un sous-arbre d&rsquo;expression pour la valeur étant assignée. Tout cela avec seulement un token de lookahead et pas de backtracking.</p>
<h3><a href="#sémantique-daffectation" id="sémantique-daffectation"><small>8&#8202;.&#8202;4&#8202;.&#8202;2</small>Sémantique d&rsquo;affectation</a></h3>
<p>Nous avons un nouveau nœud d&rsquo;arbre syntaxique, donc notre interpréteur obtient une nouvelle méthode visit.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitVarStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitAssignExpr</span>(<span class="t">Expr</span>.<span class="t">Assign</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">value</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">value</span>);
    <span class="i">environment</span>.<span class="i">assign</span>(<span class="i">expr</span>.<span class="i">name</span>, <span class="i">value</span>);
    <span class="k">return</span> <span class="i">value</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitVarStmt</em>()</div>

<p>Pour des raisons évidentes, c&rsquo;est similaire à la déclaration de variable. Elle évalue le côté droit pour obtenir la valeur, puis la stocke dans la variable nommée. Au lieu d&rsquo;utiliser <code>define()</code> sur Environment, elle appelle cette nouvelle méthode :</p>
<div class="codehilite"><div class="source-file"><em>lox/Environment.java</em><br>
add after <em>get</em>()</div>
<pre>  <span class="t">void</span> <span class="i">assign</span>(<span class="t">Token</span> <span class="i">name</span>, <span class="t">Object</span> <span class="i">value</span>) {
    <span class="k">if</span> (<span class="i">values</span>.<span class="i">containsKey</span>(<span class="i">name</span>.<span class="i">lexeme</span>)) {
      <span class="i">values</span>.<span class="i">put</span>(<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">value</span>);
      <span class="k">return</span>;
    }

    <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">name</span>,
        <span class="s">&quot;Undefined variable &#39;&quot;</span> + <span class="i">name</span>.<span class="i">lexeme</span> + <span class="s">&quot;&#39;.&quot;</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, add after <em>get</em>()</div>

<p>La différence clé entre l&rsquo;affectation et la définition est que l&rsquo;affectation n&rsquo;est pas <span name="new">autorisée</span> à créer une <em>nouvelle</em> variable. En termes de notre implémentation, cela signifie que c&rsquo;est une erreur d&rsquo;exécution si la clé n&rsquo;existe pas déjà dans la map de variables de l&rsquo;environnement.</p>
<aside name="new">
<p>Contrairement à Python et Ruby, Lox ne fait pas de <a href="#design-note">déclaration de variable implicite</a>.</p>
</aside>
<p>La dernière chose que la méthode <code>visit()</code> fait est de renvoyer la valeur assignée. C&rsquo;est parce que l&rsquo;affectation est une expression qui peut être imbriquée à l&rsquo;intérieur d&rsquo;autres expressions, comme ceci :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
<span class="k">print</span> <span class="i">a</span> = <span class="n">2</span>; <span class="c">// &quot;2&quot;.</span>
</pre></div>
<p>Notre interpréteur peut maintenant créer, lire, et modifier des variables. C&rsquo;est à peu près aussi sophistiqué que les premiers <span name="basic">BASICs</span>. Les variables globales sont simples, mais écrire un gros programme quand deux morceaux de code quelconques peuvent accidentellement marcher sur l&rsquo;état de l&rsquo;autre n&rsquo;est pas amusant. Nous voulons des variables <em>locales</em>, ce qui signifie qu&rsquo;il est temps pour la <em>portée</em>.</p>
<aside name="basic">
<p>Peut-être un peu mieux que ça. Contrairement à certains vieux BASICs, Lox peut gérer des noms de variables plus longs que deux caractères.</p>
</aside>
<h2><a href="#portée" id="portée"><small>8&#8202;.&#8202;5</small>Portée</a></h2>
<p>Une <strong>portée</strong> (scope) définit une région où un nom mappe vers une certaine entité. De multiples portées permettent au même nom de se référer à différentes choses dans différents contextes. Dans ma maison, &ldquo;Bob&rdquo; se réfère généralement à moi. Mais peut-être que dans votre ville vous connaissez un Bob différent. Même nom, mais différents mecs basés sur où vous le dites.</p>
<p>La <span name="lexical"><strong>portée lexicale</strong></span> (ou la <strong>portée statique</strong> moins communément entendue) est un style spécifique de portée où le texte du programme lui-même montre où une portée commence et se termine. Dans Lox, comme dans la plupart des langages modernes, les variables sont lexicalement portées. Quand vous voyez une expression qui utilise une certaine variable, vous pouvez comprendre à quelle déclaration de variable elle se réfère juste en lisant statiquement le code.</p>
<aside name="lexical">
<p>&ldquo;Lexical&rdquo; vient du grec &ldquo;lexikos&rdquo; qui signifie &ldquo;lié aux mots&rdquo;. Quand nous l&rsquo;utilisons dans les langages de programmation, cela signifie généralement une chose que vous pouvez comprendre à partir du code source lui-même sans avoir à exécuter quoi que ce soit.</p>
<p>La portée lexicale est arrivée sur la scène avec ALGOL. Les langages plus tôt étaient souvent portés dynamiquement. Les informaticiens à l&rsquo;époque croyaient que la portée dynamique était plus rapide à exécuter. Aujourd&rsquo;hui, grâce aux premiers hackers Scheme, nous savons que ce n&rsquo;est pas vrai. Au contraire, c&rsquo;est l&rsquo;opposé.</p>
<p>La portée dynamique pour les variables survit dans certains coins. Emacs Lisp utilise par défaut la portée dynamique pour les variables. La macro <a href="http://clojuredocs.org/clojure.core/binding"><code>binding</code></a> dans Clojure la fournit. L&rsquo;instruction <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with"><code>with</code></a> largement détestée en JavaScript transforme les propriétés sur un objet en variables portées dynamiquement.</p>
</aside>
<p>Par exemple :</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;premier&quot;</span>;
  <span class="k">print</span> <span class="i">a</span>; <span class="c">// &quot;premier&quot;.</span>
}

{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;second&quot;</span>;
  <span class="k">print</span> <span class="i">a</span>; <span class="c">// &quot;second&quot;.</span>
}
</pre></div>
<p>Ici, nous avons deux blocs avec une variable <code>a</code> déclarée dans chacun d&rsquo;eux. Vous et moi pouvons dire juste en regardant le code que l&rsquo;utilisation de <code>a</code> dans la première instruction <code>print</code> se réfère au premier <code>a</code>, et la seconde se réfère au second.</p><img src="image/statements-and-state/blocks.png" alt="Un environnement pour chaque 'a'." />
<p>Ceci est en contraste avec la <strong>portée dynamique</strong> où vous ne savez pas à quoi un nom se réfère avant d&rsquo;exécuter le code. Lox n&rsquo;a pas de <em>variables</em> portées dynamiquement, mais les méthodes et champs sur les objets sont portés dynamiquement.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Saxophone</span> {
  <span class="i">play</span>() {
    <span class="k">print</span> <span class="s">&quot;Careless Whisper&quot;</span>;
  }
}

<span class="k">class</span> <span class="t">GolfClub</span> {
  <span class="i">play</span>() {
    <span class="k">print</span> <span class="s">&quot;Fore!&quot;</span>;
  }
}

<span class="k">fun</span> <span class="i">playIt</span>(<span class="i">thing</span>) {
  <span class="i">thing</span>.<span class="i">play</span>();
}
</pre></div>
<p>Quand <code>playIt()</code> appelle <code>thing.play()</code>, nous ne savons pas si nous sommes sur le point d&rsquo;entendre &ldquo;Careless Whisper&rdquo; ou &ldquo;Fore!&rdquo;. Cela dépend de si vous passez un Saxophone ou un GolfClub à la fonction, et nous ne le savons pas avant l&rsquo;exécution.</p>
<p>La portée et les environnements sont des cousins proches. La première est le concept théorique, et le second est la machinerie qui l&rsquo;implémente. Alors que notre interpréteur fait son chemin à travers le code, les nœuds d&rsquo;arbre syntaxique qui affectent la portée changeront l&rsquo;environnement. Dans une syntaxe à la C comme celle de Lox, la portée est contrôlée par des blocs entre accolades. (C&rsquo;est pourquoi nous l&rsquo;appelons <strong>portée de bloc</strong>.)</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;dans le bloc&quot;</span>;
}
<span class="k">print</span> <span class="i">a</span>; <span class="c">// Erreur ! Plus de &quot;a&quot;.</span>
</pre></div>
<p>Le début d&rsquo;un bloc introduit une nouvelle portée locale, et cette portée se termine quand l&rsquo;exécution passe le <code>}</code> fermant. Toutes les variables déclarées à l&rsquo;intérieur du bloc disparaissent.</p>
<h3><a href="#imbrication-et-masquage" id="imbrication-et-masquage"><small>8&#8202;.&#8202;5&#8202;.&#8202;1</small>Imbrication et masquage</a></h3>
<p>Un premier essai pour implémenter la portée de bloc pourrait fonctionner comme ceci :</p>
<ol>
<li>
<p>Alors que nous visitons chaque instruction à l&rsquo;intérieur du bloc, garder une trace de toutes les variables déclarées.</p>
</li>
<li>
<p>Après que la dernière instruction est exécutée, dire à l&rsquo;environnement de supprimer toutes ces variables.</p>
</li>
</ol>
<p>Cela fonctionnerait pour l&rsquo;exemple précédent. Mais rappelez-vous, une motivation pour la portée locale est l&rsquo;encapsulation<span class="em">&mdash;</span>un bloc de code dans un coin du programme ne devrait pas interférer avec un autre bloc. Regardez ça :</p>
<div class="codehilite"><pre><span class="c">// Quel volume ?</span>
<span class="k">var</span> <span class="i">volume</span> = <span class="n">11</span>;

<span class="c">// Silence.</span>
<span class="i">volume</span> = <span class="n">0</span>;

<span class="c">// Calculer la taille d&#39;un cuboïde 3x4x5.</span>
{
  <span class="k">var</span> <span class="i">volume</span> = <span class="n">3</span> * <span class="n">4</span> * <span class="n">5</span>;
  <span class="k">print</span> <span class="i">volume</span>;
}
</pre></div>
<p>Regardez le bloc où nous calculons le volume du cuboïde en utilisant une déclaration locale de <code>volume</code>. Après que le bloc sorte, l&rsquo;interpréteur supprimera la variable <code>volume</code> <em>globale</em>. Ce n&rsquo;est pas juste. Quand nous sortons du bloc, nous devrions retirer toutes les variables déclarées à l&rsquo;intérieur du bloc, mais s&rsquo;il y a une variable avec le même nom déclarée à l&rsquo;extérieur du bloc, <em>c&rsquo;est une variable différente</em>. Elle ne devrait pas être touchée.</p>
<p>Quand une variable locale a le même nom qu&rsquo;une variable dans une portée englobante, elle <strong>masque</strong> (shadows) l&rsquo;externe. Le code à l&rsquo;intérieur du bloc ne peut plus la voir<span class="em">&mdash;</span>elle est cachée dans l&rsquo;&ldquo;ombre&rdquo; jetée par l&rsquo;interne<span class="em">&mdash;</span>mais elle est toujours là.</p>
<p>Quand nous entrons dans une nouvelle portée de bloc, nous devons préserver les variables définies dans les portées externes pour qu&rsquo;elles soient toujours là quand nous sortons du bloc interne. Nous faisons cela en définissant un environnement frais pour chaque bloc contenant seulement les variables définies dans cette portée. Quand nous sortons du bloc, nous rejetons son environnement et restaurons le précédent.</p>
<p>Nous avons aussi besoin de gérer les variables englobantes qui ne sont <em>pas</em> masquées.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">global</span> = <span class="s">&quot;dehors&quot;</span>;
{
  <span class="k">var</span> <span class="i">local</span> = <span class="s">&quot;dedans&quot;</span>;
  <span class="k">print</span> <span class="i">global</span> + <span class="i">local</span>;
}
</pre></div>
<p>Ici, <code>global</code> vit dans l&rsquo;environnement global externe et <code>local</code> est défini à l&rsquo;intérieur de l&rsquo;environnement du bloc. Dans cette instruction <code>print</code>, ces deux variables sont dans la portée. Afin de les trouver, l&rsquo;interpréteur doit chercher non seulement l&rsquo;environnement le plus interne courant, mais aussi tous ceux englobants.</p>
<p>Nous implémentons cela en <span name="cactus">chaînant</span> les environnements ensemble. Chaque environnement a une référence vers l&rsquo;environnement de la portée immédiatement englobante. Quand nous cherchons une variable, nous marchons dans cette chaîne du plus interne vers l&rsquo;extérieur jusqu&rsquo;à ce que nous trouvions la variable. Commencer à la portée interne est la façon dont nous faisons masquer les variables externes par les locales.</p><img src="image/statements-and-state/chaining.png" alt="Environnements pour chaque portée, liés ensemble." />
<aside name="cactus">
<p>Pendant que l&rsquo;interpréteur tourne, les environnements forment une liste linéaire d&rsquo;objets, mais considérez l&rsquo;ensemble complet des environnements créés durant l&rsquo;exécution entière. Une portée externe peut avoir de multiples blocs imbriqués en son sein, et chacun pointera vers l&rsquo;externe, donnant une structure arborescente, bien qu&rsquo;un seul chemin à travers l&rsquo;arbre existe à la fois.</p>
<p>Le nom ennuyeux pour cela est un <a href="https://en.wikipedia.org/wiki/Parent_pointer_tree"><strong>arbre à pointeur de parent</strong></a>, mais je préfère de loin le nom évocateur de <strong>pile cactus</strong>.</p><img class="above" src="image/statements-and-state/cactus.png" alt="Chaque branche pointe vers son parent. La racine est la portée globale." />
</aside>
<p>Avant que nous ajoutions la syntaxe de bloc à la grammaire, nous allons renforcer notre classe Environment avec le support pour cette imbrication. D&rsquo;abord, nous donnons à chaque environnement une référence vers son englobant.</p>
<div class="codehilite"><pre class="insert-before">class Environment {
</pre><div class="source-file"><em>lox/Environment.java</em><br>
in class <em>Environment</em></div>
<pre class="insert">  <span class="k">final</span> <span class="t">Environment</span> <span class="i">enclosing</span>;
</pre><pre class="insert-after">  private final Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, in class <em>Environment</em></div>

<p>Ce champ doit être initialisé, donc nous ajoutons une paire de constructeurs.</p>
<div class="codehilite"><div class="source-file"><em>lox/Environment.java</em><br>
in class <em>Environment</em></div>
<pre>  <span class="t">Environment</span>() {
    <span class="i">enclosing</span> = <span class="k">null</span>;
  }

  <span class="t">Environment</span>(<span class="t">Environment</span> <span class="i">enclosing</span>) {
    <span class="k">this</span>.<span class="i">enclosing</span> = <span class="i">enclosing</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, in class <em>Environment</em></div>

<p>Le constructeur sans argument est pour l&rsquo;environnement de la portée globale, qui termine la chaîne. L&rsquo;autre constructeur crée une nouvelle portée locale imbriquée à l&rsquo;intérieur de celle externe donnée.</p>
<p>Nous n&rsquo;avons pas à toucher la méthode <code>define()</code><span class="em">&mdash;</span>une nouvelle variable est toujours déclarée dans la portée la plus interne courante. Mais la recherche de variable et l&rsquo;affectation fonctionnent avec des variables existantes et elles doivent marcher dans la chaîne pour les trouver. D&rsquo;abord, la recherche :</p>
<div class="codehilite"><pre class="insert-before">      return values.get(name.lexeme);
    }
</pre><div class="source-file"><em>lox/Environment.java</em><br>
in <em>get</em>()</div>
<pre class="insert">

    <span class="k">if</span> (<span class="i">enclosing</span> != <span class="k">null</span>) <span class="k">return</span> <span class="i">enclosing</span>.<span class="i">get</span>(<span class="i">name</span>);
</pre><pre class="insert-after">

    throw new RuntimeError(name,
        &quot;Undefined variable '&quot; + name.lexeme + &quot;'.&quot;);
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, in <em>get</em>()</div>

<p>Si la variable n&rsquo;est pas trouvée dans cet environnement, nous essayons simplement celui englobant. Celui-là fait à son tour la même chose <span name="recurse">récursivement</span>, donc cela marchera finalement la chaîne entière. Si nous atteignons un environnement sans englobant et ne trouvons toujours pas la variable, alors nous abandonnons et rapportons une erreur comme avant.</p>
<p>L&rsquo;affectation fonctionne de la même manière.</p>
<aside name="recurse">
<p>C&rsquo;est probablement plus rapide de marcher itérativement dans la chaîne, mais je pense que la solution récursive est plus jolie. Nous ferons quelque chose de <em>beaucoup</em> plus rapide dans clox.</p>
</aside>
<div class="codehilite"><pre class="insert-before">      values.put(name.lexeme, value);
      return;
    }

</pre><div class="source-file"><em>lox/Environment.java</em><br>
in <em>assign</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">enclosing</span> != <span class="k">null</span>) {
      <span class="i">enclosing</span>.<span class="i">assign</span>(<span class="i">name</span>, <span class="i">value</span>);
      <span class="k">return</span>;
    }

</pre><pre class="insert-after">    throw new RuntimeError(name,
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, in <em>assign</em>()</div>

<p>Encore une fois, si la variable n&rsquo;est pas dans cet environnement, elle vérifie l&rsquo;externe, récursivement.</p>
<h3><a href="#syntaxe-et-sémantique-de-bloc" id="syntaxe-et-sémantique-de-bloc"><small>8&#8202;.&#8202;5&#8202;.&#8202;2</small>Syntaxe et sémantique de bloc</a></h3>
<p>Maintenant que les environnements s&rsquo;imbriquent, nous sommes prêts à ajouter les blocs au langage. Contemplez la grammaire :</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">block</span> ;

<span class="i">block</span>          → <span class="s">&quot;{&quot;</span> <span class="i">declaration</span>* <span class="s">&quot;}&quot;</span> ;
</pre></div>
<p>Un bloc est une série (possiblement vide) d&rsquo;instructions ou de déclarations entourée par des accolades. Un bloc est lui-même une instruction et peut apparaître n&rsquo;importe où une instruction est autorisée. Le nœud d&rsquo;<span name="block-ast">arbre syntaxique</span> ressemble à ceci :</p>
<div class="codehilite"><pre class="insert-before">    defineAst(outputDir, &quot;Stmt&quot;, Arrays.asList(
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Block      : List&lt;Stmt&gt; statements&quot;</span>,
</pre><pre class="insert-after">      &quot;Expression : Expr expression&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="block-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#block-statement">Annexe II</a>.</p>
</aside>
<p><span name="generate">Il</span> contient la liste des instructions qui sont à l&rsquo;intérieur du bloc. Le parsing est direct. Comme d&rsquo;autres instructions, nous détectons le début d&rsquo;un bloc par son token de tête<span class="em">&mdash;</span>dans ce cas le <code>{</code>. Dans la méthode <code>statement()</code>, nous ajoutons :</p>
<aside name="generate">
<p>Comme toujours, n&rsquo;oubliez pas d&rsquo;exécuter &ldquo;GenerateAst.java&rdquo;.</p>
</aside>
<div class="codehilite"><pre class="insert-before">    if (match(PRINT)) return printStatement();
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">LEFT_BRACE</span>)) <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Block</span>(<span class="i">block</span>());
</pre><pre class="insert-after">

    return expressionStatement();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>

<p>Tout le vrai travail se passe ici :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>expressionStatement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">block</span>() {
    <span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">statements</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();

    <span class="k">while</span> (!<span class="i">check</span>(<span class="i">RIGHT_BRACE</span>) &amp;&amp; !<span class="i">isAtEnd</span>()) {
      <span class="i">statements</span>.<span class="i">add</span>(<span class="i">declaration</span>());
    }

    <span class="i">consume</span>(<span class="i">RIGHT_BRACE</span>, <span class="s">&quot;Expect &#39;}&#39; after block.&quot;</span>);
    <span class="k">return</span> <span class="i">statements</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>expressionStatement</em>()</div>

<p>Nous <span name="list">créons</span> une liste vide et ensuite parsons les instructions et les ajoutons à la liste jusqu&rsquo;à ce que nous atteignions la fin du bloc, marquée par le <code>}</code> fermant. Notez que la boucle a aussi une vérification explicite pour <code>isAtEnd()</code>. Nous devons faire attention à éviter les boucles infinies, même en parsant du code invalide. Si l&rsquo;utilisateur oublie un <code>}</code> fermant, le parseur ne doit pas rester coincé.</p>
<aside name="list">
<p>Faire que <code>block()</code> renvoie la liste brute d&rsquo;instructions et laisser à <code>statement()</code> le soin d&rsquo;envelopper la liste dans un Stmt.Block semble un peu bizarre. Je l&rsquo;ai fait de cette façon parce que nous réutiliserons <code>block()</code> plus tard pour parser les corps de fonction et nous ne voulons pas que ce corps soit enveloppé dans un Stmt.Block.</p>
</aside>
<p>C&rsquo;est tout pour la syntaxe. Pour la sémantique, nous ajoutons une autre méthode visit à Interpreter.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>execute</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitBlockStmt</span>(<span class="t">Stmt</span>.<span class="t">Block</span> <span class="i">stmt</span>) {
    <span class="i">executeBlock</span>(<span class="i">stmt</span>.<span class="i">statements</span>, <span class="k">new</span> <span class="t">Environment</span>(<span class="i">environment</span>));
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>execute</em>()</div>

<p>Pour exécuter un bloc, nous créons un nouvel environnement pour la portée du bloc et le passons à cette autre méthode :</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>execute</em>()</div>
<pre>  <span class="t">void</span> <span class="i">executeBlock</span>(<span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">statements</span>,
                    <span class="t">Environment</span> <span class="i">environment</span>) {
    <span class="t">Environment</span> <span class="i">previous</span> = <span class="k">this</span>.<span class="i">environment</span>;
    <span class="k">try</span> {
      <span class="k">this</span>.<span class="i">environment</span> = <span class="i">environment</span>;

      <span class="k">for</span> (<span class="t">Stmt</span> <span class="i">statement</span> : <span class="i">statements</span>) {
        <span class="i">execute</span>(<span class="i">statement</span>);
      }
    } <span class="k">finally</span> {
      <span class="k">this</span>.<span class="i">environment</span> = <span class="i">previous</span>;
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>execute</em>()</div>

<p>Cette nouvelle méthode exécute une liste d&rsquo;instructions dans le contexte d&rsquo;un <span name="param">environnement</span> donné. Jusqu&rsquo;à maintenant, le champ <code>environment</code> dans Interpreter pointait toujours vers le même environnement<span class="em">&mdash;</span>le global. Maintenant, ce champ représente l&rsquo;environnement <em>courant</em>. C&rsquo;est l&rsquo;environnement qui correspond à la portée la plus interne contenant le code à exécuter.</p>
<p>Pour exécuter du code au sein d&rsquo;une portée donnée, cette méthode met à jour le champ <code>environment</code> de l&rsquo;interpréteur, visite toutes les instructions, et ensuite restaure la valeur précédente. Comme c&rsquo;est toujours une bonne pratique en Java, elle restaure l&rsquo;environnement précédent en utilisant une clause finally. De cette façon il est restauré même si une exception est lancée.</p>
<aside name="param">
<p>Changer manuellement et restaurer un champ <code>environment</code> mutable semble inélégant. Une autre approche classique est de passer explicitement l&rsquo;environnement comme paramètre à chaque méthode visit. Pour &ldquo;changer&rdquo; l&rsquo;environnement, vous en passez un différent alors que vous récursez vers le bas de l&rsquo;arbre. Vous n&rsquo;avez pas à restaurer l&rsquo;ancien, puisque le nouveau vit sur la pile Java et est implicitement rejeté quand l&rsquo;interpréteur revient de la méthode visit du bloc.</p>
<p>J&rsquo;ai considéré cela pour jlox, mais c&rsquo;est un peu fastidieux et verbeux d&rsquo;ajouter un paramètre environnement à chaque méthode visit unique. Pour garder le livre un peu plus simple, je suis allé avec le champ mutable.</p>
</aside>
<p>Étonnamment, c&rsquo;est tout ce que nous avons besoin de faire afin de supporter entièrement les variables locales, l&rsquo;imbrication, et le masquage. Allez-y et essayez ceci :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;global a&quot;</span>;
<span class="k">var</span> <span class="i">b</span> = <span class="s">&quot;global b&quot;</span>;
<span class="k">var</span> <span class="i">c</span> = <span class="s">&quot;global c&quot;</span>;
{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;outer a&quot;</span>;
  <span class="k">var</span> <span class="i">b</span> = <span class="s">&quot;outer b&quot;</span>;
  {
    <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;inner a&quot;</span>;
    <span class="k">print</span> <span class="i">a</span>;
    <span class="k">print</span> <span class="i">b</span>;
    <span class="k">print</span> <span class="i">c</span>;
  }
  <span class="k">print</span> <span class="i">a</span>;
  <span class="k">print</span> <span class="i">b</span>;
  <span class="k">print</span> <span class="i">c</span>;
}
<span class="k">print</span> <span class="i">a</span>;
<span class="k">print</span> <span class="i">b</span>;
<span class="k">print</span> <span class="i">c</span>;
</pre></div>
<p>Notre petit interpréteur peut se souvenir de choses maintenant. Nous nous rapprochons centimètre par centimètre de quelque chose ressemblant à un langage de programmation complet.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>8&#8202;.&#8202;6</small>Défis</a></h2>
<ol>
<li>
<p>Le REPL ne supporte plus l&rsquo;entrée d&rsquo;une seule expression et l&rsquo;impression automatique de sa valeur résultat. C&rsquo;est barbant. Ajoutez le support au REPL pour laisser les utilisateurs taper à la fois des instructions et des expressions. S&rsquo;ils entrent une instruction, exécutez-la. S&rsquo;ils entrent une expression, évaluez-la et affichez la valeur résultat.</p>
</li>
<li>
<p>Peut-être voulez-vous que Lox soit un peu plus explicite à propos de l&rsquo;initialisation de variable. Au lieu d&rsquo;initialiser implicitement les variables à <code>nil</code>, faites-en une erreur d&rsquo;exécution d&rsquo;accéder à une variable qui n&rsquo;a pas été initialisée ou assignée, comme dans :</p>
<div class="codehilite"><pre><span class="c">// Pas d&#39;initialiseurs.</span>
<span class="k">var</span> <span class="i">a</span>;
<span class="k">var</span> <span class="i">b</span>;

<span class="i">a</span> = <span class="s">&quot;assigné&quot;</span>;
<span class="k">print</span> <span class="i">a</span>; <span class="c">// OK, a été assigné en premier.</span>

<span class="k">print</span> <span class="i">b</span>; <span class="c">// Erreur !</span>
</pre></div>
</li>
<li>
<p>Que fait le programme suivant ?</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
{
  <span class="k">var</span> <span class="i">a</span> = <span class="i">a</span> + <span class="n">2</span>;
  <span class="k">print</span> <span class="i">a</span>;
}
</pre></div>
<p>que vous <em>attendiez</em>-vous à ce qu&rsquo;il fasse ? Est-ce ce que vous pensez qu&rsquo;il devrait faire ? Que fait le code analogue dans d&rsquo;autres langages avec lesquels vous êtes familiers ? Que pensez-vous que les utilisateurs s&rsquo;attendront à ce qu&rsquo;il fasse ?</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--déclaration-de-variable-implicite" id="note-de-conception--déclaration-de-variable-implicite"><small>8&#8202;.&#8202;7</small>Note de Conception : Déclaration de Variable Implicite</a></h2>
<p>Lox a une syntaxe distincte pour déclarer une nouvelle variable et assigner à une existante. Certains langages effondrent celles-ci en seulement la syntaxe d&rsquo;affectation. Assigner à une variable non-existante l&rsquo;amène automatiquement à l&rsquo;existence. Ceci est appelé <strong>déclaration de variable implicite</strong> et existe en Python, Ruby, et CoffeeScript, parmi d&rsquo;autres. JavaScript a une syntaxe explicite pour déclarer des variables, mais peut aussi créer de nouvelles variables lors de l&rsquo;affectation. Visual Basic a <a href="https://msdn.microsoft.com/en-us/library/xe53dz5w(v=vs.100).aspx">une option pour activer ou désactiver les variables implicites</a>.</p>
<p>Quand la même syntaxe peut assigner ou créer une variable, chaque langage doit décider ce qui se passe quand il n&rsquo;est pas clair quel comportement l&rsquo;utilisateur a l&rsquo;intention d&rsquo;avoir. En particulier, chaque langage doit choisir comment la déclaration implicite interagit avec le masquage, et dans quelle portée une variable implicitement déclarée va.</p>
<ul>
<li>
<p>En Python, l&rsquo;affectation crée toujours une variable dans la portée de la fonction courante, même s&rsquo;il y a une variable avec le même nom déclarée à l&rsquo;extérieur de la fonction.</p>
</li>
<li>
<p>Ruby évite une certaine ambiguïté en ayant des règles de nommage différentes pour les variables locales et globales. Cependant, les blocs en Ruby (qui sont plus comme des fermetures que comme des &ldquo;blocs&rdquo; en C) ont leur propre portée, donc il a toujours le problème. L&rsquo;affectation en Ruby assigne à une variable existante à l&rsquo;extérieur du bloc courant s&rsquo;il y en a une avec le même nom. Sinon, elle crée une nouvelle variable dans la portée du bloc courant.</p>
</li>
<li>
<p>CoffeeScript, qui tient de Ruby de nombreuses façons, est similaire. Il interdit explicitement le masquage en disant que l&rsquo;affectation assigne toujours à une variable dans une portée externe s&rsquo;il y en a une, tout le chemin jusqu&rsquo;à la portée globale la plus externe. Sinon, il crée la variable dans la portée de la fonction courante.</p>
</li>
<li>
<p>En JavaScript, l&rsquo;affectation modifie une variable existante dans n&rsquo;importe quelle portée englobante, si trouvée. Si non, elle crée implicitement une nouvelle variable dans la portée <em>globale</em>.</p>
</li>
</ul>
<p>L&rsquo;avantage principal de la déclaration implicite est la simplicité. Il y a moins de syntaxe et pas de concept de &ldquo;déclaration&rdquo; à apprendre. Les utilisateurs peuvent juste commencer à assigner des trucs et le langage se débrouille.</p>
<p>Les langages plus vieux, typés statiquement comme C bénéficient de la déclaration explicite parce qu&rsquo;ils donnent à l&rsquo;utilisateur un endroit pour dire au compilateur quel type chaque variable a et combien de stockage allouer pour elle. Dans un langage typé dynamiquement, ramassé par le garbage collector, ce n&rsquo;est pas vraiment nécessaire, donc vous pouvez vous en sortir en rendant les déclarations implicites. Cela semble un peu plus &ldquo;scripty&rdquo;, plus &ldquo;tu vois ce que je veux dire&rdquo;.</p>
<p>Mais est-ce une bonne idée ? La déclaration implicite a quelques problèmes.</p>
<ul>
<li>
<p>Un utilisateur peut avoir l&rsquo;intention d&rsquo;assigner à une variable existante, mais peut l&rsquo;avoir mal orthographiée. L&rsquo;interpréteur ne le sait pas, donc il y va et crée silencieusement une nouvelle variable et la variable à laquelle l&rsquo;utilisateur voulait assigner a toujours son ancienne valeur. C&rsquo;est particulièrement odieux en JavaScript où une faute de frappe créera une variable <em>globale</em>, qui peut à son tour interférer avec d&rsquo;autre code.</p>
</li>
<li>
<p>JS, Ruby, et CoffeeScript utilisent la présence d&rsquo;une variable existante avec le même nom<span class="em">&mdash;</span>même dans une portée externe<span class="em">&mdash;</span>pour déterminer si oui ou non une affectation crée une nouvelle variable ou assigne à une existante. Cela signifie qu&rsquo;ajouter une nouvelle variable dans une portée environnante peut changer le sens du code existant. Ce qui était une fois une variable locale peut silencieusement se transformer en une affectation à cette nouvelle variable externe.</p>
</li>
<li>
<p>En Python, vous pouvez <em>vouloir</em> assigner à une variable à l&rsquo;extérieur de la fonction courante au lieu de créer une nouvelle variable dans la courante, mais vous ne pouvez pas.</p>
</li>
</ul>
<p>Avec le temps, les langages que je connais avec déclaration de variable implicite ont fini par ajouter plus de fonctionnalités et de complexité pour gérer ces problèmes.</p>
<ul>
<li>
<p>La déclaration implicite de variables globales en JavaScript est universellement considérée comme une erreur aujourd&rsquo;hui. Le &ldquo;mode strict&rdquo; la désactive et en fait une erreur de compilation.</p>
</li>
<li>
<p>Python a ajouté une instruction <code>global</code> pour vous laisser assigner explicitement à une variable globale depuis l&rsquo;intérieur d&rsquo;une fonction. Plus tard, alors que la programmation fonctionnelle et les fonctions imbriquées devenaient plus populaires, ils ont ajouté une instruction <code>nonlocal</code> similaire pour assigner aux variables dans les fonctions englobantes.</p>
</li>
<li>
<p>Ruby a étendu sa syntaxe de bloc pour permettre de déclarer certaines variables comme étant explicitement locales au bloc même si le même nom existe dans une portée externe.</p>
</li>
</ul>
<p>Étant donné ceux-là, je pense que l&rsquo;argument de simplicité est principalement perdu. Il y a un argument que la déclaration implicite est le bon <em>défaut</em> mais je trouve personnellement cela moins convaincant.</p>
<p>Mon opinion est que la déclaration implicite avait du sens dans les années passées quand la plupart des langages de script étaient lourdement impératifs et le code était assez plat. À mesure que les programmeurs sont devenus plus à l&rsquo;aise avec l&rsquo;imbrication profonde, la programmation fonctionnelle, et les fermetures, il est devenu beaucoup plus courant de vouloir accéder aux variables dans les portées externes. Cela rend plus probable le fait que les utilisateurs tomberont dans les cas délicats où il n&rsquo;est pas clair s&rsquo;ils ont l&rsquo;intention que leur affectation crée une nouvelle variable ou réutilise une environnante.</p>
<p>Donc je préfère déclarer explicitement les variables, c&rsquo;est pourquoi Lox l&rsquo;exige.</p>
</div>

<footer>
<a href="contrôle-de-flux.html" class="next">
  Next Chapter: &ldquo;Contrôle de flux&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
