<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Compilation des expressions &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Compilation des expressions<small>17</small></a></h3>

<ul>
    <li><a href="#compilation-&amp;agrave;-une-passe"><small>17.1</small> Compilation &amp;agrave; Une Passe</a></li>
    <li><a href="#parser-les-tokens"><small>17.2</small> Parser les Tokens</a></li>
    <li><a href="#émettre-du-bytecode"><small>17.3</small> Émettre du Bytecode</a></li>
    <li><a href="#parser-les-expressions-préfixes"><small>17.4</small> Parser les Expressions Préfixes</a></li>
    <li><a href="#parser-les-expressions-infixes"><small>17.5</small> Parser les Expressions Infixes</a></li>
    <li><a href="#un-parseur-pratt"><small>17.6</small> Un Parseur Pratt</a></li>
    <li><a href="#dumper-les-morceaux"><small>17.7</small> Dumper les Morceaux</a></li>
    <li><a href="#défis"><small>17.8</small> Défis</a></li>
    <li><a href="#note-de-conception--cest-juste-du-parsing"><small>17.9</small> Note de Conception : C&#x27;est Juste du Parsing</a></li>
</ul>


<div class="prev-next">
    <a href="analyse-à-la-demande.html" title="Analyse à la demande" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="types-de-valeurs.html" title="Types de valeurs" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="analyse-à-la-demande.html" title="Analyse à la demande" class="prev">←</a>
<a href="types-de-valeurs.html" title="Types de valeurs" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Compilation des expressions<small>17</small></a></h3>

<ul>
    <li><a href="#compilation-&amp;agrave;-une-passe"><small>17.1</small> Compilation &amp;agrave; Une Passe</a></li>
    <li><a href="#parser-les-tokens"><small>17.2</small> Parser les Tokens</a></li>
    <li><a href="#émettre-du-bytecode"><small>17.3</small> Émettre du Bytecode</a></li>
    <li><a href="#parser-les-expressions-préfixes"><small>17.4</small> Parser les Expressions Préfixes</a></li>
    <li><a href="#parser-les-expressions-infixes"><small>17.5</small> Parser les Expressions Infixes</a></li>
    <li><a href="#un-parseur-pratt"><small>17.6</small> Un Parseur Pratt</a></li>
    <li><a href="#dumper-les-morceaux"><small>17.7</small> Dumper les Morceaux</a></li>
    <li><a href="#défis"><small>17.8</small> Défis</a></li>
    <li><a href="#note-de-conception--cest-juste-du-parsing"><small>17.9</small> Note de Conception : C&#x27;est Juste du Parsing</a></li>
</ul>


<div class="prev-next">
    <a href="analyse-à-la-demande.html" title="Analyse à la demande" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="types-de-valeurs.html" title="Types de valeurs" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">17</div>
  <h1>Compilation des expressions</h1>

<blockquote>
<p>Au milieu du chemin de notre vie je me retrouvai par une forêt obscure où la voie droite était perdue.</p>
<p><cite>Dante Alighieri, <em>Enfer</em></cite></p>
</blockquote>
<p>Ce chapitre est excitant pour non pas une, non pas deux, mais <em>trois</em> raisons. Premièrement, il fournit le segment final du pipeline d&rsquo;exécution de notre VM. Une fois en place, nous pouvons tuyauter le code source de l&rsquo;utilisateur depuis le scan tout le long jusqu&rsquo;à son exécution.</p><img src="image/compiling-expressions/pipeline.png" alt="Abaisser la section 'compilateur' du tuyau entre 'scanner' et 'VM'." />
<p>Deuxièmement, nous pouvons écrire un <em>compilateur</em> réel, authentique. Il parse le code source et sort une série d&rsquo;instructions binaires de bas niveau. Bien sûr, c&rsquo;est du <span name="wirth">bytecode</span> et pas le jeu d&rsquo;instructions natif d&rsquo;une puce, mais c&rsquo;est bien plus proche du métal que ne l&rsquo;était jlox. Nous sommes sur le point d&rsquo;être de vrais hackers de langage.</p>
<aside name="wirth">
<p>Le bytecode était assez bon pour Niklaus Wirth, et personne ne remet en question sa crédibilité de rue.</p>
</aside>
<p><span name="pratt">Troisièmement</span> et finalement, je peux vous montrer l&rsquo;un de mes algorithmes favoris absolus : l&rsquo;&ldquo;analyse syntaxique à précédence d&rsquo;opérateur descendante&rdquo; de Vaughan Pratt. C&rsquo;est la façon la plus élégante que je connaisse de parser des expressions. Elle gère avec grâce les opérateurs préfixes, postfixes, infixes, <em>mixfixes</em>, n&rsquo;importe quel genre de <em>-fixe</em> que vous avez. Elle traite la précédence et l&rsquo;associativité sans transpirer. J&rsquo;adore ça.</p>
<aside name="pratt">
<p>Les parseurs Pratt sont une sorte de tradition orale dans l&rsquo;industrie. Aucun livre de compilateur ou de langage que j&rsquo;ai lu ne les enseigne. Le monde académique est très focalisé sur les parseurs générés, et la technique de Pratt est pour ceux écrits à la main, donc elle est négligée.</p>
<p>Mais dans les compilateurs en production, où les parseurs roulés à la main sont communs, vous seriez surpris de combien de gens la connaissent. Demandez où ils l&rsquo;ont apprise, et c&rsquo;est toujours, &ldquo;Oh, j&rsquo;ai travaillé sur ce compilateur il y a des années et mon collègue a dit qu&rsquo;ils l&rsquo;avaient prise de ce vieux front end<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>&rdquo;</p>
</aside>
<p>Comme d&rsquo;habitude, avant que nous arrivions aux trucs amusants, nous avons quelques préliminaires à travailler. Vous devez manger vos légumes avant d&rsquo;avoir le dessert. D&rsquo;abord, abandonnons cet échafaudage temporaire que nous avons écrit pour tester le scanner et remplaçons-le par quelque chose de plus utile.</p>
<div class="codehilite"><pre class="insert-before">InterpretResult interpret(const char* source) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>interpret</em>()<br>
replace 2 lines</div>
<pre class="insert">  <span class="t">Chunk</span> <span class="i">chunk</span>;
  <span class="i">initChunk</span>(&amp;<span class="i">chunk</span>);

  <span class="k">if</span> (!<span class="i">compile</span>(<span class="i">source</span>, &amp;<span class="i">chunk</span>)) {
    <span class="i">freeChunk</span>(&amp;<span class="i">chunk</span>);
    <span class="k">return</span> <span class="a">INTERPRET_COMPILE_ERROR</span>;
  }

  <span class="i">vm</span>.<span class="i">chunk</span> = &amp;<span class="i">chunk</span>;
  <span class="i">vm</span>.<span class="i">ip</span> = <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>;

  <span class="t">InterpretResult</span> <span class="i">result</span> = <span class="i">run</span>();

  <span class="i">freeChunk</span>(&amp;<span class="i">chunk</span>);
  <span class="k">return</span> <span class="i">result</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 2 lines</div>

<p>Nous créons un nouveau morceau vide et le passons au compilateur. Le compilateur prendra le programme de l&rsquo;utilisateur et remplira le morceau avec du bytecode. Au moins, c&rsquo;est ce qu&rsquo;il fera si le programme n&rsquo;a aucune erreur de compilation. S&rsquo;il rencontre une erreur, <code>compile()</code> renvoie <code>false</code> et nous jetons le morceau inutilisable.</p>
<p>Sinon, nous envoyons le morceau complété à la VM pour être exécuté. Quand la VM finit, nous libérons le morceau et nous avons fini. Comme vous pouvez le voir, la signature de <code>compile()</code> est différente maintenant.</p>
<div class="codehilite"><pre class="insert-before">#define clox_compiler_h

</pre><div class="source-file"><em>compiler.h</em><br>
replace 1 line</div>
<pre class="insert"><span class="a">#include &quot;vm.h&quot;</span>

<span class="t">bool</span> <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em>, replace 1 line</div>

<p>Nous passons le morceau où le compilateur écrira le code, et ensuite <code>compile()</code> renvoie si la compilation a réussi ou non. Nous faisons le même changement à la signature dans l&rsquo;implémentation.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;scanner.h&quot;

</pre><div class="source-file"><em>compiler.c</em><br>
function <em>compile</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="t">bool</span> <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>) {
</pre><pre class="insert-after">  initScanner(source);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>compile</em>(), replace 1 line</div>

<p>Cet appel à <code>initScanner()</code> est la seule ligne qui survit à ce chapitre. Arrachez le code temporaire que nous avons écrit pour tester le scanner et remplacez-le par ces trois lignes :</p>
<div class="codehilite"><pre class="insert-before">  initScanner(source);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()<br>
replace 13 lines</div>
<pre class="insert">  <span class="i">advance</span>();
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_EOF</span>, <span class="s">&quot;Expect end of expression.&quot;</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>(), replace 13 lines</div>

<p>L&rsquo;appel à <code>advance()</code> &ldquo;amorce la pompe&rdquo; sur le scanner. Nous verrons ce qu&rsquo;il fait bientôt. Ensuit nous parsons une unique expression. Nous n&rsquo;allons pas faire les instructions (statements) encore, donc c&rsquo;est le seul sous-ensemble de la grammaire que nous supportons. Nous revisiterons cela quand nous <a href="variables-globales.html">ajouterons les instructions dans quelques chapitres</a>. Après que nous ayons compilé l&rsquo;expression, nous devrions être à la fin du code source, donc nous vérifions le token sentinelle EOF.</p>
<p>Nous allons passer le reste du chapitre à faire marcher cette fonction, spécialement ce petit appel <code>expression()</code>. Normalement, nous plongerions directement dans cette définition de fonction et travaillerions notre chemin à travers l&rsquo;implémentation de haut en bas.</p>
<p>Ce chapitre est <span name="blog">différent</span>. La technique de parsing de Pratt est remarquablement simple une fois que vous l&rsquo;avez toute chargée dans votre tête, mais c&rsquo;est un peu délicat de la casser en morceaux de taille bouchée. Elle est récursive, bien sûr, ce qui est une partie du problème. Mais elle repose aussi sur une grosse table de données. Alors que nous construisons l&rsquo;algorithme, cette table grandit de colonnes additionnelles.</p>
<aside name="blog">
<p>Si ce chapitre ne clique pas avec vous et que vous aimeriez une autre prise sur les concepts, j&rsquo;ai écrit un article qui enseigne le même algorithme mais en utilisant Java et un style orienté objet : <a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">&ldquo;Pratt Parsing: Expression Parsing Made Easy&rdquo;</a>.</p>
</aside>
<p>Je ne veux pas revisiter 40 et quelques lignes de code chaque fois que nous étendons la table. Donc nous allons travailler notre chemin vers le cœur du parseur depuis l&rsquo;extérieur et couvrir tous les bouts environnants avant que nous arrivions au centre juteux. Cela exigera un peu plus de patience et d&rsquo;espace de brouillon mental que la plupart des chapitres, mais c&rsquo;est le mieux que je pouvais faire.</p>
<h2><a href="#compilation-&agrave;-une-passe" id="compilation-&agrave;-une-passe"><small>17&#8202;.&#8202;1</small>Compilation &agrave; Une Passe</a></h2>
<p>Un compilateur a grossièrement deux travaux. Il parse le code source de l&rsquo;utilisateur pour comprendre ce qu&rsquo;il signifie. Ensuite il prend cette connaissance et sort des instructions de bas niveau qui produisent la même sémantique. Beaucoup de langages séparent ces deux rôles en deux <span name="passes">passes</span> séparées dans l&rsquo;implémentation. Un parseur produit un AST<span class="em">&mdash;</span>juste comme jlox le fait<span class="em">&mdash;</span>et ensuite un générateur de code traverse l&rsquo;AST et sort le code cible.</p>
<aside name="passes">
<p>En fait, la plupart des compilateurs optimisants sophistiqués ont un sacré paquet de plus que deux passes. Déterminer non seulement <em>quelles</em> passes d&rsquo;optimisation avoir, mais comment les ordonner pour presser le plus de performance hors du compilateur<span class="em">&mdash;</span>puisque les optimisations interagissent souvent de manières complexes<span class="em">&mdash;</span>est quelque part entre une &ldquo;zone ouverte de recherche&rdquo; et un &ldquo;art noir&rdquo;.</p>
</aside>
<p>Dans clox, nous prenons une approche vieille méthode et fusionnons ces deux passes en une. À l&rsquo;époque, les hackers de langage faisaient cela parce que les ordinateurs n&rsquo;avaient littéralement pas assez de mémoire pour stocker l&rsquo;AST d&rsquo;un fichier source entier. Nous le faisons parce que cela garde notre compilateur plus simple, ce qui est un vrai atout quand on programme en C.</p>
<p>Les compilateurs à une passe comme nous allons construire ne fonctionnent pas bien pour tous les langages. Puisque le compilateur a seulement une vue par le trou de la serrure dans le programme de l&rsquo;utilisateur tout en générant du code, le langage doit être conçu de telle sorte que vous n&rsquo;avez pas besoin de beaucoup de contexte environnant pour comprendre un morceau de syntaxe. Heureusement, le minuscule Lox typé dynamiquement est <span name="lox">bien adapté</span> à cela.</p>
<aside name="lox">
<p>Pas que cela devrait venir comme une grosse surprise. J&rsquo;ai conçu le langage spécifiquement pour ce livre après tout.</p><img src="image/compiling-expressions/keyhole.png" alt="Regardant à travers un trou de serrure à 'var x;'" />
</aside>
<p>Ce que cela signifie en termes pratiques est que notre module C &ldquo;compilateur&rdquo; a une fonctionnalité que vous reconnaîtrez de jlox pour parser<span class="em">&mdash;</span>consommer des tokens, correspondre des types de token attendus, etc. Et il a aussi des fonctions pour la génération de code<span class="em">&mdash;</span>émettre du bytecode et ajouter des constantes au morceau de destination. (Et cela signifie que j&rsquo;utiliserai &ldquo;parser&rdquo; et &ldquo;compiler&rdquo; de manière interchangeable à travers ce chapitre et les suivants.)</p>
<p>Nous construirons les moitiés de parsing et de génération de code d&rsquo;abord. Ensuite nous les coudrons ensemble avec le code au milieu qui utilise la technique de Pratt pour parser la grammaire particulière de Lox et sortir le bon bytecode.</p>
<h2><a href="#parser-les-tokens" id="parser-les-tokens"><small>17&#8202;.&#8202;2</small>Parser les Tokens</a></h2>
<p>En premier, la moitié avant du compilateur. Le nom de cette fonction devrait sembler familier.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;scanner.h&quot;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert">

<span class="k">static</span> <span class="t">void</span> <span class="i">advance</span>() {
  <span class="i">parser</span>.<span class="i">previous</span> = <span class="i">parser</span>.<span class="i">current</span>;

  <span class="k">for</span> (;;) {
    <span class="i">parser</span>.<span class="i">current</span> = <span class="i">scanToken</span>();
    <span class="k">if</span> (<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span> != <span class="a">TOKEN_ERROR</span>) <span class="k">break</span>;

    <span class="i">errorAtCurrent</span>(<span class="i">parser</span>.<span class="i">current</span>.<span class="i">start</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>Juste comme dans jlox, elle avance d&rsquo;un pas à travers le flux de tokens. Elle demande au scanner le prochain token et le stocke pour une utilisation ultérieure. Avant de faire cela, elle prend le vieux token <code>current</code> et planque ça dans un champ <code>previous</code>. Cela deviendra utile plus tard pour que nous puissions accéder au lexème après que nous ayons correspondu un token.</p>
<p>Le code pour lire le prochain token est enveloppé dans une boucle. Rappelez-vous, le scanner de clox ne rapporte pas les erreurs lexicales. Au lieu de cela, il crée des <em>tokens d&rsquo;erreur</em> spéciaux et laisse au parseur le soin de les rapporter. Nous faisons cela ici.</p>
<p>Nous continuons de boucler, lisant des tokens et rapportant les erreurs, jusqu&rsquo;à ce nous touchions un non-erreur ou atteignions la fin. De cette façon, le reste du parseur voit seulement des tokens valides. Le token courant et le précédent sont stockés dans cette struct :</p>
<div class="codehilite"><pre class="insert-before">#include &quot;scanner.h&quot;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Token</span> <span class="i">current</span>;
  <span class="t">Token</span> <span class="i">previous</span>;
} <span class="t">Parser</span>;

<span class="t">Parser</span> <span class="i">parser</span>;
</pre><pre class="insert-after">

static void advance() {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>Comme nous l&rsquo;avons fait dans d&rsquo;autres modules, nous avons une variable globale unique de ce type struct pour que nous n&rsquo;ayons pas besoin de passer l&rsquo;état de fonction en fonction dans le compilateur.</p>
<h3><a href="#gestion-des-erreurs-de-syntaxe" id="gestion-des-erreurs-de-syntaxe"><small>17&#8202;.&#8202;2&#8202;.&#8202;1</small>Gestion des erreurs de syntaxe</a></h3>
<p>Si le scanner nous passe un token d&rsquo;erreur, nous devons dire réellement à l&rsquo;utilisateur. Cela arrive en utilisant ceci :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after variable <em>parser</em></div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">errorAtCurrent</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="i">errorAt</span>(&amp;<span class="i">parser</span>.<span class="i">current</span>, <span class="i">message</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>

<p>Nous tirons l&rsquo;emplacement hors du token courant afin de dire à l&rsquo;utilisateur où l&rsquo;erreur s&rsquo;est produite et de transférer à <code>errorAt()</code>. Plus souvent, nous rapporterons une erreur à l&rsquo;emplacement du token que nous venons de consommer, donc nous donnons le nom plus court à cette autre fonction :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after variable <em>parser</em></div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">error</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="i">errorAt</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>, <span class="i">message</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>

<p>Le travail réel se passe ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after variable <em>parser</em></div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">errorAt</span>(<span class="t">Token</span>* <span class="i">token</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;[line %d] Error&quot;</span>, <span class="i">token</span>-&gt;<span class="i">line</span>);

  <span class="k">if</span> (<span class="i">token</span>-&gt;<span class="i">type</span> == <span class="a">TOKEN_EOF</span>) {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot; at end&quot;</span>);
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">token</span>-&gt;<span class="i">type</span> == <span class="a">TOKEN_ERROR</span>) {
    <span class="c">// Nothing.</span>
  } <span class="k">else</span> {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot; at &#39;%.*s&#39;&quot;</span>, <span class="i">token</span>-&gt;<span class="i">length</span>, <span class="i">token</span>-&gt;<span class="i">start</span>);
  }

  <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;: %s</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">message</span>);
  <span class="i">parser</span>.<span class="i">hadError</span> = <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>

<p>D&rsquo;abord, nous imprimons où l&rsquo;erreur s&rsquo;est produite. Nous essayons de montrer le lexème s&rsquo;il est lisible par un humain. Ensuite nous imprimons le message d&rsquo;erreur lui-même. Après cela, nous définissons ce drapeau <code>hadError</code>. Cela enregistre si des erreurs se sont produites durant la compilation. Ce champ vit aussi dans la struct parser.</p>
<div class="codehilite"><pre class="insert-before">  Token previous;
</pre><div class="source-file"><em>compiler.c</em><br>
in struct <em>Parser</em></div>
<pre class="insert">  <span class="t">bool</span> <span class="i">hadError</span>;
</pre><pre class="insert-after">} Parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Parser</em></div>

<p>Plus tôt j&rsquo;ai dit que <code>compile()</code> devrait renvoyer <code>false</code> si une erreur s&rsquo;est produite. Maintenant nous pouvons faire en sorte qu&rsquo;il fasse cela.</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_EOF, &quot;Expect end of expression.&quot;);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">  <span class="k">return</span> !<span class="i">parser</span>.<span class="i">hadError</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<p>J&rsquo;ai un autre drapeau à introduire pour la gestion d&rsquo;erreur. Nous voulons éviter les cascades d&rsquo;erreurs. Si l&rsquo;utilisateur a une erreur dans son code et que le parseur devient confus sur où il est dans la grammaire, nous ne voulons pas qu&rsquo;il vomisse tout un tas d&rsquo;erreurs consécutives sans signification après la première.</p>
<p>Nous avons corrigé ça dans jlox en utilisant la récupération d&rsquo;erreur en mode panique. Dans l&rsquo;interpréteur Java, nous levions une exception pour dérouler hors de tout le code du parseur à un point où nous pouvions sauter des tokens et resynchroniser. Nous n&rsquo;avons pas d&rsquo;<span name="setjmp">exceptions</span> en C. Au lieu de cela, nous ferons un peu de fumée et de miroirs. Nous ajoutons un drapeau pour suivre si nous sommes actuellement en mode panique.</p>
<aside name="setjmp">
<p>Il y a <code>setjmp()</code> et <code>longjmp()</code>, mais je préférerais ne pas aller par là. Ceux-là rendent trop facile de fuiter de la mémoire, d&rsquo;oublier de maintenir des invariants, ou autrement d&rsquo;avoir une Très Mauvaise Journée.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  bool hadError;
</pre><div class="source-file"><em>compiler.c</em><br>
in struct <em>Parser</em></div>
<pre class="insert">  <span class="t">bool</span> <span class="i">panicMode</span>;
</pre><pre class="insert-after">} Parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Parser</em></div>

<p>Quand une erreur se produit, nous le définissons.</p>
<div class="codehilite"><pre class="insert-before">static void errorAt(Token* token, const char* message) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>errorAt</em>()</div>
<pre class="insert">  <span class="i">parser</span>.<span class="i">panicMode</span> = <span class="k">true</span>;
</pre><pre class="insert-after">  fprintf(stderr, &quot;[line %d] Error&quot;, token-&gt;line);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>errorAt</em>()</div>

<p>Après cela, nous allons de l&rsquo;avant et continuons de compiler comme normal comme si l&rsquo;erreur ne s&rsquo;était jamais produite. Le bytecode ne sera jamais exécuté, donc c&rsquo;est inoffensif de continuer à avancer. Le truc est que tant que le drapeau de mode panique est défini, nous supprimons simplement toute autre erreur qui est détectée.</p>
<div class="codehilite"><pre class="insert-before">static void errorAt(Token* token, const char* message) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>errorAt</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">parser</span>.<span class="i">panicMode</span>) <span class="k">return</span>;
</pre><pre class="insert-after">  parser.panicMode = true;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>errorAt</em>()</div>

<p>Il y a une bonne chance que le parseur aille dans les mauvaises herbes, mais l&rsquo;utilisateur ne le saura pas parce que les erreurs sont toutes avalées. Le mode panique finit quand le parseur atteint un point de synchronisation. Pour Lox, nous avons choisi les frontières d&rsquo;instruction (statement), donc quand nous ajouterons plus tard celles-ci à notre compilateur, nous effacerons le drapeau là.</p>
<p>Ces nouveaux champs ont besoin d&rsquo;être initialisés.</p>
<div class="codehilite"><pre class="insert-before">  initScanner(source);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">

  <span class="i">parser</span>.<span class="i">hadError</span> = <span class="k">false</span>;
  <span class="i">parser</span>.<span class="i">panicMode</span> = <span class="k">false</span>;

</pre><pre class="insert-after">  advance();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<p>Et pour afficher les erreurs, nous avons besoin d&rsquo;un en-tête standard.</p>
<div class="codehilite"><pre class="insert-before">#include &lt;stdio.h&gt;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert"><span class="a">#include &lt;stdlib.h&gt;</span>
</pre><pre class="insert-after">

#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>Il y a une dernière fonction de parsing, une autre vieille amie de jlox.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>advance</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">consume</span>(<span class="t">TokenType</span> <span class="i">type</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="k">if</span> (<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span> == <span class="i">type</span>) {
    <span class="i">advance</span>();
    <span class="k">return</span>;
  }

  <span class="i">errorAtCurrent</span>(<span class="i">message</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>advance</em>()</div>

<p>Elle est similaire à <code>advance()</code> en ce qu&rsquo;elle lit le prochain token. Mais elle valide aussi que le token a un type attendu. Si non, elle rapporte une erreur. Cette fonction est la fondation de la plupart des erreurs de syntaxe dans le compilateur.</p>
<p>OK, c&rsquo;est assez sur le front end pour l&rsquo;instant.</p>
<h2><a href="#émettre-du-bytecode" id="émettre-du-bytecode"><small>17&#8202;.&#8202;3</small>Émettre du Bytecode</a></h2>
<p>Après que nous ayons parsé et compris un morceau du programme de l&rsquo;utilisateur, la prochaine étape est de traduire cela vers une série d&rsquo;instructions bytecode. Cela commence avec l&rsquo;étape la plus facile possible : ajouter un seul octet au morceau.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>consume</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">emitByte</span>(<span class="t">uint8_t</span> <span class="i">byte</span>) {
  <span class="i">writeChunk</span>(<span class="i">currentChunk</span>(), <span class="i">byte</span>, <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">line</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>consume</em>()</div>

<p>C&rsquo;est dur de croire que de grandes choses découleront d&rsquo;une fonction si simple. Elle écrit l&rsquo;octet donné, qui peut être un opcode ou un opérande à une instruction. Elle envoie l&rsquo;information de ligne du token précédent de sorte que les erreurs d&rsquo;exécution soient associées à cette ligne.</p>
<p>Le morceau que nous écrivons est passé dans <code>compile()</code>, mais il a besoin de faire son chemin vers <code>emitByte()</code>. Pour faire ça, nous comptons sur cette fonction intermédiaire :</p>
<div class="codehilite"><pre class="insert-before">Parser parser;
</pre><div class="source-file"><em>compiler.c</em><br>
add after variable <em>parser</em></div>
<pre class="insert"><span class="t">Chunk</span>* <span class="i">compilingChunk</span>;

<span class="k">static</span> <span class="t">Chunk</span>* <span class="i">currentChunk</span>() {
  <span class="k">return</span> <span class="i">compilingChunk</span>;
}

</pre><pre class="insert-after">static void errorAt(Token* token, const char* message) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>

<p>En ce moment, le pointeur de morceau est stocké dans une variable au niveau du module comme nous stockons d&rsquo;autre état global. Plus tard, quand nous commencerons à compiler des fonctions définies par l&rsquo;utilisateur, la notion de &ldquo;morceau courant&rdquo; deviendra plus compliquée. Pour éviter d&rsquo;avoir à revenir et changer beaucoup de code, j&rsquo;encapsule cette logique dans la fonction <code>currentChunk()</code>.</p>
<p>Nous initialisons cette nouvelle variable de module avant que nous écrivions tout bytecode :</p>
<div class="codehilite"><pre class="insert-before">bool compile(const char* source, Chunk* chunk) {
  initScanner(source);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">  <span class="i">compilingChunk</span> = <span class="i">chunk</span>;
</pre><pre class="insert-after">

  parser.hadError = false;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<p>Ensuite, à la toute fin, quand nous avons fini de compiler le morceau, nous emballons les choses.</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_EOF, &quot;Expect end of expression.&quot;);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">  <span class="i">endCompiler</span>();
</pre><pre class="insert-after">  return !parser.hadError;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<p>Cela appelle ceci :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitByte</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">endCompiler</span>() {
  <span class="i">emitReturn</span>();
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitByte</em>()</div>

<p>Dans ce chapitre, notre VM traite seulement avec des expressions. Quand vous lancez clox, il parsera, compilera, et exécutera une unique expression, puis imprimera le résultat. Pour imprimer cette valeur, nous utilisons temporairement l&rsquo;instruction <code>OP_RETURN</code>. Donc nous faisons en sorte que le compilateur ajoute une de celles-ci à la fin du morceau.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitByte</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">emitReturn</span>() {
  <span class="i">emitByte</span>(<span class="a">OP_RETURN</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitByte</em>()</div>

<p>Tant que nous sommes ici dans le back end nous pourrions aussi bien nous rendre la vie plus facile.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitByte</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">emitBytes</span>(<span class="t">uint8_t</span> <span class="i">byte1</span>, <span class="t">uint8_t</span> <span class="i">byte2</span>) {
  <span class="i">emitByte</span>(<span class="i">byte1</span>);
  <span class="i">emitByte</span>(<span class="i">byte2</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitByte</em>()</div>

<p>Avec le temps, nous aurons assez de cas où nous avons besoin d&rsquo;écrire un opcode suivi par un opérande d&rsquo;un octet pour qu&rsquo;il vaille la peine de définir cette fonction de commodité.</p>
<h2><a href="#parser-les-expressions-préfixes" id="parser-les-expressions-préfixes"><small>17&#8202;.&#8202;4</small>Parser les Expressions Préfixes</a></h2>
<p>Nous avons assemblé nos fonctions utilitaires de parsing et de génération de code. La pièce manquante est le code au milieu qui connecte celles-ci ensemble.</p><img src="image/compiling-expressions/mystery.png" alt="Fonctions de parsing à gauche, fonctions d'émission de bytecode à droite. Qu'est-ce qui va au milieu ?" />
<p>La seule étape dans <code>compile()</code> qu&rsquo;il nous reste à implémenter est cette fonction :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">expression</span>() {
  <span class="c">// What goes here?</span>
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>Nous ne sommes pas prêts à implémenter chaque sorte d&rsquo;expression en Lox encore. Zut, nous n&rsquo;avons même pas les Booléens. Pour ce chapitre, nous allons seulement nous inquiéter de quatre :</p>
<ul>
<li>Littéraux nombre : <code>123</code></li>
<li>Parenthèses pour le groupement : <code>(123)</code></li>
<li>Négation unaire : <code>-123</code></li>
<li>Les Quatre Cavaliers de l&rsquo;Arithmétique : <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
</ul>
<p>Alors que nous travaillons à travers les fonctions pour compiler chacun de ces genres d&rsquo;expressions, nous assemblerons aussi les exigences pour le parseur piloté par table qui les appelle.</p>
<h3><a href="#parseurs-pour-tokens" id="parseurs-pour-tokens"><small>17&#8202;.&#8202;4&#8202;.&#8202;1</small>Parseurs pour tokens</a></h3>
<p>Pour l&rsquo;instant, concentrons-nous sur les expressions Lox qui sont chacune seulement un token unique. Dans ce chapitre, c&rsquo;est juste les littéraux nombre, mais il y en aura plus tard. Voici comment nous pouvons les compiler :</p>
<p>Nous mappons chaque type de token vers un genre différent d&rsquo;expression. Nous définissons une fonction pour chaque expression qui sort le bytecode approprié. Ensuite nous construisons un tableau de pointeurs de fonction. Les index dans le tableau correspondent aux valeurs de l&rsquo;enum <code>TokenType</code>, et la fonction à chaque index est le code pour compiler une expression de ce type de token.</p>
<p>Pour compiler les littéraux nombre, nous stockons un pointeur vers la fonction suivante à l&rsquo;index <code>TOKEN_NUMBER</code> dans le tableau.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">number</span>() {
  <span class="t">double</span> <span class="i">value</span> = <span class="i">strtod</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">start</span>, <span class="a">NULL</span>);
  <span class="i">emitConstant</span>(<span class="i">value</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>Nous supposons que le token pour le littéral nombre a déjà été consommé et est stocké dans <code>previous</code>. Nous prenons ce lexème et utilisons la bibliothèque standard C pour le convertir en une valeur double. Ensuite nous générons le code pour charger cette valeur en utilisant cette fonction :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitReturn</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">emitConstant</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="i">emitBytes</span>(<span class="a">OP_CONSTANT</span>, <span class="i">makeConstant</span>(<span class="i">value</span>));
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitReturn</em>()</div>

<p>D&rsquo;abord, nous ajoutons la valeur à la table de constantes, ensuite nous émettons une instruction <code>OP_CONSTANT</code> qui la pousse sur la pile à l&rsquo;exécution. Pour insérer une entrée dans la table de constantes, nous comptons sur :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitReturn</em>()</div>
<pre><span class="k">static</span> <span class="t">uint8_t</span> <span class="i">makeConstant</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="t">int</span> <span class="i">constant</span> = <span class="i">addConstant</span>(<span class="i">currentChunk</span>(), <span class="i">value</span>);
  <span class="k">if</span> (<span class="i">constant</span> &gt; <span class="a">UINT8_MAX</span>) {
    <span class="i">error</span>(<span class="s">&quot;Too many constants in one chunk.&quot;</span>);
    <span class="k">return</span> <span class="n">0</span>;
  }

  <span class="k">return</span> (<span class="t">uint8_t</span>)<span class="i">constant</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitReturn</em>()</div>

<p>La plupart du travail se passe dans <code>addConstant()</code>, que nous avons définie de retour dans un <a href="morceaux-de-bytecode.html">chapitre précédent</a>. Cela ajoute la valeur donnée à la fin de la table de constantes du morceau et renvoie son index. Le travail de la nouvelle fonction est surtout de s&rsquo;assurer que nous n&rsquo;avons pas trop de constantes. Puisque l&rsquo;instruction <code>OP_CONSTANT</code> utilise un unique octet pour l&rsquo;opérande d&rsquo;index, nous pouvons stocker et charger seulement jusqu&rsquo;à <span name="256">256</span> constantes dans un morceau.</p>
<aside name="256">
<p>Oui, cette limite est assez basse. Si c&rsquo;était une implémentation de langage de pleine taille, nous voudrions ajouter une autre instruction comme <code>OP_CONSTANT_16</code> qui stocke l&rsquo;index comme un opérande de deux octets pour que nous puissions gérer plus de constantes quand nécessaire.</p>
<p>Le code pour supporter cela n&rsquo;est pas particulièrement illuminant, donc je l&rsquo;ai omis de clox, mais vous voudrez que vos VMs passent à l&rsquo;échelle pour de plus gros programmes.</p>
</aside>
<p>C&rsquo;est basiquement tout ce qu&rsquo;il faut. Pourvu qu&rsquo;il y ait quelque code convenable qui consomme un token <code>TOKEN_NUMBER</code>, cherche <code>number()</code> dans le tableau de pointeurs de fonction, et ensuite l&rsquo;appelle, nous pouvons maintenant compiler les littéraux nombre vers du bytecode.</p>
<h3><a href="#parenthèses-pour-le-groupement" id="parenthèses-pour-le-groupement"><small>17&#8202;.&#8202;4&#8202;.&#8202;2</small>Parenthèses pour le groupement</a></h3>
<p>Notre tableau de pointeurs de fonction de parsing pour l&rsquo;instant imaginaire serait génial si chaque expression était longue de seulement un token unique. Hélas, la plupart sont plus longues. Cependant, beaucoup d&rsquo;expressions <em>commencent</em> avec un token particulier. Nous appelons celles-ci des expressions <em>préfixes</em>. Par exemple, quand nous parsons une expression et que le token courant est <code>(</code>, nous savons que nous devons regarder une expression de groupement parenthésée.</p>
<p>Il s&rsquo;avère que notre tableau de pointeurs de fonction gère celles-ci aussi. La fonction de parsing pour un type d&rsquo;expression peut consommer tous les tokens additionnels qu&rsquo;elle veut, juste comme dans un parseur à descente récursive régulier. Voici comment les parenthèses fonctionnent :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">grouping</span>() {
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after expression.&quot;</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>Encore une fois, nous supposons que la parenthèse <code>(</code> initiale a déjà été consommée. Nous appelons <span name="recursive">récursivement</span> de retour dans <code>expression()</code> pour compiler l&rsquo;expression entre les parenthèses, puis parsons la parenthèse fermante <code>)</code> à la fin.</p>
<aside name="recursive">
<p>Un parseur Pratt n&rsquo;est pas un parseur à <em>descente</em> récursive, mais il est toujours récursif. C&rsquo;est attendu puisque la grammaire elle-même est récursive.</p>
</aside>
<p>Pour autant que le back end soit concerné, il n&rsquo;y a littéralement rien à une expression de groupement. Sa seule fonction est syntaxique<span class="em">&mdash;</span>elle vous laisse insérer une expression de priorité plus basse là où une priorité plus haute est attendue. Ainsi, elle n&rsquo;a aucune sémantique d&rsquo;exécution par elle-même et par conséquent n&rsquo;émet aucun bytecode. L&rsquo;appel intérieur à <code>expression()</code> prend soin de générer le bytecode pour l&rsquo;expression à l&rsquo;intérieur des parenthèses.</p>
<h3><a href="#négation-unaire" id="négation-unaire"><small>17&#8202;.&#8202;4&#8202;.&#8202;3</small>Négation unaire</a></h3>
<p>Le moins unaire est aussi une expression préfixe, donc cela fonctionne avec notre modèle aussi.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>number</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">unary</span>() {
  <span class="t">TokenType</span> <span class="i">operatorType</span> = <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>;

  <span class="c">// Compile the operand.</span>
  <span class="i">expression</span>();

  <span class="c">// Emit the operator instruction.</span>
  <span class="k">switch</span> (<span class="i">operatorType</span>) {
    <span class="k">case</span> <span class="a">TOKEN_MINUS</span>: <span class="i">emitByte</span>(<span class="a">OP_NEGATE</span>); <span class="k">break</span>;
    <span class="k">default</span>: <span class="k">return</span>; <span class="c">// Unreachable.</span>
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>number</em>()</div>

<p>Le token <code>-</code> de tête a été consommé et est assis dans <code>parser.previous</code>. Nous attrapons le type de token de là pour noter à quel opérateur unaire nous avons affaire. C&rsquo;est inutile pour l&rsquo;instant, mais cela aura plus de sens quand nous utiliserons cette même fonction pour compiler l&rsquo;opérateur <code>!</code> dans <a href="types-de-valeurs.html">le prochain chapitre</a>.</p>
<p>Comme dans <code>grouping()</code>, nous appelons récursivement <code>expression()</code> pour compiler l&rsquo;opérande. Après cela, nous émettons le bytecode pour effectuer la négation. Cela pourrait sembler un peu bizarre d&rsquo;écrire l&rsquo;instruction negate <em>après</em> le bytecode de son opérande puisque le <code>-</code> apparaît sur la gauche, mais pensez-y en termes d&rsquo;ordre d&rsquo;exécution :</p>
<ol>
<li>
<p>Nous évaluons l&rsquo;opérande d&rsquo;abord ce qui laisse sa valeur sur la pile.</p>
</li>
<li>
<p>Ensuite nous dépilons cette valeur, la nions, et poussons le résultat.</p>
</li>
</ol>
<p>Donc l&rsquo;instruction <code>OP_NEGATE</code> devrait être émise en <span name="line">dernier</span>. C&rsquo;est une partie du travail du compilateur<span class="em">&mdash;</span>parser le programme dans l&rsquo;ordre où il apparaît dans le code source et le réarranger dans l&rsquo;ordre où l&rsquo;exécution se produit.</p>
<aside name="line">
<p>Émettre l&rsquo;instruction <code>OP_NEGATE</code> après les opérandes signifie que le token courant quand le bytecode est écrit n&rsquo;est <em>pas</em> le token <code>-</code>. Cela n&rsquo;a surtout pas d&rsquo;importance, excepté que nous utilisons ce token pour le numéro de ligne à associer avec cette instruction.</p>
<p>Cela signifie que si vous avez une expression de négation multi-lignes, comme :</p>
<div class="codehilite"><pre><span class="k">print</span> -
  <span class="k">true</span>;
</pre></div>
<p>Alors l&rsquo;erreur d&rsquo;exécution sera rapportée sur la mauvaise ligne. Ici, elle montrerait l&rsquo;erreur à la ligne 2, même si le <code>-</code> est à la ligne 1. Une approche plus robuste serait de stocker la ligne du token avant de compiler l&rsquo;opérande et ensuite de passer cela dans <code>emitByte()</code>, mais je voulais garder les choses simples pour le livre.</p>
</aside>
<p>Il y a un problème avec ce code, cependant. La fonction <code>expression()</code> qu&rsquo;il appelle parsera n&rsquo;importe quelle expression pour l&rsquo;opérande, indépendamment de la précédence. Une fois que nous ajouterons les opérateurs binaires et autre syntaxe, cela fera la mauvaise chose. Considérez :</p>
<div class="codehilite"><pre>-<span class="i">a</span>.<span class="i">b</span> + <span class="i">c</span>;
</pre></div>
<p>Ici, l&rsquo;opérande de <code>-</code> devrait être juste l&rsquo;expression <code>a.b</code>, pas le <code>a.b + c</code> entier. Mais si <code>unary()</code> appelle <code>expression()</code>, cette dernière mâchera joyeusement à travers tout le code restant incluant le <code>+</code>. Elle traitera faussement le <code>-</code> comme de précédence plus basse que le <code>+</code>.</p>
<p>Quand nous parsons l&rsquo;opérande de <code>-</code> unaire, nous avons besoin de compiler seulement les expressions à un certain niveau de précédence ou plus haut. Dans le parseur à descente récursive de jlox nous accomplissions cela en appelant dans la méthode de parsing pour l&rsquo;expression de plus basse priorité que nous voulions autoriser (dans ce cas, <code>call()</code>). Chaque méthode pour parser une expression spécifique parsait aussi n&rsquo;importe quelles expressions de priorité plus haute aussi, donc cela incluait le reste de la table de précédence.</p>
<p>Les fonctions de parsing comme <code>number()</code> et <code>unary()</code> ici dans clox sont différentes. Chacune parse seulement exactement un type d&rsquo;expression. Elles ne cascadent pas pour inclure les types d&rsquo;expression de priorité plus haute aussi. Nous avons besoin d&rsquo;une solution différente, et elle ressemble à ceci :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>unary</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">parsePrecedence</span>(<span class="t">Precedence</span> <span class="i">precedence</span>) {
  <span class="c">// What goes here?</span>
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>unary</em>()</div>

<p>Cette fonction<span class="em">&mdash;</span>une fois que nous l&rsquo;implémenterons<span class="em">&mdash;</span>commence au token courant et parse n&rsquo;importe quelle expression au niveau de précédence donné ou plus haut. Nous avons quelque autre installation à traverser avant que nous puissions écrire le corps de cette fonction, mais vous pouvez probablement deviner qu&rsquo;elle utilisera cette table de pointeurs de fonction de parsing dont j&rsquo;ai parlé. Pour l&rsquo;instant, ne vous inquiétez pas trop de comment elle fonctionne. Afin de prendre la &ldquo;précédence&rdquo; comme un paramètre, nous la définissons numériquement.</p>
<div class="codehilite"><pre class="insert-before">} Parser;
</pre><div class="source-file"><em>compiler.c</em><br>
add after struct <em>Parser</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">PREC_NONE</span>,
  <span class="a">PREC_ASSIGNMENT</span>,  <span class="c">// =</span>
  <span class="a">PREC_OR</span>,          <span class="c">// or</span>
  <span class="a">PREC_AND</span>,         <span class="c">// and</span>
  <span class="a">PREC_EQUALITY</span>,    <span class="c">// == !=</span>
  <span class="a">PREC_COMPARISON</span>,  <span class="c">// &lt; &gt; &lt;= &gt;=</span>
  <span class="a">PREC_TERM</span>,        <span class="c">// + -</span>
  <span class="a">PREC_FACTOR</span>,      <span class="c">// * /</span>
  <span class="a">PREC_UNARY</span>,       <span class="c">// ! -</span>
  <span class="a">PREC_CALL</span>,        <span class="c">// . ()</span>
  <span class="a">PREC_PRIMARY</span>
} <span class="t">Precedence</span>;
</pre><pre class="insert-after">

Parser parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>Parser</em></div>

<p>Ce sont tous les niveaux de précédence de Lox dans l&rsquo;ordre du plus bas au plus haut. Puisque C donne implicitement des nombres successivement plus grands pour les enums, cela signifie que <code>PREC_CALL</code> est numériquement plus grand que <code>PREC_UNARY</code>. Par exemple, disons que le compilateur est assis sur un morceau de code comme :</p>
<div class="codehilite"><pre>-<span class="i">a</span>.<span class="i">b</span> + <span class="i">c</span>
</pre></div>
<p>Si nous appelons <code>parsePrecedence(PREC_ASSIGNMENT)</code>, alors il parsera l&rsquo;expression entière parce que <code>+</code> a une priorité plus haute que l&rsquo;assignation. Si au lieu de cela nous appelons <code>parsePrecedence(PREC_UNARY)</code>, il compilera le <code>-a.b</code> et arrêtera là. Il ne continue pas à travers le <code>+</code> parce que l&rsquo;addition a une priorité plus basse que les opérateurs unaires.</p>
<p>Avec cette fonction en main, c&rsquo;est un jeu d&rsquo;enfant de remplir le corps manquant pour <code>expression()</code>.</p>
<div class="codehilite"><pre class="insert-before">static void expression() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>expression</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">parsePrecedence</span>(<span class="a">PREC_ASSIGNMENT</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>expression</em>(), replace 1 line</div>

<p>Nous parsons simplement le niveau de précédence le plus bas, qui subsume toutes les expressions de priorité plus haute aussi. Maintenant, pour compiler l&rsquo;opérande pour une expression unaire, nous appelons cette nouvelle fonction et la limitons au niveau approprié :</p>
<div class="codehilite"><pre class="insert-before">  // Compile the operand.
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>unary</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">parsePrecedence</span>(<span class="a">PREC_UNARY</span>);
</pre><pre class="insert-after">

  // Emit the operator instruction.
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>unary</em>(), replace 1 line</div>

<p>Nous utilisons la propre précédence <code>PREC_UNARY</code> de l&rsquo;opérateur unaire pour permettre des expressions unaires <span name="useful">imbriquées</span> comme <code>!!doubleNegative</code>. Puisque les opérateurs unaires ont une priorité assez haute, cela exclut correctement des choses comme les opérateurs binaires. En parlant desquels<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<aside name="useful">
<p>Pas que l&rsquo;imbrication d&rsquo;expressions unaires soit particulièrement utile en Lox. Mais d&rsquo;autres langages vous laissent le faire, donc nous aussi.</p>
</aside>
<h2><a href="#parser-les-expressions-infixes" id="parser-les-expressions-infixes"><small>17&#8202;.&#8202;5</small>Parser les Expressions Infixes</a></h2>
<p>Les opérateurs binaires sont différents des expressions précédentes parce qu&rsquo;ils sont <em>infixes</em>. Avec les autres expressions, nous savons ce que nous parsons dès le tout premier token. Avec les expressions infixes, nous ne savons pas que nous sommes au milieu d&rsquo;un opérateur binaire jusqu&rsquo;à <em>après</em> que nous ayons parsé son opérande gauche et ensuite trébuché sur le token opérateur au milieu.</p>
<p>Voici un exemple :</p>
<div class="codehilite"><pre><span class="n">1</span> + <span class="n">2</span>
</pre></div>
<p>Marchons à travers l&rsquo;essai de compilation de ceci avec ce que nous savons jusqu&rsquo;ici :</p>
<ol>
<li>
<p>Nous appelons <code>expression()</code>. Cela appelle à son tour
<code>parsePrecedence(PREC_ASSIGNMENT)</code>.</p>
</li>
<li>
<p>Cette fonction (une fois que nous l&rsquo;implémentons) voit le token nombre de tête et reconnaît qu&rsquo;elle parse un littéral nombre. Elle passe la main à <code>number()</code>.</p>
</li>
<li>
<p><code>number()</code> crée une constante, émet un <code>OP_CONSTANT</code>, et renvoie vers <code>parsePrecedence()</code>.</p>
</li>
</ol>
<p>Maintenant quoi ? L&rsquo;appel à <code>parsePrecedence()</code> devrait consommer l&rsquo;expression d&rsquo;addition entière, donc il a besoin de continuer d&rsquo;une manière ou d&rsquo;une autre. Heureusement, le parseur est juste là où nous avons besoin qu&rsquo;il soit. Maintenant que nous avons compilé l&rsquo;expression de nombre de tête, le prochain token est <code>+</code>. C&rsquo;est le token exact dont <code>parsePrecedence()</code> a besoin pour détecter que nous sommes au milieu d&rsquo;une expression infixe et pour réaliser que l&rsquo;expression que nous avons déjà compilée est en fait un opérande à cela.</p>
<p>Donc ce tableau hypothétique de pointeurs de fonction ne liste pas juste des fonctions pour parser des expressions qui commencent avec un token donné. Au lieu de cela, c&rsquo;est une <em>table</em> de pointeurs de fonction. Une colonne associe les fonctions de parsing préfixes avec les types de token. La seconde colonne associe les fonctions de parsing infixes avec les types de token.</p>
<p>La fonction que nous utiliserons comme le parseur infixe pour <code>TOKEN_PLUS</code>, <code>TOKEN_MINUS</code>, <code>TOKEN_STAR</code>, et <code>TOKEN_SLASH</code> est celle-ci :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">binary</span>() {
  <span class="t">TokenType</span> <span class="i">operatorType</span> = <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>;
  <span class="t">ParseRule</span>* <span class="i">rule</span> = <span class="i">getRule</span>(<span class="i">operatorType</span>);
  <span class="i">parsePrecedence</span>((<span class="t">Precedence</span>)(<span class="i">rule</span>-&gt;<span class="i">precedence</span> + <span class="n">1</span>));

  <span class="k">switch</span> (<span class="i">operatorType</span>) {
    <span class="k">case</span> <span class="a">TOKEN_PLUS</span>:          <span class="i">emitByte</span>(<span class="a">OP_ADD</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_MINUS</span>:         <span class="i">emitByte</span>(<span class="a">OP_SUBTRACT</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_STAR</span>:          <span class="i">emitByte</span>(<span class="a">OP_MULTIPLY</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_SLASH</span>:         <span class="i">emitByte</span>(<span class="a">OP_DIVIDE</span>); <span class="k">break</span>;
    <span class="k">default</span>: <span class="k">return</span>; <span class="c">// Unreachable.</span>
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>Quand une fonction de parsing préfixe est appelée, le token de tête a déjà été consommé. Une fonction de parsing infixe est encore plus <em>in medias res</em><span class="em">&mdash;</span>l&rsquo;expression de l&rsquo;opérande gauche entier a déjà été compilée et l&rsquo;opérateur infixe subséquent consommé.</p>
<p>Le fait que l&rsquo;opérande gauche soit compilé en premier s&rsquo;arrange bien. Cela signifie qu&rsquo;à l&rsquo;exécution, ce code est exécuté en premier. Quand il tourne, la valeur qu&rsquo;il produit finira sur la pile. C&rsquo;est juste là où l&rsquo;opérateur infixe va en avoir besoin.</p>
<p>Ensuite nous venons ici à <code>binary()</code> pour gérer le reste des opérateurs arithmétiques. Cette fonction compile l&rsquo;opérande droit, un peu comme comment <code>unary()</code> compile son propre opérande de traîne. Finalement, elle émet l&rsquo;instruction bytecode qui effectue l&rsquo;opération binaire.</p>
<p>Quand tourné, la VM exécutera le code de l&rsquo;opérande gauche et droit, dans cet ordre, laissant leurs valeurs sur la pile. Ensuite elle exécute l&rsquo;instruction pour l&rsquo;opérateur. Cela dépile les deux valeurs, calcule l&rsquo;opération, et pousse le résultat.</p>
<p>Le code qui a probablement attiré votre œil ici est cette ligne <code>getRule()</code>. Quand nous parsons l&rsquo;opérande de droite, nous avons de nouveau besoin de nous inquiéter de la précédence. Prenez une expression comme :</p>
<div class="codehilite"><pre><span class="n">2</span> * <span class="n">3</span> + <span class="n">4</span>
</pre></div>
<p>Quand nous parsons l&rsquo;opérande droit de l&rsquo;expression <code>*</code>, nous avons besoin de juste capturer <code>3</code>, et non <code>3 + 4</code>, parce que <code>+</code> est de précédence plus basse que <code>*</code>. Nous pourrions définir une fonction séparée pour chaque opérateur binaire. Chacune appellerait <code>parsePrecedence()</code> et passerait le niveau de précédence correct pour son opérande.</p>
<p>Mais c&rsquo;est un peu fastidieux. La précédence de l&rsquo;opérande de droite de chaque opérateur binaire est un niveau plus <span name="higher">haut</span> que la sienne. Nous pouvons chercher cela dynamiquement avec ce truc <code>getRule()</code> auquel nous arriverons bientôt. Utilisant cela, nous appelons <code>parsePrecedence()</code> avec un niveau plus haut que le niveau de cet opérateur.</p>
<aside name="higher">
<p>Nous utilisons un niveau de précédence plus <em>haut</em> pour l&rsquo;opérande droit parce que les opérateurs binaires sont associatifs à gauche. Étant donné une série du <em>même</em> opérateur, comme :</p>
<div class="codehilite"><pre><span class="n">1</span> + <span class="n">2</span> + <span class="n">3</span> + <span class="n">4</span>
</pre></div>
<p>Nous voulons le parser comme :</p>
<div class="codehilite"><pre>((<span class="n">1</span> + <span class="n">2</span>) + <span class="n">3</span>) + <span class="n">4</span>
</pre></div>
<p>Ainsi, quand nous parsons l&rsquo;opérande de droite pour le premier <code>+</code>, nous voulons consommer le <code>2</code>, mais pas le reste, donc nous utilisons un niveau au-dessus de la précédence de <code>+</code>. Mais si notre opérateur était associatif à <em>droite</em>, ce serait faux. Étant donné :</p>
<div class="codehilite"><pre><span class="i">a</span> = <span class="i">b</span> = <span class="i">c</span> = <span class="i">d</span>
</pre></div>
<p>Puisque l&rsquo;assignation est associative à droite, nous voulons le parser comme :</p>
<div class="codehilite"><pre><span class="i">a</span> = (<span class="i">b</span> = (<span class="i">c</span> = <span class="i">d</span>))
</pre></div>
<p>Pour permettre cela, nous appellerions <code>parsePrecedence()</code> avec la <em>même</em> précédence que l&rsquo;opérateur courant.</p>
</aside>
<p>De cette façon, nous pouvons utiliser une fonction <code>binary()</code> unique pour tous les opérateurs binaires même s&rsquo;ils ont des précédences différentes.</p>
<h2><a href="#un-parseur-pratt" id="un-parseur-pratt"><small>17&#8202;.&#8202;6</small>Un Parseur Pratt</a></h2>
<p>Nous avons maintenant toutes les pièces et parties du compilateur disposées. Nous avons une fonction pour chaque production de grammaire : <code>number()</code>, <code>grouping()</code>, <code>unary()</code>, et <code>binary()</code>. Nous avons encore besoin d&rsquo;implémenter <code>parsePrecedence()</code>, et <code>getRule()</code>. Nous savons aussi que nous avons besoin d&rsquo;une table qui, étant donné un type de token, nous laisse trouver :</p>
<ul>
<li>
<p>la fonction pour compiler une expression préfixe commençant avec un token de ce type,</p>
</li>
<li>
<p>la fonction pour compiler une expression infixe dont l&rsquo;opérande gauche est suivi par un token de ce type, et</p>
</li>
<li>
<p>la précédence d&rsquo;une expression <span name="prefix">infixe</span> qui utilise ce token comme un opérateur.</p>
</li>
</ul>
<aside name="prefix">
<p>Nous n&rsquo;avons pas besoin de suivre la précédence de l&rsquo;expression <em>préfixe</em> commençant avec un token donné parce que tous les opérateurs préfixes en Lox ont la même précédence.</p>
</aside>
<p>Nous enveloppons ces trois propriétés dans une petite struct qui représente une ligne unique dans la table du parseur.</p>
<div class="codehilite"><pre class="insert-before">} Precedence;
</pre><div class="source-file"><em>compiler.c</em><br>
add after enum <em>Precedence</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">ParseFn</span> <span class="i">prefix</span>;
  <span class="t">ParseFn</span> <span class="i">infix</span>;
  <span class="t">Precedence</span> <span class="i">precedence</span>;
} <span class="t">ParseRule</span>;
</pre><pre class="insert-after">

Parser parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after enum <em>Precedence</em></div>

<p>Ce type ParseFn est un simple <span name="typedef">typedef</span> pour un type de fonction qui ne prend aucun argument et ne renvoie rien.</p>
<aside name="typedef" class="bottom">
<p>La syntaxe de C pour les types de pointeur de fonction est si mauvaise que je la cache toujours derrière un typedef. Je comprends l&rsquo;intention derrière la syntaxe<span class="em">&mdash;</span>le truc entier &ldquo;la déclaration reflète l&rsquo;utilisation&rdquo;<span class="em">&mdash;</span>mais je pense que c&rsquo;était une expérience syntaxique ratée.</p>
</aside>
<div class="codehilite"><pre class="insert-before">} Precedence;
</pre><div class="source-file"><em>compiler.c</em><br>
add after enum <em>Precedence</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="t">void</span> (*<span class="t">ParseFn</span>)();
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after enum <em>Precedence</em></div>

<p>La table qui pilote notre parseur entier est un tableau de ParseRules. Nous en avons parlé depuis toujours, et finalement vous pouvez la voir.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>unary</em>()</div>
<pre><span class="t">ParseRule</span> <span class="i">rules</span>[] = {
  [<span class="a">TOKEN_LEFT_PAREN</span>]    = {<span class="i">grouping</span>, <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_RIGHT_PAREN</span>]   = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_LEFT_BRACE</span>]    = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},<span name="big"> </span>
  [<span class="a">TOKEN_RIGHT_BRACE</span>]   = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_COMMA</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_DOT</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_MINUS</span>]         = {<span class="i">unary</span>,    <span class="i">binary</span>, <span class="a">PREC_TERM</span>},
  [<span class="a">TOKEN_PLUS</span>]          = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_TERM</span>},
  [<span class="a">TOKEN_SEMICOLON</span>]     = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_SLASH</span>]         = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_FACTOR</span>},
  [<span class="a">TOKEN_STAR</span>]          = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_FACTOR</span>},
  [<span class="a">TOKEN_BANG</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_BANG_EQUAL</span>]    = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_EQUAL</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_EQUAL_EQUAL</span>]   = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_GREATER</span>]       = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_GREATER_EQUAL</span>] = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_LESS</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_LESS_EQUAL</span>]    = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_IDENTIFIER</span>]    = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_STRING</span>]        = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_NUMBER</span>]        = {<span class="i">number</span>,   <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_AND</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_CLASS</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_ELSE</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_FALSE</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_FOR</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_FUN</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_IF</span>]            = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_NIL</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_OR</span>]            = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_PRINT</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_RETURN</span>]        = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_SUPER</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_THIS</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_TRUE</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_VAR</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_WHILE</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_ERROR</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_EOF</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
};
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>unary</em>()</div>

<aside name="big">
<p>Voyez ce que je veux dire à propos de ne pas vouloir revisiter la table chaque fois que nous avions besoin d&rsquo;une nouvelle colonne ? C&rsquo;est une bête.</p>
<p>Si vous n&rsquo;avez pas vu la syntaxe <code>[TOKEN_DOT] =</code> dans un littéral de tableau C, c&rsquo;est la syntaxe d&rsquo;initialiseur désigné de C99. C&rsquo;est plus clair que d&rsquo;avoir à compter les index de tableau à la main.</p>
</aside>
<p>Vous pouvez voir comment <code>grouping</code> et <code>unary</code> sont insérés dans la colonne de parseur préfixe pour leurs types de token respectifs. Dans la colonne suivante, <code>binary</code> est câblé aux quatre opérateurs infixes arithmétiques. Ces opérateurs infixes ont aussi leurs précédences définies dans la dernière colonne.</p>
<p>À part ceux-là, le reste de la table est plein de <code>NULL</code> et <code>PREC_NONE</code>. La plupart de ces cellules vides sont parce qu&rsquo;il n&rsquo;y a pas d&rsquo;expression associée avec ces tokens. Vous ne pouvez pas commencer une expression avec, disons, <code>else</code>, et <code>}</code> ferait un opérateur infixe assez confus.</p>
<p>Mais, aussi, nous n&rsquo;avons pas encore rempli la grammaire entière. Dans les chapitres ultérieurs, alors que nous ajoutons de nouveaux types d&rsquo;expression, certains de ces créneaux obtiendront des fonctions dedans. Une des choses que j&rsquo;aime à propos de cette approche du parsing est qu&rsquo;elle rend très facile de voir quels tokens sont utilisés par la grammaire et lesquels sont disponibles.</p>
<p>Maintenant que nous avons la table, nous sommes enfin prêts à écrire le code qui l&rsquo;utilise. C&rsquo;est là que notre parseur Pratt prend vie. La fonction la plus facile à définir est <code>getRule()</code>.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>parsePrecedence</em>()</div>
<pre><span class="k">static</span> <span class="t">ParseRule</span>* <span class="i">getRule</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="k">return</span> &amp;<span class="i">rules</span>[<span class="i">type</span>];
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parsePrecedence</em>()</div>

<p>Elle renvoie simplement la règle à l&rsquo;index donné. Elle est appelée par <code>binary()</code> pour chercher la précédence de l&rsquo;opérateur courant. Cette fonction existe seulement pour gérer un cycle de déclaration dans le code C. <code>binary()</code> est définie <em>avant</em> la table de règles de sorte que la table peut stocker un pointeur vers elle. Cela signifie que le corps de <code>binary()</code> ne peut pas accéder à la table directement.</p>
<p>Au lieu de cela, nous enveloppons la recherche dans une fonction. Cela nous laisse déclarer de manière anticipée <code>getRule()</code> avant la définition de <code>binary()</code>, et <span name="forward">ensuite</span> <em>définir</em> <code>getRule()</code> après la table. Nous aurons besoin d&rsquo;une couple d&rsquo;autres déclarations anticipées pour gérer le fait que notre grammaire est récursive, donc sortons-les toutes du chemin.</p>
<aside name="forward">
<p>C&rsquo;est ce qui arrive quand vous écrivez votre VM dans un langage qui a été conçu pour être compilé sur un PDP-11.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  emitReturn();
}
</pre><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre class="insert">

<span class="k">static</span> <span class="t">void</span> <span class="i">expression</span>();
<span class="k">static</span> <span class="t">ParseRule</span>* <span class="i">getRule</span>(<span class="t">TokenType</span> <span class="i">type</span>);
<span class="k">static</span> <span class="t">void</span> <span class="i">parsePrecedence</span>(<span class="t">Precedence</span> <span class="i">precedence</span>);

</pre><pre class="insert-after">static void binary() {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>Si vous suivez et implémentez clox vous-même, faites très attention aux petites annotations qui vous disent où mettre ces bouts de code. Ne vous inquiétez pas, cependant, si vous vous trompez, le compilateur C sera heureux de vous le dire.</p>
<h3><a href="#parser-avec-précédence" id="parser-avec-précédence"><small>17&#8202;.&#8202;6&#8202;.&#8202;1</small>Parser avec précédence</a></h3>
<p>Maintenant nous arrivons aux trucs amusants. Le maestro qui orchestre toutes les fonctions de parsing que nous avons définies est <code>parsePrecedence()</code>. Commençons avec le parsing des expressions préfixes.</p>
<div class="codehilite"><pre class="insert-before">static void parsePrecedence(Precedence precedence) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parsePrecedence</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">advance</span>();
  <span class="t">ParseFn</span> <span class="i">prefixRule</span> = <span class="i">getRule</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>)-&gt;<span class="i">prefix</span>;
  <span class="k">if</span> (<span class="i">prefixRule</span> == <span class="a">NULL</span>) {
    <span class="i">error</span>(<span class="s">&quot;Expect expression.&quot;</span>);
    <span class="k">return</span>;
  }

  <span class="i">prefixRule</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>(), replace 1 line</div>

<p>Nous lisons le prochain token et cherchons la ParseRule correspondante. S&rsquo;il n&rsquo;y a pas de parseur préfixe, alors le token doit être une erreur de syntaxe. Nous rapportons cela et revenons à l&rsquo;appelant.</p>
<p>Sinon, nous appelons cette fonction de parsing préfixe et la laissons faire son truc. Ce parseur préfixe compile le reste de l&rsquo;expression préfixe, consommant tous les autres tokens dont il a besoin, et revient ici. Les expressions infixes sont là où ça devient intéressant puisque la précédence entre en jeu. L&rsquo;implémentation est remarquablement simple.</p>
<div class="codehilite"><pre class="insert-before">  prefixRule();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parsePrecedence</em>()</div>
<pre class="insert">

  <span class="k">while</span> (<span class="i">precedence</span> &lt;= <span class="i">getRule</span>(<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span>)-&gt;<span class="i">precedence</span>) {
    <span class="i">advance</span>();
    <span class="t">ParseFn</span> <span class="i">infixRule</span> = <span class="i">getRule</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>)-&gt;<span class="i">infix</span>;
    <span class="i">infixRule</span>();
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>()</div>

<p>C&rsquo;est la chose entière. Vraiment. Voici comment la fonction entière fonctionne : Au début de <code>parsePrecedence()</code>, nous cherchons un parseur préfixe pour le token courant. Le premier token va <em>toujours</em> appartenir à quelque sorte d&rsquo;expression préfixe, par définition. Il peut s&rsquo;avérer être imbriqué comme un opérande à l&rsquo;intérieur d&rsquo;une ou plusieurs expressions infixes, mais alors que vous lisez le code de gauche à droite, le premier token que vous touchez appartient toujours à une expression préfixe.</p>
<p>Après avoir parsé cela, ce qui peut consommer plus de tokens, l&rsquo;expression préfixe est faite. Maintenant nous cherchons un parseur infixe pour le prochain token. Si nous en trouvons un, cela signifie que l&rsquo;expression préfixe que nous avons déjà compilée pourrait être un opérande pour lui. Mais seulement si l&rsquo;appel à <code>parsePrecedence()</code> a une <code>precedence</code> qui est assez basse pour permettre cet opérateur infixe.</p>
<p>Si le prochain token est de trop basse priorité, ou n&rsquo;est pas un opérateur infixe du tout, nous avons fini. Nous avons parsé autant d&rsquo;expression que nous pouvons. Sinon, nous consommons l&rsquo;opérateur et passons la main au parseur infixe que nous avons trouvé. Il consomme quels que soient les autres tokens dont il a besoin (habituellement l&rsquo;opérande de droite) et revient à <code>parsePrecedence()</code>. Ensuite nous bouclons en arrière et voyons si le <em>prochain</em> token est aussi un opérateur infixe valide qui peut prendre l&rsquo;expression précédente entière comme son opérande. Nous continuons de boucler comme ça, craquant à travers les opérateurs infixes et leurs opérandes jusqu&rsquo;à ce nous touchions un token qui n&rsquo;est pas un opérateur infixe ou est de trop basse priorité et nous arrêtons.</p>
<p>C&rsquo;est beaucoup de prose, mais si vous voulez vraiment fusionner votre esprit avec Vaughan Pratt et comprendre pleinement l&rsquo;algorithme, passez à travers le parseur dans votre débogueur alors qu&rsquo;il travaille à travers quelques expressions. Peut-être qu&rsquo;une image aidera. Il n&rsquo;y a qu&rsquo;une poignée de fonctions, mais elles sont merveilleusement entrelacées :</p>
<p><span name="connections"></span></p><img src="image/compiling-expressions/connections.png" alt="Les diverses fonctions de parsing et comment elles s'appellent les unes les autres." />
<aside name="connections">
<p>La flèche <img src="image/compiling-expressions/calls.png" alt="Une flèche pleine." class="arrow" /> connecte une fonction à une autre fonction qu&rsquo;elle appelle directement. La flèche <img src="image/compiling-expressions/points-to.png" alt="Une flèche ouverte." class="arrow" /> montre les pointeurs de la table vers les fonctions de parsing.</p>
</aside>
<p>Plus tard, nous aurons besoin d&rsquo;ajuster le code dans ce chapitre pour gérer l&rsquo;assignation. Mais, autrement, ce que nous avons écrit couvre tous nos besoins de compilation d&rsquo;expression pour le reste du livre. Nous brancherons des fonctions de parsing supplémentaires dans la table quand nous ajouterons de nouveaux genres d&rsquo;expressions, mais <code>parsePrecedence()</code> est complète.</p>
<h2><a href="#dumper-les-morceaux" id="dumper-les-morceaux"><small>17&#8202;.&#8202;7</small>Dumper les Morceaux</a></h2>
<p>Pendant que nous sommes ici dans le cœur de notre compilateur, nous devrions mettre un peu d&rsquo;instrumentation. Pour aider à déboguer le bytecode généré, nous ajouterons le support pour dumper le morceau une fois que le compilateur finit. Nous avons eu un peu de journalisation temporaire plus tôt quand nous écrivions le morceau à la main. Maintenant nous mettrons du vrai code pour que nous puissions l&rsquo;activer chaque fois que nous voulons.</p>
<p>Puisque ce n&rsquo;est pas pour les utilisateurs finaux, nous le cachons derrière un drapeau.</p>
<div class="codehilite"><pre class="insert-before">#include &lt;stdint.h&gt;

</pre><div class="source-file"><em>common.h</em></div>
<pre class="insert"><span class="a">#define DEBUG_PRINT_CODE</span>
</pre><pre class="insert-after">#define DEBUG_TRACE_EXECUTION
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>

<p>Quand ce drapeau est défini, nous utilisons notre module &ldquo;debug&rdquo; existant pour imprimer le bytecode du morceau.</p>
<div class="codehilite"><pre class="insert-before">  emitReturn();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endCompiler</em>()</div>
<pre class="insert"><span class="a">#ifdef DEBUG_PRINT_CODE</span>
  <span class="k">if</span> (!<span class="i">parser</span>.<span class="i">hadError</span>) {
    <span class="i">disassembleChunk</span>(<span class="i">currentChunk</span>(), <span class="s">&quot;code&quot;</span>);
  }
<span class="a">#endif</span>
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>()</div>

<p>Nous faisons cela seulement si le code était libre d&rsquo;erreurs. Après une erreur de syntaxe, le compilateur continue d&rsquo;avancer mais il est dans une sorte d&rsquo;état bizarre et pourrait produire du code cassé. C&rsquo;est inoffensif parce qu&rsquo;il ne sera pas exécuté, mais nous nous embrouillerons juste nous-mêmes si nous essayons de le lire.</p>
<p>Finalement, pour accéder à <code>disassembleChunk()</code>, nous avons besoin d&rsquo;inclure son en-tête.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;scanner.h&quot;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert">

<span class="a">#ifdef DEBUG_PRINT_CODE</span>
<span class="a">#include &quot;debug.h&quot;</span>
<span class="a">#endif</span>
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>Nous l&rsquo;avons fait ! C&rsquo;était la dernière section majeure à installer dans le pipeline de compilation et d&rsquo;exécution de notre VM. Notre interpréteur ne <em>ressemble</em> pas à grand-chose, mais à l&rsquo;intérieur il scanne, parse, compile vers du bytecode, et exécute.</p>
<p>Démarrez la VM et tapez une expression. Si nous avons tout fait juste, il devrait calculer et imprimer le résultat. Nous avons maintenant une calculatrice arithmétique très sur-ingénierée. Nous avons beaucoup de fonctionnalités de langage à ajouter dans les chapitres à venir, mais la fondation est en place.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>17&#8202;.&#8202;8</small>Défis</a></h2>
<ol>
<li>
<p>Pour comprendre vraiment le parseur, vous avez besoin de voir comment l&rsquo;exécution file à travers les fonctions de parsing intéressantes<span class="em">&mdash;</span><code>parsePrecedence()</code> et les fonctions de parseur stockées dans la table. Prenez cette (étrange) expression :</p>
<div class="codehilite"><pre>(-<span class="n">1</span> + <span class="n">2</span>) * <span class="n">3</span> - -<span class="n">4</span>
</pre></div>
<p>Écrivez une trace de comment ces fonctions sont appelées. Montrez l&rsquo;ordre dans lequel elles sont appelées, qui appelle qui, et les arguments passés à elles.</p>
</li>
<li>
<p>La ligne ParseRule pour <code>TOKEN_MINUS</code> a les deux pointeurs de fonction préfixe et infixe. C&rsquo;est parce que <code>-</code> est à la fois un opérateur préfixe (négation unaire) et un infixe (soustraction).</p>
<p>Dans le langage Lox complet, quels autres tokens peuvent être utilisés dans les deux positions préfixe et infixe ? Quoi à propos de C ou dans un autre langage de votre choix ?</p>
</li>
<li>
<p>Vous pourriez vous interroger sur les expressions complexes &ldquo;mixfixes&rdquo; qui ont plus que deux opérandes séparés par des tokens. L&rsquo;opérateur conditionnel ou &ldquo;ternaire&rdquo; de C, <code>?:</code>, est un largement connu.</p>
<p>Ajoutez le support pour cet opérateur au compilateur. Vous n&rsquo;avez pas à générer de bytecode, montrez juste comment vous le connecteriez au parseur et géreriez les opérandes.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--cest-juste-du-parsing" id="note-de-conception--cest-juste-du-parsing"><small>17&#8202;.&#8202;9</small>Note de Conception : C&rsquo;est Juste du Parsing</a></h2>
<p>Je vais faire une déclaration ici qui sera impopulaire avec certains gens de compilateur et de langage. C&rsquo;est OK si vous n&rsquo;êtes pas d&rsquo;accord. Personnellement, j&rsquo;apprends plus d&rsquo;opinions fortement énoncées avec lesquelles je suis en désaccord que je ne le fais de plusieurs pages de qualificatifs et d&rsquo;équivoque. Ma réclamation est que <em>le parsing n&rsquo;a pas d&rsquo;importance</em>.</p>
<p>Au fil des années, beaucoup de gens de langage de programmation, spécialement dans le monde académique, se sont mis <em>vraiment</em> dans les parseurs et les ont pris très sérieusement. Initialement, c&rsquo;étaient les gens de compilateur qui se sont mis dans les <span name="yacc">compilateurs de compilateurs</span>, LALR, et d&rsquo;autres trucs comme ça. La première moitié du livre du dragon est une longue lettre d&rsquo;amour aux merveilles des générateurs de parseurs.</p>
<aside name="yacc">
<p>Nous souffrons tous du vice de &ldquo;quand tout ce que vous avez est un marteau, tout ressemble à un clou&rdquo;, mais peut-être aucun si visiblement que les gens de compilateur. Vous ne croiriez pas l&rsquo;ampleur des problèmes logiciels qui semblent miraculeusement exiger un nouveau petit langage dans leur solution dès que vous demandez de l&rsquo;aide à un hacker de compilateur.</p>
<p>Yacc et d&rsquo;autres compilateurs de compilateurs sont l&rsquo;exemple le plus délicieusement récursif. &ldquo;Wouah, écrire des compilateurs est une corvée. Je sais, écrivons un compilateur pour écrire notre compilateur pour nous.&rdquo;</p>
<p>Pour l&rsquo;enregistrement, je ne réclame pas l&rsquo;immunité à cette affliction.</p>
</aside>
<p>Plus tard, les gens de programmation fonctionnelle se sont mis dans les combinateurs de parseurs, les parseurs packrat, et d&rsquo;autres sortes de choses. Parce que, évidemment, si vous donnez un problème à un programmeur fonctionnel, la première chose qu&rsquo;ils feront est de sortir une poche pleine de fonctions d&rsquo;ordre supérieur.</p>
<p>Là-bas dans le pays de l&rsquo;analyse d&rsquo;algorithme et de maths, il y a un long héritage de recherche dans la preuve de temps et d&rsquo;utilisation mémoire pour diverses techniques de parsing, transformant des problèmes de parsing en d&rsquo;autres problèmes et vice versa, et assignant des classes de complexité à différentes grammaires.
À un niveau, ce truc est important. Si vous implémentez un langage, vous voulez une certaine assurance que votre parseur ne deviendra pas exponentiel et prendra 7 000 ans pour parser un cas limite bizarre dans la grammaire. La théorie des parseurs vous donne cette borne. Comme exercice intellectuel, apprendre les techniques de parsing est aussi amusant et gratifiant.</p>
<p>Mais si votre but est juste d&rsquo;implémenter un langage et de le mettre devant des utilisateurs, presque tout ce truc n&rsquo;a pas d&rsquo;importance. Il est vraiment facile de se laisser emporter par l&rsquo;enthousiasme des gens qui <em>sont</em> dedans et pensent que votre front end a <em>besoin</em> de quelque chose de génial type usine-de-parseur-combinateur-généré. J&rsquo;ai vu des gens brûler des tonnes de temps à écrire et réécrire leur parseur en utilisant quelle que soit la bibliothèque ou technique chaude d&rsquo;aujourd&rsquo;hui.</p>
<p>C&rsquo;est du temps qui n&rsquo;ajoute aucune valeur à la vie de votre utilisateur. Si vous essayez juste de finir votre parseur, choisissez une des techniques standard, utilisez-la, et passez à autre chose. La descente récursive, le parsing Pratt, et les générateurs de parseurs populaires comme ANTLR ou Bison sont tous bien.</p>
<p>Prenez le temps supplémentaire que vous avez économisé à ne pas réécrire votre code de parsing et dépensez-le à améliorer les messages d&rsquo;erreur de compilation que votre compilateur montre aux utilisateurs. Une bonne gestion et rapport d&rsquo;erreur est plus précieuse aux utilisateurs que presque n&rsquo;importe quoi d&rsquo;autre dans lequel vous pouvez mettre du temps dans le front end.</p>
</div>

<footer>
<a href="types-de-valeurs.html" class="next">
  Next Chapter: &ldquo;Types de valeurs&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
