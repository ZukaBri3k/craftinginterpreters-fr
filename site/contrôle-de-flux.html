<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Contrôle de flux &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Contrôle de flux<small>9</small></a></h3>

<ul>
    <li><a href="#machines-de-turing-brièvement"><small>9.1</small> Machines de Turing (Brièvement)</a></li>
    <li><a href="#exécution-conditionnelle"><small>9.2</small> Exécution Conditionnelle</a></li>
    <li><a href="#opérateurs-logiques"><small>9.3</small> Opérateurs Logiques</a></li>
    <li><a href="#boucles-while"><small>9.4</small> Boucles While</a></li>
    <li><a href="#boucles-for"><small>9.5</small> Boucles For</a></li>
    <li><a href="#défis"><small>9.6</small> Défis</a></li>
    <li><a href="#note-de-conception--cuillerées-de-sucre-syntaxique"><small>9.7</small> Note de Conception : Cuillerées de Sucre Syntaxique</a></li>
</ul>


<div class="prev-next">
    <a href="instructions-et-état.html" title="Instructions et état" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="fonctions.html" title="Fonctions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="instructions-et-état.html" title="Instructions et état" class="prev">←</a>
<a href="fonctions.html" title="Fonctions" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Contrôle de flux<small>9</small></a></h3>

<ul>
    <li><a href="#machines-de-turing-brièvement"><small>9.1</small> Machines de Turing (Brièvement)</a></li>
    <li><a href="#exécution-conditionnelle"><small>9.2</small> Exécution Conditionnelle</a></li>
    <li><a href="#opérateurs-logiques"><small>9.3</small> Opérateurs Logiques</a></li>
    <li><a href="#boucles-while"><small>9.4</small> Boucles While</a></li>
    <li><a href="#boucles-for"><small>9.5</small> Boucles For</a></li>
    <li><a href="#défis"><small>9.6</small> Défis</a></li>
    <li><a href="#note-de-conception--cuillerées-de-sucre-syntaxique"><small>9.7</small> Note de Conception : Cuillerées de Sucre Syntaxique</a></li>
</ul>


<div class="prev-next">
    <a href="instructions-et-état.html" title="Instructions et état" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="fonctions.html" title="Fonctions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">9</div>
  <h1>Contrôle de flux</h1>

<blockquote>
<p>La logique, comme le whisky, perd son effet bénéfique quand prise en trop larges
quantités.</p>
<p><cite>Edward John Moreton Drax Plunkett, Lord Dunsany</cite></p>
</blockquote>
<p>Comparé au marathon épuisant du <a href="statements-and-state.html">dernier chapitre</a>, aujourd&rsquo;hui est une gambade légère à travers une prairie de marguerites. Mais alors que le travail est facile, la récompense est étonnamment grande.</p>
<p>Pour l&rsquo;instant, notre interpréteur est un peu plus qu&rsquo;une calculatrice. Un programme Lox peut seulement faire une quantité fixe de travail avant de se terminer. Pour le faire tourner deux fois plus longtemps, vous devez rendre le code source deux fois plus long. Nous sommes sur le point de corriger cela. Dans ce chapitre, notre interpréteur fait un grand pas vers les ligues majeures des langages de programmation : la <em>Turing-complétude</em>.</p>
<h2><a href="#machines-de-turing-brièvement" id="machines-de-turing-brièvement"><small>9&#8202;.&#8202;1</small>Machines de Turing (Brièvement)</a></h2>
<p>Au début du siècle dernier, les mathématiciens ont trébuché sur une série de <span name="paradox">paradoxes</span> confus qui les ont menés à douter de la stabilité de la fondation sur laquelle ils avaient construit leur travail. Pour adresser cette <a href="https://en.wikipedia.org/wiki/Foundations_of_mathematics#Foundational_crisis">crise</a>, ils sont retournés à la case départ. En partant d&rsquo;une poignée d&rsquo;axiomes, de logique, et de théorie des ensembles, ils espéraient reconstruire les mathématiques au-dessus d&rsquo;une fondation imperméable.</p>
<aside name="paradox">
<p>Le plus célèbre est le <a href="https://fr.wikipedia.org/wiki/Paradoxe_de_Russell"><strong>paradoxe de Russell</strong></a>. Initialement, la théorie des ensembles vous permettait de définir n&rsquo;importe quelle sorte d&rsquo;ensemble. Si vous pouviez le décrire en anglais, c&rsquo;était valide. Naturellement, étant donné la prédilection des mathématiciens pour l&rsquo;auto-référence, les ensembles peuvent contenir d&rsquo;autres ensembles. Donc Russell, coquin qu&rsquo;il était, est arrivé avec :</p>
<p><em>R est l&rsquo;ensemble de tous les ensembles qui ne se contiennent pas eux-mêmes.</em></p>
<p>Est-ce que R se contient lui-même ? S&rsquo;il ne le fait pas, alors selon la seconde moitié de la définition il le devrait. Mais s&rsquo;il le fait, alors il ne respecte plus la définition. Cerveau qui explose.</p>
</aside>
<p>Ils voulaient répondre rigoureusement à des questions comme, &ldquo;Toutes les instructions vraies peuvent-elles être prouvées ?&rdquo;, &ldquo;Pouvons-nous <a href="https://en.wikipedia.org/wiki/Computable_function">calculer</a> toutes les fonctions que nous pouvons définir ?&rdquo;, ou même la question plus générale, &ldquo;Que voulons-nous dire quand nous prétendons qu&rsquo;une fonction est &lsquo;calculable&rsquo; ?&rdquo;</p>
<p>Ils présumaient que la réponse aux deux premières questions serait &ldquo;oui&rdquo;. Tout ce qui restait était de le prouver. Il s&rsquo;avère que la réponse aux deux est &ldquo;non&rdquo;, et étonnamment, les deux questions sont profondément entrelacées. C&rsquo;est un coin fascinant des mathématiques qui touche aux questions fondamentales sur ce que les cerveaux sont capables de faire et comment l&rsquo;univers fonctionne. Je ne peux pas lui rendre justice ici.</p>
<p>Ce que je veux noter est que dans le processus de prouver que la réponse aux deux premières questions est &ldquo;non&rdquo;, Alan Turing et Alonzo Church ont conçu une réponse précise à la dernière question<span class="em">&mdash;</span>une définition de quels types de fonctions sont <span name="uncomputable">calculables</span>. Ils ont chacun fabriqué un système minuscule avec un ensemble minimum de machinerie qui est encore assez puissant pour calculer n&rsquo;importe laquelle d&rsquo;une (très) grande classe de fonctions.</p>
<aside name="uncomputable">
<p>Ils ont prouvé que la réponse à la première question est &ldquo;non&rdquo; en montrant que la fonction qui renvoie la valeur de vérité d&rsquo;une instruction donnée n&rsquo;est <em>pas</em> calculable.</p>
</aside>
<p>Celles-ci sont maintenant considérées comme les &ldquo;fonctions calculables&rdquo;. Le système de Turing est appelé une <span name="turing"><strong>machine de Turing</strong></span>. Celui de Church est le <strong>lambda-calcul</strong>. Les deux sont encore largement utilisés comme base pour les modèles de calcul et, en fait, beaucoup de langages de programmation fonctionnels modernes utilisent le lambda-calcul à leur cœur.</p>
<aside name="turing">
<p>Turing appelait ses inventions &ldquo;a-machines&rdquo; pour &ldquo;automatique&rdquo;. Il n&rsquo;était pas auto-glorifiant au point de mettre son <em>propre</em> nom dessus. Plus tard les mathématiciens ont fait ça pour lui. C&rsquo;est comme ça qu&rsquo;on devient célèbre tout en gardant un peu de modestie.</p>
</aside><img src="image/control-flow/turing-machine.png" alt="Une machine de Turing." />
<p>Les machines de Turing ont une meilleure reconnaissance de nom<span class="em">&mdash;</span>il n&rsquo;y a pas encore de film hollywoodien sur Alonzo Church<span class="em">&mdash;</span>mais les deux formalismes sont <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">équivalents en puissance</a>. En fait, n&rsquo;importe quel langage de programmation avec un certain niveau minimal d&rsquo;expressivité est assez puissant pour calculer <em>n&rsquo;importe quelle</em> fonction calculable.</p>
<p>Vous pouvez prouver cela en écrivant un simulateur pour une machine de Turing dans votre langage. Puisque Turing a prouvé que sa machine peut calculer n&rsquo;importe quelle fonction calculable, par extension, cela signifie que votre langage le peut aussi. Tout ce que vous avez besoin de faire est de traduire la fonction en une machine de Turing, et ensuite d&rsquo;exécuter cela sur votre simulateur.</p>
<p>Si votre langage est assez expressif pour faire cela, il est considéré <strong>Turing-complet</strong>. Les machines de Turing sont assez simples, donc ça ne prend pas beaucoup de puissance pour faire cela. Vous avez fondamentalement besoin d&rsquo;arithmétique, d&rsquo;un peu de contrôle de flux, et de la capacité d&rsquo;allouer et d&rsquo;utiliser (théoriquement) des quantités arbitraires de mémoire. Nous avons la première. À la fin de ce chapitre, nous aurons la <span name="memory">seconde</span>.</p>
<aside name="memory">
<p>Nous avons <em>presque</em> la troisième aussi. Vous pouvez créer et concaténer des chaînes de taille arbitraire, donc vous pouvez <em>stocker</em> une mémoire illimitée. Mais nous n&rsquo;avons aucun moyen d&rsquo;accéder aux parties d&rsquo;une chaîne.</p>
</aside>
<h2><a href="#exécution-conditionnelle" id="exécution-conditionnelle"><small>9&#8202;.&#8202;2</small>Exécution Conditionnelle</a></h2>
<p>Assez d&rsquo;histoire, allons jazzer notre langage. Nous pouvons diviser le contrôle de flux grossièrement en deux types :</p>
<ul>
<li>
<p>Le <strong>contrôle de flux conditionnel</strong> ou <strong>de branchement</strong> est utilisé pour <em>ne pas</em> exécuter un certain morceau de code. Impérativement, vous pouvez penser à cela comme sauter <em>par-dessus</em> une région de code.</p>
</li>
<li>
<p>Le <strong>contrôle de flux de boucle</strong> exécute un morceau de code plus d&rsquo;une fois. Il saute en <em>arrière</em> pour que vous puissiez faire quelque chose à nouveau. Puisque vous ne voulez généralement pas de boucles <em>infinies</em>, il a typiquement une certaine logique conditionnelle pour savoir quand arrêter de boucler aussi.</p>
</li>
</ul>
<p>Le branchement est plus simple, donc nous commencerons là. Les langages dérivés de C ont deux fonctionnalités principales d&rsquo;exécution conditionnelle, l&rsquo;instruction <code>if</code> et l&rsquo;<span name="ternary">opérateur</span> &ldquo;conditionnel&rdquo; nommé avec perspicacité (<code>?:</code>). Une instruction <code>if</code> vous laisse exécuter conditionnellement des instructions et l&rsquo;opérateur conditionnel vous laisse exécuter conditionnellement des expressions.</p>
<aside name="ternary">
<p>L&rsquo;opérateur conditionnel est aussi appelé l&rsquo;opérateur &ldquo;ternaire&rdquo; parce que c&rsquo;est le seul opérateur en C qui prend trois opérandes.</p>
</aside>
<p>Pour la simplicité, Lox n&rsquo;a pas d&rsquo;opérateur conditionnel, donc allons-y avec notre instruction <code>if</code>. Notre grammaire d&rsquo;instructions obtient une nouvelle production.</p>
<p><span name="semicolon"></span></p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">block</span> ;

<span class="i">ifStmt</span>         → <span class="s">&quot;if&quot;</span> <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> <span class="i">statement</span>
               ( <span class="s">&quot;else&quot;</span> <span class="i">statement</span> )? ;
</pre></div>
<aside name="semicolon">
<p>Les points-virgules dans les règles ne sont pas cités, ce qui signifie qu&rsquo;ils font partie de la métasyntaxe de grammaire, pas de la syntaxe de Lox. Un bloc n&rsquo;a pas de <code>;</code> à la fin et une instruction <code>if</code> non plus, à moins que l&rsquo;instruction then ou else se trouve être une qui finit par un point-virgule.</p>
</aside>
<p>Une instruction <code>if</code> a une expression pour la condition, puis une instruction à exécuter si la condition est truthy (&ldquo;vraie&rdquo;). Optionnellement, elle peut aussi avoir un mot-clé <code>else</code> et une instruction à exécuter si la condition est falsey (&ldquo;fausse&rdquo;). Le <span name="if-ast">nœud d&rsquo;arbre syntaxique</span> a des champs pour chacune de ces trois pièces.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Expression : Expr expression&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;If         : Expr condition, Stmt thenBranch,&quot;</span> +
                  <span class="s">&quot; Stmt elseBranch&quot;</span>,
</pre><pre class="insert-after">      &quot;Print      : Expr expression&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="if-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#if-statement">Annexe II</a>.</p>
</aside>
<p>Comme les autres instructions, le parseur reconnaît une instruction <code>if</code> par le mot-clé <code>if</code> de tête.</p>
<div class="codehilite"><pre class="insert-before">  private Stmt statement() {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">IF</span>)) <span class="k">return</span> <span class="i">ifStatement</span>();
</pre><pre class="insert-after">    if (match(PRINT)) return printStatement();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>

<p>Quand il en trouve un, il appelle cette nouvelle méthode pour parser le reste :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>statement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">ifStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;if&#39;.&quot;</span>);
    <span class="t">Expr</span> <span class="i">condition</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after if condition.&quot;</span>);<span name="parens"> </span>

    <span class="t">Stmt</span> <span class="i">thenBranch</span> = <span class="i">statement</span>();
    <span class="t">Stmt</span> <span class="i">elseBranch</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">ELSE</span>)) {
      <span class="i">elseBranch</span> = <span class="i">statement</span>();
    }

    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">If</span>(<span class="i">condition</span>, <span class="i">thenBranch</span>, <span class="i">elseBranch</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>statement</em>()</div>

<aside name="parens">
<p>Les parenthèses autour de la condition sont seulement à moitié utiles. Vous avez besoin d&rsquo;une sorte de délimiteur <em>entre</em> la condition et l&rsquo;instruction then, sinon le parseur ne peut pas dire quand il a atteint la fin de l&rsquo;expression de condition. Mais la parenthèse <em>ouvrante</em> après <code>if</code> ne fait rien d&rsquo;utile. Dennis Ritchie l&rsquo;a mise là pour qu&rsquo;il puisse utiliser <code>)</code> comme délimiteur de fin sans avoir de parenthèses non balancées.</p>
<p>D&rsquo;autres langages comme Lua et certains BASICs utilisent un mot-clé comme <code>then</code> comme délimiteur de fin et n&rsquo;ont rien avant la condition. Go et Swift exigent à la place que l&rsquo;instruction soit un bloc entre accolades. Cela leur permet d&rsquo;utiliser le <code>{</code> au début de l&rsquo;instruction pour dire quand la condition est finie.</p>
</aside>
<p>Comme d&rsquo;habitude, le code de parsing colle de près à la grammaire. Il détecte une clause else en cherchant le mot-clé <code>else</code> précédent. S&rsquo;il n&rsquo;y en a pas, le champ <code>elseBranch</code> dans l&rsquo;arbre syntaxique est <code>null</code>.</p>
<p>Ce else optionnel apparemment inoffensif a, en fait, ouvert une ambiguïté dans notre grammaire. Considérez :</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">first</span>) <span class="k">if</span> (<span class="i">second</span>) <span class="i">whenTrue</span>(); <span class="k">else</span> <span class="i">whenFalse</span>();
</pre></div>
<p>Voici l&rsquo;énigme : À quelle instruction <code>if</code> cette clause else appartient-elle ? Ce n&rsquo;est pas juste une question théorique sur la façon dont nous notons notre grammaire. Cela affecte réellement comment le code s&rsquo;exécute :</p>
<ul>
<li>
<p>Si nous attachons le else à la première instruction <code>if</code>, alors <code>whenFalse()</code> est appelée si <code>first</code> est falsey, peu importe quelle valeur <code>second</code> a.</p>
</li>
<li>
<p>Si nous l&rsquo;attachons à la seconde instruction <code>if</code>, alors <code>whenFalse()</code> est seulement appelée si <code>first</code> est truthy et <code>second</code> est falsey.</p>
</li>
</ul>
<p>Puisque les clauses else sont optionnelles, et qu&rsquo;il n&rsquo;y a pas de délimiteur explicite marquant la fin de l&rsquo;instruction <code>if</code>, la grammaire est ambiguë quand vous imbriquez des <code>if</code>s de cette façon. Ce piège classique de syntaxe est appelé le problème du <strong><a href="https://en.wikipedia.org/wiki/Dangling_else">dangling else</a></strong> (else pendant).</p>
<p><span name="else"></span></p><img class="above" src="image/control-flow/dangling-else.png" alt="Deux façons dont le else peut être interprété." />
<aside name="else">
<p>Ici, le formatage souligne les deux façons dont le else pourrait être parsé. Mais notez que puisque les caractères d&rsquo;espacement sont ignorés par le parseur, c&rsquo;est seulement un guide pour le lecteur humain.</p>
</aside>
<p>Il <em>est</em> possible de définir une grammaire hors-contexte qui évite l&rsquo;ambiguïté directement, mais elle exige de diviser la plupart des règles d&rsquo;instruction en paires, une qui permet un <code>if</code> avec un <code>else</code> et une qui ne le permet pas. C&rsquo;est ennuyeux.</p>
<p>Au lieu de cela, la plupart des langages et parseurs évitent le problème d&rsquo;une manière ad hoc. Peu importe quel hack ils utilisent pour se sortir du pétrin, ils choisissent toujours la même interprétation<span class="em">&mdash;</span>le <code>else</code> est lié au <code>if</code> le plus proche qui le précède.</p>
<p>Notre parseur fait commodément cela déjà. Puisque <code>ifStatement()</code> cherche avidement un <code>else</code> avant de retourner, l&rsquo;appel le plus interne à une série imbriquée réclamera la clause else pour lui-même avant de retourner aux instructions <code>if</code> externes.</p>
<p>Syntaxe en main, nous sommes prêts à interpréter.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitExpressionStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitIfStmt</span>(<span class="t">Stmt</span>.<span class="t">If</span> <span class="i">stmt</span>) {
    <span class="k">if</span> (<span class="i">isTruthy</span>(<span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">condition</span>))) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">thenBranch</span>);
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">elseBranch</span> != <span class="k">null</span>) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">elseBranch</span>);
    }
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitExpressionStmt</em>()</div>

<p>L&rsquo;implémentation de l&rsquo;interpréteur est une fine enveloppe autour du code Java lui-même. Elle évalue la condition. Si truthy, elle exécute la branche then. Sinon, s&rsquo;il y a une branche else, elle exécute celle-là.</p>
<p>Si vous comparez ce code à la façon dont l&rsquo;interpréteur gère d&rsquo;autres syntaxes que nous avons implémentées, la partie qui rend le contrôle de flux spécial est cette instruction <code>if</code> Java. La plupart des autres arbres syntaxiques évaluent toujours leurs sous-arbres. Ici, nous pouvons ne pas évaluer l&rsquo;instruction then ou else. Si l&rsquo;une ou l&rsquo;autre a un effet de bord, le choix de ne pas l&rsquo;évaluer devient visible par l&rsquo;utilisateur.</p>
<h2><a href="#opérateurs-logiques" id="opérateurs-logiques"><small>9&#8202;.&#8202;3</small>Opérateurs Logiques</a></h2>
<p>Puisque nous n&rsquo;avons pas l&rsquo;opérateur conditionnel, vous pourriez penser que nous en avons fini avec le branchement, mais non. Même sans l&rsquo;opérateur ternaire, il y a deux autres opérateurs qui sont techniquement des constructions de contrôle de flux<span class="em">&mdash;</span>les opérateurs logiques <code>and</code> et <code>or</code>.</p>
<p>Ceux-ci ne sont pas comme les autres opérateurs binaires parce qu&rsquo;ils <strong>court-circuitent</strong>. Si, après avoir évalué l&rsquo;opérande gauche, nous savons quel doit être le résultat de l&rsquo;expression logique, nous n&rsquo;évaluons pas l&rsquo;opérande droit. Par exemple :</p>
<div class="codehilite"><pre><span class="k">false</span> <span class="k">and</span> <span class="i">sideEffect</span>();
</pre></div>
<p>Pour qu&rsquo;une expression <code>and</code> s&rsquo;évalue en quelque chose de truthy, les deux opérandes doivent être truthy. Nous pouvons voir dès que nous évaluons l&rsquo;opérande gauche <code>false</code> que ça ne va pas être le cas, donc il n&rsquo;y a pas besoin d&rsquo;évaluer <code>sideEffect()</code> et il est sauté.</p>
<p>C&rsquo;est pourquoi nous n&rsquo;avons pas implémenté les opérateurs logiques avec les autres opérateurs binaires. Maintenant nous sommes prêts. Les deux nouveaux opérateurs sont bas dans la table de précédence. Similaire à <code>||</code> et <code>&amp;&amp;</code> en C, ils ont chacun leur <span name="logical">propre</span> précédence avec <code>or</code> plus bas que <code>and</code>. Nous les glissons juste entre <code>assignment</code> et <code>equality</code>.</p>
<aside name="logical">
<p>Je me suis toujours demandé pourquoi ils n&rsquo;ont pas la même précédence, comme le font les divers opérateurs de comparaison ou d&rsquo;égalité.</p>
</aside>
<div class="codehilite"><pre><span class="i">expression</span>     → <span class="i">assignment</span> ;
<span class="i">assignment</span>     → <span class="t">IDENTIFIER</span> <span class="s">&quot;=&quot;</span> <span class="i">assignment</span>
               | <span class="i">logic_or</span> ;
<span class="i">logic_or</span>       → <span class="i">logic_and</span> ( <span class="s">&quot;or&quot;</span> <span class="i">logic_and</span> )* ;
<span class="i">logic_and</span>      → <span class="i">equality</span> ( <span class="s">&quot;and&quot;</span> <span class="i">equality</span> )* ;
</pre></div>
<p>Au lieu de se replier sur <code>equality</code>, <code>assignment</code> cascade maintenant vers <code>logic_or</code>. Les deux nouvelles règles, <code>logic_or</code> et <code>logic_and</code>, sont <span name="same">similaires</span> aux autres opérateurs binaires. Puis <code>logic_and</code> appelle <code>equality</code> pour ses opérandes, et nous rechaînons vers le reste des règles d&rsquo;expression.</p>
<aside name="same">
<p>La <em>syntaxe</em> se fiche qu&rsquo;ils court-circuitent. C&rsquo;est une préoccupation sémantique.</p>
</aside>
<p>Nous pourrions réutiliser la classe Expr.Binary existante pour ces deux nouvelles expressions puisqu&rsquo;elles ont les mêmes champs. Mais alors <code>visitBinaryExpr()</code> devrait vérifier pour voir si l&rsquo;opérateur est l&rsquo;un des opérateurs logiques et utiliser un chemin de code différent pour gérer le court-circuitage. Je pense que c&rsquo;est plus propre de définir une <span name="logical-ast">nouvelle classe</span> pour ces opérateurs pour qu&rsquo;ils obtiennent leur propre méthode visit.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Literal  : Object value&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Logical  : Expr left, Token operator, Expr right&quot;</span>,
</pre><pre class="insert-after">      &quot;Unary    : Token operator, Expr right&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="logical-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#logical-expression">Annexe II</a>.</p>
</aside>
<p>Pour tisser les nouvelles expressions dans le parseur, nous changeons d&rsquo;abord le code de parsing pour l&rsquo;affectation pour appeler <code>or()</code>.</p>
<div class="codehilite"><pre class="insert-before">  private Expr assignment() {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>assignment</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">or</span>();
</pre><pre class="insert-after">

    if (match(EQUAL)) {
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>assignment</em>(), replace 1 line</div>

<p>Le code pour parser une série d&rsquo;expressions <code>or</code> reflète les autres opérateurs binaires.</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>assignment</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">or</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">and</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">OR</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">and</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Logical</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>assignment</em>()</div>

<p>Ses opérandes sont le niveau de précédence immédiatement supérieur, la nouvelle expression <code>and</code>.</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>or</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">and</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">equality</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">AND</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">equality</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Logical</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>or</em>()</div>

<p>Cela appelle <code>equality()</code> pour ses opérandes, et avec cela, le parseur d&rsquo;expression est tout relié ensemble à nouveau. Nous sommes prêts à interpréter.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitLiteralExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitLogicalExpr</span>(<span class="t">Expr</span>.<span class="t">Logical</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">left</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">left</span>);

    <span class="k">if</span> (<span class="i">expr</span>.<span class="i">operator</span>.<span class="i">type</span> == <span class="t">TokenType</span>.<span class="i">OR</span>) {
      <span class="k">if</span> (<span class="i">isTruthy</span>(<span class="i">left</span>)) <span class="k">return</span> <span class="i">left</span>;
    } <span class="k">else</span> {
      <span class="k">if</span> (!<span class="i">isTruthy</span>(<span class="i">left</span>)) <span class="k">return</span> <span class="i">left</span>;
    }

    <span class="k">return</span> <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">right</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitLiteralExpr</em>()</div>

<p>Si vous comparez cela à la méthode <code>visitBinaryExpr()</code> du <a href="evaluating-expressions.html">chapitre précédent</a>, vous pouvez voir la différence. Ici, nous évaluons l&rsquo;opérande gauche d&rsquo;abord. Nous regardons sa valeur pour voir si nous pouvons cour-circuiter. Si non, et seulement alors, nous évaluons l&rsquo;opérande droit.</p>
<p>L&rsquo;autre morceau intéressant ici est de décider quelle valeur réelle renvoyer. Puisque Lox est typé dynamiquement, nous autorisons des opérandes de n&rsquo;importe quel type et utilisons la véracité (truthiness) pour déterminer ce que chaque opérande représente. Nous appliquons un raisonnement similaire au résultat. Au lieu de promettre de renvoyer littéralement <code>true</code> ou <code>false</code>, un opérateur logique garantit simplement qu&rsquo;il renverra une valeur avec la véracité appropriée.</p>
<p>Heureusement, nous avons des valeurs avec la bonne véracité juste sous la main<span class="em">&mdash;</span>les résultats des opérandes eux-mêmes. Donc nous utilisons ceux-là. Par exemple :</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="s">&quot;salut&quot;</span> <span class="k">or</span> <span class="n">2</span>; <span class="c">// &quot;salut&quot;.</span>
<span class="k">print</span> <span class="k">nil</span> <span class="k">or</span> <span class="s">&quot;oui&quot;</span>; <span class="c">// &quot;oui&quot;.</span>
</pre></div>
<p>Sur la première ligne, <code>"salut"</code> est truthy, donc le <code>or</code> court-circuite et renvoie ça. Sur la seconde ligne, <code>nil</code> est falsey, donc il évalue et renvoie le second opérande, <code>"oui"</code>.</p>
<p>Cela couvre toutes les primitives de branchement dans Lox. Nous sommes prêts à sauter en avant vers les boucles. Vous voyez ce que j&rsquo;ai fait là ? <em>Sauter. En avant.</em> Vous avez compris ? Voyez, c&rsquo;est comme une référence à<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>oh, oubliez ça.</p>
<h2><a href="#boucles-while" id="boucles-while"><small>9&#8202;.&#8202;4</small>Boucles While</a></h2>
<p>Lox propose deux instructions de contrôle de flux de boucle, <code>while</code> et <code>for</code>. La boucle <code>while</code> est la plus simple, donc nous commencerons là. Sa grammaire est la même qu&rsquo;en C.</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;

<span class="i">whileStmt</span>      → <span class="s">&quot;while&quot;</span> <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> <span class="i">statement</span> ;
</pre></div>
<p>Nous ajoutons une autre clause à la règle statement qui pointe vers la nouvelle règle pour while. Elle prend un mot-clé <code>while</code>, suivi par une expression de condition parenthésée, puis une instruction pour le corps. Cette nouvelle règle de grammaire obtient un <span name="while-ast">nœud d&rsquo;arbre syntaxique</span>.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Print      : Expr expression&quot;,
</pre><pre class="insert-before">      <span class="s">&quot;Var        : Token name, Expr initializer&quot;</span><span class="insert-comma">,</span>
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()<br>
add <em>&ldquo;,&rdquo;</em> to previous line</div>
<pre class="insert">      <span class="s">&quot;While      : Expr condition, Stmt body&quot;</span>
</pre><pre class="insert-after">    ));
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>(), add <em>&ldquo;,&rdquo;</em> to previous line</div>

<aside name="while-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#while-statement">Annexe II</a>.</p>
</aside>
<p>Le nœud stocke la condition et le corps. Ici vous pouvez voir pourquoi c&rsquo;est agréable d&rsquo;avoir des classes de base séparées pour les expressions et les instructions. Les déclarations de champ rendent clair que la condition est une expression et le corps est une instruction.</p>
<p>Là-bas dans le parseur, nous suivons le même processus que nous avons utilisé pour les instructions <code>if</code>. D&rsquo;abord, nous ajoutons un autre cas dans <code>statement()</code> pour détecter et matcher le mot-clé de tête.</p>
<div class="codehilite"><pre class="insert-before">    if (match(PRINT)) return printStatement();
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">WHILE</span>)) <span class="k">return</span> <span class="i">whileStatement</span>();
</pre><pre class="insert-after">    if (match(LEFT_BRACE)) return new Stmt.Block(block());
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>

<p>Cela délègue le vrai travail à cette méthode :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>varDeclaration</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">whileStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;while&#39;.&quot;</span>);
    <span class="t">Expr</span> <span class="i">condition</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after condition.&quot;</span>);
    <span class="t">Stmt</span> <span class="i">body</span> = <span class="i">statement</span>();

    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">While</span>(<span class="i">condition</span>, <span class="i">body</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>varDeclaration</em>()</div>

<p>La grammaire est simple à mourir et c&rsquo;est une traduction directe de celle-ci vers Java. En parlant de traduire directement vers Java, voici comment nous exécutons la nouvelle syntaxe :</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitVarStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitWhileStmt</span>(<span class="t">Stmt</span>.<span class="t">While</span> <span class="i">stmt</span>) {
    <span class="k">while</span> (<span class="i">isTruthy</span>(<span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">condition</span>))) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">body</span>);
    }
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitVarStmt</em>()</div>

<p>Comme la méthode visit pour <code>if</code>, ce visiteur utilise la fonctionnalité Java correspondante. Cette méthode n&rsquo;est pas complexe, mais elle rend Lox beaucoup plus puissant. Nous pouvons enfin écrire un programme dont le temps d&rsquo;exécution n&rsquo;est pas strictement lié par la longueur du code source.</p>
<h2><a href="#boucles-for" id="boucles-for"><small>9&#8202;.&#8202;5</small>Boucles For</a></h2>
<p>Nous sommes enfin à la dernière construction de contrôle de flux, <span name="for">Ye Olde</span> boucle <code>for</code> de style C. Je n&rsquo;ai probablement pas besoin de vous rappeler, mais ça ressemble à ça :</p>
<div class="codehilite"><pre><span class="k">for</span> (<span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="n">10</span>; <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>) <span class="k">print</span> <span class="i">i</span>;
</pre></div>
<p>En grammairien, c&rsquo;est :</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">forStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;

<span class="i">forStmt</span>        → <span class="s">&quot;for&quot;</span> <span class="s">&quot;(&quot;</span> ( <span class="i">varDecl</span> | <span class="i">exprStmt</span> | <span class="s">&quot;;&quot;</span> )
                 <span class="i">expression</span>? <span class="s">&quot;;&quot;</span>
                 <span class="i">expression</span>? <span class="s">&quot;)&quot;</span> <span class="i">statement</span> ;
</pre></div>
<aside name="for">
<p>La plupart des langages modernes ont une instruction de boucle de plus haut niveau pour itérer sur des séquences arbitraires définies par l&rsquo;utilisateur. C# a <code>foreach</code>, Java a le &ldquo;enhanced for&rdquo;, même C++ a des instructions <code>for</code> basées sur l&rsquo;intervalle maintenant. Celles-là offrent une syntaxe plus propre que l&rsquo;instruction <code>for</code> du C en appelant implicitement un protocole d&rsquo;itération que l&rsquo;objet sur lequel on boucle supporte.</p>
<p>Je les adore. Pour Lox, cependant, nous sommes limités par la construction de l&rsquo;interpréteur un chapitre à la fois. Nous n&rsquo;avons pas encore d&rsquo;objets et de méthodes, donc nous n&rsquo;avons aucun moyen de définir un protocole d&rsquo;itération que la boucle <code>for</code> pourrait utiliser. Donc nous allons rester avec la boucle <code>for</code> C vieille école. Pensez-y comme &ldquo;vintage&rdquo;. Le fixie des instructions de contrôle de flux.</p>
</aside>
<p>À l&rsquo;intérieur des parenthèses, vous avez trois clauses séparées par des points-virgules :</p>
<ol>
<li>
<p>La première clause est l&rsquo;<em>initialiseur</em>. Elle est exécutée exactement une fois, avant tout le reste. C&rsquo;est habituellement une expression, mais pour la commodité, nous autorisons aussi une déclaration de variable. Dans ce cas, la variable est portée au reste de la boucle <code>for</code><span class="em">&mdash;</span>les deux autres clauses et le corps.</p>
</li>
<li>
<p>Ensuite est la <em>condition</em>. Comme dans une boucle <code>while</code>, cette expression contrôle quand sortir de la boucle. Elle est évaluée une fois au début de chaque itération, incluant la première. Si le résultat est truthy, elle exécute le corps de la boucle. Sinon, elle se tire.</p>
</li>
<li>
<p>La dernière clause est l&rsquo;<em>incrément</em>. C&rsquo;est une expression arbitraire qui fait un peu de travail à la fin de chaque itération de boucle. Le résultat de l&rsquo;expression est rejeté, donc elle doit avoir un effet de bord pour être utile. En pratique, elle incrémente habituellement une variable.</p>
</li>
</ol>
<p>N&rsquo;importe laquelle de ces clauses peut être omise. Suivant la parenthèse fermante est une instruction pour le corps, qui est typiquement un bloc.</p>
<h3><a href="#désucrage" id="désucrage"><small>9&#8202;.&#8202;5&#8202;.&#8202;1</small>Désucrage</a></h3>
<p>C&rsquo;est beaucoup de machinerie, mais notez qu&rsquo;aucune partie ne fait quelque chose que vous ne pourriez pas faire avec les instructions que nous avons déjà. Si les boucles <code>for</code> ne supportaient pas de clauses d&rsquo;initialiseur, vous pourriez juste mettre l&rsquo;expression d&rsquo;initialiseur avant l&rsquo;instruction <code>for</code>. Sans une clause d&rsquo;incrément, vous pourriez simplement mettre l&rsquo;expression d&rsquo;incrément à la fin du corps vous-même.</p>
<p>En d&rsquo;autres termes, Lox n&rsquo;a pas <em>besoin</em> de boucles <code>for</code>, elles rendent juste certains motifs de code courants plus plaisants à écrire. Ces types de fonctionnalités sont appelés du <span name="sugar"><strong>sucre syntaxique</strong></span>. Par exemple, la boucle <code>for</code> précédente pourrait être réécrite comme ceci :</p>
<aside name="sugar">
<p>Cette délicieuse tournure de phrase a été inventée par Peter J. Landin en 1964 pour décrire comment certaines des jolies formes d&rsquo;expression supportées par des langages comme ALGOL étaient un édulcorant saupoudré sur le lambda-calcul plus fondamental<span class="em">&mdash;</span>mais présumément moins agréable au goût<span class="em">&mdash;</span>en dessous.</p><img class="above" src="image/control-flow/sugar.png" alt="Légèrement plus qu'une cuillère de sucre." />
</aside>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>;
  <span class="k">while</span> (<span class="i">i</span> &lt; <span class="n">10</span>) {
    <span class="k">print</span> <span class="i">i</span>;
    <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>;
  }
}
</pre></div>
<p>Ce script a exactement la même sémantique que le précédent, bien qu&rsquo;il ne soit pas aussi facile pour les yeux. Les fonctionnalités de sucre syntaxique comme la boucle <code>for</code> de Lox rendent un langage plus plaisant et productif pour y travailler. Mais, spécialement dans les implémentations de langage sophistiquées, chaque fonctionnalité de langage qui nécessite du support en back-end et de l&rsquo;optimisation est coûteuse.</p>
<p>Nous pouvons avoir le beurre et l&rsquo;argent du beurre en <span name="caramel"><strong>désucrant</strong></span>. Ce mot drôle décrit un processus où le front end prend du code utilisant du sucre syntaxique et le traduit vers une forme plus primitive que le back end sait déjà comment exécuter.</p>
<aside name="caramel">
<p>Oh, combien je souhaite que le terme accepté pour cela fût &ldquo;caramélisation&rdquo;. Pourquoi introduire une métaphore si vous n&rsquo;allez pas rester avec ?</p>
</aside>
<p>Nous allons désucrer les boucles <code>for</code> vers les boucles <code>while</code> et d&rsquo;autres instructions que l&rsquo;interpréteur gère déjà. Dans notre interpréteur simple, le désucrage ne nous économise vraiment pas beaucoup de travail, mais il me donne une excuse pour vous introduire à la technique. Donc, contrairement aux instructions précédentes, nous n&rsquo;ajouterons <em>pas</em> un nouveau nœud d&rsquo;arbre syntaxique. Au lieu de cela, nous allons directement au parsing. D&rsquo;abord, ajoutez un import dont nous aurons besoin bientôt.</p>
<div class="codehilite"><pre class="insert-before">import java.util.ArrayList;
</pre><div class="source-file"><em>lox/Parser.java</em></div>
<pre class="insert"><span class="k">import</span> <span class="i">java.util.Arrays</span>;
</pre><pre class="insert-after">import java.util.List;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em></div>

<p>Comme chaque instruction, nous commençons à parser une boucle <code>for</code> en matchant son mot-clé.</p>
<div class="codehilite"><pre class="insert-before">  private Stmt statement() {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">FOR</span>)) <span class="k">return</span> <span class="i">forStatement</span>();
</pre><pre class="insert-after">    if (match(IF)) return ifStatement();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>

<p>C&rsquo;est ici que ça devient intéressant. Le désucrage va se passer ici, donc nous construirons cette méthode un morceau à la fois, en commençant avec la parenthèse ouvrante avant les clauses.</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>statement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">forStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;for&#39;.&quot;</span>);

    <span class="c">// More here...</span>
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>statement</em>()</div>

<p>La première clause suivant cela est l&rsquo;initialiseur.</p>
<div class="codehilite"><pre class="insert-before">    consume(LEFT_PAREN, &quot;Expect '(' after 'for'.&quot;);

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">Stmt</span> <span class="i">initializer</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">SEMICOLON</span>)) {
      <span class="i">initializer</span> = <span class="k">null</span>;
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="i">VAR</span>)) {
      <span class="i">initializer</span> = <span class="i">varDeclaration</span>();
    } <span class="k">else</span> {
      <span class="i">initializer</span> = <span class="i">expressionStatement</span>();
    }
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>(), replace 1 line</div>

<p>Si le token suivant la <code>(</code> est un point-virgule alors l&rsquo;initialiseur a été omis. Sinon, nous vérifions un mot-clé <code>var</code> pour voir si c&rsquo;est une déclaration de <span name="variable">variable</span>. Si aucun de ceux-ci n&rsquo;a matché, ce doit être une expression. Nous parsons cela et l&rsquo;enveloppons dans une instruction d&rsquo;expression pour que l&rsquo;initialiseur soit toujours de type Stmt.</p>
<aside name="variable">
<p>Dans un chapitre précédent, j&rsquo;ai dit que nous pouvons diviser les arbres syntaxiques d&rsquo;expression et d&rsquo;instruction en deux hiérarchies de classe séparées parce qu&rsquo;il n&rsquo;y a pas un seul endroit dans la grammaire qui autorise à la fois une expression et une instruction. Ce n&rsquo;était pas <em>entièrement</em> vrai, je suppose.</p>
</aside>
<p>La suivante est la condition.</p>
<div class="codehilite"><pre class="insert-before">      initializer = expressionStatement();
    }
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">

    <span class="t">Expr</span> <span class="i">condition</span> = <span class="k">null</span>;
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">SEMICOLON</span>)) {
      <span class="i">condition</span> = <span class="i">expression</span>();
    }
    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after loop condition.&quot;</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Encore une fois, nous cherchons un point-virgule pour voir si la clause a été omise. La dernière clause est l&rsquo;incrément.</p>
<div class="codehilite"><pre class="insert-before">    consume(SEMICOLON, &quot;Expect ';' after loop condition.&quot;);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">

    <span class="t">Expr</span> <span class="i">increment</span> = <span class="k">null</span>;
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">RIGHT_PAREN</span>)) {
      <span class="i">increment</span> = <span class="i">expression</span>();
    }
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after for clauses.&quot;</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>C&rsquo;est similaire à la clause de condition sauf que celle-ci est terminée par la parenthèse fermante. Tout ce qui reste est le <span name="body">corps</span>.</p>
<aside name="body">
<p>Est-ce juste moi ou est-ce que ça sonne morbide ? &ldquo;Tout ce qui restait<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>était le <em>corps</em>&rdquo;.</p>
</aside>
<div class="codehilite"><pre class="insert-before">    consume(RIGHT_PAREN, &quot;Expect ')' after for clauses.&quot;);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="t">Stmt</span> <span class="i">body</span> = <span class="i">statement</span>();

    <span class="k">return</span> <span class="i">body</span>;
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Nous avons parsé toutes les pièces variées de la boucle <code>for</code> et les nœuds AST résultants sont assis dans une poignée de variables locales Java. C&rsquo;est là que le désucrage arrive. Nous prenons ceux-là et les utilisons pour synthétiser des nœuds d&rsquo;arbre syntaxique qui expriment la sémantique de la boucle <code>for</code>, comme l&rsquo;exemple désucré à la main que je vous ai montré plus tôt.</p>
<p>Le code est un peu plus simple si nous travaillons à l&rsquo;envers, donc nous commençons avec la clause d&rsquo;incrément.</p>
<div class="codehilite"><pre class="insert-before">    Stmt body = statement();

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">increment</span> != <span class="k">null</span>) {
      <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Block</span>(
          <span class="t">Arrays</span>.<span class="i">asList</span>(
              <span class="i">body</span>,
              <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Expression</span>(<span class="i">increment</span>)));
    }

</pre><pre class="insert-after">    return body;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>L&rsquo;incrément, s&rsquo;il y en a un, s&rsquo;exécute après le corps à chaque itération de la boucle. Nous faisons cela en remplaçant le corps par un petit bloc qui contient le corps original suivi par une instruction d&rsquo;expression qui évalue l&rsquo;incrément.</p>
<div class="codehilite"><pre class="insert-before">    }

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">condition</span> == <span class="k">null</span>) <span class="i">condition</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="k">true</span>);
    <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">While</span>(<span class="i">condition</span>, <span class="i">body</span>);

</pre><pre class="insert-after">    return body;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Ensuite, nous prenons la condition et le corps et construisons la boucle en utilisant une boucle primitive <code>while</code>. Si la condition est omise, nous bourrons <code>true</code> dedans pour faire une boucle infinie.</p>
<div class="codehilite"><pre class="insert-before">    body = new Stmt.While(condition, body);

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">initializer</span> != <span class="k">null</span>) {
      <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Block</span>(<span class="t">Arrays</span>.<span class="i">asList</span>(<span class="i">initializer</span>, <span class="i">body</span>));
    }

</pre><pre class="insert-after">    return body;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Finalement, s&rsquo;il y a un initialiseur, il tourne une fois avant la boucle entière. Nous faisons cela en, encore une fois, remplaçant l&rsquo;instruction entière par un bloc qui exécute l&rsquo;initialiseur et ensuite exécute la boucle.</p>
<p>C&rsquo;est tout. Notre interpréteur supporte maintenant les boucles <code>for</code> de style C et nous n&rsquo;avons pas eu à toucher la classe Interpreter du tout. Puisque nous avons désucré vers des nœuds que l&rsquo;interpréteur sait déjà comment visiter, il n&rsquo;y a plus de travail à faire.</p>
<p>Finalement, Lox est assez puissant pour nous divertir, au moins pour quelques minutes. Voici un programme minuscule pour imprimer les 21 premiers éléments dans la suite de Fibonacci :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">0</span>;
<span class="k">var</span> <span class="i">temp</span>;

<span class="k">for</span> (<span class="k">var</span> <span class="i">b</span> = <span class="n">1</span>; <span class="i">a</span> &lt; <span class="n">10000</span>; <span class="i">b</span> = <span class="i">temp</span> + <span class="i">b</span>) {
  <span class="k">print</span> <span class="i">a</span>;
  <span class="i">temp</span> = <span class="i">a</span>;
  <span class="i">a</span> = <span class="i">b</span>;
}
</pre></div>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>9&#8202;.&#8202;6</small>Défis</a></h2>
<ol>
<li>
<p>Quelques chapitres plus loin, quand Lox supportera les fonctions de première classe et le dispatch dynamique, nous n&rsquo;aurons techniquement pas <em>besoin</em> d&rsquo;instructions de branchement intégrées dans le langage. Montrez comment l&rsquo;exécution conditionnelle peut être implémentée en termes de celles-ci. Nommez un langage qui utilise cette technique pour son contrôle de flux.</p>
</li>
<li>
<p>De même, le bouclage peut être implémenté en utilisant ces mêmes outils, pourvu que notre interpréteur supporte une optimisation importante. Quelle est-elle, et pourquoi est-elle nécessaire ? Nommez un langage qui utilise cette technique pour l&rsquo;itération.</p>
</li>
<li>
<p>Contrairement à Lox, la plupart des autres langages de style C supportent aussi les instructions <code>break</code> et <code>continue</code> à l&rsquo;intérieur des boucles. Ajoutez le support pour les instructions <code>break</code>.</p>
<p>La syntaxe est un mot-clé <code>break</code> suivi par un point-virgule. Ce devrait être une erreur de syntaxe d&rsquo;avoir une instruction <code>break</code> apparaissant en dehors de toute boucle englobante. À l&rsquo;exécution, une instruction <code>break</code> fait sauter l&rsquo;exécution à la fin de la boucle englobante la plus proche et procède à partir de là. Notez que le <code>break</code> peut être imbriqué à l&rsquo;intérieur d&rsquo;autres blocs et instructions <code>if</code> qui ont aussi besoin d&rsquo;être sortis.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--cuillerées-de-sucre-syntaxique" id="note-de-conception--cuillerées-de-sucre-syntaxique"><small>9&#8202;.&#8202;7</small>Note de Conception : Cuillerées de Sucre Syntaxique</a></h2>
<p>Quand vous concevez votre propre langage, vous choisissez combien de sucre syntaxique verser dans la grammaire. Faites-vous une nourriture saine non sucrée où chaque opération sémantique mappe vers une seule unité syntaxique, ou quelque dessert décadent où chaque bit de comportement peut être exprimé de dix façons différentes ? Les langages à succès habitent tous les points le long de ce continuum.</p>
<p>À l&rsquo;extrémité acre extrême sont ceux avec une syntaxe impitoyablement minimale comme Lisp, Forth, et Smalltalk. Les Lisperiens prétendent fameusement que leur langage &ldquo;n&rsquo;a pas de syntaxe&rdquo;, alors que les Smalltalkers montrent fièrement que vous pouvez faire tenir la grammaire entière sur une fiche cartonnée. Cette tribu a la philosophie que le <em>langage</em> n&rsquo;a pas besoin de sucre syntaxique. Au lieu de cela, la syntaxe minimale et la sémantique qu&rsquo;il fournit sont assez puissantes pour laisser le code de bibliothèque être aussi expressif que s&rsquo;il faisait partie du langage lui-même.</p>
<p>Près de ceux-ci sont des langages comme C, Lua, et Go. Ils visent la simplicité et la clarté par-dessus le minimalisme. Certains, comme Go, évitent délibérément à la fois le sucre syntaxique et le genre d&rsquo;extensibilité syntaxique de la catégorie précédente. Ils veulent que la syntaxe s&rsquo;écarte du chemin de la sémantique, donc ils se concentrent sur garder à la fois la grammaire et les bibliothèques simples. Le code devrait être évident plus que beau.</p>
<p>Quelque part au milieu vous avez des langages comme Java, C#, et Python. Finalement vous atteignez Ruby, C++, Perl, et D<span class="em">&mdash;</span>des langages qui ont bourré tellement de syntaxe dans leur grammaire, qu&rsquo;ils manquent de caractères de ponctuation sur le clavier.</p>
<p>À un certain degré, l&rsquo;emplacement sur le spectre corrèle avec l&rsquo;âge. C&rsquo;est relativement facile d&rsquo;ajouter des morceaux de sucre syntaxique dans des versions ultérieures. La nouvelle syntaxe plaît à la foule, et c&rsquo;est moins susceptible de casser les programmes existants que de tripatouiller la sémantique. Une fois ajouté, vous ne pouvez jamais l&rsquo;enlever, donc les langages tendent à s&rsquo;adoucir avec le temps. L&rsquo;un des bénéfices principaux de créer un nouveau langage depuis zéro est que cela vous donne une opportunité de racler ces couches accumulées de glaçage et de recommencer.</p>
<p>Le sucre syntaxique a mauvaise réputation parmi l&rsquo;intelligentsia des langages de programmation. Il y a un vrai fétichisme pour le minimalisme dans cette foule. Il y a une certaine justification à cela. Une syntaxe mal conçue, inutile, élève la charge cognitive sans ajouter assez d&rsquo;expressivité pour porter son poids. Puisqu&rsquo;il y a toujours une pression pour entasser de nouvelles fonctionnalités dans le langage, cela prend de la discipline et une focalisation sur la simplicité pour éviter le ballonnement. Une fois que vous ajoutez une certaine syntaxe, vous êtes coincé avec, donc c&rsquo;est intelligent d&rsquo;être parcimonieux.</p>
<p>En même temps, la plupart des langages à succès ont des grammaires passablement complexes, au moins au moment où ils sont largement utilisés. Les programmeurs passent une tonne de temps dans leur langage de choix, et quelques gentillesses ici et là peuvent vraiment améliorer le confort et l&rsquo;efficacité de leur travail.</p>
<p>Frapper le bon équilibre<span class="em">&mdash;</span>choisir le bon niveau de douceur pour votre langage<span class="em">&mdash;</span>repose sur votre propre sens du goût.</p>
</div>

<footer>
<a href="fonctions.html" class="next">
  Next Chapter: &ldquo;Fonctions&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
