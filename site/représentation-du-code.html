<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Représentation du code &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Représentation du code<small>5</small></a></h3>

<ul>
    <li><a href="#grammaires-non-contextuelles"><small>5.1</small> Grammaires non contextuelles</a></li>
    <li><a href="#implémenter-des-arbres-syntaxiques"><small>5.2</small> Implémenter des Arbres Syntaxiques</a></li>
    <li><a href="#travailler-avec-des-arbres"><small>5.3</small> Travailler avec des Arbres</a></li>
    <li><a href="#un-pretty-printer-pas-très-joli"><small>5.4</small> Un Pretty Printer (Pas Très) Joli</a></li>
    <li><a href="#défis"><small>5.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="analyse-lexicale.html" title="Analyse lexicale" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="analyse-des-expressions.html" title="Analyse des expressions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="analyse-lexicale.html" title="Analyse lexicale" class="prev">←</a>
<a href="analyse-des-expressions.html" title="Analyse des expressions" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Représentation du code<small>5</small></a></h3>

<ul>
    <li><a href="#grammaires-non-contextuelles"><small>5.1</small> Grammaires non contextuelles</a></li>
    <li><a href="#implémenter-des-arbres-syntaxiques"><small>5.2</small> Implémenter des Arbres Syntaxiques</a></li>
    <li><a href="#travailler-avec-des-arbres"><small>5.3</small> Travailler avec des Arbres</a></li>
    <li><a href="#un-pretty-printer-pas-très-joli"><small>5.4</small> Un Pretty Printer (Pas Très) Joli</a></li>
    <li><a href="#défis"><small>5.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="analyse-lexicale.html" title="Analyse lexicale" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="analyse-des-expressions.html" title="Analyse des expressions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">5</div>
  <h1>Représentation du code</h1>

<blockquote>
<p>Pour les habitants d&rsquo;un bois, presque chaque espèce d&rsquo;arbre a sa voix aussi bien que
son apparence.
<cite>Thomas Hardy, <em>Under the Greenwood Tree</em></cite></p>
</blockquote>
<p>Dans le <a href="scanning.html">dernier chapitre</a>, nous avons pris le code source brut sous forme de chaîne et l&rsquo;avons transformé en une représentation de niveau légèrement supérieur : une série de tokens. Le parseur que nous écrirons dans le <a href="parsing-expressions.html">prochain chapitre</a> prendra ces tokens et les transformera encore une fois, en une représentation encore plus riche et plus complexe.</p>
<p>Avant de pouvoir produire cette représentation, nous devons la définir. C&rsquo;est le sujet de ce chapitre. En chemin, nous <span name="boring">couvrirons</span> un peu de théorie autour des grammaires formelles, sentirons la différence entre la programmation fonctionnelle et orientée objet, passerons en revue quelques patrons de conception, et ferons un peu de métaprogrammation.</p>
<aside name="boring">
<p>J&rsquo;étais tellement inquiet que ce soit l&rsquo;un des chapitres les plus ennuyeux du livre que j&rsquo;ai continué à y fourrer des idées amusantes jusqu&rsquo;à ce que je n&rsquo;aie plus de place.</p>
</aside>
<p>Avant de faire tout cela, concentrons-nous sur l&rsquo;objectif principal<span class="em">&mdash;</span>une représentation pour le code. Elle devrait être simple à produire pour le parseur et facile à consommer pour l&rsquo;interpréteur. Si vous n&rsquo;avez pas encore écrit de parseur ou d&rsquo;interpréteur, ces exigences ne sont pas exactement éclairantes. Peut-être que votre intuition peut aider. Que fait votre cerveau quand vous jouez le rôle d&rsquo;un interpréteur <em>humain</em> ? Comment évaluez-vous mentalement une expression arithmétique comme celle-ci :</p>
<div class="codehilite"><pre><span class="n">1</span> + <span class="n">2</span> * <span class="n">3</span> - <span class="n">4</span>
</pre></div>
<p>Parce que vous comprenez l&rsquo;ordre des opérations<span class="em">&mdash;</span>le vieux truc &ldquo;PEMDAS&rdquo;<span class="em">&mdash;</span>vous savez que la multiplication est évaluée avant l&rsquo;addition ou la soustraction. Une façon de visualiser cette précédence est d&rsquo;utiliser un arbre. Les nœuds feuilles sont des nombres, et les nœuds intérieurs sont des opérateurs avec des branches pour chacun de leurs opérandes.</p>
<p>Pour évaluer un nœud arithmétique, vous devez connaître les valeurs numériques de ses sous-arbres, donc vous devez évaluer ceux-là d&rsquo;abord. Cela signifie travailler des feuilles jusqu&rsquo;à la racine<span class="em">&mdash;</span>un parcours <em>post-ordre</em> :</p>
<p><span name="tree-steps"></span></p><img src="image/representing-code/tree-evaluate.png" alt="Évaluation de l'arbre du bas vers le haut." />
<aside name="tree-steps">
<p>A. En commençant avec l&rsquo;arbre complet, évaluez l&rsquo;opération la plus basse, <code>2 * 3</code>.</p>
<p>B. Maintenant nous pouvons évaluer le <code>+</code>.</p>
<p>C. Ensuite, le <code>-</code>.</p>
<p>D. La réponse finale.</p>
</aside>
<p>Si je vous donnais une expression arithmétique, vous pourriez dessiner l&rsquo;un de ces arbres assez facilement. Étant donné un arbre, vous pouvez l&rsquo;évaluer sans transpirer. Il semble donc intuitivement qu&rsquo;une représentation viable de notre code soit un <span name="only">arbre</span> qui correspond à la structure grammaticale<span class="em">&mdash;</span>l&rsquo;imbrication des opérateurs<span class="em">&mdash;</span>du langage.</p>
<aside name="only">
<p>Cela ne veut pas dire qu&rsquo;un arbre est la <em>seule</em> représentation possible de notre code. Dans la [Partie III][], nous générerons du bytecode, une autre représentation qui n&rsquo;est pas aussi conviviale pour les humains mais qui est plus proche de la machine.</p>
</aside>
<p>Nous devons être plus précis sur ce qu&rsquo;est cette grammaire alors. Comme les grammaires lexicales dans le dernier chapitre, il y a une tonne de théorie autour des grammaires syntaxiques. Nous entrons dans cette théorie un peu plus que nous ne l&rsquo;avons fait lors de l&rsquo;analyse lexicale parce qu&rsquo;il s&rsquo;avère que c&rsquo;est un outil utile pour une grande partie de l&rsquo;interpréteur. Nous commençons par monter d&rsquo;un niveau dans la [hiérarchie de Chomsky][]<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h2><a href="#grammaires-non-contextuelles" id="grammaires-non-contextuelles"><small>5&#8202;.&#8202;1</small>Grammaires non contextuelles</a></h2>
<p>Dans le dernier chapitre, le formalisme que nous avons utilisé pour définir la grammaire lexicale<span class="em">&mdash;</span>les règles pour comment les caractères sont regroupés en tokens<span class="em">&mdash;</span>s&rsquo;appelait un <em>langage régulier</em>. C&rsquo;était bien pour notre scanner, qui émet une séquence plate de tokens. Mais les langages réguliers ne sont pas assez puissants pour gérer des expressions qui peuvent s&rsquo;imbriquer arbitrairement profondément.</p>
<p>Nous avons besoin d&rsquo;un plus gros marteau, et ce marteau est une <strong>grammaire non contextuelle</strong> (<strong>GNC</strong>). C&rsquo;est l&rsquo;outil le plus lourd suivant dans la caisse à outils des <strong>[grammaires formelles][]</strong>. Une grammaire formelle prend un ensemble de pièces atomiques qu&rsquo;elle appelle son &ldquo;alphabet&rdquo;. Ensuite, elle définit un ensemble (généralement infini) de &ldquo;chaînes&rdquo; qui sont &ldquo;dans&rdquo; la grammaire. Chaque chaîne est une séquence de &ldquo;lettres&rdquo; de l&rsquo;alphabet.</p>
<p>J&rsquo;utilise tous ces guillemets parce que les termes deviennent un peu confus quand vous passez des grammaires lexicales aux grammaires syntaxiques. Dans la grammaire de notre scanner, l&rsquo;alphabet consiste en des caractères individuels et les chaînes sont les lexèmes valides<span class="em">&mdash;</span>grosso modo les &ldquo;mots&rdquo;. Dans la grammaire syntaxique dont nous parlons maintenant, nous sommes à un niveau de granularité différent. Maintenant chaque &ldquo;lettre&rdquo; dans l&rsquo;alphabet est un token entier et une &ldquo;chaîne&rdquo; est une séquence de <em>tokens</em><span class="em">&mdash;</span>une expression entière.</p>
<p>Ouf. Peut-être qu&rsquo;un tableau aidera :</p><table>
<thead>
<tr>
  <td>Terminologie</td>
  <td></td>
  <td>Grammaire lexicale</td>
  <td>Grammaire syntaxique</td>
</tr>
</thead>
<tbody>
<tr>
  <td>L'&ldquo;alphabet&rdquo; est<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.</span></td>
  <td>&rarr;&ensp;</td>
  <td>Caractères</td>
  <td>Tokens</td>
</tr>
<tr>
  <td>Une &ldquo;chaîne&rdquo; est<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.</span></td>
  <td>&rarr;&ensp;</td>
  <td>Lexème ou token</td>
  <td>Expression</td>
</tr>
<tr>
  <td>C'est implémenté par le<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.</span></td>
  <td>&rarr;&ensp;</td>
  <td>Scanner</td>
  <td>Parseur</td>
</tr>
</tbody>
</table>
<p>Le travail d&rsquo;une grammaire formelle est de spécifier quelles chaînes sont valides et lesquelles ne le sont pas. Si nous définissions une grammaire pour des phrases en anglais, &ldquo;eggs are tasty for breakfast&rdquo; serait dans la grammaire, mais &ldquo;tasty breakfast for are eggs&rdquo; ne le serait probablement pas.</p>
<h3><a href="#règles-pour-les-grammaires" id="règles-pour-les-grammaires"><small>5&#8202;.&#8202;1&#8202;.&#8202;1</small>Règles pour les grammaires</a></h3>
<p>Comment écrivons-nous une grammaire qui contient un nombre infini de chaînes valides ? Nous ne pouvons évidemment pas toutes les lister. Au lieu de cela, nous créons un ensemble fini de règles. Vous pouvez penser à elles comme un jeu auquel vous pouvez &ldquo;jouer&rdquo; dans l&rsquo;une de deux directions.</p>
<p>Si vous commencez avec les règles, vous pouvez les utiliser pour <em>générer</em> des chaînes qui sont dans la grammaire. Les chaînes créées de cette façon sont appelées des <strong>dérivations</strong> parce que chacune est <em>dérivée</em> des règles de la grammaire. À chaque étape du jeu, vous choisissez une règle et suivez ce qu&rsquo;elle vous dit de faire. La plupart du jargon autour des grammaires formelles vient du fait de les jouer dans cette direction. Les règles sont appelées <strong>productions</strong> parce qu&rsquo;elles <em>produisent</em> des chaînes dans la grammaire.</p>
<p>Chaque production dans une grammaire non contextuelle a une <strong>tête</strong><span class="em">&mdash;</span>son <span name="name">nom</span><span class="em">&mdash;</span>et un <strong>corps</strong>, qui décrit ce qu&rsquo;elle génère. Dans sa forme pure, le corps est simplement une liste de symboles. Les symboles viennent en deux saveurs délectables :</p>
<aside name="name">
<p>Restreindre les têtes à un seul symbole est une caractéristique qui définit les grammaires non contextuelles. Des formalismes plus puissants comme les <strong>[grammaires non restreintes][]</strong> autorisent une séquence de symboles dans la tête aussi bien que dans le corps.</p>
</aside>
<ul>
<li>
<p>Un <strong>terminal</strong> est une lettre de l&rsquo;alphabet de la grammaire. Vous pouvez le voir comme une valeur littérale. Dans la grammaire syntaxique que nous définissons, les terminaux sont des lexèmes individuels<span class="em">&mdash;</span>des tokens venant du scanner comme <code>if</code> ou <code>1234</code>.</p>
<p>On les appelle &ldquo;terminaux&rdquo;, dans le sens de &ldquo;point final&rdquo; parce qu&rsquo;ils ne mènent à aucun autre &ldquo;coup&rdquo; dans le jeu. Vous produisez simplement ce symbole unique.</p>
</li>
<li>
<p>Un <strong>non-terminal</strong> est une référence nommée à une autre règle dans la grammaire. Cela signifie &ldquo;joue cette règle et insère quoi qu&rsquo;elle produise ici&rdquo;. De cette façon, la grammaire se compose.</p>
</li>
</ul>
<p>Il y a un dernier raffinement : vous pouvez avoir plusieurs règles avec le même nom. Lorsque vous atteignez un non-terminal avec ce nom, vous êtes autorisé à choisir n&rsquo;importe laquelle des règles pour lui, celle qui vous plaît.</p>
<p>Pour rendre cela concret, nous avons besoin d&rsquo;une <span name="turtles">façon</span> d&rsquo;écrire ces règles de production. Les gens ont essayé de cristalliser la grammaire depuis l&rsquo;<em>Ashtadhyayi</em> de Pāṇini, qui a codifié la grammaire sanskrite il y a seulement quelques milliers d&rsquo;années. Peu de progrès ont eu lieu jusqu&rsquo;à ce que John Backus et compagnie aient besoin d&rsquo;une notation pour spécifier ALGOL 58 et inventent la <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form"><strong>forme de Backus-Naur</strong></a> (<strong>BNF</strong>). Depuis lors, presque tout le monde utilise une variante de BNF, ajustée à ses propres goûts.</p>
<p>J&rsquo;ai essayé de trouver quelque chose de propre. Chaque règle est un nom, suivi d&rsquo;une flèche (<code>→</code>), suivi d&rsquo;une séquence de symboles, et se terminant finalement par un point-virgule (<code>;</code>). Les terminaux sont des chaînes entre guillemets, et les non-terminaux sont des mots en minuscules.</p>
<aside name="turtles">
<p>Oui, nous avons besoin de définir une syntaxe à utiliser pour les règles qui définissent notre syntaxe. Devrions-nous spécifier cette <em>métasyntaxe</em> aussi ? Quelle notation utilisons-nous pour <em>elle</em> ? C&rsquo;est des langages jusqu&rsquo;en bas !</p>
</aside>
<p>En utilisant cela, voici une grammaire pour les menus du <span name="breakfast">petit-déjeuner</span> :</p>
<aside name="breakfast">
<p>Oui, je vais vraiment utiliser des exemples de petit-déjeuner tout au long de ce livre. Désolé.</p>
</aside>
<div class="codehilite"><pre><span class="i">breakfast</span>  → <span class="i">protein</span> <span class="s">&quot;with&quot;</span> <span class="i">breakfast</span> <span class="s">&quot;on the side&quot;</span> ;
<span class="i">breakfast</span>  → <span class="i">protein</span> ;
<span class="i">breakfast</span>  → <span class="i">bread</span> ;

<span class="i">protein</span>    → <span class="i">crispiness</span> <span class="s">&quot;crispy&quot;</span> <span class="s">&quot;bacon&quot;</span> ;
<span class="i">protein</span>    → <span class="s">&quot;sausage&quot;</span> ;
<span class="i">protein</span>    → <span class="i">cooked</span> <span class="s">&quot;eggs&quot;</span> ;

<span class="i">crispiness</span> → <span class="s">&quot;really&quot;</span> ;
<span class="i">crispiness</span> → <span class="s">&quot;really&quot;</span> <span class="i">crispiness</span> ;

<span class="i">cooked</span>     → <span class="s">&quot;scrambled&quot;</span> ;
<span class="i">cooked</span>     → <span class="s">&quot;poached&quot;</span> ;
<span class="i">cooked</span>     → <span class="s">&quot;fried&quot;</span> ;

<span class="i">bread</span>      → <span class="s">&quot;toast&quot;</span> ;
<span class="i">bread</span>      → <span class="s">&quot;biscuits&quot;</span> ;
<span class="i">bread</span>      → <span class="s">&quot;English muffin&quot;</span> ;
</pre></div>
<p>Nous pouvons utiliser cette grammaire pour générer des petits-déjeuners aléatoires. Jouons un tour et voyons comment ça marche. Par une convention séculaire, le jeu commence avec la première règle dans la grammaire, ici <code>breakfast</code>. Il y a trois productions pour celle-ci, et nous choisissons au hasard la première. Notre chaîne résultante ressemble à :</p>
<div class="codehilite"><pre>protein &quot;with&quot; breakfast &quot;on the side&quot;
</pre></div>
<p>Nous avons besoin d&rsquo;étendre ce premier non-terminal, <code>protein</code>, donc nous choisissons une production pour lui. Choisissons :</p>
<div class="codehilite"><pre><span class="i">protein</span> → <span class="i">cooked</span> <span class="s">&quot;eggs&quot;</span> ;
</pre></div>
<p>Ensuite, nous avons besoin d&rsquo;une production pour <code>cooked</code>, et donc nous choisissons <code>"poached"</code>. C&rsquo;est un terminal, donc nous l&rsquo;ajoutons. Maintenant notre chaîne ressemble à :</p>
<div class="codehilite"><pre>&quot;poached&quot; &quot;eggs&quot; &quot;with&quot; breakfast &quot;on the side&quot;
</pre></div>
<p>Le prochain non-terminal est <code>breakfast</code> à nouveau. La première production <code>breakfast</code> que nous avons choisie fait référence récursivement à la règle <code>breakfast</code>. La récursion dans la grammaire est un bon signe que le langage défini est non contextuel au lieu de régulier. En particulier, la récursion où le non-terminal récursif a des productions des <span name="nest">deux</span> côtés implique que le langage n&rsquo;est pas régulier.</p>
<aside name="nest">
<p>Imaginez que nous ayons étendu récursivement la règle <code>breakfast</code> ici plusieurs fois, comme &ldquo;bacon with bacon with bacon with<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>&rdquo; Pour compléter la chaîne correctement, nous avons besoin d&rsquo;ajouter un nombre <em>égal</em> de bouts &ldquo;on the side&rdquo; à la fin. Suivre le nombre de parties finales requises est au-delà des capacités d&rsquo;une grammaire régulière. Les grammaires régulières peuvent exprimer la <em>répétition</em>, mais elles ne peuvent pas <em>compter</em> combien de répétitions il y a, ce qui est nécessaire pour s&rsquo;assurer que la chaîne a le même nombre de parties <code>with</code> et <code>on the side</code>.</p>
</aside>
<p>Nous pourrions continuer à choisir la première production pour <code>breakfast</code> encore et encore produisant toute sorte de petits-déjeuners comme &ldquo;bacon with sausage with scrambled eggs with bacon<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>&rdquo; Nous ne le ferons pas cependant. Cette fois nous choisirons <code>bread</code>. Il y a trois règles pour cela, chacune contenant seulement un terminal. Nous choisirons &ldquo;English muffin&rdquo;.</p>
<p>Avec cela, chaque non-terminal dans la chaîne a été étendu jusqu&rsquo;à ce qu&rsquo;il ne contienne finalement que des terminaux et nous nous retrouvons avec :</p><img src="image/representing-code/breakfast.png" alt='"Jouer" la grammaire pour générer une chaîne.' />
<p>Ajoutez du jambon et de la sauce Hollandaise, et vous avez des œufs Bénédicte.</p>
<p>Chaque fois que nous tombions sur une règle qui avait plusieurs productions, nous en choisissions juste une arbitrairement. C&rsquo;est cette flexibilité qui permet à un petit nombre de règles de grammaire d&rsquo;encoder un ensemble combinatoirement plus grand de chaînes. Le fait qu&rsquo;une règle puisse se référer à elle-même<span class="em">&mdash;</span>directement ou indirectement<span class="em">&mdash;</span>augmente encore cela, nous laissant emballer un nombre infini de chaînes dans une grammaire finie.</p>
<h3><a href="#améliorer-notre-notation" id="améliorer-notre-notation"><small>5&#8202;.&#8202;1&#8202;.&#8202;2</small>Améliorer notre notation</a></h3>
<p>Fourrer un ensemble infini de chaînes dans une poignée de règles est assez fantastique, mais allons plus loin. Notre notation fonctionne, mais elle est fastidieuse. Donc, comme tout bon concepteur de langage, nous saupoudrerons un peu de sucre syntaxique dessus<span class="em">&mdash;</span>une notation de commodité supplémentaire. En plus des terminaux et des non-terminaux, nous autoriserons quelques autres types d&rsquo;expressions dans le corps d&rsquo;une règle :</p>
<ul>
<li>
<p>Au lieu de répéter le nom de la règle chaque fois que nous voulons ajouter une autre production pour elle, nous autoriserons une série de productions séparées par un pipe (<code>|</code>).</p>
<div class="codehilite"><pre><span class="i">bread</span> → <span class="s">&quot;toast&quot;</span> | <span class="s">&quot;biscuits&quot;</span> | <span class="s">&quot;English muffin&quot;</span> ;
</pre></div>
</li>
<li>
<p>De plus, nous autoriserons les parenthèses pour le groupement et ensuite autoriserons <code>|</code> à l&rsquo;intérieur pour sélectionner une option parmi une série au milieu d&rsquo;une production.</p>
<div class="codehilite"><pre><span class="i">protein</span> → ( <span class="s">&quot;scrambled&quot;</span> | <span class="s">&quot;poached&quot;</span> | <span class="s">&quot;fried&quot;</span> ) <span class="s">&quot;eggs&quot;</span> ;
</pre></div>
</li>
<li>
<p>Utiliser la récursion pour supporter des séquences répétées de symboles a une certaine <span name="purity">pureté</span> attirante, mais c&rsquo;est un peu une corvée de faire une sous-règle nommée séparée chaque fois que nous voulons boucler. Donc, nous utilisons aussi un suffixe <code>*</code> pour permettre au symbole ou groupe précédent d&rsquo;être répété zéro ou plusieurs fois.</p>
<div class="codehilite"><pre><span class="i">crispiness</span> → <span class="s">&quot;really&quot;</span> <span class="s">&quot;really&quot;</span>* ;
</pre></div>
</li>
</ul>
<aside name="purity">
<p>C&rsquo;est comme ça que le langage de programmation Scheme fonctionne. Il n&rsquo;a aucune fonctionnalité de boucle intégrée du tout. Au lieu de cela, <em>toute</em> répétition est exprimée en termes de récursion.</p>
</aside>
<ul>
<li>
<p>Un suffixe <code>+</code> est similaire, mais exige que la production précédente apparaisse au moins une fois.</p>
<div class="codehilite"><pre><span class="i">crispiness</span> → <span class="s">&quot;really&quot;</span>+ ;
</pre></div>
</li>
<li>
<p>Un suffixe <code>?</code> est pour une production optionnelle. La chose avant elle peut apparaître zéro ou une fois, mais pas plus.</p>
<div class="codehilite"><pre><span class="i">breakfast</span> → <span class="i">protein</span> ( <span class="s">&quot;with&quot;</span> <span class="i">breakfast</span> <span class="s">&quot;on the side&quot;</span> )? ;
</pre></div>
</li>
</ul>
<p>Avec toutes ces gentillesses syntaxiques, notre grammaire de petit-déjeuner se condense en :</p>
<div class="codehilite"><pre><span class="i">breakfast</span> → <span class="i">protein</span> ( <span class="s">&quot;with&quot;</span> <span class="i">breakfast</span> <span class="s">&quot;on the side&quot;</span> )?
          | <span class="i">bread</span> ;

<span class="i">protein</span>   → <span class="s">&quot;really&quot;</span>+ <span class="s">&quot;crispy&quot;</span> <span class="s">&quot;bacon&quot;</span>
          | <span class="s">&quot;sausage&quot;</span>
          | ( <span class="s">&quot;scrambled&quot;</span> | <span class="s">&quot;poached&quot;</span> | <span class="s">&quot;fried&quot;</span> ) <span class="s">&quot;eggs&quot;</span> ;

<span class="i">bread</span>     → <span class="s">&quot;toast&quot;</span> | <span class="s">&quot;biscuits&quot;</span> | <span class="s">&quot;English muffin&quot;</span> ;
</pre></div>
<p>Pas trop mal, j&rsquo;espère. Si vous êtes habitué à grep ou à utiliser des <a href="https://en.wikipedia.org/wiki/Regular_expression#Standards">expressions régulières</a> dans votre éditeur de texte, la plupart de la ponctuation devrait être familière. La principale différence est que les symboles ici représentent des tokens entiers, pas des caractères uniques.</p>
<p>Nous utiliserons cette notation tout au long du reste du livre pour décrire précisément la grammaire de Lox. En travaillant sur des langages de programmation, vous découvrirez que les grammaires non contextuelles (utilisant ceci ou <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a> ou une autre notation) vous aident à cristalliser vos idées informelles de conception de syntaxe. Elles sont aussi un support pratique pour communiquer avec d&rsquo;autres hackers de langage à propos de la syntaxe.</p>
<p>Les règles et productions que nous définissons pour Lox sont aussi notre guide pour la structure de données en arbre que nous allons implémenter pour représenter le code en mémoire. Avant de pouvoir faire cela, nous avons besoin d&rsquo;une vraie grammaire pour Lox, ou au moins assez pour nous permettre de commencer.</p>
<h3><a href="#une-grammaire-pour-les-expressions-lox" id="une-grammaire-pour-les-expressions-lox"><small>5&#8202;.&#8202;1&#8202;.&#8202;3</small>Une grammaire pour les expressions Lox</a></h3>
<p>Dans le chapitre précédent, nous avons fait toute la grammaire lexicale de Lox d&rsquo;un seul coup. Chaque mot-clé et morceau de ponctuation est là. La grammaire syntaxique est plus grande, et ce serait vraiment ennuyeux de parcourir le tout avant que nous ayons réellement notre interpréteur en marche.</p>
<p>Au lieu de cela, nous traiterons un sous-ensemble du langage dans les deux prochains chapitres. Une fois que nous aurons ce mini-langage représenté, parsé et interprété, les chapitres ultérieurs ajouteront progressivement de nouvelles fonctionnalités, y compris la nouvelle syntaxe. Pour l&rsquo;instant, nous allons nous soucier uniquement d&rsquo;une poignée d&rsquo;expressions :</p>
<ul>
<li>
<p><strong>Littéraux.</strong> Nombres, chaînes, Booléens, et <code>nil</code>.</p>
</li>
<li>
<p><strong>Expressions unaires.</strong> Un préfixe <code>!</code> pour effectuer un non logique, et <code>-</code> pour nier un nombre.</p>
</li>
<li>
<p><strong>Expressions binaires.</strong> Les opérateurs arithmétiques infixes (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) et logiques (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>) que nous connaissons et aimons.</p>
</li>
<li>
<p><strong>Parenthèses.</strong> Une paire de <code>(</code> et <code>)</code> enroulée autour d&rsquo;une expression.</p>
</li>
</ul>
<p>Cela nous donne assez de syntaxe pour des expressions comme :</p>
<div class="codehilite"><pre><span class="n">1</span> - (<span class="n">2</span> * <span class="n">3</span>) &lt; <span class="n">4</span> == <span class="k">false</span>
</pre></div>
<p>En utilisant notre nouvelle notation bien pratique, voici une grammaire pour ceux-là :</p>
<div class="codehilite"><pre><span class="i">expression</span>     → <span class="i">literal</span>
               | <span class="i">unary</span>
               | <span class="i">binary</span>
               | <span class="i">grouping</span> ;

<span class="i">literal</span>        → <span class="t">NUMBER</span> | <span class="t">STRING</span> | <span class="s">&quot;true&quot;</span> | <span class="s">&quot;false&quot;</span> | <span class="s">&quot;nil&quot;</span> ;
<span class="i">grouping</span>       → <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> ;
<span class="i">unary</span>          → ( <span class="s">&quot;-&quot;</span> | <span class="s">&quot;!&quot;</span> ) <span class="i">expression</span> ;
<span class="i">binary</span>         → <span class="i">expression</span> <span class="i">operator</span> <span class="i">expression</span> ;
<span class="i">operator</span>       → <span class="s">&quot;==&quot;</span> | <span class="s">&quot;!=&quot;</span> | <span class="s">&quot;&lt;&quot;</span> | <span class="s">&quot;&lt;=&quot;</span> | <span class="s">&quot;&gt;&quot;</span> | <span class="s">&quot;&gt;=&quot;</span>
               | <span class="s">&quot;+&quot;</span>  | <span class="s">&quot;-&quot;</span>  | <span class="s">&quot;*&quot;</span> | <span class="s">&quot;/&quot;</span> ;
</pre></div>
<p>Il y a un peu de <span name="play">métasyntaxe</span> supplémentaire ici. En plus des chaînes entre guillemets pour les terminaux qui matchent des lexèmes exacts, nous mettons en <code>MAJUSCULES</code> les terminaux qui sont un seul lexème dont la représentation textuelle peut varier. <code>NUMBER</code> est n&rsquo;importe quel littéral numérique, et <code>STRING</code> est n&rsquo;importe quel littéral de chaîne. Plus tard, nous ferons la même chose pour <code>IDENTIFIER</code>.</p>
<p>Cette grammaire est en fait ambiguë, ce que nous verrons quand nous arriverons à la parser. Mais c&rsquo;est assez bon pour l&rsquo;instant.</p>
<aside name="play">
<p>Si vous êtes enclin à le faire, essayez d&rsquo;utiliser cette grammaire pour générer quelques expressions comme nous l&rsquo;avons fait avec la grammaire du petit-déjeuner auparavant. Les expressions résultantes vous semblent-elles correctes ? Pouvez-vous lui faire générer quelque chose de faux comme <code>1 + / 3</code> ?</p>
</aside>
<h2><a href="#implémenter-des-arbres-syntaxiques" id="implémenter-des-arbres-syntaxiques"><small>5&#8202;.&#8202;2</small>Implémenter des Arbres Syntaxiques</a></h2>
<p>Finalement, nous arrivons à écrire un peu de code. Cette petite grammaire d&rsquo;expression est notre squelette. Puisque la grammaire est récursive<span class="em">&mdash;</span>notez comment <code>grouping</code>, <code>unary</code>, et <code>binary</code> se réfèrent tous à <code>expression</code><span class="em">&mdash;</span>notre structure de données formera un arbre. Puisque cette structure représente la syntaxe de notre langage, elle est appelée un <span name="ast"><strong>arbre syntaxique</strong></span>.</p>
<aside name="ast">
<p>En particulier, nous définissons un <strong>arbre syntaxique abstrait</strong> (<strong>ASA</strong> ou <strong>AST</strong>). Dans un <strong>arbre d&rsquo;analyse</strong>, chaque production de grammaire devient un nœud dans l&rsquo;arbre. Un AST élide les productions qui ne sont pas nécessaires pour les phases ultérieures.</p>
</aside>
<p>Notre scanner utilisait une seule classe Token pour représenter toutes sortes de lexèmes. Pour distinguer les différentes sortes<span class="em">&mdash;</span>pensez au nombre <code>123</code> versus la chaîne <code>"123"</code><span class="em">&mdash;</span>nous incluions un simple enum TokenType. Les arbres syntaxiques ne sont pas si <span name="token-data">homogènes</span>. Les expressions unaires ont un seul opérande, les expressions binaires en ont deux, et les littéraux n&rsquo;en ont aucun.</p>
<p>Nous <em>pourrions</em> écraser tout cela ensemble dans une seule classe Expression avec une liste arbitraire d&rsquo;enfants. Certains compilateurs le font. Mais j&rsquo;aime tirer le meilleur du système de types de Java. Donc nous définirons une classe de base pour les expressions. Ensuite, pour chaque type d&rsquo;expression<span class="em">&mdash;</span>chaque production sous <code>expression</code><span class="em">&mdash;</span>nous créons une sous-classe qui a des champs pour les non-terminaux spécifiques à cette règle. De cette façon, nous obtenons une erreur de compilation si nous essayons, disons, d&rsquo;accéder au deuxième opérande d&rsquo;une expression unaire.</p>
<aside name="token-data">
<p>Les tokens ne sont pas entièrement homogènes non plus. Les tokens pour les littéraux stockent la valeur, mais d&rsquo;autres sortes de lexèmes n&rsquo;ont pas besoin de cet état. J&rsquo;ai vu des scanners qui utilisent différentes classes pour les littéraux et d&rsquo;autres sortes de lexèmes, mais je me suis dit que je garderais les choses plus simples.</p>
</aside>
<p>Quelque chose comme ceci :</p>
<div class="codehilite"><pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">abstract</span> <span class="k">class</span> <span class="t">Expr</span> {<span name="expr"> </span>
  <span class="k">static</span> <span class="k">class</span> <span class="t">Binary</span> <span class="k">extends</span> <span class="t">Expr</span> {
    <span class="t">Binary</span>(<span class="t">Expr</span> <span class="i">left</span>, <span class="t">Token</span> <span class="i">operator</span>, <span class="t">Expr</span> <span class="i">right</span>) {
      <span class="k">this</span>.<span class="i">left</span> = <span class="i">left</span>;
      <span class="k">this</span>.<span class="i">operator</span> = <span class="i">operator</span>;
      <span class="k">this</span>.<span class="i">right</span> = <span class="i">right</span>;
    }

    <span class="k">final</span> <span class="t">Expr</span> <span class="i">left</span>;
    <span class="k">final</span> <span class="t">Token</span> <span class="i">operator</span>;
    <span class="k">final</span> <span class="t">Expr</span> <span class="i">right</span>;
  }

  <span class="c">// Other expressions...</span>
}
</pre></div>
<aside name="expr">
<p>J&rsquo;évite les abréviations dans mon code parce qu&rsquo;elles font trébucher un lecteur qui ne sait pas ce qu&rsquo;elles signifient. Mais dans les compilateurs que j&rsquo;ai regardés, &ldquo;Expr&rdquo; et &ldquo;Stmt&rdquo; sont si omniprésents que je peux aussi bien commencer à vous y habituer maintenant.</p>
</aside>
<p>Expr est la classe de base dont héritent toutes les classes d&rsquo;expression. Comme vous pouvez le voir avec <code>Binary</code>, les sous-classes sont imbriquées à l&rsquo;intérieur. Il n&rsquo;y a pas de besoin technique pour cela, mais cela nous laisse fourrer toutes les classes dans un seul fichier Java.</p>
<h3><a href="#objets-désorientés" id="objets-désorientés"><small>5&#8202;.&#8202;2&#8202;.&#8202;1</small>Objets désorientés</a></h3>
<p>Vous noterez que, tout comme la classe Token, il n&rsquo;y a pas de méthodes ici. C&rsquo;est une structure bête. Joliment typée, mais simplement un sac de données. Cela semble étrange dans un langage orienté objet comme Java. La classe ne devrait-elle pas <em>faire des trucs</em> ?</p>
<p>Le problème est que ces classes d&rsquo;arbres ne sont possédées par aucun domaine unique. Devraient-elles avoir des méthodes pour le parsing puisque c&rsquo;est là que les arbres sont créés ? Ou l&rsquo;interprétation puisque c&rsquo;est là qu&rsquo;ils sont consommés ? Les arbres enjambent la frontière entre ces territoires, ce qui signifie qu&rsquo;ils ne sont vraiment possédés par <em>aucun</em> des deux.</p>
<p>En fait, ces types existent pour permettre au parseur et à l&rsquo;interpréteur de <em>communiquer</em>. Cela se prête à des types qui sont simplement des données sans comportement associé. Ce style est très naturel dans des langages fonctionnels comme Lisp et ML où <em>toutes</em> les données sont séparées du comportement, mais cela semble bizarre en Java.</p>
<p>Les aficionados de la programmation fonctionnelle sautent en ce moment pour s&rsquo;exclamer &ldquo;Tu vois ! Les langages orientés objet sont un mauvais choix pour un interpréteur !&rdquo; Je n&rsquo;irai pas jusque-là. Vous vous souviendrez que le scanner lui-même était admirablement adapté à l&rsquo;orientation objet. Il avait tout l&rsquo;état mutable pour garder une trace d&rsquo;où il était dans le code source, un ensemble bien défini de méthodes publiques, et une poignée d&rsquo;assistants privés.</p>
<p>Mon sentiment est que chaque phase ou partie de l&rsquo;interpréteur fonctionne bien dans un style orienté objet. Ce sont les structures de données qui circulent entre elles qui sont dépouillées de comportement.</p>
<h3><a href="#métaprogrammer-les-arbres" id="métaprogrammer-les-arbres"><small>5&#8202;.&#8202;2&#8202;.&#8202;2</small>Métaprogrammer les arbres</a></h3>
<p>Java peut exprimer des classes sans comportement, mais je ne dirais pas qu&rsquo;il est particulièrement bon à ça. Onze lignes de code pour fourrer trois champs dans un objet est assez fastidieux, et quand nous aurons fini, nous aurons 21 de ces classes.</p>
<p>Je ne veux pas perdre votre temps ou mon encre à écrire tout cela. Vraiment, quelle est l&rsquo;essence de chaque sous-classe ? Un nom, et une liste de champs typés. C&rsquo;est tout. Nous sommes des hackers de langage intelligents, non ? <span name="automate">Automatisons</span>.</p>
<aside name="automate">
<p>Imaginez-moi faisant une danse de robot maladroite quand vous lisez ceci. &ldquo;AU-TO-MA-TI-SONS.&rdquo;</p>
</aside>
<p>Au lieu d&rsquo;écrire laborieusement à la main chaque définition de classe, déclaration de champ, constructeur et initialiseur, nous bricolerons un <span name="python">script</span> qui le fait pour nous. Il a une description de chaque type d&rsquo;arbre<span class="em">&mdash;</span>son nom et ses champs<span class="em">&mdash;</span>et il affiche le code Java nécessaire pour définir une classe avec ce nom et cet état.</p>
<p>Ce script est une minuscule application en ligne de commande Java qui génère un fichier nommé &ldquo;Expr.java&rdquo; :</p>
<aside name="python">
<p>J&rsquo;ai eu l&rsquo;idée de scripter les classes d&rsquo;arbre syntaxique de Jim Hugunin, créateur de Jython et IronPython.</p>
<p>Un vrai langage de script serait un meilleur choix pour cela que Java, mais j&rsquo;essaie de ne pas vous jeter trop de langages à la figure.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>tool/GenerateAst.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.tool</span>;

<span class="k">import</span> <span class="i">java.io.IOException</span>;
<span class="k">import</span> <span class="i">java.io.PrintWriter</span>;
<span class="k">import</span> <span class="i">java.util.Arrays</span>;
<span class="k">import</span> <span class="i">java.util.List</span>;

<span class="k">public</span> <span class="k">class</span> <span class="t">GenerateAst</span> {
  <span class="k">public</span> <span class="k">static</span> <span class="t">void</span> <span class="i">main</span>(<span class="t">String</span>[] <span class="i">args</span>) <span class="k">throws</span> <span class="t">IOException</span> {
    <span class="k">if</span> (<span class="i">args</span>.<span class="i">length</span> != <span class="n">1</span>) {
      <span class="t">System</span>.<span class="i">err</span>.<span class="i">println</span>(<span class="s">&quot;Usage: generate_ast &lt;output directory&gt;&quot;</span>);
      <span class="t">System</span>.<span class="i">exit</span>(<span class="n">64</span>);
    }
    <span class="t">String</span> <span class="i">outputDir</span> = <span class="i">args</span>[<span class="n">0</span>];
  }
}
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, create new file</div>

<p>Notez que ce fichier est dans un paquetage différent, <code>.tool</code> au lieu de <code>.lox</code>. Ce script ne fait pas partie de l&rsquo;interpréteur lui-même. C&rsquo;est un outil que <em>nous</em>, les gens qui hackent l&rsquo;interpréteur, exécutons nous-mêmes pour générer les classes d&rsquo;arbre syntaxique. Quand c&rsquo;est fini, nous traitons &ldquo;Expr.java&rdquo; comme n&rsquo;importe quel autre fichier dans l&rsquo;implémentation. Nous automatisons simplement la façon dont ce fichier est rédigé.</p>
<p>Pour générer les classes, il a besoin d&rsquo;avoir une description de chaque type et de ses champs.</p>
<div class="codehilite"><pre class="insert-before">    String outputDir = args[0];
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">    <span class="i">defineAst</span>(<span class="i">outputDir</span>, <span class="s">&quot;Expr&quot;</span>, <span class="t">Arrays</span>.<span class="i">asList</span>(
      <span class="s">&quot;Binary   : Expr left, Token operator, Expr right&quot;</span>,
      <span class="s">&quot;Grouping : Expr expression&quot;</span>,
      <span class="s">&quot;Literal  : Object value&quot;</span>,
      <span class="s">&quot;Unary    : Token operator, Expr right&quot;</span>
    ));
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<p>Pour la concision, j&rsquo;ai coincé les descriptions des types d&rsquo;expression dans des chaînes. Chacune est le nom de la classe suivi par <code>:</code> et la liste des champs, séparés par des virgules. Chaque champ a un type et un nom.</p>
<p>La première chose que <code>defineAst()</code> doit faire est de sortir la classe de base Expr.</p>
<div class="codehilite"><div class="source-file"><em>tool/GenerateAst.java</em><br>
add after <em>main</em>()</div>
<pre>  <span class="k">private</span> <span class="k">static</span> <span class="t">void</span> <span class="i">defineAst</span>(
      <span class="t">String</span> <span class="i">outputDir</span>, <span class="t">String</span> <span class="i">baseName</span>, <span class="t">List</span>&lt;<span class="t">String</span>&gt; <span class="i">types</span>)
      <span class="k">throws</span> <span class="t">IOException</span> {
    <span class="t">String</span> <span class="i">path</span> = <span class="i">outputDir</span> + <span class="s">&quot;/&quot;</span> + <span class="i">baseName</span> + <span class="s">&quot;.java&quot;</span>;
    <span class="t">PrintWriter</span> <span class="i">writer</span> = <span class="k">new</span> <span class="t">PrintWriter</span>(<span class="i">path</span>, <span class="s">&quot;UTF-8&quot;</span>);

    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;package com.craftinginterpreters.lox;&quot;</span>);
    <span class="i">writer</span>.<span class="i">println</span>();
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;import java.util.List;&quot;</span>);
    <span class="i">writer</span>.<span class="i">println</span>();
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;abstract class &quot;</span> + <span class="i">baseName</span> + <span class="s">&quot; {&quot;</span>);

    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;}&quot;</span>);
    <span class="i">writer</span>.<span class="i">close</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, add after <em>main</em>()</div>

<p>Quand nous appelons ceci, <code>baseName</code> est &ldquo;Expr&rdquo;, qui est à la fois le nom de la classe et le nom du fichier qu&rsquo;il produit. Nous passons ceci comme argument au lieu de coder en dur le nom parce que nous ajouterons une famille séparée de classes plus tard pour les instructions.</p>
<p>À l&rsquo;intérieur de la classe de base, nous définissons chaque sous-classe.</p>
<div class="codehilite"><pre class="insert-before">    writer.println(&quot;abstract class &quot; + baseName + &quot; {&quot;);

</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>defineAst</em>()</div>
<pre class="insert">    <span class="c">// The AST classes.</span>
    <span class="k">for</span> (<span class="t">String</span> <span class="i">type</span> : <span class="i">types</span>) {
      <span class="t">String</span> <span class="i">className</span> = <span class="i">type</span>.<span class="i">split</span>(<span class="s">&quot;:&quot;</span>)[<span class="n">0</span>].<span class="i">trim</span>();
      <span class="t">String</span> <span class="i">fields</span> = <span class="i">type</span>.<span class="i">split</span>(<span class="s">&quot;:&quot;</span>)[<span class="n">1</span>].<span class="i">trim</span>();<span name="robust"> </span>
      <span class="i">defineType</span>(<span class="i">writer</span>, <span class="i">baseName</span>, <span class="i">className</span>, <span class="i">fields</span>);
    }
</pre><pre class="insert-after">    writer.println(&quot;}&quot;);
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>defineAst</em>()</div>

<aside name="robust">
<p>Ce n&rsquo;est pas le code de manipulation de chaînes le plus élégant du monde, mais c&rsquo;est bon. Il ne s&rsquo;exécute que sur l&rsquo;ensemble exact de définitions de classes que nous lui donnons. La robustesse n&rsquo;est pas une priorité.</p>
</aside>
<p>Ce code, à son tour, appelle :</p>
<div class="codehilite"><div class="source-file"><em>tool/GenerateAst.java</em><br>
add after <em>defineAst</em>()</div>
<pre>  <span class="k">private</span> <span class="k">static</span> <span class="t">void</span> <span class="i">defineType</span>(
      <span class="t">PrintWriter</span> <span class="i">writer</span>, <span class="t">String</span> <span class="i">baseName</span>,
      <span class="t">String</span> <span class="i">className</span>, <span class="t">String</span> <span class="i">fieldList</span>) {
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;  static class &quot;</span> + <span class="i">className</span> + <span class="s">&quot; extends &quot;</span> +
        <span class="i">baseName</span> + <span class="s">&quot; {&quot;</span>);

    <span class="c">// Constructor.</span>
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    &quot;</span> + <span class="i">className</span> + <span class="s">&quot;(&quot;</span> + <span class="i">fieldList</span> + <span class="s">&quot;) {&quot;</span>);

    <span class="c">// Store parameters in fields.</span>
    <span class="t">String</span>[] <span class="i">fields</span> = <span class="i">fieldList</span>.<span class="i">split</span>(<span class="s">&quot;, &quot;</span>);
    <span class="k">for</span> (<span class="t">String</span> <span class="i">field</span> : <span class="i">fields</span>) {
      <span class="t">String</span> <span class="i">name</span> = <span class="i">field</span>.<span class="i">split</span>(<span class="s">&quot; &quot;</span>)[<span class="n">1</span>];
      <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;      this.&quot;</span> + <span class="i">name</span> + <span class="s">&quot; = &quot;</span> + <span class="i">name</span> + <span class="s">&quot;;&quot;</span>);
    }

    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    }&quot;</span>);

    <span class="c">// Fields.</span>
    <span class="i">writer</span>.<span class="i">println</span>();
    <span class="k">for</span> (<span class="t">String</span> <span class="i">field</span> : <span class="i">fields</span>) {
      <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    final &quot;</span> + <span class="i">field</span> + <span class="s">&quot;;&quot;</span>);
    }

    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;  }&quot;</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, add after <em>defineAst</em>()</div>

<p>Et voilà. Tout ce superbe code standard Java est fait. Il déclare chaque champ dans le corps de la classe. Il définit un constructeur pour la classe avec des paramètres pour chaque champ et les initialise dans le corps.</p>
<p>Compilez et lancez ce programme Java maintenant et il [crache][longer] un nouveau fichier &rdquo;.java&rdquo; contenant quelques douzaines de lignes de code. Ce fichier est sur le point de devenir encore plus long.</p>
<aside name="longer">
<p>L&rsquo;[Annexe II][] contient le code généré par ce script une fois que nous avons fini d&rsquo;implémenter jlox et défini tous ses nœuds d&rsquo;arbre syntaxique.</p>
</aside>
<h2><a href="#travailler-avec-des-arbres" id="travailler-avec-des-arbres"><small>5&#8202;.&#8202;3</small>Travailler avec des Arbres</a></h2>
<p>Mettez votre chapeau d&rsquo;imagination un instant. Même si nous n&rsquo;y sommes pas encore, considérez ce que l&rsquo;interpréteur fera avec les arbres syntaxiques. Chaque type d&rsquo;expression dans Lox se comporte différemment à l&rsquo;exécution. Cela signifie que l&rsquo;interpréteur a besoin de sélectionner un morceau de code différent pour gérer chaque type d&rsquo;expression. Avec les tokens, nous pouvons simplement switcher sur le TokenType. Mais nous n&rsquo;avons pas un enum &ldquo;type&rdquo; pour les arbres syntaxiques, juste une classe Java séparée pour chacun.</p>
<p>Nous pourrions écrire une longue chaîne de tests de type :</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">expr</span> <span class="k">instanceof</span> <span class="t">Expr</span>.<span class="t">Binary</span>) {
  <span class="c">// ...</span>
} <span class="k">else</span> <span class="k">if</span> (<span class="i">expr</span> <span class="k">instanceof</span> <span class="t">Expr</span>.<span class="t">Grouping</span>) {
  <span class="c">// ...</span>
} <span class="k">else</span> <span class="c">// ...</span>
</pre></div>
<p>Mais tous ces tests de type séquentiels sont lents. Les types d&rsquo;expression dont les noms sont alphabétiquement plus tard prendraient plus de temps à s&rsquo;exécuter parce qu&rsquo;ils tomberaient à travers plus de cas <code>if</code> avant de trouver le bon type. Ce n&rsquo;est pas mon idée d&rsquo;une solution élégante.</p>
<p>Nous avons une famille de classes et nous avons besoin d&rsquo;associer un morceau de comportement avec chacune. La solution naturelle dans un langage orienté objet comme Java est de mettre ces comportements dans des méthodes sur les classes elles-mêmes. Nous pourrions ajouter une méthode abstraite <span name="interpreter-pattern"><code>interpret()</code></span> sur Expr que chaque sous-classe implémenterait alors pour s&rsquo;interpréter elle-même.</p>
<aside name="interpreter-pattern">
<p>Cette chose exacte est littéralement appelée le <a href="https://en.wikipedia.org/wiki/Interpreter_pattern">&ldquo;Patron Interpréteur&rdquo;</a> dans <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, par Erich Gamma, et al.</p>
</aside>
<p>Cela marche bien pour les petits projets, mais cela passe mal à l&rsquo;échelle. Comme je l&rsquo;ai noté avant, ces classes d&rsquo;arbres enjambent quelques domaines. À tout le moins, le parseur et l&rsquo;interpréteur vont tous deux tripatouiller avec elles. Comme <a href="resolving-and-binding.html">vous le verrez plus tard</a>, nous avons besoin de faire une résolution de noms sur elles. Si notre langage était typé statiquement, nous aurions une passe de vérification de type.</p>
<p>Si nous ajoutions des méthodes d&rsquo;instance aux classes d&rsquo;expression pour chacune de ces opérations, cela écraserait un tas de domaines différents ensemble. Cela viole la [séparation des préoccupations][] et mène à du code difficile à maintenir.</p>
<h3><a href="#le-problème-de-lexpression" id="le-problème-de-lexpression"><small>5&#8202;.&#8202;3&#8202;.&#8202;1</small>Le problème de l&rsquo;expression</a></h3>
<p>Ce problème est plus fondamental qu&rsquo;il n&rsquo;y paraît au premier abord. Nous avons une poignée de types, et une poignée d&rsquo;opérations de haut niveau comme &ldquo;interpréter&rdquo;. Pour chaque paire de type et d&rsquo;opération, nous avons besoin d&rsquo;une implémentation spécifique. Imaginez un tableau :</p><img src="image/representing-code/table.png" alt="Un tableau où les lignes sont étiquetées avec les classes d'expression, et les colonnes sont des noms de fonctions." />
<p>Les lignes sont les types, et les colonnes sont les opérations. Chaque cellule représente le morceau de code unique pour implémenter cette opération sur ce type.</p>
<p>Un langage orienté objet comme Java suppose que tout le code dans une ligne va naturellement ensemble. Il se figure que toutes les choses que vous faites avec un type sont probablement liées les unes aux autres, et le langage rend facile de les définir ensemble comme méthodes à l&rsquo;intérieur de la même classe.</p><img src="image/representing-code/rows.png" alt="Le tableau séparé en lignes pour chaque classe." />
<p>Cela rend facile l&rsquo;extension du tableau en ajoutant de nouvelles lignes. Définissez simplement une nouvelle classe. Aucun code existant n&rsquo;a besoin d&rsquo;être touché. Mais imaginez si vous voulez ajouter une nouvelle <em>opération</em><span class="em">&mdash;</span>une nouvelle colonne. En Java, cela signifie ouvrir chacune de ces classes existantes et y ajouter une méthode.</p>
<p>Les langages du paradigme fonctionnel de la famille <span name="ml">ML</span> retournent cela. Là, vous n&rsquo;avez pas de classes avec des méthodes. Les types et les fonctions sont totalement distincts. Pour implémenter une opération pour un certain nombre de types différents, vous définissez une seule fonction. Dans le corps de cette fonction, vous utilisez le <em>pattern matching</em> (filtrage par motif)<span class="em">&mdash;</span>sorte de switch basé sur le type sous stéroïdes<span class="em">&mdash;</span>pour implémenter l&rsquo;opération pour chaque type tout en un seul endroit.</p>
<aside name="ml">
<p>ML, abréviation de &ldquo;métalangage&rdquo;, a été créé par Robin Milner et ses amis et forme l&rsquo;une des branches principales dans le grand arbre généalogique des langages de programmation. Ses enfants incluent SML, Caml, OCaml, Haskell, et F#. Même Scala, Rust, et Swift portent une forte ressemblance.</p>
<p>Tout comme Lisp, c&rsquo;est l&rsquo;un de ces langages qui est si plein de bonnes idées que les concepteurs de langage aujourd&rsquo;hui les redécouvrent encore plus de quarante ans plus tard.</p>
</aside>
<p>Cela rend trivial l&rsquo;ajout de nouvelles opérations<span class="em">&mdash;</span>définissez simplement une autre fonction qui fait du pattern matching sur tous les types.</p><img src="image/representing-code/columns.png" alt="Le tableau séparé en colonnes pour chaque fonction." />
<p>Mais, inversement, ajouter un nouveau type est difficile. Vous devez revenir en arrière et ajouter un nouveau cas à tous les pattern matchings dans toutes les fonctions existantes.</p>
<p>Chaque style a un certain &ldquo;grain&rdquo;. C&rsquo;est ce que le nom du paradigme dit littéralement<span class="em">&mdash;</span>un langage orienté objet veut que vous <em>orientiez</em> votre code le long des lignes de types. Un langage fonctionnel vous encourage au contraire à regrouper le code de chaque colonne dans une <em>fonction</em>.</p>
<p>Un tas de nerds intelligents en langage ont remarqué qu&rsquo;aucun des deux styles ne rendait facile l&rsquo;ajout <em>à la fois</em> de lignes et de colonnes au <span name="multi">tableau</span>. Ils ont appelé cette difficulté le &ldquo;problème de l&rsquo;expression&rdquo; parce que<span class="em">&mdash;</span>comme nous maintenant<span class="em">&mdash;</span>ils l&rsquo;ont rencontré pour la première fois quand ils essayaient de trouver la meilleure façon de modéliser les nœuds d&rsquo;arbre syntaxique d&rsquo;expression dans un compilateur.</p>
<aside name="multi">
<p>Les langages avec <em>multiméthodes</em>, comme CLOS de Common Lisp, Dylan, et Julia supportent l&rsquo;ajout facile à la fois de nouveaux types et d&rsquo;opérations. Ce qu&rsquo;ils sacrifient typiquement est soit la vérification statique de type, soit la compilation séparée.</p>
</aside>
<p>Les gens ont lancé toutes sortes de fonctionnalités de langage, de patrons de conception et d&rsquo;astuces de programmation pour essayer d&rsquo;abattre ce problème mais aucun langage parfait ne l&rsquo;a encore achevé. En attendant, le mieux que nous puissions faire est d&rsquo;essayer de choisir un langage dont l&rsquo;orientation correspond aux coutures architecturales naturelles dans le programme que nous écrivons.</p>
<p>L&rsquo;orientation objet fonctionne bien pour de nombreuses parties de notre interpréteur, mais ces classes d&rsquo;arbres vont à l&rsquo;encontre du grain de Java. Heureusement, il y a un patron de conception que nous pouvons mettre à profit ici.</p>
<h3><a href="#le-patron-visiteur" id="le-patron-visiteur"><small>5&#8202;.&#8202;3&#8202;.&#8202;2</small>Le patron Visiteur</a></h3>
<p>Le <strong>patron Visiteur</strong> est le patron le plus largement mal compris de tout <em>Design Patterns</em>, ce qui veut vraiment dire quelque chose quand vous regardez les excès d&rsquo;architecture logicielle des deux dernières décennies.</p>
<p>Le problème commence avec la terminologie. Le patron n&rsquo;a rien à voir avec &ldquo;visiter&rdquo;, et la méthode &ldquo;accept&rdquo; dedans n&rsquo;évoque aucune image utile non plus. Beaucoup pensent que le patron a à voir avec la traversée d&rsquo;arbres, ce qui n&rsquo;est pas le cas du tout. Nous <em>allons</em> l&rsquo;utiliser sur un ensemble de classes qui sont arborescentes, mais c&rsquo;est une coïncidence. Comme vous le verrez, le patron fonctionne aussi bien sur un seul objet.</p>
<p>Le patron Visiteur consiste vraiment à approximer le style fonctionnel au sein d&rsquo;un langage POO. Il nous permet d&rsquo;ajouter facilement de nouvelles colonnes à ce tableau. Nous pouvons définir tout le comportement pour une nouvelle opération sur un ensemble de types en un seul endroit, sans avoir à toucher aux types eux-mêmes. Il fait cela de la même manière que nous résolvons presque tous les problèmes en informatique : en ajoutant une couche d&rsquo;indirection.</p>
<p>Avant de l&rsquo;appliquer à nos classes Expr auto-générées, parcourons un exemple plus simple. Disons que nous avons deux sortes de pâtisseries : des <span name="beignet">beignets</span> et des crullers.</p>
<aside name="beignet">
<p>Un beignet (prononcé &ldquo;bè-nié&ldquo;) est une pâtisserie frite de la même famille que les donuts. Quand les Français ont colonisé l&rsquo;Amérique du Nord dans les années 1700, ils ont apporté les beignets avec eux. Aujourd&rsquo;hui, aux US, ils sont le plus fortement associés à la cuisine de la Nouvelle-Orléans.</p>
<p>Ma façon préférée de les consommer est tout juste sortis de la friteuse au Café du Monde, empilés haut sous le sucre en poudre, et arrosés d&rsquo;une tasse de café au lait pendant que je regarde les touristes tituber autour en essayant de secouer leur gueule de bois des festivités de la nuit précédente.</p>
</aside>
<div class="codehilite"><pre>  <span class="k">abstract</span> <span class="k">class</span> <span class="t">Pastry</span> {
  }

  <span class="k">class</span> <span class="t">Beignet</span> <span class="k">extends</span> <span class="t">Pastry</span> {
  }

  <span class="k">class</span> <span class="t">Cruller</span> <span class="k">extends</span> <span class="t">Pastry</span> {
  }
</pre></div>

<p>Nous voulons être capables de définir de nouvelles opérations de pâtisserie<span class="em">&mdash;</span>les cuire, les manger, les décorer, etc.<span class="em">&mdash;</span>sans avoir à ajouter une nouvelle méthode à chaque classe à chaque fois. Voici comment nous faisons. D&rsquo;abord, nous définissons une interface séparée.</p>
<div class="codehilite"><pre>  <span class="k">interface</span> <span class="t">PastryVisitor</span> {
    <span class="t">void</span> <span class="i">visitBeignet</span>(<span class="t">Beignet</span> <span class="i">beignet</span>);<span name="overload"> </span>
    <span class="t">void</span> <span class="i">visitCruller</span>(<span class="t">Cruller</span> <span class="i">cruller</span>);
  }
</pre></div>

<aside name="overload">
<p>Dans <em>Design Patterns</em>, ces deux méthodes sont confusément nommées <code>visit()</code>, et elles comptent sur la surcharge pour les distinguer. Cela conduit certains lecteurs à penser que la bonne méthode visit est choisie <em>à l&rsquo;exécution</em> basée sur son type de paramètre. Ce n&rsquo;est pas le cas. Contrairement à la réécriture (overriding), la surcharge (overloading) est dépêchée statiquement au moment de la compilation.</p>
<p>Utiliser des noms distincts pour chaque méthode rend le dispatch plus évident, et vous montre aussi comment appliquer ce patron dans des langages qui ne supportent pas la surcharge.</p>
</aside>
<p>Chaque opération qui peut être effectuée sur des pâtisseries est une nouvelle classe qui implémente cette interface. Elle a une méthode concrète pour chaque type de pâtisserie. Cela garde le code pour l&rsquo;opération sur les deux types tout niché confortablement ensemble dans une classe.</p>
<p>Étant donné une certaine pâtisserie, comment la router vers la bonne méthode sur le visiteur en fonction de son type ? Le polymorphisme à la rescousse ! Nous ajoutons cette méthode à Pastry :</p>
<div class="codehilite"><pre class="insert-before">  abstract class Pastry {
</pre><pre class="insert">    <span class="k">abstract</span> <span class="t">void</span> <span class="i">accept</span>(<span class="t">PastryVisitor</span> <span class="i">visitor</span>);
</pre><pre class="insert-after">  }
</pre></div>

<p>Chaque sous-classe l&rsquo;implémente.</p>
<div class="codehilite"><pre class="insert-before">  class Beignet extends Pastry {
</pre><pre class="insert">    <span class="a">@Override</span>
    <span class="t">void</span> <span class="i">accept</span>(<span class="t">PastryVisitor</span> <span class="i">visitor</span>) {
      <span class="i">visitor</span>.<span class="i">visitBeignet</span>(<span class="k">this</span>);
    }
</pre><pre class="insert-after">  }
</pre></div>

<p>Et :</p>
<div class="codehilite"><pre class="insert-before">  class Cruller extends Pastry {
</pre><pre class="insert">    <span class="a">@Override</span>
    <span class="t">void</span> <span class="i">accept</span>(<span class="t">PastryVisitor</span> <span class="i">visitor</span>) {
      <span class="i">visitor</span>.<span class="i">visitCruller</span>(<span class="k">this</span>);
    }
</pre><pre class="insert-after">  }
</pre></div>

<p>Pour effectuer une opération sur une pâtisserie, nous appelons sa méthode <code>accept()</code> et passons le visiteur pour l&rsquo;opération que nous voulons exécuter. La pâtisserie<span class="em">&mdash;</span>l&rsquo;implémentation de réécriture de <code>accept()</code> de la sous-classe spécifique<span class="em">&mdash;</span>se retourne et appelle la méthode visit appropriée sur le visiteur et lui passe <em>elle-même</em>.</p>
<p>C&rsquo;est le cœur du truc juste là. Cela nous permet d&rsquo;utiliser le dispatch polymorphique sur les classes de <em>pâtisserie</em> pour sélectionner la méthode appropriée sur la classe <em>visiteur</em>. Dans le tableau, chaque classe de pâtisserie est une ligne, mais si vous regardez toutes les méthodes pour un seul visiteur, elles forment une <em>colonne</em>.</p><img src="image/representing-code/visitor.png" alt="Maintenant toutes les cellules pour une opération font partie de la même classe, le visiteur." />
<p>Nous avons ajouté une méthode <code>accept()</code> à chaque classe, et nous pouvons l&rsquo;utiliser pour autant de visiteurs que nous voulons sans jamais avoir à toucher aux classes de pâtisserie à nouveau. C&rsquo;est un patron intelligent.</p>
<h3><a href="#visiteurs-pour-les-expressions" id="visiteurs-pour-les-expressions"><small>5&#8202;.&#8202;3&#8202;.&#8202;3</small>Visiteurs pour les expressions</a></h3>
<p>OK, tissons-le dans nos classes d&rsquo;expression. Nous allons aussi <span name="context">affiner</span> le patron un peu. Dans l&rsquo;exemple de la pâtisserie, les méthodes visit et <code>accept()</code> ne renvoient rien. En pratique, les visiteurs veulent souvent définir des opérations qui produisent des valeurs. Mais quel type de retour devrait avoir <code>accept()</code> ? Nous ne pouvons pas supposer que chaque classe de visiteur veuille produire le même type, donc nous utiliserons des génériques pour laisser chaque implémentation remplir un type de retour.</p>
<aside name="context">
<p>Un autre raffinement courant est un paramètre &ldquo;contexte&rdquo; supplémentaire qui est passé aux méthodes visit et ensuite renvoyé à travers comme paramètre à <code>accept()</code>. Cela permet aux opérations de prendre un paramètre supplémentaire. Les visiteurs que nous définirons dans le livre n&rsquo;ont pas besoin de cela, donc je l&rsquo;ai omis.</p>
</aside>
<p>D&rsquo;abord, nous définissons l&rsquo;interface visiteur. Encore une fois, nous l&rsquo;imbriquons à l&rsquo;intérieur de la classe de base pour pouvoir tout garder dans un fichier.</p>
<div class="codehilite"><pre class="insert-before">    writer.println(&quot;abstract class &quot; + baseName + &quot; {&quot;);

</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>defineAst</em>()</div>
<pre class="insert">    <span class="i">defineVisitor</span>(<span class="i">writer</span>, <span class="i">baseName</span>, <span class="i">types</span>);

</pre><pre class="insert-after">    // The AST classes.
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>defineAst</em>()</div>

<p>Cette fonction génère l&rsquo;interface visiteur.</p>
<div class="codehilite"><div class="source-file"><em>tool/GenerateAst.java</em><br>
add after <em>defineAst</em>()</div>
<pre>  <span class="k">private</span> <span class="k">static</span> <span class="t">void</span> <span class="i">defineVisitor</span>(
      <span class="t">PrintWriter</span> <span class="i">writer</span>, <span class="t">String</span> <span class="i">baseName</span>, <span class="t">List</span>&lt;<span class="t">String</span>&gt; <span class="i">types</span>) {
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;  interface Visitor&lt;R&gt; {&quot;</span>);

    <span class="k">for</span> (<span class="t">String</span> <span class="i">type</span> : <span class="i">types</span>) {
      <span class="t">String</span> <span class="i">typeName</span> = <span class="i">type</span>.<span class="i">split</span>(<span class="s">&quot;:&quot;</span>)[<span class="n">0</span>].<span class="i">trim</span>();
      <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    R visit&quot;</span> + <span class="i">typeName</span> + <span class="i">baseName</span> + <span class="s">&quot;(&quot;</span> +
          <span class="i">typeName</span> + <span class="s">&quot; &quot;</span> + <span class="i">baseName</span>.<span class="i">toLowerCase</span>() + <span class="s">&quot;);&quot;</span>);
    }

    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;  }&quot;</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, add after <em>defineAst</em>()</div>

<p>Ici, nous itérons à travers toutes les sous-classes et déclarons une méthode visit pour chacune. Quand nous définirons de nouveaux types d&rsquo;expression plus tard, cela les inclura automatiquement.</p>
<p>À l&rsquo;intérieur de la classe de base, nous définissons la méthode abstraite <code>accept()</code>.</p>
<div class="codehilite"><pre class="insert-before">      defineType(writer, baseName, className, fields);
    }
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>defineAst</em>()</div>
<pre class="insert">

    <span class="c">// The base accept() method.</span>
    <span class="i">writer</span>.<span class="i">println</span>();
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;  abstract &lt;R&gt; R accept(Visitor&lt;R&gt; visitor);&quot;</span>);

</pre><pre class="insert-after">    writer.println(&quot;}&quot;);
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>defineAst</em>()</div>

<p>Enfin, chaque sous-classe implémente cela et appelle la bonne méthode visit pour son propre type.</p>
<div class="codehilite"><pre class="insert-before">    writer.println(&quot;    }&quot;);
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>defineType</em>()</div>
<pre class="insert">

    <span class="c">// Visitor pattern.</span>
    <span class="i">writer</span>.<span class="i">println</span>();
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    @Override&quot;</span>);
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    &lt;R&gt; R accept(Visitor&lt;R&gt; visitor) {&quot;</span>);
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;      return visitor.visit&quot;</span> +
        <span class="i">className</span> + <span class="i">baseName</span> + <span class="s">&quot;(this);&quot;</span>);
    <span class="i">writer</span>.<span class="i">println</span>(<span class="s">&quot;    }&quot;</span>);
</pre><pre class="insert-after">

    // Fields.
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>defineType</em>()</div>

<p>Et voilà. Maintenant nous pouvons définir des opérations sur les expressions sans avoir à trifouiller avec les classes ou notre script générateur. Compilez et lancez ce script générateur pour sortir un fichier &ldquo;Expr.java&rdquo; mis à jour. Il contient une interface Visitor générée et un ensemble de classes de nœud d&rsquo;expression qui supportent le patron Visiteur en l&rsquo;utilisant.</p>
<p>Avant de terminer ce chapitre décousu, implémentons cette interface Visitor et voyons le patron en action.</p>
<h2><a href="#un-pretty-printer-pas-très-joli" id="un-pretty-printer-pas-très-joli"><small>5&#8202;.&#8202;4</small>Un Pretty Printer (Pas Très) Joli</a></h2>
<p>Quand nous déboguons notre parseur et interpréteur, c&rsquo;est souvent utile de regarder un arbre syntaxique parsé et de s&rsquo;assurer qu&rsquo;il a la structure que nous attendons. Nous pourrions l&rsquo;inspecter dans le débogueur, mais cela peut être une corvée.</p>
<p>Au lieu de cela, nous aimerions du code qui, étant donné un arbre syntaxique, produit une représentation en chaîne non ambiguë de celui-ci. Convertir un arbre en chaîne est une sorte d&rsquo;opposé d&rsquo;un parseur, et est souvent appelé &ldquo;pretty printing&rdquo; quand le but est de produire une chaîne de texte qui est une syntaxe valide dans le langage source.</p>
<p>Ce n&rsquo;est pas notre but ici. Nous voulons que la chaîne montre très explicitement la structure d&rsquo;imbrication de l&rsquo;arbre. Un printer qui renverrait <code>1 + 2 * 3</code> n&rsquo;est pas super utile si ce que nous essayons de déboguer est de savoir si la précédence des opérateurs est gérée correctement. Nous voulons savoir si le <code>+</code> ou le <code>*</code> est au sommet de l&rsquo;arbre.</p>
<p>À cette fin, la représentation en chaîne que nous produisons ne va pas être de la syntaxe Lox. Au lieu de cela, elle ressemblera beaucoup à, eh bien, du Lisp. Chaque expression est explicitement parenthésée, et toutes ses sous-expressions et tokens sont contenus là-dedans.</p>
<p>Étant donné un arbre syntaxique comme :</p><img src="image/representing-code/expression.png" alt="Un exemple d'arbre syntaxique." />
<p>Il produit :</p>
<div class="codehilite"><pre>(* (- 123) (group 45.67))
</pre></div>
<p>Pas exactement &ldquo;joli&rdquo;, mais cela montre l&rsquo;imbrication et le groupement explicitement. Pour implémenter cela, nous définissons une nouvelle classe.</p>
<div class="codehilite"><div class="source-file"><em>lox/AstPrinter.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">class</span> <span class="t">AstPrinter</span> <span class="k">implements</span> <span class="t">Expr</span>.<span class="t">Visitor</span>&lt;<span class="t">String</span>&gt; {
  <span class="t">String</span> <span class="i">print</span>(<span class="t">Expr</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">expr</span>.<span class="i">accept</span>(<span class="k">this</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/AstPrinter.java</em>, create new file</div>

<p>Comme vous pouvez le voir, elle implémente l&rsquo;interface visiteur. Cela signifie que nous avons besoin de méthodes visit pour chaque type d&rsquo;expression que nous avons jusqu&rsquo;à présent.</p>
<div class="codehilite"><pre class="insert-before">    return expr.accept(this);
  }
</pre><div class="source-file"><em>lox/AstPrinter.java</em><br>
add after <em>print</em>()</div>
<pre class="insert">

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">visitBinaryExpr</span>(<span class="t">Expr</span>.<span class="t">Binary</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">parenthesize</span>(<span class="i">expr</span>.<span class="i">operator</span>.<span class="i">lexeme</span>,
                        <span class="i">expr</span>.<span class="i">left</span>, <span class="i">expr</span>.<span class="i">right</span>);
  }

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">visitGroupingExpr</span>(<span class="t">Expr</span>.<span class="t">Grouping</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">parenthesize</span>(<span class="s">&quot;group&quot;</span>, <span class="i">expr</span>.<span class="i">expression</span>);
  }

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">visitLiteralExpr</span>(<span class="t">Expr</span>.<span class="t">Literal</span> <span class="i">expr</span>) {
    <span class="k">if</span> (<span class="i">expr</span>.<span class="i">value</span> == <span class="k">null</span>) <span class="k">return</span> <span class="s">&quot;nil&quot;</span>;
    <span class="k">return</span> <span class="i">expr</span>.<span class="i">value</span>.<span class="i">toString</span>();
  }

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">visitUnaryExpr</span>(<span class="t">Expr</span>.<span class="t">Unary</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">parenthesize</span>(<span class="i">expr</span>.<span class="i">operator</span>.<span class="i">lexeme</span>, <span class="i">expr</span>.<span class="i">right</span>);
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>lox/AstPrinter.java</em>, add after <em>print</em>()</div>

<p>Les expressions littérales sont faciles<span class="em">&mdash;</span>elles convertissent la valeur en chaîne avec une petite vérification pour gérer le <code>null</code> de Java remplaçant le <code>nil</code> de Lox. Les autres expressions ont des sous-expressions, donc elles utilisent cette méthode d&rsquo;aide <code>parenthesize()</code> :</p>
<div class="codehilite"><div class="source-file"><em>lox/AstPrinter.java</em><br>
add after <em>visitUnaryExpr</em>()</div>
<pre>  <span class="k">private</span> <span class="t">String</span> <span class="i">parenthesize</span>(<span class="t">String</span> <span class="i">name</span>, <span class="t">Expr</span>... <span class="i">exprs</span>) {
    <span class="t">StringBuilder</span> <span class="i">builder</span> = <span class="k">new</span> <span class="t">StringBuilder</span>();

    <span class="i">builder</span>.<span class="i">append</span>(<span class="s">&quot;(&quot;</span>).<span class="i">append</span>(<span class="i">name</span>);
    <span class="k">for</span> (<span class="t">Expr</span> <span class="i">expr</span> : <span class="i">exprs</span>) {
      <span class="i">builder</span>.<span class="i">append</span>(<span class="s">&quot; &quot;</span>);
      <span class="i">builder</span>.<span class="i">append</span>(<span class="i">expr</span>.<span class="i">accept</span>(<span class="k">this</span>));
    }
    <span class="i">builder</span>.<span class="i">append</span>(<span class="s">&quot;)&quot;</span>);

    <span class="k">return</span> <span class="i">builder</span>.<span class="i">toString</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/AstPrinter.java</em>, add after <em>visitUnaryExpr</em>()</div>

<p>Elle prend un nom et une liste de sous-expressions et les enveloppe toutes dans des parenthèses, donnant une chaîne comme :</p>
<div class="codehilite"><pre>(+ 1 2)
</pre></div>
<p>Notez qu&rsquo;elle appelle <code>accept()</code> sur chaque sous-expression et se passe elle-même. C&rsquo;est l&rsquo;étape <span name="tree">récursive</span> qui nous permet d&rsquo;afficher un arbre entier.</p>
<aside name="tree">
<p>Cette récursion est aussi la raison pour laquelle les gens pensent que le patron Visiteur lui-même a à voir avec des arbres.</p>
</aside>
<p>Nous n&rsquo;avons pas encore de parseur, donc il est difficile de voir cela en action. Pour l&rsquo;instant, nous allons bricoler une petite méthode <code>main()</code> qui instancie manuellement un arbre et l&rsquo;affiche.</p>
<div class="codehilite"><div class="source-file"><em>lox/AstPrinter.java</em><br>
add after <em>parenthesize</em>()</div>
<pre>  <span class="k">public</span> <span class="k">static</span> <span class="t">void</span> <span class="i">main</span>(<span class="t">String</span>[] <span class="i">args</span>) {
    <span class="t">Expr</span> <span class="i">expression</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Binary</span>(
        <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Unary</span>(
            <span class="k">new</span> <span class="t">Token</span>(<span class="t">TokenType</span>.<span class="i">MINUS</span>, <span class="s">&quot;-&quot;</span>, <span class="k">null</span>, <span class="n">1</span>),
            <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="n">123</span>)),
        <span class="k">new</span> <span class="t">Token</span>(<span class="t">TokenType</span>.<span class="i">STAR</span>, <span class="s">&quot;*&quot;</span>, <span class="k">null</span>, <span class="n">1</span>),
        <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Grouping</span>(
            <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="n">45.67</span>)));

    <span class="t">System</span>.<span class="i">out</span>.<span class="i">println</span>(<span class="k">new</span> <span class="t">AstPrinter</span>().<span class="i">print</span>(<span class="i">expression</span>));
  }
</pre></div>
<div class="source-file-narrow"><em>lox/AstPrinter.java</em>, add after <em>parenthesize</em>()</div>

<p>Si nous avons tout fait juste, cela affiche :</p>
<div class="codehilite"><pre>(* (- 123) (group 45.67))
</pre></div>
<p>Vous pouvez y aller et supprimer cette méthode. Nous n&rsquo;en aurons pas besoin. Aussi, comme nous ajouterons de nouveaux types d&rsquo;arbre syntaxique, je ne prendrai pas la peine de montrer les méthodes visit nécessaires pour eux dans AstPrinter. Si vous voulez (et que vous voulez que le compilateur Java ne vous crie pas dessus), allez-y et ajoutez-les vous-même. Cela sera utile dans le prochain chapitre quand nous commencerons à parser du code Lox en arbres syntaxiques. Ou, si vous ne tenez pas à maintenir AstPrinter, sentez-vous libre de la supprimer. Nous n&rsquo;en aurons plus besoin.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>5&#8202;.&#8202;5</small>Défis</a></h2>
<ol>
<li>
<p>Plus tôt, j&rsquo;ai dit que les formes <code>|</code>, <code>*</code>, et <code>+</code> que nous avons ajoutées à notre métasyntaxe de grammaire étaient juste du sucre syntaxique. Prenez cette grammaire :</p>
<div class="codehilite"><pre><span class="i">expr</span> → <span class="i">expr</span> ( <span class="s">&quot;(&quot;</span> ( <span class="i">expr</span> ( <span class="s">&quot;,&quot;</span> <span class="i">expr</span> )* )? <span class="s">&quot;)&quot;</span> | <span class="s">&quot;.&quot;</span> <span class="t">IDENTIFIER</span> )+
     | <span class="t">IDENTIFIER</span>
     | <span class="t">NUMBER</span>
</pre></div>
<p>Produisez une grammaire qui matche le même langage mais n&rsquo;utilise aucun de ces sucres notationnels.</p>
<p><em>Bonus :</em> Quel genre d&rsquo;expression ce bout de grammaire encode-t-il ?</p>
</li>
<li>
<p>Le patron Visiteur vous permet d&rsquo;émuler le style fonctionnel dans un langage orienté objet. Concevez un patron complémentaire pour un langage fonctionnel. Il devrait vous permettre de regrouper toutes les opérations sur un type ensemble et vous permettre de définir de nouveaux types facilement.</p>
<p>(SML ou Haskell serait idéal pour cet exercice, mais Scheme ou un autre Lisp marche aussi bien.)</p>
</li>
<li>
<p>En <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">notation polonaise inverse</a> (NPI), les opérandes d&rsquo;un opérateur arithmétique sont tous deux placés avant l&rsquo;opérateur, donc <code>1 + 2</code> devient <code>1 2 +</code>. L&rsquo;évaluation procède de gauche à droite. Les nombres sont poussés sur une pile implicite. Un opérateur arithmétique dépile les deux nombres du haut, effectue l&rsquo;opération, et empile le résultat. Ainsi, ceci :</p>
<div class="codehilite"><pre>(<span class="n">1</span> + <span class="n">2</span>) * (<span class="n">4</span> - <span class="n">3</span>)
</pre></div>
<p>en NPI devient :</p>
<div class="codehilite"><pre><span class="n">1</span> <span class="n">2</span> + <span class="n">4</span> <span class="n">3</span> - *
</pre></div>
<p>Définissez une classe visiteur pour nos classes d&rsquo;arbre syntaxique qui prend une expression, la convertit en NPI, et renvoie la chaîne résultante.</p>
</li>
</ol>
</div>

<footer>
<a href="analyse-des-expressions.html" class="next">
  Next Chapter: &ldquo;Analyse des expressions&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
