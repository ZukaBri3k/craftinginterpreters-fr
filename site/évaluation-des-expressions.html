<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Évaluation des expressions &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Évaluation des expressions<small>7</small></a></h3>

<ul>
    <li><a href="#représenter-les-valeurs"><small>7.1</small> Représenter les Valeurs</a></li>
    <li><a href="#évaluation-des-expressions"><small>7.2</small> Évaluation des Expressions</a></li>
    <li><a href="#erreurs-dexécution"><small>7.3</small> Erreurs d&#x27;Exécution</a></li>
    <li><a href="#connecter-linterpréteur"><small>7.4</small> Connecter l&#x27;Interpréteur</a></li>
    <li><a href="#défis"><small>7.5</small> Défis</a></li>
    <li><a href="#note-de-conception--typage-statique-et-dynamique"><small>7.6</small> Note de Conception : Typage Statique et Dynamique</a></li>
</ul>


<div class="prev-next">
    <a href="analyse-des-expressions.html" title="Analyse des expressions" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="instructions-et-état.html" title="Instructions et état" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="analyse-des-expressions.html" title="Analyse des expressions" class="prev">←</a>
<a href="instructions-et-état.html" title="Instructions et état" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Évaluation des expressions<small>7</small></a></h3>

<ul>
    <li><a href="#représenter-les-valeurs"><small>7.1</small> Représenter les Valeurs</a></li>
    <li><a href="#évaluation-des-expressions"><small>7.2</small> Évaluation des Expressions</a></li>
    <li><a href="#erreurs-dexécution"><small>7.3</small> Erreurs d&#x27;Exécution</a></li>
    <li><a href="#connecter-linterpréteur"><small>7.4</small> Connecter l&#x27;Interpréteur</a></li>
    <li><a href="#défis"><small>7.5</small> Défis</a></li>
    <li><a href="#note-de-conception--typage-statique-et-dynamique"><small>7.6</small> Note de Conception : Typage Statique et Dynamique</a></li>
</ul>


<div class="prev-next">
    <a href="analyse-des-expressions.html" title="Analyse des expressions" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="instructions-et-état.html" title="Instructions et état" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">7</div>
  <h1>Évaluation des expressions</h1>

<blockquote>
<p>Tu es mon créateur, mais je suis ton maître ; Obéis !</p>
<p><cite>Mary Shelley, <em>Frankenstein</em></cite></p>
</blockquote>
<p>Si vous voulez correctement mettre l&rsquo;ambiance pour ce chapitre, essayez d&rsquo;invoquer un orage, l&rsquo;une de ces tempêtes tourbillonnantes qui aiment arracher les volets au point culminant de l&rsquo;histoire. Peut-être jeter quelques éclairs. Dans ce chapitre, notre interpréteur va prendre sa respiration, ouvrir les yeux, et exécuter du code.</p>
<p><span name="spooky"></span></p><img src="image/evaluating-expressions/lightning.png" alt="Un éclair frappe un manoir victorien. Effrayant !" />
<aside name="spooky">
<p>Un manoir victorien décrépit est optionnel, mais ajoute à l&rsquo;ambiance.</p>
</aside>
<p>Il y a toutes sortes de façons dont les implémentations de langage font faire à un ordinateur ce que le code source de l&rsquo;utilisateur commande. Elles peuvent le compiler en code machine, le traduire vers un autre langage de haut niveau, ou le réduire à un format bytecode pour qu&rsquo;une machine virtuelle l&rsquo;exécute. Pour notre premier interpréteur, cependant, nous allons prendre le chemin le plus simple, le plus court et exécuter l&rsquo;arbre syntaxique lui-même.</p>
<p>Pour l&rsquo;instant, notre parseur supporte seulement les expressions. Donc, pour &ldquo;exécuter&rdquo; du code, nous évaluerons une expression et produirons une valeur. Pour chaque type de syntaxe d&rsquo;expression que nous pouvons parser<span class="em">&mdash;</span>littéral, opérateur, etc.<span class="em">&mdash;</span>nous avons besoin d&rsquo;un morceau de code correspondant qui sait comment évaluer cet arbre et produire un résultat. Cela soulève deux questions :</p>
<ol>
<li>
<p>Quels types de valeurs produisons-nous ?</p>
</li>
<li>
<p>Comment organisons-nous ces morceaux de code ?</p>
</li>
</ol>
<p>Prenons-les une par une<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h2><a href="#représenter-les-valeurs" id="représenter-les-valeurs"><small>7&#8202;.&#8202;1</small>Représenter les Valeurs</a></h2>
<p>Dans Lox, les <span name="value">valeurs</span> sont créées par les littéraux, calculées par les expressions, et stockées dans des variables. L&rsquo;utilisateur les voit comme des objets <em>Lox</em>, mais elles sont implémentées dans le langage sous-jacent dans lequel notre interpréteur est écrit. Cela signifie faire le pont entre les terres du typage dynamique de Lox et les types statiques de Java. Une variable dans Lox peut stocker une valeur de n&rsquo;importe quel type (Lox), et peut même stocker des valeurs de différents types à différents moments. Quel type Java pourrions-nous utiliser pour représenter cela ?</p>
<aside name="value">
<p>Ici, j&rsquo;utilise &ldquo;valeur&rdquo; et &ldquo;objet&rdquo; à peu près de manière interchangeable.</p>
<p>Plus tard dans l&rsquo;interpréteur C, nous ferons une légère distinction entre eux, mais c&rsquo;est surtout pour avoir des termes uniques pour deux coins différents de l&rsquo;implémentation<span class="em">&mdash;</span>données en place contre allouées sur le tas. Du point de vue de l&rsquo;utilisateur, les termes sont synonymes.</p>
</aside>
<p>Étant donné une variable Java avec ce type statique, nous devons aussi être capables de déterminer quel genre de valeur elle contient à l&rsquo;exécution. Quand l&rsquo;interpréteur exécute un opérateur <code>+</code>, il a besoin de dire s&rsquo;il ajoute deux nombres ou concatène deux chaînes. Y a-t-il un type Java qui peut contenir des nombres, des chaînes, des booléens, et plus ? Y en a-t-il un qui peut nous dire quel est son type d&rsquo;exécution ? Il y en a un ! Le bon vieux java.lang.Object.</p>
<p>Dans les endroits de l&rsquo;interpréteur où nous avons besoin de stocker une valeur Lox, nous pouvons utiliser Object comme type. Java a des versions &ldquo;boxées&rdquo; (enveloppées) de ses types primitifs qui sous-classent toutes Object, donc nous pouvons utiliser celles-ci pour les types intégrés de Lox :</p><table>
<thead>
<tr>
  <td>Type Lox</td>
  <td>Représentation Java</td>
</tr>
</thead>
<tbody>
<tr>
  <td>N'importe quelle valeur Lox</td>
  <td>Object</td>
</tr>
<tr>
  <td><code>nil</code></td>
  <td><code>null</code></td>
</tr>
<tr>
  <td>Booléen</td>
  <td>Boolean</td>
</tr>
<tr>
  <td>nombre</td>
  <td>Double</td>
</tr>
<tr>
  <td>chaîne</td>
  <td>String</td>
</tr>
</tbody>
</table>
<p>Étant donné une valeur de type statique Object, nous pouvons déterminer si la valeur d&rsquo;exécution est un nombre ou une chaîne ou quoi que ce soit en utilisant l&rsquo;opérateur intégré de Java <code>instanceof</code>. En d&rsquo;autres termes, la propre représentation d&rsquo;objet de la <span name="jvm">JVM</span> nous donne commodément tout ce dont nous avons besoin pour implémenter les types intégrés de Lox. Nous devrons faire un peu plus de travail plus tard quand nous ajouterons les notions de fonctions, classes et instances de Lox, mais Object et les classes primitives boxées sont suffisants pour les types dont nous avons besoin pour l&rsquo;instant.</p>
<aside name="jvm">
<p>Une autre chose que nous devons faire avec les valeurs est gérer leur mémoire, et Java fait cela aussi. Une représentation d&rsquo;objet pratique et un ramasse-miettes vraiment sympa sont les raisons principales pour lesquelles nous écrivons notre premier interpréteur en Java.</p>
</aside>
<h2><a href="#évaluation-des-expressions" id="évaluation-des-expressions"><small>7&#8202;.&#8202;2</small>Évaluation des Expressions</a></h2>
<p>Ensuite, nous avons besoin de paquets de code pour implémenter la logique d&rsquo;évaluation pour chaque type d&rsquo;expression que nous pouvons parser. Nous pourrions fourrer ce code dans les classes d&rsquo;arbre syntaxique dans quelque chose comme une méthode <code>interpret()</code>. En effet, nous pourrions dire à chaque nœud d&rsquo;arbre syntaxique, &ldquo;Interprète-toi toi-même&rdquo;. C&rsquo;est le <a href="https://en.wikipedia.org/wiki/Interpreter_pattern">patron de conception Interpréteur</a> du Gang of Four. C&rsquo;est un patron sympa, mais comme je l&rsquo;ai mentionné plus tôt, cela devient désordonné si nous bourrons toutes sortes de logique dans les classes d&rsquo;arbre.</p>
<p>Au lieu de cela, nous allons réutiliser notre groovy <a href="representing-code.html#the-visitor-pattern">patron Visiteur</a>. Dans le chapitre précédent, nous avons créé une classe AstPrinter. Elle prenait un arbre syntaxique et le parcourait récursivement, construisant une chaîne qu&rsquo;elle renvoyait finalement. C&rsquo;est presque exactement ce qu&rsquo;un vrai interpréteur fait, sauf qu&rsquo;au lieu de concaténer des chaînes, il calcule des valeurs.</p>
<p>Nous commençons avec une nouvelle classe.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">class</span> <span class="t">Interpreter</span> <span class="k">implements</span> <span class="t">Expr</span>.<span class="t">Visitor</span>&lt;<span class="t">Object</span>&gt; {
}
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, create new file</div>

<p>La classe déclare qu&rsquo;elle est un visiteur. Le type de retour des méthodes visit sera Object, la classe racine que nous utilisons pour nous référer à une valeur Lox dans notre code Java. Pour satisfaire l&rsquo;interface Visitor, nous devons définir des méthodes visit pour chacune des quatre classes d&rsquo;arbre d&rsquo;expression que notre parseur produit. Nous commencerons par la plus simple<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h3><a href="#évaluation-des-littéraux" id="évaluation-des-littéraux"><small>7&#8202;.&#8202;2&#8202;.&#8202;1</small>Évaluation des littéraux</a></h3>
<p>Les feuilles d&rsquo;un arbre d&rsquo;expression<span class="em">&mdash;</span>les bouts atomiques de syntaxe dont toutes les autres expressions sont composées<span class="em">&mdash;</span>sont les <span name="leaf">littéraux</span>. Les littéraux sont presque déjà des valeurs, mais la distinction est importante. Un littéral est un <em>bout de syntaxe</em> qui produit une valeur. Un littéral apparaît toujours quelque part dans le code source de l&rsquo;utilisateur. Beaucoup de valeurs sont produites par le calcul et n&rsquo;existent nulle part dans le code lui-même. Ce ne sont pas des littéraux. Un littéral vient du domaine du parseur. Les valeurs sont un concept de l&rsquo;interpréteur, une partie du monde de l&rsquo;exécution (runtime).</p>
<aside name="leaf">
<p>Dans le <a href="statements-and-state.html">prochain chapitre</a>, quand nous implémenterons les variables, nous ajouterons les expressions d&rsquo;identifiant, qui sont aussi des nœuds feuilles.</p>
</aside>
<p>Donc, tout comme nous avons converti un <em>token</em> littéral en un <em>nœud d&rsquo;arbre syntaxique</em> littéral dans le parseur, maintenant nous convertissons le nœud d&rsquo;arbre littéral en une valeur d&rsquo;exécution. Cela s&rsquo;avère être trivial.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
in class <em>Interpreter</em></div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitLiteralExpr</span>(<span class="t">Expr</span>.<span class="t">Literal</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">expr</span>.<span class="i">value</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in class <em>Interpreter</em></div>

<p>Nous avons produit avidemment la valeur d&rsquo;exécution bien avant pendant le scan et l&rsquo;avons fourrée dans le token. Le parseur a pris cette valeur et l&rsquo;a collée dans le nœud d&rsquo;arbre littéral, donc pour évaluer un littéral, nous la ressortons simplement.</p>
<h3><a href="#évaluation-des-parenthèses" id="évaluation-des-parenthèses"><small>7&#8202;.&#8202;2&#8202;.&#8202;2</small>Évaluation des parenthèses</a></h3>
<p>Le prochain nœud le plus simple à évaluer est le groupement<span class="em">&mdash;</span>le nœud que vous obtenez comme résultat de l&rsquo;utilisation de parenthèses explicites dans une expression.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
in class <em>Interpreter</em></div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitGroupingExpr</span>(<span class="t">Expr</span>.<span class="t">Grouping</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">expression</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in class <em>Interpreter</em></div>

<p>Un nœud de <span name="grouping">groupement</span> a une référence vers un nœud interne pour l&rsquo;expression contenue à l&rsquo;intérieur des parenthèses. Pour évaluer l&rsquo;expression de groupement elle-même, nous évaluons récursivement cette sous-expression et la renvoyons.</p>
<p>Nous comptons sur cette méthode d&rsquo;aide qui renvoie simplement l&rsquo;expression dans l&rsquo;implémentation du visiteur de l&rsquo;interpréteur :</p>
<aside name="grouping">
<p>Certains parseurs ne définissent pas de nœuds d&rsquo;arbre pour les parenthèses. Au lieu de cela, lors du parsing d&rsquo;une expression parenthésée, ils renvoient simplement le nœud pour l&rsquo;expression interne. Nous créons un nœud pour les parenthèses dans Lox parce que nous en aurons besoin plus tard pour gérer correctement les côtés gauches des expressions d&rsquo;affectation.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
in class <em>Interpreter</em></div>
<pre>  <span class="k">private</span> <span class="t">Object</span> <span class="i">evaluate</span>(<span class="t">Expr</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">expr</span>.<span class="i">accept</span>(<span class="k">this</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in class <em>Interpreter</em></div>

<h3><a href="#évaluation-des-expressions-unaires" id="évaluation-des-expressions-unaires"><small>7&#8202;.&#8202;2&#8202;.&#8202;3</small>Évaluation des expressions unaires</a></h3>
<p>Comme le groupement, les expressions unaires ont une seule sous-expression que nous devons évaluer en premier. La différence est que l&rsquo;expression unaire elle-même fait un peu de travail après.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitLiteralExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitUnaryExpr</span>(<span class="t">Expr</span>.<span class="t">Unary</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">right</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">right</span>);

    <span class="k">switch</span> (<span class="i">expr</span>.<span class="i">operator</span>.<span class="i">type</span>) {
      <span class="k">case</span> <span class="i">MINUS</span>:
        <span class="k">return</span> -(<span class="t">double</span>)<span class="i">right</span>;
    }

    <span class="c">// Unreachable.</span>
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitLiteralExpr</em>()</div>

<p>D&rsquo;abord, nous évaluons l&rsquo;expression opérande. Ensuite, nous appliquons l&rsquo;opérateur unaire lui-même au résultat de cela. Il y a deux expressions unaires différentes, identifiées par le type du token opérateur.</p>
<p>Montré ici est <code>-</code>, qui inverse le signe du résultat de la sous-expression. La sous-expression doit être un nombre. Puisque nous ne savons pas <em>statiquement</em> cela en Java, nous le <span name="cast">castons</span> avant d&rsquo;effectuer l&rsquo;opération. Ce cast de type se produit à l&rsquo;exécution quand le <code>-</code> est évalué. C&rsquo;est le cœur de ce qui rend un langage typé dynamiquement juste là.</p>
<aside name="cast">
<p>Vous vous demandez probablement ce qui se passe si le cast échoue. N&rsquo;ayez crainte, nous y viendrons bientôt.</p>
</aside>
<p>Vous pouvez commencer à voir comment l&rsquo;évaluation traverse récursivement l&rsquo;arbre. Nous ne pouvons pas évaluer l&rsquo;opérateur unaire lui-même avant d&rsquo;avoir évalué sa sous-expression opérande. Cela signifie que notre interpréteur fait un <strong>parcours post-ordre</strong><span class="em">&mdash;</span>chaque nœud évalue ses enfants avant de faire son propre travail.</p>
<p>L&rsquo;autre opérateur unaire est le non logique.</p>
<div class="codehilite"><pre class="insert-before">    switch (expr.operator.type) {
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitUnaryExpr</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="i">BANG</span>:
        <span class="k">return</span> !<span class="i">isTruthy</span>(<span class="i">right</span>);
</pre><pre class="insert-after">      case MINUS:
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitUnaryExpr</em>()</div>

<p>L&rsquo;implémentation est simple, mais c&rsquo;est quoi ce truc &ldquo;truthy&rdquo; (vrai) ? Nous avons besoin de faire une petite excursion vers l&rsquo;une des grandes questions de la philosophie occidentale : <em>Qu&rsquo;est-ce que la vérité ?</em></p>
<h3><a href="#vérité-et-fausseté" id="vérité-et-fausseté"><small>7&#8202;.&#8202;2&#8202;.&#8202;4</small>Vérité et fausseté</a></h3>
<p>OK, peut-être que nous n&rsquo;allons pas vraiment entrer dans la question universelle, mais au moins à l&rsquo;intérieur du monde de Lox, nous devons décider ce qui se passe quand vous utilisez quelque chose d&rsquo;autre que <code>true</code> ou <code>false</code> dans une opération logique comme <code>!</code> ou n&rsquo;importe quel autre endroit où un Booléen est attendu.</p>
<p>Nous <em>pourrions</em> juste dire que c&rsquo;est une erreur parce que nous ne roulons pas avec les conversions implicites, mais la plupart des langages typés dynamiquement ne sont pas aussi ascétiques. Au lieu de cela, ils prennent l&rsquo;univers des valeurs de tous types et les partitionnent en deux ensembles, l&rsquo;un qu&rsquo;ils définissent comme &ldquo;vrai&rdquo;, ou &ldquo;truthy&rdquo;, et le reste qui sont &ldquo;faux&rdquo; ou &ldquo;falsey&rdquo;. Ce partitionnement est quelque peu arbitraire et devient <span name="weird">bizarre</span> dans quelques langages.</p>
<aside name="weird" class="bottom">
<p>En JavaScript, les chaînes sont truthy, mais les chaînes vides ne le sont pas. Les tableaux sont truthy mais les tableaux vides sont<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>aussi truthy. Le nombre <code>0</code> est falsey, mais la <em>chaîne</em> <code>"0"</code> est truthy.</p>
<p>En Python, les chaînes vides sont falsey comme en JS, mais d&rsquo;autres séquences vides sont falsey aussi.</p>
<p>En PHP, à la fois le nombre <code>0</code> et la chaîne <code>"0"</code> sont falsey. La plupart des autres chaînes non vides sont truthy.</p>
<p>Vous avez tout suivi ?</p>
</aside>
<p>Lox suit la règle simple de Ruby : <code>false</code> et <code>nil</code> sont falsey, et tout le reste est truthy. Nous implémentons cela comme ceci :</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitUnaryExpr</em>()</div>
<pre>  <span class="k">private</span> <span class="t">boolean</span> <span class="i">isTruthy</span>(<span class="t">Object</span> <span class="i">object</span>) {
    <span class="k">if</span> (<span class="i">object</span> == <span class="k">null</span>) <span class="k">return</span> <span class="k">false</span>;
    <span class="k">if</span> (<span class="i">object</span> <span class="k">instanceof</span> <span class="t">Boolean</span>) <span class="k">return</span> (<span class="t">boolean</span>)<span class="i">object</span>;
    <span class="k">return</span> <span class="k">true</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitUnaryExpr</em>()</div>

<h3><a href="#évaluation-des-opérateurs-binaires" id="évaluation-des-opérateurs-binaires"><small>7&#8202;.&#8202;2&#8202;.&#8202;5</small>Évaluation des opérateurs binaires</a></h3>
<p>Passons à la dernière classe d&rsquo;arbre d&rsquo;expression, les opérateurs binaires. Il y en a une poignée, et nous commencerons par ceux arithmétiques.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>evaluate</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitBinaryExpr</span>(<span class="t">Expr</span>.<span class="t">Binary</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">left</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">left</span>);
    <span class="t">Object</span> <span class="i">right</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">right</span>);<span name="left"> </span>

    <span class="k">switch</span> (<span class="i">expr</span>.<span class="i">operator</span>.<span class="i">type</span>) {
      <span class="k">case</span> <span class="i">MINUS</span>:
        <span class="k">return</span> (<span class="t">double</span>)<span class="i">left</span> - (<span class="t">double</span>)<span class="i">right</span>;
      <span class="k">case</span> <span class="i">SLASH</span>:
        <span class="k">return</span> (<span class="t">double</span>)<span class="i">left</span> / (<span class="t">double</span>)<span class="i">right</span>;
      <span class="k">case</span> <span class="i">STAR</span>:
        <span class="k">return</span> (<span class="t">double</span>)<span class="i">left</span> * (<span class="t">double</span>)<span class="i">right</span>;
    }

    <span class="c">// Unreachable.</span>
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>evaluate</em>()</div>

<aside name="left">
<p>Avez-vous remarqué que nous avons épinglé un coin subtil de la sémantique du langage ici ? Dans une expression binaire, nous évaluons les opérandes dans l&rsquo;ordre de gauche à droite. Si ces opérandes ont des effets de bord, ce choix est visible par l&rsquo;utilisateur, donc ce n&rsquo;est pas simplement un détail d&rsquo;implémentation.</p>
<p>Si nous voulons que nos deux interpréteurs soient cohérents (indice : nous le voulons), nous devrons nous assurer que clox fait la même chose.</p>
</aside>
<p>Je pense que vous pouvez comprendre ce qui se passe ici. La différence principale avec l&rsquo;opérateur de négation unaire est que nous avons deux opérandes à évaluer.</p>
<p>J&rsquo;ai laissé de côté un opérateur arithmétique parce qu&rsquo;il est un peu spécial.</p>
<div class="codehilite"><pre class="insert-before">    switch (expr.operator.type) {
      case MINUS:
        return (double)left - (double)right;
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitBinaryExpr</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="i">PLUS</span>:
        <span class="k">if</span> (<span class="i">left</span> <span class="k">instanceof</span> <span class="t">Double</span> &amp;&amp; <span class="i">right</span> <span class="k">instanceof</span> <span class="t">Double</span>) {
          <span class="k">return</span> (<span class="t">double</span>)<span class="i">left</span> + (<span class="t">double</span>)<span class="i">right</span>;
        }<span name="plus"> </span>

        <span class="k">if</span> (<span class="i">left</span> <span class="k">instanceof</span> <span class="t">String</span> &amp;&amp; <span class="i">right</span> <span class="k">instanceof</span> <span class="t">String</span>) {
          <span class="k">return</span> (<span class="t">String</span>)<span class="i">left</span> + (<span class="t">String</span>)<span class="i">right</span>;
        }

        <span class="k">break</span>;
</pre><pre class="insert-after">      case SLASH:
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitBinaryExpr</em>()</div>

<p>L&rsquo;opérateur <code>+</code> peut aussi être utilisé pour concaténer deux chaînes. Pour gérer cela, nous ne supposons pas juste que les opérandes sont d&rsquo;un certain type et les <em>castons</em>, nous <em>vérifions</em> dynamiquement le type et choisissons l&rsquo;opération appropriée. C&rsquo;est pourquoi nous avons besoin que notre représentation d&rsquo;objet supporte <code>instanceof</code>.</p>
<aside name="plus">
<p>Nous aurions pu définir un opérateur spécifiquement pour la concaténation de chaînes. C&rsquo;est ce que Perl (<code>.</code>), Lua (<code>..</code>), Smalltalk (<code>,</code>), Haskell (<code>++</code>), et d&rsquo;autres font.</p>
<p>J&rsquo;ai pensé que cela rendrait Lox un peu plus abordable d&rsquo;utiliser la même syntaxe que Java, JavaScript, Python, et d&rsquo;autres. Cela signifie que l&rsquo;opérateur <code>+</code> est <strong>surchargé</strong> pour supporter à la fois l&rsquo;addition de nombres et la concaténation de chaînes. Même dans les langages qui n&rsquo;utilisent pas <code>+</code> pour les chaînes, ils le surchargent toujours souvent pour ajouter à la fois des entiers et des nombres à virgule flottante.</p>
</aside>
<p>Les suivants sont les opérateurs de comparaison.</p>
<div class="codehilite"><pre class="insert-before">    switch (expr.operator.type) {
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitBinaryExpr</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="i">GREATER</span>:
        <span class="k">return</span> (<span class="t">double</span>)<span class="i">left</span> &gt; (<span class="t">double</span>)<span class="i">right</span>;
      <span class="k">case</span> <span class="i">GREATER_EQUAL</span>:
        <span class="k">return</span> (<span class="t">double</span>)<span class="i">left</span> &gt;= (<span class="t">double</span>)<span class="i">right</span>;
      <span class="k">case</span> <span class="i">LESS</span>:
        <span class="k">return</span> (<span class="t">double</span>)<span class="i">left</span> &lt; (<span class="t">double</span>)<span class="i">right</span>;
      <span class="k">case</span> <span class="i">LESS_EQUAL</span>:
        <span class="k">return</span> (<span class="t">double</span>)<span class="i">left</span> &lt;= (<span class="t">double</span>)<span class="i">right</span>;
</pre><pre class="insert-after">      case MINUS:
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitBinaryExpr</em>()</div>

<p>Ils sont fondamentalement les mêmes que l&rsquo;arithmétique. La seule différence est que là où les opérateurs arithmétiques produisent une valeur dont le type est le même que les opérandes (nombres ou chaînes), les opérateurs de comparaison produisent toujours un Booléen.</p>
<p>La dernière paire d&rsquo;opérateurs sont pour l&rsquo;égalité.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitBinaryExpr</em>()</div>
<pre>      <span class="k">case</span> <span class="i">BANG_EQUAL</span>: <span class="k">return</span> !<span class="i">isEqual</span>(<span class="i">left</span>, <span class="i">right</span>);
      <span class="k">case</span> <span class="i">EQUAL_EQUAL</span>: <span class="k">return</span> <span class="i">isEqual</span>(<span class="i">left</span>, <span class="i">right</span>);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitBinaryExpr</em>()</div>

<p>Contrairement aux opérateurs de comparaison qui nécessitent des nombres, les opérateurs d&rsquo;égalité supportent des opérandes de n&rsquo;importe quel type, même mixtes. Vous ne pouvez pas demander à Lox si 3 est <em>plus petit</em> que <code>"trois"</code>, mais vous pouvez demander s&rsquo;il est <span name="equal"><em>égal</em></span> à lui.</p>
<aside name="equal">
<p>Alerte spoiler : il ne l&rsquo;est pas.</p>
</aside>
<p>Comme la véracité (truthiness), la logique d&rsquo;égalité est hissée hors dans une méthode séparée.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>isTruthy</em>()</div>
<pre>  <span class="k">private</span> <span class="t">boolean</span> <span class="i">isEqual</span>(<span class="t">Object</span> <span class="i">a</span>, <span class="t">Object</span> <span class="i">b</span>) {
    <span class="k">if</span> (<span class="i">a</span> == <span class="k">null</span> &amp;&amp; <span class="i">b</span> == <span class="k">null</span>) <span class="k">return</span> <span class="k">true</span>;
    <span class="k">if</span> (<span class="i">a</span> == <span class="k">null</span>) <span class="k">return</span> <span class="k">false</span>;

    <span class="k">return</span> <span class="i">a</span>.<span class="i">equals</span>(<span class="i">b</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>isTruthy</em>()</div>

<p>C&rsquo;est l&rsquo;un de ces coins où les détails de comment nous représentons les objets Lox en termes de Java comptent. Nous devons implémenter correctement la notion d&rsquo;égalité de <em>Lox</em>, qui peut être différente de celle de Java.</p>
<p>Heureusement, les deux sont assez similaires. Lox ne fait pas de conversions implicites dans l&rsquo;égalité et Java non plus. Nous devons gérer <code>nil</code>/<code>null</code> spécialement afin de ne pas lancer de NullPointerException si nous essayons d&rsquo;appeler <code>equals()</code> sur <code>null</code>. Sinon, nous sommes bons. La méthode <span name="nan"><code>equals()</code></span> de Java sur Boolean, Double, et String a le comportement que nous voulons pour Lox.</p>
<aside name="nan">
<p>À quoi vous attendez-vous que ceci évalue :</p>
<div class="codehilite"><pre>(<span class="n">0</span> / <span class="n">0</span>) == (<span class="n">0</span> / <span class="n">0</span>)
</pre></div>
<p>Selon <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a>, qui spécifie le comportement des nombres à double précision, diviser un zéro par zéro vous donne la valeur spéciale <strong>NaN</strong> (&ldquo;not a number&rdquo; - pas un nombre). Étrangement assez, NaN n&rsquo;est <em>pas</em> égal à lui-même.</p>
<p>En Java, l&rsquo;opérateur <code>==</code> sur les doubles primitifs préserve ce comportement, mais la méthode <code>equals()</code> sur la classe Double ne le fait pas. Lox utilise cette dernière, donc ne suit pas IEEE. Ces types d&rsquo;incompatibilités subtiles occupent une fraction consternante de la vie des implémenteurs de langage.</p>
</aside>
<p>Et c&rsquo;est tout ! C&rsquo;est tout le code dont nous avons besoin pour interpréter correctement une expression Lox valide. Mais qu&rsquo;en est-il d&rsquo;une <em>invalide</em> ? En particulier, que se passe-t-il quand une sous-expression s&rsquo;évalue en un objet du mauvais type pour l&rsquo;opération effectuée ?</p>
<h2><a href="#erreurs-dexécution" id="erreurs-dexécution"><small>7&#8202;.&#8202;3</small>Erreurs d&rsquo;Exécution</a></h2>
<p>J&rsquo;ai été cavalier en bourrant des casts chaque fois qu&rsquo;une sous-expression produit un Object et que l&rsquo;opérateur exige qu&rsquo;il soit un nombre ou une chaîne. Ces casts peuvent échouer. Même si le code de l&rsquo;utilisateur est erroné, si nous voulons faire un langage <span name="fail">utilisable</span>, nous sommes responsables de la gestion de cette erreur avec grâce.</p>
<aside name="fail">
<p>Nous pourrions simplement ne pas détecter ou rapporter une erreur de type du tout. C&rsquo;est ce que fait C si vous castez un pointeur vers un certain type qui ne correspond pas aux données qui sont réellement pointées. C gagne de la flexibilité et de la vitesse en permettant cela, mais est aussi fameusement dangereux. Une fois que vous mésinterprétez des bits en mémoire, tous les paris sont ouverts.</p>
<p>Peu de langages modernes acceptent des opérations non sûres comme celle-là. Au lieu de cela, la plupart sont <strong>sûrs pour la mémoire</strong> et assurent<span class="em">&mdash;</span>à travers une combinaison de vérifications statiques et à l&rsquo;exécution<span class="em">&mdash;</span>qu&rsquo;un programme ne peut jamais interpréter incorrectement la valeur stockée dans un morceau de mémoire.</p>
</aside>
<p>Il est temps pour nous de parler des <strong>erreurs d&rsquo;exécution</strong> (runtime errors). J&rsquo;ai versé beaucoup d&rsquo;encre dans les chapitres précédents en parlant de la gestion d&rsquo;erreur, mais c&rsquo;étaient toutes des erreurs de <em>syntaxe</em> ou <em>statiques</em>. Celles-ci sont détectées et rapportées avant que <em>le moindre</em> code soit exécuté. Les erreurs d&rsquo;exécution sont des échecs que la sémantique du langage exige que nous détections et rapportions pendant que le programme s&rsquo;exécute (d&rsquo;où le nom).</p>
<p>Pour l&rsquo;instant, si un opérande est du mauvais type pour l&rsquo;opération effectuée, le cast Java échouera et la JVM lancera une ClassCastException. Cela déroule toute la pile et quitte l&rsquo;application, vomissant une trace de pile Java sur l&rsquo;utilisateur. Ce n&rsquo;est probablement pas ce que nous voulons. Le fait que Lox soit implémenté en Java devrait être un détail caché de l&rsquo;utilisateur. Au lieu de cela, nous voulons qu&rsquo;ils comprennent qu&rsquo;une erreur d&rsquo;exécution <em>Lox</em> s&rsquo;est produite, et leur donner un message d&rsquo;erreur pertinent pour notre langage et leur programme.</p>
<p>Le comportement Java a une chose pour lui, cependant. Il arrête correctement l&rsquo;exécution de tout code quand l&rsquo;erreur se produit. Disons que l&rsquo;utilisateur entre une expression comme :</p>
<div class="codehilite"><pre><span class="n">2</span> * (<span class="n">3</span> / -<span class="s">&quot;muffin&quot;</span>)
</pre></div>
<p>Vous ne pouvez pas inverser le signe d&rsquo;un <span name="muffin">muffin</span>, donc nous devons rapporter une erreur d&rsquo;exécution à cette expression <code>-</code> interne. Cela signifie à son tour que nous ne pouvons pas évaluer l&rsquo;expression <code>/</code> puisqu&rsquo;elle n&rsquo;a pas d&rsquo;opérande droit significatif. De même pour le <code>*</code>. Donc quand une erreur d&rsquo;exécution se produit profondément dans une expression, nous avons besoin de nous échapper tout le chemin vers l&rsquo;extérieur.</p>
<aside name="muffin">
<p>Je ne sais pas, mec, <em>peux</em>-tu inverser le signe d&rsquo;un muffin ?</p><img src="image/evaluating-expressions/muffin.png" alt="Un muffin, inversé." />
</aside>
<p>Nous pourrions imprimer une erreur d&rsquo;exécution et ensuite avorter le processus et quitter l&rsquo;application entièrement. Cela a un certain flair mélodramatique. Sorte d&rsquo;équivalent pour un interpréteur de langage de programmation d&rsquo;un lâcher de micro.</p>
<p>Aussi tentant que cela soit, nous devrions probablement faire quelque chose d&rsquo;un peu moins cataclysmique. Bien qu&rsquo;une erreur d&rsquo;exécution doive arrêter l&rsquo;évaluation de l&rsquo;<em>expression</em>, elle ne devrait pas tuer l&rsquo;<em>interpréteur</em>. Si un utilisateur exécute le REPL et a une faute de frappe dans une ligne de code, il devrait toujours être capable de garder la session en cours et d&rsquo;entrer plus de code après cela.</p>
<h3><a href="#détecter-les-erreurs-dexécution" id="détecter-les-erreurs-dexécution"><small>7&#8202;.&#8202;3&#8202;.&#8202;1</small>Détecter les erreurs d&rsquo;exécution</a></h3>
<p>Notre interpréteur à parcours d&rsquo;arbre évalue les expressions imbriquées en utilisant des appels de méthode récursifs, et nous avons besoin de nous dérouler hors de tout ceux-là. Lancer une exception en Java est un bon moyen d&rsquo;accomplir cela. Cependant, au lieu d&rsquo;utiliser le propre échec de cast de Java, nous en définirons un spécifique à Lox afin que nous puissions le gérer comme nous voulons.</p>
<p>Avant de faire le cast, nous vérifions le type de l&rsquo;objet nous-mêmes. Donc, pour le <code>-</code> unaire, nous ajoutons :</p>
<div class="codehilite"><pre class="insert-before">      case MINUS:
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitUnaryExpr</em>()</div>
<pre class="insert">        <span class="i">checkNumberOperand</span>(<span class="i">expr</span>.<span class="i">operator</span>, <span class="i">right</span>);
</pre><pre class="insert-after">        return -(double)right;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitUnaryExpr</em>()</div>

<p>Le code pour vérifier l&rsquo;opérande est :</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitUnaryExpr</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">checkNumberOperand</span>(<span class="t">Token</span> <span class="i">operator</span>, <span class="t">Object</span> <span class="i">operand</span>) {
    <span class="k">if</span> (<span class="i">operand</span> <span class="k">instanceof</span> <span class="t">Double</span>) <span class="k">return</span>;
    <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">operator</span>, <span class="s">&quot;Operand must be a number.&quot;</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitUnaryExpr</em>()</div>

<p>Quand la vérification échoue, elle lance un de ceux-ci :</p>
<div class="codehilite"><div class="source-file"><em>lox/RuntimeError.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">class</span> <span class="t">RuntimeError</span> <span class="k">extends</span> <span class="t">RuntimeException</span> {
  <span class="k">final</span> <span class="t">Token</span> <span class="i">token</span>;

  <span class="t">RuntimeError</span>(<span class="t">Token</span> <span class="i">token</span>, <span class="t">String</span> <span class="i">message</span>) {
    <span class="k">super</span>(<span class="i">message</span>);
    <span class="k">this</span>.<span class="i">token</span> = <span class="i">token</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/RuntimeError.java</em>, create new file</div>

<p>Contrairement à l&rsquo;exception de cast Java, notre <span name="class">classe</span> suit le token qui identifie d&rsquo;où dans le code de l&rsquo;utilisateur l&rsquo;erreur d&rsquo;exécution est venue. Comme pour les erreurs statiques, cela aide l&rsquo;utilisateur à savoir où corriger son code.</p>
<aside name="class">
<p>J&rsquo;admets que le nom &ldquo;RuntimeError&rdquo; est confus puisque Java définit une classe RuntimeException. Une chose ennuyeuse à propos de la construction d&rsquo;interpréteurs est que vos noms entrent souvent en collision avec ceux déjà pris par le langage d&rsquo;implémentation. Attendez juste que nous supportions les classes Lox.</p>
</aside>
<p>Nous avons besoin de vérifications similaires pour les opérateurs binaires. Puisque je vous ai promis chaque ligne de code nécessaire pour implémenter les interpréteurs, je vais toutes les passer en revue.</p>
<p>Plus grand que :</p>
<div class="codehilite"><pre class="insert-before">      case GREATER:
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitBinaryExpr</em>()</div>
<pre class="insert">        <span class="i">checkNumberOperands</span>(<span class="i">expr</span>.<span class="i">operator</span>, <span class="i">left</span>, <span class="i">right</span>);
</pre><pre class="insert-after">        return (double)left &gt; (double)right;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitBinaryExpr</em>()</div>

<p>Plus grand ou égal à :</p>
<div class="codehilite"><pre class="insert-before">      case GREATER_EQUAL:
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitBinaryExpr</em>()</div>
<pre class="insert">        <span class="i">checkNumberOperands</span>(<span class="i">expr</span>.<span class="i">operator</span>, <span class="i">left</span>, <span class="i">right</span>);
</pre><pre class="insert-after">        return (double)left &gt;= (double)right;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitBinaryExpr</em>()</div>

<p>Plus petit que :</p>
<div class="codehilite"><pre class="insert-before">      case LESS:
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitBinaryExpr</em>()</div>
<pre class="insert">        <span class="i">checkNumberOperands</span>(<span class="i">expr</span>.<span class="i">operator</span>, <span class="i">left</span>, <span class="i">right</span>);
</pre><pre class="insert-after">        return (double)left &lt; (double)right;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitBinaryExpr</em>()</div>

<p>Plus petit ou égal à :</p>
<div class="codehilite"><pre class="insert-before">      case LESS_EQUAL:
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitBinaryExpr</em>()</div>
<pre class="insert">        <span class="i">checkNumberOperands</span>(<span class="i">expr</span>.<span class="i">operator</span>, <span class="i">left</span>, <span class="i">right</span>);
</pre><pre class="insert-after">        return (double)left &lt;= (double)right;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitBinaryExpr</em>()</div>

<p>Soustraction :</p>
<div class="codehilite"><pre class="insert-before">      case MINUS:
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitBinaryExpr</em>()</div>
<pre class="insert">        <span class="i">checkNumberOperands</span>(<span class="i">expr</span>.<span class="i">operator</span>, <span class="i">left</span>, <span class="i">right</span>);
</pre><pre class="insert-after">        return (double)left - (double)right;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitBinaryExpr</em>()</div>

<p>Division :</p>
<div class="codehilite"><pre class="insert-before">      case SLASH:
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitBinaryExpr</em>()</div>
<pre class="insert">        <span class="i">checkNumberOperands</span>(<span class="i">expr</span>.<span class="i">operator</span>, <span class="i">left</span>, <span class="i">right</span>);
</pre><pre class="insert-after">        return (double)left / (double)right;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitBinaryExpr</em>()</div>

<p>Multiplication :</p>
<div class="codehilite"><pre class="insert-before">      case STAR:
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitBinaryExpr</em>()</div>
<pre class="insert">        <span class="i">checkNumberOperands</span>(<span class="i">expr</span>.<span class="i">operator</span>, <span class="i">left</span>, <span class="i">right</span>);
</pre><pre class="insert-after">        return (double)left * (double)right;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitBinaryExpr</em>()</div>

<p>Tous ceux-là reposent sur ce validateur, qui est virtuellement le même que celui unaire :</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>checkNumberOperand</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">checkNumberOperands</span>(<span class="t">Token</span> <span class="i">operator</span>,
                                   <span class="t">Object</span> <span class="i">left</span>, <span class="t">Object</span> <span class="i">right</span>) {
    <span class="k">if</span> (<span class="i">left</span> <span class="k">instanceof</span> <span class="t">Double</span> &amp;&amp; <span class="i">right</span> <span class="k">instanceof</span> <span class="t">Double</span>) <span class="k">return</span>;
   <span name="operand"> </span>
    <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">operator</span>, <span class="s">&quot;Operands must be numbers.&quot;</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>checkNumberOperand</em>()</div>

<aside name="operand">
<p>Un autre choix sémantique subtil : Nous évaluons les <em>deux</em> opérandes avant de vérifier le type de l&rsquo;<em>un ou l&rsquo;autre</em>. Imaginez que nous ayons une fonction <code>say()</code> qui imprime son argument puis le renvoie. En utilisant cela, nous écrivons :</p>
<div class="codehilite"><pre><span class="i">say</span>(<span class="s">&quot;left&quot;</span>) - <span class="i">say</span>(<span class="s">&quot;right&quot;</span>);
</pre></div>
<p>Notre interpréteur imprime &ldquo;left&rdquo; et &ldquo;right&rdquo; avant de rapporter l&rsquo;erreur d&rsquo;exécution. Nous aurions pu à la place spécifier que l&rsquo;opérande gauche est vérifié avant même d&rsquo;évaluer le droit.</p>
</aside>
<p>Le dernier opérateur restant, encore l&rsquo;intrus, est l&rsquo;addition. Puisque <code>+</code> est surchargé pour les nombres et les chaînes, il a déjà du code pour vérifier les types. Tout ce que nous avons besoin de faire est d&rsquo;échouer si aucun des deux cas de succès ne matche.</p>
<div class="codehilite"><pre class="insert-before">          return (String)left + (String)right;
        }

</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitBinaryExpr</em>()<br>
replace 1 line</div>
<pre class="insert">        <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">expr</span>.<span class="i">operator</span>,
            <span class="s">&quot;Operands must be two numbers or two strings.&quot;</span>);
</pre><pre class="insert-after">      case SLASH:
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitBinaryExpr</em>(), replace 1 line</div>

<p>Cela nous permet de détecter les erreurs d&rsquo;exécution profondément dans les entrailles de l&rsquo;évaluateur. Les erreurs sont lancées. L&rsquo;étape suivante est d&rsquo;écrire le code qui les attrape. Pour cela, nous avons besoin de brancher la classe Interpreter dans la classe Lox principale qui la pilote.</p>
<h2><a href="#connecter-linterpréteur" id="connecter-linterpréteur"><small>7&#8202;.&#8202;4</small>Connecter l&rsquo;Interpréteur</a></h2>
<p>Les méthodes visit sont en quelque sorte les tripes de la classe Interpreter, où le vrai travail se passe. Nous avons besoin d&rsquo;envelopper une peau autour d&rsquo;elles pour s&rsquo;interfacer avec le reste du programme. L&rsquo;API publique de l&rsquo;Interpreter est simplement une méthode.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
in class <em>Interpreter</em></div>
<pre>  <span class="t">void</span> <span class="i">interpret</span>(<span class="t">Expr</span> <span class="i">expression</span>) {<span name="void"> </span>
    <span class="k">try</span> {
      <span class="t">Object</span> <span class="i">value</span> = <span class="i">evaluate</span>(<span class="i">expression</span>);
      <span class="t">System</span>.<span class="i">out</span>.<span class="i">println</span>(<span class="i">stringify</span>(<span class="i">value</span>));
    } <span class="k">catch</span> (<span class="t">RuntimeError</span> <span class="i">error</span>) {
      <span class="t">Lox</span>.<span class="i">runtimeError</span>(<span class="i">error</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in class <em>Interpreter</em></div>

<p>Celle-ci prend un arbre syntaxique pour une expression et l&rsquo;évalue. Si cela réussit, <code>evaluate()</code> renvoie un objet pour la valeur résultat. <code>interpret()</code> convertit cela en une chaîne et la montre à l&rsquo;utilisateur. Pour convertir une valeur Lox en chaîne, nous comptons sur :</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>isEqual</em>()</div>
<pre>  <span class="k">private</span> <span class="t">String</span> <span class="i">stringify</span>(<span class="t">Object</span> <span class="i">object</span>) {
    <span class="k">if</span> (<span class="i">object</span> == <span class="k">null</span>) <span class="k">return</span> <span class="s">&quot;nil&quot;</span>;

    <span class="k">if</span> (<span class="i">object</span> <span class="k">instanceof</span> <span class="t">Double</span>) {
      <span class="t">String</span> <span class="i">text</span> = <span class="i">object</span>.<span class="i">toString</span>();
      <span class="k">if</span> (<span class="i">text</span>.<span class="i">endsWith</span>(<span class="s">&quot;.0&quot;</span>)) {
        <span class="i">text</span> = <span class="i">text</span>.<span class="i">substring</span>(<span class="n">0</span>, <span class="i">text</span>.<span class="i">length</span>() - <span class="n">2</span>);
      }
      <span class="k">return</span> <span class="i">text</span>;
    }

    <span class="k">return</span> <span class="i">object</span>.<span class="i">toString</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>isEqual</em>()</div>

<p>C&rsquo;est une autre de ces pièces de code comme <code>isTruthy()</code> qui traverse la membrane entre la vue de l&rsquo;utilisateur des objets Lox et leur représentation interne en Java.</p>
<p>C&rsquo;est assez direct. Puisque Lox a été conçu pour être familier à quelqu&rsquo;un venant de Java, des choses comme les Booléens semblent identiques dans les deux langages. Les deux cas limites sont <code>nil</code>, que nous représentons en utilisant le <code>null</code> de Java, et les nombres.</p>
<p>Lox utilise des nombres à double précision même pour les valeurs entières. Dans ce cas, ils devraient s&rsquo;imprimer sans point décimal. Puisque Java a à la fois des types à virgule flottante et entiers, il veut que vous sachiez lequel vous utilisez. Il vous le dit en ajoutant un <code>.0</code> explicite aux doubles à valeur entière. Nous ne nous soucions pas de cela, donc nous le <span name="number">hachons</span> de la fin.</p>
<aside name="number">
<p>Encore une fois, nous prenons soin de ce cas limite avec les nombres pour nous assurer que jlox et clox fonctionnent de la même manière. Gérer des coins bizarres du langage comme celui-ci vous rendra fou mais est une partie importante du boulot.</p>
<p>Les utilisateurs comptent sur ces détails<span class="em">&mdash;</span>soit délibérément soit par inadvertance<span class="em">&mdash;</span>et si les implémentations ne sont pas cohérentes, leur programme cassera quand ils l&rsquo;exécuteront sur différents interpréteurs.</p>
</aside>
<h3><a href="#rapporter-les-erreurs-dexécution" id="rapporter-les-erreurs-dexécution"><small>7&#8202;.&#8202;4&#8202;.&#8202;1</small>Rapporter les erreurs d&rsquo;exécution</a></h3>
<p>Si une erreur d&rsquo;exécution est lancée pendant l&rsquo;évaluation de l&rsquo;expression, <code>interpret()</code> l&rsquo;attrape. Cela nous laisse rapporter l&rsquo;erreur à l&rsquo;utilisateur et ensuite continuer avec grâce. Tout notre code de rapport d&rsquo;erreur existant vit dans la classe Lox, donc nous mettons cette méthode là aussi :</p>
<div class="codehilite"><div class="source-file"><em>lox/Lox.java</em><br>
add after <em>error</em>()</div>
<pre>  <span class="k">static</span> <span class="t">void</span> <span class="i">runtimeError</span>(<span class="t">RuntimeError</span> <span class="i">error</span>) {
    <span class="t">System</span>.<span class="i">err</span>.<span class="i">println</span>(<span class="i">error</span>.<span class="i">getMessage</span>() +
        <span class="s">&quot;</span><span class="e">\n</span><span class="s">[line &quot;</span> + <span class="i">error</span>.<span class="i">token</span>.<span class="i">line</span> + <span class="s">&quot;]&quot;</span>);
    <span class="i">hadRuntimeError</span> = <span class="k">true</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, add after <em>error</em>()</div>

<p>Nous utilisons le token associé à la RuntimeError pour dire à l&rsquo;utilisateur quelle ligne de code s&rsquo;exécutait quand l&rsquo;erreur s&rsquo;est produite. Encore mieux serait de donner à l&rsquo;utilisateur une pile d&rsquo;appels entière pour montrer comment ils sont <em>arrivés</em> à exécuter ce code. Mais nous n&rsquo;avons pas encore d&rsquo;appels de fonction, donc je suppose que nous n&rsquo;avons pas à nous en soucier.</p>
<p>Après avoir montré l&rsquo;erreur, <code>runtimeError()</code> définit ce champ :</p>
<div class="codehilite"><pre class="insert-before">  static boolean hadError = false;
</pre><div class="source-file"><em>lox/Lox.java</em><br>
in class <em>Lox</em></div>
<pre class="insert">  <span class="k">static</span> <span class="t">boolean</span> <span class="i">hadRuntimeError</span> = <span class="k">false</span>;

</pre><pre class="insert-after">  public static void main(String[] args) throws IOException {
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in class <em>Lox</em></div>

<p>Ce champ joue un petit mais important rôle.</p>
<div class="codehilite"><pre class="insert-before">    run(new String(bytes, Charset.defaultCharset()));

    // Indicate an error in the exit code.
    if (hadError) System.exit(65);
</pre><div class="source-file"><em>lox/Lox.java</em><br>
in <em>runFile</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">hadRuntimeError</span>) <span class="t">System</span>.<span class="i">exit</span>(<span class="n">70</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>runFile</em>()</div>

<p>Si l&rsquo;utilisateur exécute un <span name="repl">script Lox depuis un fichier</span> et qu&rsquo;une erreur d&rsquo;exécution se produit, nous définissons un code de sortie quand le processus quitte pour le faire savoir au processus appelant. Tout le monde ne se soucie pas de l&rsquo;étiquette du shell, mais nous si.</p>
<aside name="repl">
<p>Si l&rsquo;utilisateur exécute le REPL, nous ne nous soucions pas de suivre les erreurs d&rsquo;exécution. Après qu&rsquo;elles soient rapportées, nous bouclons simplement et les laissons entrer du nouveau code et continuer.</p>
</aside>
<h3><a href="#exécuter-linterpréteur" id="exécuter-linterpréteur"><small>7&#8202;.&#8202;4&#8202;.&#8202;2</small>Exécuter l&rsquo;interpréteur</a></h3>
<p>Maintenant que nous avons un interpréteur, la classe Lox peut commencer à l&rsquo;utiliser.</p>
<div class="codehilite"><pre class="insert-before">public class Lox {
</pre><div class="source-file"><em>lox/Lox.java</em><br>
in class <em>Lox</em></div>
<pre class="insert">  <span class="k">private</span> <span class="k">static</span> <span class="k">final</span> <span class="t">Interpreter</span> <span class="i">interpreter</span> = <span class="k">new</span> <span class="t">Interpreter</span>();
</pre><pre class="insert-after">  static boolean hadError = false;
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in class <em>Lox</em></div>

<p>Nous rendons le champ statique afin que les appels successifs à <code>run()</code> à l&rsquo;intérieur d&rsquo;une session REPL réutilisent le même interpréteur. Cela ne fait pas de différence maintenant, mais cela en fera plus tard quand l&rsquo;interpréteur stockera des variables globales. Ces variables devraient persister tout au long de la session REPL.</p>
<p>Finalement, nous supprimons la ligne de code temporaire du <a href="parsing-expressions.html">dernier chapitre</a> pour imprimer l&rsquo;arbre syntaxique et la remplaçons par ceci :</p>
<div class="codehilite"><pre class="insert-before">    // Stop if there was a syntax error.
    if (hadError) return;

</pre><div class="source-file"><em>lox/Lox.java</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">interpreter</span>.<span class="i">interpret</span>(<span class="i">expression</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>run</em>(), replace 1 line</div>

<p>Nous avons un pipeline de langage entier maintenant : scan, parsing, et exécution. Félicitations, vous avez maintenant votre propre calculatrice arithmétique.</p>
<p>Comme vous pouvez le voir, l&rsquo;interpréteur est assez squelettique. Mais la classe Interpreter et le patron Visiteur que nous avons mis en place aujourd&rsquo;hui forment le squelette que les chapitres ultérieurs bourreront plein de tripes intéressantes<span class="em">&mdash;</span>variables, fonctions, etc. Pour l&rsquo;instant, l&rsquo;interpréteur ne fait pas grand chose, mais il est vivant !</p><img src="image/evaluating-expressions/skeleton.png" alt="Un squelette disant bonjour de la main." />
<div class="challenges">
<h2><a href="#défis" id="défis"><small>7&#8202;.&#8202;5</small>Défis</a></h2>
<ol>
<li>
<p>Permettre des comparaisons sur des types autres que les nombres pourrait être utile. Les opérateurs pourraient avoir une interprétation raisonnable pour les chaînes. Même les comparaisons parmi des types mixtes, comme <code>3 &lt; "pancake"</code> pourraient être pratiques pour permettre des choses comme des collections ordonnées de types hétérogènes. Ou cela pourrait simplement mener à des bugs et de la confusion.</p>
<p>Étenderiez-vous Lox pour supporter la comparaison d&rsquo;autres types ? Si oui, quelles paires de types autorisez-vous et comment définissez-vous leur ordre ? Justifiez vos choix et comparez-les à d&rsquo;autres langages.</p>
</li>
<li>
<p>Beaucoup de langages définissent <code>+</code> tel que si <em>l&rsquo;un ou l&rsquo;autre</em> des opérandes est une chaîne, l&rsquo;autre est converti en une chaîne et les résultats sont ensuite concaténés. Par exemple, <code>"scone" + 4</code> donnerait <code>scone4</code>. Étendez le code dans <code>visitBinaryExpr()</code> pour supporter cela.</p>
</li>
<li>
<p>Qu&rsquo;est-ce qui se passe pour l&rsquo;instant si vous divisez un nombre par zéro ? Que pensez-vous qu&rsquo;il devrait se passer ? Justifiez votre choix. Comment d&rsquo;autres langages que vous connaissez gèrent-ils la division par zéro, et pourquoi font-ils les choix qu&rsquo;ils font ?</p>
<p>Changez l&rsquo;implémentation dans <code>visitBinaryExpr()</code> pour détecter et rapporter une erreur d&rsquo;exécution pour ce cas.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--typage-statique-et-dynamique" id="note-de-conception--typage-statique-et-dynamique"><small>7&#8202;.&#8202;6</small>Note de Conception : Typage Statique et Dynamique</a></h2>
<p>Certains langages, comme Java, sont typés statiquement ce qui signifie que les erreurs de type sont détectées et rapportées au temps de compilation avant que le moindre code ne soit exécuté. D&rsquo;autres, comme Lox, sont typés dynamiquement et diffèrent la vérification des erreurs de type jusqu&rsquo;à l&rsquo;exécution juste avant qu&rsquo;une opération ne soit tentée. Nous avons tendance à considérer cela comme un choix noir ou blanc, mais il y a en fait un continuum entre eux.</p>
<p>Il s&rsquo;avère que même la plupart des langages typés statiquement font <em>quelques</em> vérifications de type à l&rsquo;exécution. Le système de type vérifie la plupart des règles de type statiquement, mais insère des vérifications à l&rsquo;exécution dans le code généré pour d&rsquo;autres opérations.</p>
<p>Par exemple, en Java, le système de type <em>statique</em> suppose qu&rsquo;une expression de cast réussira toujours en toute sécurité. Après avoir casté une valeur, vous pouvez statiquement la traiter comme le type de destination et ne pas obtenir d&rsquo;erreurs de compilation. Mais les downcasts peuvent échouer, évidemment. La seule raison pour laquelle le vérificateur statique peut présumer que les casts réussissent toujours sans violer les garanties de robustesse du langage, est parce que le cast est vérifié <em>à l&rsquo;exécution</em> et lance une exception en cas d&rsquo;échec.</p>
<p>Un exemple plus subtil est les <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Covariant_arrays_in_Java_and_C.23">tableaux covariants</a> en Java et C#. Les règles de sous-typage statique pour les tableaux autorisent des opérations qui ne sont pas sûres. Considérez :</p>
<div class="codehilite"><pre><span class="t">Object</span>[] <span class="i">stuff</span> = <span class="k">new</span> <span class="t">Integer</span>[<span class="n">1</span>];
<span class="i">stuff</span>[<span class="n">0</span>] = <span class="s">&quot;pas un int !&quot;</span>;
</pre></div>
<p>Ce code compile sans aucune erreur. La première ligne upcaste le tableau d&rsquo;Integer et le stocke dans une variable de type tableau d&rsquo;Object. La seconde ligne stocke une chaîne dans l&rsquo;une de ses cellules. Le type tableau d&rsquo;Object autorise statiquement cela<span class="em">&mdash;</span>les chaînes <em>sont</em> des Objects<span class="em">&mdash;</span>mais le tableau d&rsquo;Integer réel auquel <code>stuff</code> se réfère à l&rsquo;exécution ne devrait jamais avoir une chaîne dedans ! Pour éviter cette catastrophe, quand vous stockez une valeur dans un tableau, la JVM fait une vérification <em>à l&rsquo;exécution</em> pour s&rsquo;assurer que c&rsquo;est un type autorisé. Si non, elle lance une ArrayStoreException.</p>
<p>Java aurait pu éviter le besoin de vérifier cela à l&rsquo;exécution en interdisant le cast sur la première ligne. Il aurait pu rendre les tableaux <em>invariants</em> de telle sorte qu&rsquo;un tableau d&rsquo;Integers n&rsquo;est <em>pas</em> un tableau d&rsquo;Objects. C&rsquo;est statiquement sûr, mais cela interdit des patrons courants et sûrs de code qui lisent seulement depuis les tableaux. La covariance est sûre si vous n&rsquo;<em>écrivez</em> jamais dans le tableau. Ces patrons étaient particulièrement importants pour l&rsquo;utilisabilité dans Java 1.0 avant qu&rsquo;il ne supporte les génériques. James Gosling et les autres concepteurs de Java ont échangé un peu de sécurité statique et de performance<span class="em">&mdash;</span>ces vérifications de stockage de tableau prennent du temps<span class="em">&mdash;</span>en retour d&rsquo;un peu de flexibilité.</p>
<p>Il y a peu de langages typés statiquement modernes qui ne font pas ce compromis <em>quelque part</em>. Même Haskell vous laissera exécuter du code avec des correspondances non exhaustives. Si vous vous trouvez à concevoir un langage typé statiquement, gardez à l&rsquo;esprit que vous pouvez parfois donner aux utilisateurs plus de flexibilité sans sacrifier <em>trop</em> des bénéfices de la sécurité statique en différant certaines vérifications de type jusqu&rsquo;à l&rsquo;exécution.</p>
<p>D&rsquo;un autre côté, une raison clé pour laquelle les utilisateurs choisissent des langages typés statiquement est à cause de la confiance que le langage leur donne que certains types d&rsquo;erreurs ne peuvent <em>jamais</em> se produire quand leur programme est exécuté. Différez trop de vérifications de type jusqu&rsquo;à l&rsquo;exécution, et vous érodez cette confiance.</p>
</div>

<footer>
<a href="instructions-et-état.html" class="next">
  Next Chapter: &ldquo;Instructions et état&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
