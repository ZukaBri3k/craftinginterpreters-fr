<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Sauts avant et arrière &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Sauts avant et arrière<small>23</small></a></h3>

<ul>
    <li><a href="#instructions-if"><small>23.1</small> Instructions If</a></li>
    <li><a href="#opérateurs-logiques"><small>23.2</small> Opérateurs Logiques</a></li>
    <li><a href="#instructions-while"><small>23.3</small> Instructions While</a></li>
    <li><a href="#instructions-for"><small>23.4</small> Instructions For</a></li>
    <li><a href="#défis"><small>23.5</small> Défis</a></li>
    <li><a href="#note-de-conception--considérer-le-goto-nuisible"><small>23.6</small> Note de Conception : Considérer le Goto Nuisible</a></li>
</ul>


<div class="prev-next">
    <a href="variables-locales.html" title="Variables locales" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="appels-et-fonctions.html" title="Appels et fonctions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="variables-locales.html" title="Variables locales" class="prev">←</a>
<a href="appels-et-fonctions.html" title="Appels et fonctions" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Sauts avant et arrière<small>23</small></a></h3>

<ul>
    <li><a href="#instructions-if"><small>23.1</small> Instructions If</a></li>
    <li><a href="#opérateurs-logiques"><small>23.2</small> Opérateurs Logiques</a></li>
    <li><a href="#instructions-while"><small>23.3</small> Instructions While</a></li>
    <li><a href="#instructions-for"><small>23.4</small> Instructions For</a></li>
    <li><a href="#défis"><small>23.5</small> Défis</a></li>
    <li><a href="#note-de-conception--considérer-le-goto-nuisible"><small>23.6</small> Note de Conception : Considérer le Goto Nuisible</a></li>
</ul>


<div class="prev-next">
    <a href="variables-locales.html" title="Variables locales" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="appels-et-fonctions.html" title="Appels et fonctions" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">23</div>
  <h1>Sauts avant et arrière</h1>

<blockquote>
<p>L&rsquo;ordre que notre esprit imagine est comme un filet, ou comme une échelle, construit pour atteindre quelque chose. Mais après vous devez jeter l&rsquo;échelle, parce que vous découvrez que, même si c&rsquo;était utile, c&rsquo;était vide de sens.</p>
<p><cite>Umberto Eco, <em>Le Nom de la rose</em></cite></p>
</blockquote>
<p>Cela a pris un moment pour arriver ici, mais nous sommes enfin prêts à ajouter le contrôle de flux à notre machine virtuelle. Dans l&rsquo;interpréteur à parcours d&rsquo;arbre que nous avons construit pour jlox, nous avons implémenté le contrôle de flux de Lox en termes de celui de Java. Pour exécuter une instruction <code>if</code> Lox, nous avons utilisé une instruction <code>if</code> Java pour exécuter la branche choisie. Cela fonctionne, mais n&rsquo;est pas entièrement satisfaisant. Par quelle magie la <em>JVM elle-même</em> ou un CPU natif implémente-t-il les instructions <code>if</code> ? Maintenant que nous avons notre propre VM à bytecode à bricoler, nous pouvons répondre à cela.</p>
<p>Quand nous parlons de &ldquo;contrôle de flux&rdquo;, à quoi nous référons-nous ? Par &ldquo;flux&rdquo;, nous voulons dire la façon dont l&rsquo;exécution se déplace à travers le texte du programme. Presque comme s&rsquo;il y avait un petit robot à l&rsquo;intérieur de l&rsquo;ordinateur errant à travers notre code, exécutant des morceaux ici et là. Le flux est le chemin que ce robot prend, et en <em>contrôlant</em> le robot, nous pilotons quels morceaux de code il exécute.</p>
<p>Dans jlox, le lieu d&rsquo;attention du robot<span class="em">&mdash;</span>le morceau de code <em>courant</em><span class="em">&mdash;</span>était implicite basé sur quels nœuds AST étaient stockés dans diverses variables Java et quel code Java nous étions au milieu d&rsquo;exécuter. Dans clox, c&rsquo;est beaucoup plus explicite. Le champ <code>ip</code> de la VM stocke l&rsquo;adresse de l&rsquo;instruction bytecode courante. La valeur de ce champ est exactement &ldquo;où nous sommes&rdquo; dans le programme.</p>
<p>L&rsquo;exécution procède normalement en incrémentant le <code>ip</code>. Mais nous pouvons muter cette variable comme nous voulons. Afin d&rsquo;implémenter le contrôle de flux, tout ce qui est nécessaire est de changer le <code>ip</code> de façons plus intéressantes. La construction de contrôle de flux la plus simple est une instruction <code>if</code> sans clause <code>else</code> :</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">condition</span>) <span class="k">print</span>(<span class="s">&quot;condition was truthy&quot;</span>);
</pre></div>
<p>La VM évalue le bytecode pour l&rsquo;expression de condition. Si le résultat est &ldquo;truthy&rdquo; (vrai), alors elle continue et exécute l&rsquo;instruction <code>print</code> dans le corps. Le cas intéressant est quand la condition est &ldquo;falsey&rdquo; (fausse). Quand cela arrive, l&rsquo;exécution saute par-dessus la branche alors et procède à l&rsquo;instruction suivante.</p>
<p>Pour sauter par-dessus un morceau de code, nous réglons simplement le champ <code>ip</code> à l&rsquo;adresse de l&rsquo;instruction bytecode suivant ce code. Pour sauter <em>conditionnellement</em> par-dessus du code, nous avons besoin d&rsquo;une instruction qui regarde la valeur au sommet de la pile. Si elle est fausse, elle ajoute un décalage donné au <code>ip</code> pour sauter par-dessus une plage d&rsquo;instructions. Sinon, elle ne fait rien et laisse l&rsquo;exécution procéder à l&rsquo;instruction suivante comme d&rsquo;habitude.</p>
<p>Quand nous compilons vers du bytecode, la structure de bloc imbriquée explicite du code s&rsquo;évapore, laissant seulement une série plate d&rsquo;instructions derrière. Lox est un langage de <a href="https://fr.wikipedia.org/wiki/Programmation_structur%C3%A9e">programmation structurée</a>, mais le bytecode clox ne l&rsquo;est pas. Le bon<span class="em">&mdash;</span>ou mauvais, dépendant de comment vous le regardez<span class="em">&mdash;</span>ensemble d&rsquo;instructions bytecode pourrait sauter au milieu d&rsquo;un bloc, ou d&rsquo;une portée dans une autre.</p>
<p>La VM exécutera joyeusement cela, même si le résultat laisse la pile dans un état inconnu, incohérent. Donc même si le bytecode est non structuré, nous prendrons soin de nous assurer que notre compilateur génère seulement du code propre qui maintient la même structure et imbrication que Lox lui-même fait.</p>
<p>C&rsquo;est exactement comment les vrais CPUs se comportent. Même si nous pourrions les programmer utilisant des langages de plus haut niveau qui mandatent un contrôle de flux structuré, le compilateur abaisse cela à des sauts bruts. Au fond, il s&rsquo;avère que le goto est le seul vrai contrôle de flux.</p>
<p>De toute façon, je ne voulais pas devenir tout philosophique. Le morceau important est que si nous avons cette instruction de saut conditionnel, c&rsquo;est assez pour implémenter l&rsquo;instruction <code>if</code> de Lox, tant qu&rsquo;elle n&rsquo;a pas de clause <code>else</code>. Donc allons de l&rsquo;avant et commençons avec cela.</p>
<h2><a href="#instructions-if" id="instructions-if"><small>23&#8202;.&#8202;1</small>Instructions If</a></h2>
<p>Autant de chapitres dedans, vous connaissez la routine. Toute nouvelle fonctionnalité commence dans le front end et travaille son chemin à travers le pipeline. Une instruction <code>if</code> est, eh bien, une instruction, donc c&rsquo;est là où nous l&rsquo;accrochons dans l&rsquo;analyseur.</p>
<div class="codehilite"><pre class="insert-before">  if (match(TOKEN_PRINT)) {
    printStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_IF</span>)) {
    <span class="i">ifStatement</span>();
</pre><pre class="insert-after">  } else if (match(TOKEN_LEFT_BRACE)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>Quand nous voyons un mot-clé <code>if</code>, nous passons la main de la compilation à cette fonction :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expressionStatement</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">ifStatement</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;if&#39;.&quot;</span>);
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after condition.&quot;</span>);<span name="paren"> </span>

  <span class="t">int</span> <span class="i">thenJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);
  <span class="i">statement</span>();

  <span class="i">patchJump</span>(<span class="i">thenJump</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expressionStatement</em>()</div>

<aside name="paren">
<p>Avez-vous déjà remarqué que la <code>(</code> après le mot-clé <code>if</code> ne fait pas réellement quelque chose d&rsquo;utile ? Le langage serait tout aussi non ambigu et facile à analyser sans elle, comme :</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="i">condition</span>) <span class="k">print</span>(<span class="s">&quot;looks weird&quot;</span>);
</pre></div>
<p>La <code>)</code> fermante est utile parce qu&rsquo;elle sépare l&rsquo;expression de condition du corps. Certains langages utilisent un mot-clé <code>then</code> à la place. Mais la <code>(</code> ouvrante ne fait rien. Elle est juste là parce que les parenthèses non appariées semblent mauvaises pour nous humains.</p>
</aside>
<p>D&rsquo;abord nous compilons l&rsquo;expression de condition, encadrée par des parenthèses. À l&rsquo;exécution, cela laissera la valeur de condition au sommet de la pile. Nous utiliserons cela pour déterminer s&rsquo;il faut exécuter la branche alors ou la sauter.</p>
<p>Ensuite nous émettons une nouvelle instruction <code>OP_JUMP_IF_FALSE</code>. Elle a un opérande pour combien décaler le <code>ip</code><span class="em">&mdash;</span>combien d&rsquo;octets de code sauter. Si la condition est fausse, elle ajuste le <code>ip</code> par ce montant. Quelque chose comme ceci :</p>
<aside name="legend">
<p>Les boîtes avec les bords déchirés ici représentent le blob de bytecode généré en compilant quelque sous-clause d&rsquo;une construction de contrôle de flux. Donc la boîte &ldquo;expression de condition&rdquo; est toutes les instructions émises quand nous avons compilé cette expression.</p>
</aside>
<p><span name="legend"></span></p><img src="image/jumping-back-and-forth/if-without-else.png" alt="Organigramme du bytecode compilé d'une instruction if." />
<p>Mais nous avons un problème. Quand nous écrivons l&rsquo;opérande de l&rsquo;instruction <code>OP_JUMP_IF_FALSE</code>, comment savons-nous jusqu&rsquo;où sauter ? Nous n&rsquo;avons pas compilé la branche alors encore, donc nous ne savons pas combien de bytecode elle contient.</p>
<p>Pour réparer cela, nous utilisons un truc classique appelé <strong>backpatching</strong> (rétro-apiéçage). Nous émettons l&rsquo;instruction de saut d&rsquo;abord avec un opérande de décalage bouche-trou. Nous gardons la trace d&rsquo;où est cette instruction à moitié finie. Ensuite, nous compilons le corps alors. Une fois que c&rsquo;est fait, nous savons jusqu&rsquo;où sauter. Donc nous retournons en arrière et remplaçons ce décalage bouche-trou avec le vrai maintenant que nous pouvons le calculer. Sorte de comme coudre une pièce sur le tissu existant du code compilé.</p><img src="image/jumping-back-and-forth/patch.png" alt="Une pièce contenant un nombre étant cousue sur une feuille de bytecode." />
<p>Nous encodons ce truc dans deux fonctions d&rsquo;aide.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitBytes</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">emitJump</span>(<span class="t">uint8_t</span> <span class="i">instruction</span>) {
  <span class="i">emitByte</span>(<span class="i">instruction</span>);
  <span class="i">emitByte</span>(<span class="n">0xff</span>);
  <span class="i">emitByte</span>(<span class="n">0xff</span>);
  <span class="k">return</span> <span class="i">currentChunk</span>()-&gt;<span class="i">count</span> - <span class="n">2</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitBytes</em>()</div>

<p>La première émet une instruction bytecode et écrit un opérande bouche-trou pour le décalage de saut. Nous passons l&rsquo;opcode comme un argument parce que plus tard nous aurons deux instructions différentes qui utilisent cet assistant. Nous utilisons deux octets pour l&rsquo;opérande de décalage de saut. Un <span name="offset">décalage</span> de 16-bits nous laisse sauter par-dessus jusqu&rsquo;à 65 535 octets de code, ce qui devrait être plein pour nos besoins.</p>
<aside name="offset">
<p>Certains jeux d&rsquo;instructions ont des instructions de saut &ldquo;long&rdquo; séparées qui prennent de plus grands opérandes pour quand vous avez besoin de sauter une plus grande distance.</p>
</aside>
<p>La fonction renvoie le décalage de l&rsquo;instruction émise dans le chunk. Après avoir compilé la branche alors, nous prenons ce décalage et le passons à ceci :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">patchJump</span>(<span class="t">int</span> <span class="i">offset</span>) {
  <span class="c">// -2 to adjust for the bytecode for the jump offset itself.</span>
  <span class="t">int</span> <span class="i">jump</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span> - <span class="i">offset</span> - <span class="n">2</span>;

  <span class="k">if</span> (<span class="i">jump</span> &gt; <span class="a">UINT16_MAX</span>) {
    <span class="i">error</span>(<span class="s">&quot;Too much code to jump over.&quot;</span>);
  }

  <span class="i">currentChunk</span>()-&gt;<span class="i">code</span>[<span class="i">offset</span>] = (<span class="i">jump</span> &gt;&gt; <span class="n">8</span>) &amp; <span class="n">0xff</span>;
  <span class="i">currentChunk</span>()-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>] = <span class="i">jump</span> &amp; <span class="n">0xff</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitConstant</em>()</div>

<p>Ceci retourne dans le bytecode et remplace l&rsquo;opérande à l&rsquo;emplacement donné avec le décalage de saut calculé. Nous appelons <code>patchJump()</code> juste avant d&rsquo;émettre l&rsquo;instruction suivante sur laquelle nous voulons que le saut atterrisse, donc il utilise le compte de bytecode courant pour déterminer jusqu&rsquo;où sauter. Dans le cas d&rsquo;une instruction <code>if</code>, cela signifie juste après que nous compilons la branche alors et avant que nous compilions l&rsquo;instruction suivante.</p>
<p>C&rsquo;est tout ce dont nous avons besoin au moment de la compilation. Définissons la nouvelle instruction.</p>
<div class="codehilite"><pre class="insert-before">  OP_PRINT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_JUMP_IF_FALSE</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Là-bas dans la VM, nous la faisons fonctionner comme ceci :</p>
<div class="codehilite"><pre class="insert-before">        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_JUMP_IF_FALSE</span>: {
        <span class="t">uint16_t</span> <span class="i">offset</span> = <span class="a">READ_SHORT</span>();
        <span class="k">if</span> (<span class="i">isFalsey</span>(<span class="i">peek</span>(<span class="n">0</span>))) <span class="i">vm</span>.<span class="i">ip</span> += <span class="i">offset</span>;
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>C&rsquo;est la première instruction que nous avons ajoutée qui prend un opérande de 16-bits. Pour lire cela depuis le chunk, nous utilisons une nouvelle macro.</p>
<div class="codehilite"><pre class="insert-before">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#define READ_SHORT() \</span>
<span class="a">    (vm.ip += 2, (uint16_t)((vm.ip[-2] &lt;&lt; 8) | vm.ip[-1]))</span>
</pre><pre class="insert-after">#define READ_STRING() AS_STRING(READ_CONSTANT())
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Elle tire les deux prochains octets du chunk et construit un entier non signé de 16-bits hors d&rsquo;eux. Comme d&rsquo;habitude, nous nettoyons notre macro quand nous en avons fini avec elle.</p>
<div class="codehilite"><pre class="insert-before">#undef READ_BYTE
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#undef READ_SHORT</span>
</pre><pre class="insert-after">#undef READ_CONSTANT
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Après avoir lu le décalage, nous vérifions la valeur de condition au sommet de la pile. <span name="if">Si</span> elle est fausse, nous appliquons ce décalage de saut au <code>ip</code>. Sinon, nous laissons le <code>ip</code> seul et l&rsquo;exécution procédera automatiquement à l&rsquo;instruction suivante suivant l&rsquo;instruction de saut.</p>
<p>Dans le cas où la condition est fausse, nous n&rsquo;avons pas besoin de faire d&rsquo;autre travail. Nous avons décalé le <code>ip</code>, donc quand la boucle de répartition d&rsquo;instruction extérieure tourne encore, elle reprendra l&rsquo;exécution à cette nouvelle instruction, passé tout le code dans la branche alors.</p>
<aside name="if">
<p>J&rsquo;ai dit que nous n&rsquo;utiliserions pas l&rsquo;instruction <code>if</code> du C pour implémenter le contrôle de flux de Lox, mais nous en utilisons bien une ici pour déterminer si oui ou non décaler le pointeur d&rsquo;instruction. Mais nous n&rsquo;utilisons pas vraiment le C pour le <em>contrôle de flux</em>. Si nous voulions, nous pourrions faire la même chose purement arithmétiquement. Supposons que nous avons une fonction <code>falsey()</code> qui prend une Value Lox et renvoie 1 si elle est fausse ou 0 sinon. Alors nous pourrions implémenter l&rsquo;instruction de saut comme :</p>
<div class="codehilite"><pre><span class="k">case</span> <span class="a">OP_JUMP_IF_FALSE</span>: {
  <span class="t">uint16_t</span> <span class="i">offset</span> = <span class="a">READ_SHORT</span>();
  <span class="i">vm</span>.<span class="i">ip</span> += <span class="i">falsey</span>() * <span class="i">offset</span>;
  <span class="k">break</span>;
}
</pre></div>
<p>La fonction <code>falsey()</code> utiliserait probablement quelque contrôle de flux pour gérer les différents types de valeur, mais c&rsquo;est un détail d&rsquo;implémentation de cette fonction et n&rsquo;affecte pas comment notre VM fait son propre contrôle de flux.</p>
</aside>
<p>Notez que l&rsquo;instruction de saut ne dépile pas la valeur de condition de la pile. Donc nous n&rsquo;avons pas totalement fini ici, puisque cela laisse une valeur supplémentaire flottant sur la pile. Nous nettoierons cela bientôt. Ignorant cela pour le moment, nous avons bien une instruction <code>if</code> fonctionnelle dans Lox maintenant, avec seulement une petite instruction requise pour la supporter à l&rsquo;exécution dans la VM.</p>
<h3><a href="#clauses-else" id="clauses-else"><small>23&#8202;.&#8202;1&#8202;.&#8202;1</small>Clauses Else</a></h3>
<p>Une instruction <code>if</code> sans support pour les clauses <code>else</code> est comme Morticia Addams sans Gomez. Donc, après avoir compilé la branche alors, nous cherchons un mot-clé <code>else</code>. Si nous en trouvons un, nous compilons la branche sinon.</p>
<div class="codehilite"><pre class="insert-before">  patchJump(thenJump);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>ifStatement</em>()</div>
<pre class="insert">

  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_ELSE</span>)) <span class="i">statement</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>

<p>Quand la condition est fausse, nous sauterons par-dessus la branche alors. S&rsquo;il y a une branche sinon, le <code>ip</code> atterrira juste au début de son code. Mais ce n&rsquo;est pas suffisant, cependant. Voici le flux auquel cela mène :</p><img src="image/jumping-back-and-forth/bad-else.png" alt="Organigramme du bytecode compilé avec la branche alors tombant incorrectement à travers vers la branche sinon." />
<p>Si la condition est vraie, nous exécutons la branche alors comme nous voulons. Mais après cela, l&rsquo;exécution roule droit à travers dans la branche sinon. Oups ! Quand la condition est vraie, après avoir exécuté la branche alors, nous avons besoin de sauter par-dessus la branche sinon. De cette façon, dans l&rsquo;un ou l&rsquo;autre cas, nous exécutons seulement une seule branche, comme ceci :</p><img src="image/jumping-back-and-forth/if-else.png" alt="Organigramme du bytecode compilé pour un if avec une clause else." />
<p>Pour implémenter cela, nous avons besoin d&rsquo;un autre saut depuis la fin de la branche alors.</p>
<div class="codehilite"><pre class="insert-before">  statement();

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>ifStatement</em>()</div>
<pre class="insert">  <span class="t">int</span> <span class="i">elseJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP</span>);

</pre><pre class="insert-after">  patchJump(thenJump);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>

<p>Nous patchons ce décalage après la fin du corps du sinon.</p>
<div class="codehilite"><pre class="insert-before">  if (match(TOKEN_ELSE)) statement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>ifStatement</em>()</div>
<pre class="insert">  <span class="i">patchJump</span>(<span class="i">elseJump</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>

<p>Après l&rsquo;exécution de la branche alors, ceci saute à l&rsquo;instruction suivante après la branche sinon. Contrairement à l&rsquo;autre saut, ce saut est inconditionnel. Nous le prenons toujours, donc nous avons besoin d&rsquo;une autre instruction qui exprime cela.</p>
<div class="codehilite"><pre class="insert-before">  OP_PRINT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_JUMP</span>,
</pre><pre class="insert-after">  OP_JUMP_IF_FALSE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Nous l&rsquo;interprétons comme ceci :</p>
<div class="codehilite"><pre class="insert-before">        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_JUMP</span>: {
        <span class="t">uint16_t</span> <span class="i">offset</span> = <span class="a">READ_SHORT</span>();
        <span class="i">vm</span>.<span class="i">ip</span> += <span class="i">offset</span>;
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_JUMP_IF_FALSE: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Rien de trop surprenant ici<span class="em">&mdash;</span>la seule différence est qu&rsquo;elle ne vérifie pas une condition et applique toujours le décalage.</p>
<p>Nous avons les branches alors et sinon fonctionnant maintenant, donc nous sommes proches. Le dernier morceau est de nettoyer cette valeur de condition que nous avons laissée sur la pile. Rappelez-vous, chaque instruction est requise d&rsquo;avoir un effet de pile nul<span class="em">&mdash;</span>après que l&rsquo;instruction est finie d&rsquo;exécuter, la pile devrait être aussi haute qu&rsquo;elle l&rsquo;était avant.</p>
<p>Nous pourrions faire que l&rsquo;instruction <code>OP_JUMP_IF_FALSE</code> dépile la condition elle-même, mais bientôt nous utiliserons cette même instruction pour les opérateurs logiques où nous ne voulons pas que la condition soit dépilée. Au lieu de cela, nous ferons que le compilateur émette une couple d&rsquo;instructions <code>OP_POP</code> explicites lors de la compilation d&rsquo;une instruction <code>if</code>. Nous avons besoin de prendre soin que chaque chemin d&rsquo;exécution à travers le code généré dépile la condition.</p>
<p>Quand la condition est vraie, nous la dépilons juste avant le code à l&rsquo;intérieur de la branche alors.</p>
<div class="codehilite"><pre class="insert-before">  int thenJump = emitJump(OP_JUMP_IF_FALSE);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>ifStatement</em>()</div>
<pre class="insert">  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
</pre><pre class="insert-after">  statement();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>

<p>Sinon, nous la dépilons au début de la branche sinon.</p>
<div class="codehilite"><pre class="insert-before">  patchJump(thenJump);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>ifStatement</em>()</div>
<pre class="insert">  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
</pre><pre class="insert-after">

  if (match(TOKEN_ELSE)) statement();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>

<p>Cette petite instruction ici signifie aussi que chaque instruction <code>if</code> a une branche sinon implicite même si l&rsquo;utilisateur n&rsquo;a pas écrit une clause <code>else</code>. Dans le cas où ils l&rsquo;ont laissée de côté, tout ce que la branche fait est de jeter la valeur de condition.</p>
<p>Le flux correct complet ressemble à ceci :</p><img src="image/jumping-back-and-forth/full-if-else.png" alt="Organigramme du bytecode compilé incluant les instructions pop nécessaires." />
<p>Si vous tracez à travers, vous pouvez voir qu&rsquo;il exécute toujours une seule branche et assure que la condition est dépilée d&rsquo;abord. Tout ce qui reste est un peu de support de désassembleur.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_PRINT&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_JUMP</span>:
      <span class="k">return</span> <span class="i">jumpInstruction</span>(<span class="s">&quot;OP_JUMP&quot;</span>, <span class="n">1</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_JUMP_IF_FALSE</span>:
      <span class="k">return</span> <span class="i">jumpInstruction</span>(<span class="s">&quot;OP_JUMP_IF_FALSE&quot;</span>, <span class="n">1</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Ces deux instructions ont un nouveau format avec un opérande de 16-bits, donc nous ajoutons une nouvelle fonction utilitaire pour les désassembler.</p>
<div class="codehilite"><div class="source-file"><em>debug.c</em><br>
add after <em>byteInstruction</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">jumpInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">int</span> <span class="i">sign</span>,
                           <span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">int</span> <span class="i">offset</span>) {
  <span class="t">uint16_t</span> <span class="i">jump</span> = (<span class="t">uint16_t</span>)(<span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>] &lt;&lt; <span class="n">8</span>);
  <span class="i">jump</span> |= <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">2</span>];
  <span class="i">printf</span>(<span class="s">&quot;%-16s %4d -&gt; %d</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">name</span>, <span class="i">offset</span>,
         <span class="i">offset</span> + <span class="n">3</span> + <span class="i">sign</span> * <span class="i">jump</span>);
  <span class="k">return</span> <span class="i">offset</span> + <span class="n">3</span>;
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>byteInstruction</em>()</div>

<p>Et voilà, c&rsquo;est une construction de contrôle de flux complète. Si c&rsquo;était un film des années 80, la musique de montage démarrerait et le reste de la syntaxe de contrôle de flux prendrait soin de lui-même. Hélas, les <span name="80s">années 80</span> sont depuis longtemps finies, donc nous aurons à le broyer nous-mêmes.</p>
<aside name="80s">
<p>Mon amour durable de Depeche Mode nonobstant.</p>
</aside>
## Opérateurs Logiques
<p>Vous vous souvenez probablement de cela de jlox, mais les opérateurs logiques <code>and</code> et <code>or</code> ne sont pas juste une autre paire d&rsquo;opérateurs binaires comme <code>+</code> et <code>-</code>. Parce qu&rsquo;ils court-circuitent et peuvent ne pas évaluer leur opérande droit dépendant de la valeur de celui de gauche, ils fonctionnent plus comme des expressions de contrôle de flux.</p>
<p>Ils sont fondamentalement une petite variation sur une instruction <code>if</code> avec une clause <code>else</code>. La façon la plus facile de les expliquer est de juste vous montrer le code du compilateur et le contrôle de flux qu&rsquo;il produit dans le bytecode résultant. Commençant avec <code>and</code>, nous l&rsquo;accrochons dans la table d&rsquo;analyse d&rsquo;expression ici :</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_NUMBER]        = {number,   NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_AND</span>]           = {<span class="a">NULL</span>,     <span class="i">and_</span>,   <span class="a">PREC_AND</span>},
</pre><pre class="insert-after">  [TOKEN_CLASS]         = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Cela passe la main à une nouvelle fonction d&rsquo;analyseur.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>defineVariable</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">and_</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="t">int</span> <span class="i">endJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);

  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
  <span class="i">parsePrecedence</span>(<span class="a">PREC_AND</span>);

  <span class="i">patchJump</span>(<span class="i">endJump</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>defineVariable</em>()</div>

<p>Au point que ceci est appelé, l&rsquo;expression du côté gauche a déjà été compilée. Cela signifie qu&rsquo;à l&rsquo;exécution, sa valeur sera au sommet de la pile. Si cette valeur est fausse, alors nous savons que le <code>and</code> entier doit être faux, donc nous sautons l&rsquo;opérande droit et laissons la valeur du côté gauche comme le résultat de l&rsquo;expression entière. Sinon, nous jetons la valeur de gauche et évaluons l&rsquo;opérande droit qui devient le résultat du <code>and</code> entier.</p>
<p>Ces quatre lignes de code juste là produisent exactement cela. Le flux ressemble à ceci :</p><img src="image/jumping-back-and-forth/and.png" alt="Organigramme du bytecode compilé d'une expression 'and'." />
<p>Maintenant vous pouvez voir pourquoi <code>OP_JUMP_IF_FALSE</code> <span name="instr">laisse</span> la valeur au sommet de la pile. Quand le côté gauche du <code>and</code> est faux, cette valeur traîne pour devenir le résultat de l&rsquo;expression entière.</p>
<aside name="instr">
<p>Nous avons plein d&rsquo;espace laissé dans notre plage d&rsquo;opcode, donc nous pourrions avoir des instructions séparées pour les sauts conditionnels qui dépilent implicitement et ceux qui ne le font pas, je suppose. Mais j&rsquo;essaie de garder les choses minimales pour le livre. Dans votre VM à bytecode, cela vaut la peine d&rsquo;explorer l&rsquo;ajout d&rsquo;instructions plus spécialisées et voir comment elles affectent la performance.</p>
</aside>
<h3><a href="#opérateur-logique-or" id="opérateur-logique-or"><small>23&#8202;.&#8202;2&#8202;.&#8202;1</small>Opérateur logique or</a></h3>
<p>L&rsquo;opérateur <code>or</code> est un peu plus complexe. D&rsquo;abord nous l&rsquo;ajoutons à la table d&rsquo;analyse.</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_NIL]           = {literal,  NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_OR</span>]            = {<span class="a">NULL</span>,     <span class="i">or_</span>,    <span class="a">PREC_OR</span>},
</pre><pre class="insert-after">  [TOKEN_PRINT]         = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Quand cet analyseur consomme un jeton infixe <code>or</code>, il appelle ceci :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>number</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">or_</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="t">int</span> <span class="i">elseJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);
  <span class="t">int</span> <span class="i">endJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP</span>);

  <span class="i">patchJump</span>(<span class="i">elseJump</span>);
  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);

  <span class="i">parsePrecedence</span>(<span class="a">PREC_OR</span>);
  <span class="i">patchJump</span>(<span class="i">endJump</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>number</em>()</div>

<p>Dans une expression <code>or</code>, si le côté gauche est <em>vrai</em>, alors nous sautons par-dessus l&rsquo;opérande droit. Ainsi nous avons besoin de sauter quand une valeur est vraie. Nous pourrions ajouter une instruction séparée, mais juste pour montrer comment notre compilateur est libre de mapper la sémantique du langage à n&rsquo;importe quelle séquence d&rsquo;instruction qu&rsquo;il veut, je l&rsquo;ai implémenté en termes des instructions de saut que nous avons déjà.</p>
<p>Quand le côté gauche est faux, il fait un minuscule saut par-dessus l&rsquo;instruction suivante. Cette instruction est un saut inconditionnel par-dessus le code pour l&rsquo;opérande droit. Cette petite danse fait effectivement un saut quand la valeur est vraie. Le flux ressemble à ceci :</p><img src="image/jumping-back-and-forth/or.png" alt="Organigramme du bytecode compilé d'une expression logique or." />
<p>Si je suis honnête avec vous, ce n&rsquo;est pas la meilleure façon de faire cela. Il y a plus d&rsquo;instructions à répartir et plus de surcoût. Il n&rsquo;y a aucune bonne raison pourquoi <code>or</code> devrait être plus lent que <code>and</code>. Mais c&rsquo;est une sorte d&rsquo;amusement de voir qu&rsquo;il est possible d&rsquo;implémenter les deux opérateurs sans ajouter aucune nouvelle instruction. Pardonnez-moi mes indulgences.</p>
<p>OK, ce sont les trois constructions de <em>branchement</em> dans Lox. Par là, je veux dire, ce sont les fonctionnalités de contrôle de flux qui sautent seulement en <em>avant</em> par-dessus du code. D&rsquo;autres langages ont souvent quelque sorte d&rsquo;instruction de branchement multi-voie comme <code>switch</code> et peut-être une expression conditionnelle comme <code>?:</code>, mais Lox garde ça simple.</p>
<h2><a href="#instructions-while" id="instructions-while"><small>23&#8202;.&#8202;3</small>Instructions While</a></h2>
<p>Cela nous amène aux instructions de <em>boucle</em>, qui sautent en <em>arrière</em> pour que le code puisse être exécuté plus d&rsquo;une fois. Lox a seulement deux constructions de boucle, <code>while</code> et <code>for</code>. Une boucle <code>while</code> est (beaucoup) plus simple, donc nous commençons la fête là.</p>
<div class="codehilite"><pre class="insert-before">    ifStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_WHILE</span>)) {
    <span class="i">whileStatement</span>();
</pre><pre class="insert-after">  } else if (match(TOKEN_LEFT_BRACE)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>Quand nous atteignons un jeton <code>while</code>, nous appelons :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>printStatement</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">whileStatement</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;while&#39;.&quot;</span>);
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after condition.&quot;</span>);

  <span class="t">int</span> <span class="i">exitJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);
  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
  <span class="i">statement</span>();

  <span class="i">patchJump</span>(<span class="i">exitJump</span>);
  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>printStatement</em>()</div>

<p>La plupart de ceci reflète les instructions <code>if</code><span class="em">&mdash;</span>nous compilons l&rsquo;expression de condition, entourée par des parenthèses obligatoires. C&rsquo;est suivi par une instruction de saut qui saute par-dessus l&rsquo;instruction de corps subséquente si la condition est fausse.</p>
<p>Nous patchons le saut après la compilation du corps et prenons soin de <span name="pop">dépiler</span> la valeur de condition de la pile sur l&rsquo;un ou l&rsquo;autre chemin. La seule différence d&rsquo;une instruction <code>if</code> est la boucle. Cela ressemble à ceci :</p>
<aside name="pop">
<p>Je commence vraiment à remettre en question ma décision d&rsquo;utiliser les mêmes instructions de saut pour les opérateurs logiques.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  statement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>whileStatement</em>()</div>
<pre class="insert">  <span class="i">emitLoop</span>(<span class="i">loopStart</span>);
</pre><pre class="insert-after">

  patchJump(exitJump);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>whileStatement</em>()</div>

<p>Après le corps, nous appelons cette fonction pour émettre une instruction &ldquo;loop&rdquo; (boucle). Cette instruction a besoin de savoir jusqu&rsquo;où sauter en arrière. Lors du saut en avant, nous devions émettre l&rsquo;instruction en deux étapes puisque nous ne savions pas jusqu&rsquo;où nous allions sauter jusqu&rsquo;à après que nous ayons émis l&rsquo;instruction de saut. Nous n&rsquo;avons pas ce problème maintenant. Nous avons déjà compilé le point dans le code auquel nous voulons sauter en arrière<span class="em">&mdash;</span>c&rsquo;est juste avant l&rsquo;expression de condition.</p>
<p>Tout ce que nous avons besoin de faire est de capturer cet emplacement alors que nous le compilons.</p>
<div class="codehilite"><pre class="insert-before">static void whileStatement() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>whileStatement</em>()</div>
<pre class="insert">  <span class="t">int</span> <span class="i">loopStart</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span>;
</pre><pre class="insert-after">  consume(TOKEN_LEFT_PAREN, &quot;Expect '(' after 'while'.&quot;);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>whileStatement</em>()</div>

<p>Après avoir exécuté le corps d&rsquo;une boucle <code>while</code>, nous sautons tout le chemin en arrière à avant la condition. De cette façon, nous réévaluons l&rsquo;expression de condition à chaque itération. Nous stockons le compte d&rsquo;instruction courant du chunk dans <code>loopStart</code> pour enregistrer le décalage dans le bytecode juste avant l&rsquo;expression de condition que nous sommes sur le point de compiler. Ensuite nous passons cela dans cette fonction d&rsquo;aide :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitBytes</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">emitLoop</span>(<span class="t">int</span> <span class="i">loopStart</span>) {
  <span class="i">emitByte</span>(<span class="a">OP_LOOP</span>);

  <span class="t">int</span> <span class="i">offset</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span> - <span class="i">loopStart</span> + <span class="n">2</span>;
  <span class="k">if</span> (<span class="i">offset</span> &gt; <span class="a">UINT16_MAX</span>) <span class="i">error</span>(<span class="s">&quot;Loop body too large.&quot;</span>);

  <span class="i">emitByte</span>((<span class="i">offset</span> &gt;&gt; <span class="n">8</span>) &amp; <span class="n">0xff</span>);
  <span class="i">emitByte</span>(<span class="i">offset</span> &amp; <span class="n">0xff</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitBytes</em>()</div>

<p>C&rsquo;est un peu comme <code>emitJump()</code> et <code>patchJump()</code> combinés. Elle émet une nouvelle instruction de boucle, qui saute inconditionnellement en <em>arrière</em> par un décalage donné. Comme les instructions de saut, après cela nous avons un opérande de 16-bits. Nous calculons le décalage depuis l&rsquo;instruction à laquelle nous sommes actuellement vers le point <code>loopStart</code> auquel nous voulons sauter en arrière. Le <code>+ 2</code> est pour prendre en compte la taille des propres opérandes de l&rsquo;instruction <code>OP_LOOP</code> que nous avons aussi besoin de sauter par-dessus.</p>
<p>De la perspective de la VM, il n&rsquo;y a vraiment aucune différence sémantique entre <code>OP_LOOP</code> et <code>OP_JUMP</code>. Toutes deux ajoutent juste un décalage au <code>ip</code>. Nous aurions pu utiliser une seule instruction pour les deux et lui donner un opérande de décalage signé. Mais je me suis figuré que c&rsquo;était un peu plus facile d&rsquo;éviter le triturage de bits ennuyeux requis pour empaqueter manuellement un entier signé de 16-bits dans deux octets, et nous avons l&rsquo;espace d&rsquo;opcode disponible, alors pourquoi ne pas l&rsquo;utiliser ?</p>
<p>La nouvelle instruction est ici :</p>
<div class="codehilite"><pre class="insert-before">  OP_JUMP_IF_FALSE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_LOOP</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Et dans la VM, nous l&rsquo;implémentons ainsi :</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_LOOP</span>: {
        <span class="t">uint16_t</span> <span class="i">offset</span> = <span class="a">READ_SHORT</span>();
        <span class="i">vm</span>.<span class="i">ip</span> -= <span class="i">offset</span>;
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>La seule différence de <code>OP_JUMP</code> est une soustraction au lieu d&rsquo;une addition. Le désassemblage est similaire aussi.</p>
<div class="codehilite"><pre class="insert-before">      return jumpInstruction(&quot;OP_JUMP_IF_FALSE&quot;, 1, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_LOOP</span>:
      <span class="k">return</span> <span class="i">jumpInstruction</span>(<span class="s">&quot;OP_LOOP&quot;</span>, -<span class="n">1</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>C&rsquo;est notre instruction <code>while</code>. Elle contient deux sauts<span class="em">&mdash;</span>un conditionnel en avant pour échapper à la boucle quand la condition n&rsquo;est pas remplie, et une boucle inconditionnelle en arrière après que nous avons exécuté le corps. Le flux ressemble à ceci :</p><img src="image/jumping-back-and-forth/while.png" alt="Organigramme du bytecode compilé d'une instruction while." />
<h2><a href="#instructions-for" id="instructions-for"><small>23&#8202;.&#8202;4</small>Instructions For</a></h2>
<p>L&rsquo;autre instruction de boucle dans Lox est la vénérable boucle <code>for</code>, héritée du C. Elle a beaucoup plus de choses qui se passent avec elle comparée à une boucle <code>while</code>. Elle a trois clauses, qui sont toutes optionnelles :</p>
<p><span name="detail"></span></p>
<ul>
<li>
<p>L&rsquo;initialisateur peut être une déclaration de variable ou une expression. Il s&rsquo;exécute une fois au début de l&rsquo;instruction.</p>
</li>
<li>
<p>La clause de condition est une expression. Comme dans une boucle <code>while</code>, nous sortons de la boucle quand elle évalue à quelque chose de faux.</p>
</li>
<li>
<p>L&rsquo;expression d&rsquo;incrément s&rsquo;exécute une fois à la fin de chaque itération de boucle.</p>
</li>
</ul>
<aside name="detail">
<p>Si vous voulez un rafraîchissement, le chapitre correspondant dans la partie II parcourt la sémantique <a href="contrôle-de-flux.html#boucles-for">plus en détail</a>.</p>
</aside>
<p>Dans jlox, l&rsquo;analyseur dé-sucre une boucle <code>for</code> en un AST synthétisé pour une boucle <code>while</code> avec quelques trucs extra avant elle et à la fin du corps. Nous ferons quelque chose de similaire, bien que nous ne passerons par rien comme un AST. Au lieu de cela, notre compilateur de bytecode utilisera les instructions de saut et de boucle que nous avons déjà.</p>
<p>Nous travaillerons notre chemin à travers l&rsquo;implémentation un morceau à la fois, commençant avec le mot-clé <code>for</code>.</p>
<div class="codehilite"><pre class="insert-before">    printStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_FOR</span>)) {
    <span class="i">forStatement</span>();
</pre><pre class="insert-after">  } else if (match(TOKEN_IF)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>Elle appelle une fonction d&rsquo;aide. Si nous supportions seulement les boucles <code>for</code> avec des clauses vides comme <code>for (;;)</code>, alors nous pourrions l&rsquo;implémenter comme ceci :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expressionStatement</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">forStatement</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;for&#39;.&quot;</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39;.&quot;</span>);

  <span class="t">int</span> <span class="i">loopStart</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span>;
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39;.&quot;</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after for clauses.&quot;</span>);

  <span class="i">statement</span>();
  <span class="i">emitLoop</span>(<span class="i">loopStart</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expressionStatement</em>()</div>

<p>Il y a un tas de ponctuation obligatoire au sommet. Ensuite nous compilons le corps. Comme nous avons fait pour les boucles <code>while</code>, nous enregistrons le décalage bytecode au sommet du corps et émettons une boucle pour sauter en arrière à ce point après lui. Nous avons une implémentation fonctionnelle de boucles <span name="infinite">infinies</span> maintenant.</p>
<aside name="infinite">
<p>Hélas, sans instructions <code>return</code>, il n&rsquo;y a aucun moyen de la terminer à moins d&rsquo;une erreur d&rsquo;exécution.</p>
</aside>
<h3><a href="#clause-dinitialisateur" id="clause-dinitialisateur"><small>23&#8202;.&#8202;4&#8202;.&#8202;1</small>Clause d&rsquo;initialisateur</a></h3>
<p>Maintenant nous ajouterons la première clause, l&rsquo;initialisateur. Elle s&rsquo;exécute seulement une fois, avant le corps, donc compiler est direct.</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_LEFT_PAREN, &quot;Expect '(' after 'for'.&quot;);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>forStatement</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_SEMICOLON</span>)) {
    <span class="c">// No initializer.</span>
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_VAR</span>)) {
    <span class="i">varDeclaration</span>();
  } <span class="k">else</span> {
    <span class="i">expressionStatement</span>();
  }
</pre><pre class="insert-after">

  int loopStart = currentChunk()-&gt;count;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>(), replace 1 line</div>

<p>La syntaxe est un peu complexe puisque nous permettons soit une déclaration de variable soit une expression. Nous utilisons la présence du mot-clé <code>var</code> pour dire laquelle nous avons. Pour le cas de l&rsquo;expression, nous appelons <code>expressionStatement()</code> au lieu de <code>expression()</code>. Cela cherche un point-virgule, dont nous avons besoin ici aussi, et émet aussi une instruction <code>OP_POP</code> pour jeter la valeur. Nous ne voulons pas que l&rsquo;initialisateur laisse quoi que ce soit sur la pile.</p>
<p>Si une instruction <code>for</code> déclare une variable, cette variable devrait être portée au corps de la boucle. Nous assurons cela en enveloppant l&rsquo;instruction entière dans une portée.</p>
<div class="codehilite"><pre class="insert-before">static void forStatement() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">  <span class="i">beginScope</span>();
</pre><pre class="insert-after">  consume(TOKEN_LEFT_PAREN, &quot;Expect '(' after 'for'.&quot;);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>()</div>

<p>Ensuite nous la fermons à la fin.</p>
<div class="codehilite"><pre class="insert-before">  emitLoop(loopStart);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">  <span class="i">endScope</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>()</div>

<h3><a href="#clause-de-condition" id="clause-de-condition"><small>23&#8202;.&#8202;4&#8202;.&#8202;2</small>Clause de condition</a></h3>
<p>Suivant, est l&rsquo;expression de condition qui peut être utilisée pour sortir de la boucle.</p>
<div class="codehilite"><pre class="insert-before">  int loopStart = currentChunk()-&gt;count;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>forStatement</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">int</span> <span class="i">exitJump</span> = -<span class="n">1</span>;
  <span class="k">if</span> (!<span class="i">match</span>(<span class="a">TOKEN_SEMICOLON</span>)) {
    <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after loop condition.&quot;</span>);

    <span class="c">// Jump out of the loop if the condition is false.</span>
    <span class="i">exitJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>); <span class="c">// Condition.</span>
  }

</pre><pre class="insert-after">  consume(TOKEN_RIGHT_PAREN, &quot;Expect ')' after for clauses.&quot;);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>(), replace 1 line</div>

<p>Puisque la clause est optionnelle, nous avons besoin de voir si elle est réellement présente. Si la clause est omise, le jeton suivant doit être un point-virgule, donc nous cherchons cela pour dire. S&rsquo;il n&rsquo;y a pas de point-virgule, il doit y avoir une expression de condition.</p>
<p>Dans ce cas, nous la compilons. Ensuite, juste comme avec while, nous émettons un saut conditionnel qui sort de la boucle si la condition est fausse. Puisque le saut laisse la valeur sur la pile, nous la dépilons avant d&rsquo;exécuter le corps. Cela assure que nous jetons la valeur quand la condition est vraie.</p>
<p>Après le corps de la boucle, nous avons besoin de patcher ce saut.</p>
<div class="codehilite"><pre class="insert-before">  emitLoop(loopStart);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">

  <span class="k">if</span> (<span class="i">exitJump</span> != -<span class="n">1</span>) {
    <span class="i">patchJump</span>(<span class="i">exitJump</span>);
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>); <span class="c">// Condition.</span>
  }

</pre><pre class="insert-after">  endScope();
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>()</div>

<p>Nous faisons cela seulement quand il y a une clause de condition. S&rsquo;il n&rsquo;y en a pas, il n&rsquo;y a pas de saut à patcher et pas de valeur de condition sur la pile à dépiler.</p>
<h3><a href="#clause-dincrément" id="clause-dincrément"><small>23&#8202;.&#8202;4&#8202;.&#8202;3</small>Clause d&rsquo;incrément</a></h3>
<p>J&rsquo;ai gardé le meilleur pour la fin, la clause d&rsquo;incrément. C&rsquo;est assez alambiqué. Elle apparaît textuellement avant le corps, mais s&rsquo;exécute <em>après</em> lui. Si nous analysions vers un AST et générions du code dans une passe séparée, nous pourrions simplement traverser dans et compiler le champ corps de l&rsquo;AST de l&rsquo;instruction <code>for</code> avant sa clause d&rsquo;incrément.</p>
<p>Malheureusement, nous ne pouvons pas compiler la clause d&rsquo;incrément plus tard, puisque notre compilateur fait seulement une seule passe sur le code. Au lieu de cela, nous <em>sauterons par-dessus</em> l&rsquo;incrément, exécuterons le corps, sauterons <em>en arrière</em> jusqu&rsquo;à l&rsquo;incrément, l&rsquo;exécuterons, et ensuite irons à la prochaine itération.</p>
<p>Je sais, un peu bizarre, mais hey, cela bat la gestion manuelle d&rsquo;ASTs en mémoire en C, non ? Voici le code :</p>
<div class="codehilite"><pre class="insert-before">  }

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>forStatement</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (!<span class="i">match</span>(<span class="a">TOKEN_RIGHT_PAREN</span>)) {
    <span class="t">int</span> <span class="i">bodyJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP</span>);
    <span class="t">int</span> <span class="i">incrementStart</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span>;
    <span class="i">expression</span>();
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
    <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after for clauses.&quot;</span>);

    <span class="i">emitLoop</span>(<span class="i">loopStart</span>);
    <span class="i">loopStart</span> = <span class="i">incrementStart</span>;
    <span class="i">patchJump</span>(<span class="i">bodyJump</span>);
  }
</pre><pre class="insert-after">

  statement();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>(), replace 1 line</div>

<p>Encore, c&rsquo;est optionnel. Puisque c&rsquo;est la dernière clause, quand omise, le jeton suivant sera la parenthèse fermante. Quand un incrément est présent, nous avons besoin de le compiler maintenant, mais il ne devrait pas s&rsquo;exécuter encore. Donc, d&rsquo;abord, nous émettons un saut inconditionnel qui saute par-dessus le code de la clause d&rsquo;incrément vers le corps de la boucle.</p>
<p>Ensuite, nous compilons l&rsquo;expression d&rsquo;incrément elle-même. C&rsquo;est habituellement une assignation. Quoi que ce soit, nous l&rsquo;exécutons seulement pour son effet de bord, donc nous émettons aussi un pop pour jeter sa valeur.</p>
<p>La dernière partie est un peu délicate. D&rsquo;abord, nous émettons une instruction de boucle. C&rsquo;est la boucle principale qui nous ramène au sommet de la boucle <code>for</code><span class="em">&mdash;</span>juste avant l&rsquo;expression de condition s&rsquo;il y en a une. Cette boucle arrive juste après l&rsquo;incrément, puisque l&rsquo;incrément s&rsquo;exécute à la fin de chaque itération de boucle.</p>
<p>Ensuite nous changeons <code>loopStart</code> pour pointer vers le décalage où l&rsquo;expression d&rsquo;incrément commence. Plus tard, quand nous émettons l&rsquo;instruction de boucle après l&rsquo;instruction de corps, cela causera qu&rsquo;elle saute jusqu&rsquo;à l&rsquo;expression d&rsquo;<em>incrément</em> au lieu du sommet de la boucle comme elle fait quand il n&rsquo;y a pas d&rsquo;incrément. C&rsquo;est comme cela que nous tissons l&rsquo;incrément dedans pour tourner après le corps.</p>
<p>C&rsquo;est alambiqué, mais tout s&rsquo;arrange. Une boucle complète avec toutes les clauses compile vers un flux comme ceci :</p><img src="image/jumping-back-and-forth/for.png" alt="Organigramme du bytecode compilé d'une instruction for." />
<p>Comme avec l&rsquo;implémentation des boucles <code>for</code> dans jlox, nous n&rsquo;avons pas eu besoin de toucher au runtime. Tout se fait compiler vers des opérations de contrôle de flux primitives que la VM supporte déjà. Dans ce chapitre, nous avons fait un grand <span name="leap">bond</span> en avant<span class="em">&mdash;</span>clox est maintenant Turing-complet. Nous avons aussi couvert un bon peu de nouvelle syntaxe : trois instructions et deux formes d&rsquo;expression. Même ainsi, cela a seulement pris trois nouvelles instructions simples. C&rsquo;est un ratio effort-sur-récompense assez bon pour l&rsquo;architecture de notre VM.</p>
<aside name="leap">
<p>Je n&rsquo;ai pas pu résister au jeu de mots. Je ne regrette rien.</p>
</aside>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>23&#8202;.&#8202;5</small>Défis</a></h2>
<ol>
<li>
<p>En plus des instructions <code>if</code>, la plupart des langages de la famille C ont une instruction <code>switch</code> multi-voie. Ajoutez-en une à clox. La grammaire est :</p>
<div class="codehilite"><pre><span class="i">switchStmt</span>     → <span class="s">&quot;switch&quot;</span> <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span>
                 <span class="s">&quot;{&quot;</span> <span class="i">switchCase</span>* <span class="i">defaultCase</span>? <span class="s">&quot;}&quot;</span> ;
<span class="i">switchCase</span>     → <span class="s">&quot;case&quot;</span> <span class="i">expression</span> <span class="s">&quot;:&quot;</span> <span class="i">statement</span>* ;
<span class="i">defaultCase</span>    → <span class="s">&quot;default&quot;</span> <span class="s">&quot;:&quot;</span> <span class="i">statement</span>* ;
</pre></div>
<p>Pour exécuter une instruction <code>switch</code>, évaluez d&rsquo;abord l&rsquo;expression de valeur switch parenthesée. Ensuite parcourez les cas. Pour chaque cas, évaluez son expression de valeur. Si la valeur de cas est égale à la valeur switch, exécutez les instructions sous le cas et ensuite sortez de l&rsquo;instruction <code>switch</code>. Sinon, essayez le cas suivant. Si aucun cas ne correspond et qu&rsquo;il y a une clause <code>default</code>, exécutez ses instructions.</p>
<p>Pour garder les choses plus simples, nous omettons la retombée (fallthrough) et les instructions <code>break</code>. Chaque cas saute automatiquement à la fin de l&rsquo;instruction switch après que ses instructions sont faites.</p>
</li>
<li>
<p>Dans jlox, nous avions un défi pour ajouter le support pour les instructions <code>break</code>. Cette fois, faisons <code>continue</code> :</p>
<div class="codehilite"><pre><span class="i">continueStmt</span>   → <span class="s">&quot;continue&quot;</span> <span class="s">&quot;;&quot;</span> ;
</pre></div>
<p>Une instruction <code>continue</code> saute directement au sommet de la boucle englobante la plus proche, sautant le reste du corps de la boucle. À l&rsquo;intérieur d&rsquo;une boucle <code>for</code>, un <code>continue</code> saute à la clause d&rsquo;incrément, s&rsquo;il y en a une. C&rsquo;est une erreur de compilation d&rsquo;avoir une instruction <code>continue</code> non englobée dans une boucle.</p>
<p>Assurez-vous de penser à la portée. Que devrait-il arriver aux variables locales déclarées à l&rsquo;intérieur du corps de la boucle ou dans des blocs imbriqués à l&rsquo;intérieur de la boucle quand un <code>continue</code> est exécuté ?</p>
</li>
<li>
<p>Les constructions de contrôle de flux ont été surtout inchangées depuis Algol 68. L&rsquo;évolution du langage depuis lors s&rsquo;est concentrée sur rendre le code plus déclaratif et haut niveau, donc le contrôle de flux impératif n&rsquo;a pas obtenu beaucoup d&rsquo;attention.</p>
<p>Pour le plaisir, essayez d&rsquo;inventer une fonctionnalité de contrôle de flux nouvelle utile pour Lox. Cela peut être un raffinement d&rsquo;une forme existante ou quelque chose d&rsquo;entièrement nouveau. En pratique, il est dur de trouver quelque chose d&rsquo;assez utile à ce bas niveau d&rsquo;expressivité pour peser plus lourd que le coût de forcer un utilisateur à apprendre une notation et un comportement non familiers, mais c&rsquo;est une bonne chance de pratiquer vos compétences de conception.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--considérer-le-goto-nuisible" id="note-de-conception--considérer-le-goto-nuisible"><small>23&#8202;.&#8202;6</small>Note de Conception : Considérer le Goto Nuisible</a></h2>
<p>Découvrir que tout notre beau contrôle de flux structuré dans Lox est en fait compilé en sauts bruts non structurés est comme le moment dans Scooby Doo quand le monstre arrache le masque de son visage. C&rsquo;était goto tout le long ! Sauf que dans ce cas, le monstre est <em>sous</em> le masque. Nous savons tous que goto est maléfique. Mais<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>pourquoi ?</p>
<p>Il est vrai que vous pouvez écrire du code outrageusement non maintenable utilisant goto. Mais je ne pense pas que la plupart des programmeurs autour d&rsquo;aujourd&rsquo;hui ont vu cela de première main. Cela fait longtemps que ce style était commun. Ces jours-ci, c&rsquo;est un croque-mitaine que nous invoquons dans des histoires effrayantes autour du feu de camp.</p>
<p>La raison pour laquelle nous confrontons rarement ce monstre en personne est parce que Edsger Dijkstra l&rsquo;a tué avec sa célèbre lettre &ldquo;Go To Statement Considered Harmful&rdquo; (L&rsquo;instruction Go To considérée nuisible), publiée dans <em>Communications of the ACM</em> (Mars, 1968). Le débat autour de la programmation structurée avait été féroce pendant quelque temps avec des adhérents des deux côtés, mais je pense que Dijkstra mérite le plus de crédit pour effectivement y mettre fin. La plupart des nouveaux langages aujourd&rsquo;hui n&rsquo;ont pas d&rsquo;instructions de saut non structuré.</p>
<p>Une lettre d&rsquo;une page et demie qui a presque à elle seule détruit une fonctionnalité de langage doit être un truc assez impressionnant. Si vous ne l&rsquo;avez pas lue, je vous encourage à le faire. C&rsquo;est un morceau séminal du folklore de la science informatique, une des chansons ancestrales de notre tribu. Aussi, c&rsquo;est un joli, court morceau de pratique pour lire l&rsquo;<span name="style">écriture</span> académique de CS, ce qui est une compétence utile à développer.</p>
<aside name="style">
<p>C&rsquo;est-à-dire, si vous pouvez passer outre le style d&rsquo;écriture faussement modeste et auto-agrandissant insupportable de Dijkstra :</p>
<blockquote>
<p>Plus récemment, j&rsquo;ai découvert pourquoi l&rsquo;utilisation de l&rsquo;instruction go to a de tels effets désastreux. <span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>À ce moment-là, je n&rsquo;attachais pas trop d&rsquo;importance à cette découverte ; je soumets maintenant mes considérations pour publication parce que dans des discussions très récentes dans lesquelles le sujet est apparu, j&rsquo;ai été pressé de le faire.</p>
</blockquote>
<p>Ah, encore une de mes nombreuses découvertes. Je ne pouvais même pas être dérangé de l&rsquo;écrire jusqu&rsquo;à ce que les masses clamantes me supplient de le faire.</p>
</aside>
<p>Je l&rsquo;ai lue un certain nombre de fois, avec quelques critiques, réponses, et commentaires. J&rsquo;ai fini avec des sentiments mitigés, au mieux. À un très haut niveau, je suis avec lui. Son argument général est quelque chose comme ceci :</p>
<ol>
<li>
<p>En tant que programmeurs, nous écrivons des programmes<span class="em">&mdash;</span>texte statique<span class="em">&mdash;</span>mais ce dont nous nous soucions est le programme s&rsquo;exécutant réellement<span class="em">&mdash;</span>son comportement dynamique.</p>
</li>
<li>
<p>Nous sommes meilleurs à raisonner sur des choses statiques que des choses dynamiques. (Il ne fournit aucune preuve pour supporter cette affirmation, mais je l&rsquo;accepte.)</p>
</li>
<li>
<p>Ainsi, plus nous pouvons faire que l&rsquo;exécution dynamique du programme reflète sa structure textuelle, mieux c&rsquo;est.</p>
</li>
</ol>
<p>C&rsquo;est un bon début. Attirer notre attention sur la séparation entre le code que nous écrivons et le code tel qu&rsquo;il s&rsquo;exécute à l&rsquo;intérieur de la machine est une vue intéressante. Ensuite il essaie de définir une &ldquo;correspondance&rdquo; entre le texte du programme et l&rsquo;exécution. Pour quelqu&rsquo;un qui a passé littéralement sa carrière entière à préconiser une plus grande rigueur dans la programmation, sa définition est assez vague. Il dit :</p>
<blockquote>
<p>Considérons maintenant comment nous pouvons caractériser le progrès d&rsquo;un processus. (Vous pouvez penser à cette question d&rsquo;une manière très concrète : supposons qu&rsquo;un processus, considéré comme une succession temporelle d&rsquo;actions, est arrêté après une action arbitraire, quelles données devons-nous fixer afin que nous puissions refaire le processus jusqu&rsquo;au même point ?)</p>
</blockquote>
<p>Imaginez-le comme ceci. Vous avez deux ordinateurs avec le même programme s&rsquo;exécutant sur exactement les mêmes entrées<span class="em">&mdash;</span>donc totalement déterministes. Vous mettez en pause l&rsquo;un d&rsquo;eux à un point arbitraire dans son exécution. Quelles données auriez-vous besoin d&rsquo;envoyer à l&rsquo;autre ordinateur pour être capable de l&rsquo;arrêter exactement aussi loin que le premier l&rsquo;était ?</p>
<p>Si votre programme permet seulement des instructions simples comme l&rsquo;assignation, c&rsquo;est facile. Vous avez juste besoin de connaître le point après la dernière instruction que vous avez exécutée. Fondamentalement un point d&rsquo;arrêt, le <code>ip</code> dans notre VM, ou le numéro de ligne dans un message d&rsquo;erreur. Ajouter le contrôle de flux de branchement comme <code>if</code> et <code>switch</code> n&rsquo;ajoute rien de plus à cela. Même si le marqueur pointe à l&rsquo;intérieur d&rsquo;une branche, nous pouvons toujours dire où nous sommes.</p>
<p>Une fois que vous ajoutez les appels de fonction, vous avez besoin de quelque chose de plus. Vous pourriez avoir mis en pause le premier ordinateur au milieu d&rsquo;une fonction, mais cette fonction peut être appelée de multiples endroits. Pour mettre en pause la seconde machine à exactement le même point dans l&rsquo;exécution du <em>programme entier</em>, vous avez besoin de la mettre en pause sur le <em>bon</em> appel à cette fonction.</p>
<p>Donc vous avez besoin de savoir non seulement l&rsquo;instruction courante, mais, pour les appels de fonction qui n&rsquo;ont pas encore retourné, vous avez besoin de connaître les emplacements des sites d&rsquo;appel. En d&rsquo;autres termes, une pile d&rsquo;appels, bien que je ne pense pas que ce terme existait quand Dijkstra a écrit ceci. Groovy (Super).</p>
<p>Il note que les boucles rendent les choses plus dures. Si vous mettez en pause au milieu d&rsquo;un corps de boucle, vous ne savez pas combien d&rsquo;itérations ont tourné. Donc il dit que vous avez aussi besoin de garder un compte d&rsquo;itération. Et, puisque les boucles peuvent s&rsquo;imbriquer, vous avez besoin d&rsquo;une pile de ceux-ci (présumément entrelacés avec les pointeurs de pile d&rsquo;appels puisque vous pouvez être dans des boucles dans des appels extérieurs aussi).</p>
<p>C&rsquo;est là que ça devient bizarre. Donc nous construisons vraiment vers quelque chose maintenant, et vous vous attendez à ce qu&rsquo;il explique comment goto brise tout cela. Au lieu de cela, il dit juste :</p>
<blockquote>
<p>L&rsquo;utilisation débridée de l&rsquo;instruction go to a une conséquence immédiate qu&rsquo;il devient terriblement dur de trouver un ensemble significatif de coordonnées dans lequel décrire le progrès du processus.</p>
</blockquote>
<p>Il ne prouve pas que c&rsquo;est dur, ou dit pourquoi. Il le dit juste. Il dit bien qu&rsquo;une approche est insatisfaisante :</p>
<blockquote>
<p>Avec l&rsquo;instruction go to on peut, bien sûr, toujours décrire le progrès uniquement par un compteur comptant le nombre d&rsquo;actions effectuées depuis le début du programme (c.-à-d. une sorte d&rsquo;horloge normalisée). La difficulté est qu&rsquo;une telle coordonnée, bien qu&rsquo;unique, est totalement inutile.</p>
</blockquote>
<p>Mais<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>c&rsquo;est effectivement ce que les compteurs de boucle font, et il était d&rsquo;accord avec ceux-là. Ce n&rsquo;est pas comme si chaque boucle est un simple &ldquo;pour chaque entier de 0 à 10&rdquo; comptage incrémental. Beaucoup sont des boucles <code>while</code> avec des conditionnelles complexes.</p>
<p>Prenant un exemple proche de la maison, considérez la boucle d&rsquo;exécution de bytecode centrale au cœur de clox. Dijkstra argumente que cette boucle est traitable parce que nous pouvons simplement compter combien de fois la boucle a tourné pour raisonner sur son progrès. Mais cette boucle tourne une fois pour chaque instruction exécutée dans le programme Lox compilé de quelque utilisateur. Est-ce que savoir qu&rsquo;elle a exécuté 6 201 instructions bytecode nous dit vraiment <em>quoi que ce soit</em> d&rsquo;édifiant sur l&rsquo;état de l&rsquo;interpréteur ?</p>
<p>En fait, cet exemple particulier pointe vers une vérité plus profonde. Böhm et Jacopini ont <a href="https://fr.wikipedia.org/wiki/Th%C3%A9or%C3%A8me_de_b%C3%B6hm-jacopini">prouvé</a> que <em>tout</em> contrôle de flux utilisant goto peut être transformé en un utilisant juste le séquencement, les boucles, et les branches. Notre boucle d&rsquo;interpréteur de bytecode est un exemple vivant de cette preuve : elle implémente le contrôle de flux non structuré du jeu d&rsquo;instructions bytecode de clox sans utiliser aucun goto elle-même.</p>
<p>Cela semble offrir un contre-argument à l&rsquo;affirmation de Dijkstra : vous <em>pouvez</em> définir une correspondance pour un programme utilisant des gotos en le transformant en un qui ne le fait pas et ensuite utiliser la correspondance depuis ce programme, qui<span class="em">&mdash;</span>selon lui<span class="em">&mdash;</span>est acceptable parce qu&rsquo;il utilise seulement des branches et des boucles.</p>
<p>Mais, honnêtement, mon argument ici est aussi faible. Je pense que nous deux faisons fondamentalement des maths pour de faux et utilisons de la fausse logique pour faire ce qui devrait être un argument empirique, centré sur l&rsquo;humain. Dijkstra a raison que du code utilisant goto est vraiment mauvais. Beaucoup de cela pourrait et devrait être tourné en code plus clair en utilisant le contrôle de flux structuré.</p>
<p>En éliminant goto complètement des langages, vous êtes définitivement empêché d&rsquo;écrire du mauvais code utilisant des gotos. Il se peut que forcer les utilisateurs à utiliser le contrôle de flux structuré et faire que ce soit une bataille difficile d&rsquo;écrire du code de type goto utilisant ces constructions est un gain net pour toute notre productivité.</p>
<p>Mais je me demande parfois si nous avons jeté le bébé avec l&rsquo;eau du bain. En l&rsquo;absence de goto, nous recourons souvent à des motifs structurés plus complexes. Le &ldquo;switch à l&rsquo;intérieur d&rsquo;une boucle&rdquo; en est un classique. Un autre est l&rsquo;utilisation d&rsquo;une variable garde pour sortir d&rsquo;une série de boucles imbriquées :</p><span name="break">
</span>
<div class="codehilite"><pre><span class="c">// Voir si la matrice contient un zéro.</span>
<span class="t">bool</span> <span class="i">found</span> = <span class="k">false</span>;
<span class="k">for</span> (<span class="t">int</span> <span class="i">x</span> = <span class="n">0</span>; <span class="i">x</span> &lt; <span class="i">xSize</span>; <span class="i">x</span>++) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">y</span> = <span class="n">0</span>; <span class="i">y</span> &lt; <span class="i">ySize</span>; <span class="i">y</span>++) {
    <span class="k">for</span> (<span class="t">int</span> <span class="i">z</span> = <span class="n">0</span>; <span class="i">z</span> &lt; <span class="i">zSize</span>; <span class="i">z</span>++) {
      <span class="k">if</span> (<span class="i">matrix</span>[<span class="i">x</span>][<span class="i">y</span>][<span class="i">z</span>] == <span class="n">0</span>) {
        <span class="i">printf</span>(<span class="s">&quot;found&quot;</span>);
        <span class="i">found</span> = <span class="k">true</span>;
        <span class="k">break</span>;
      }
    }
    <span class="k">if</span> (<span class="i">found</span>) <span class="k">break</span>;
  }
  <span class="k">if</span> (<span class="i">found</span>) <span class="k">break</span>;
}
</pre></div>
<p>Est-ce vraiment mieux que :</p>
<div class="codehilite"><pre><span class="k">for</span> (<span class="t">int</span> <span class="i">x</span> = <span class="n">0</span>; <span class="i">x</span> &lt; <span class="i">xSize</span>; <span class="i">x</span>++) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">y</span> = <span class="n">0</span>; <span class="i">y</span> &lt; <span class="i">ySize</span>; <span class="i">y</span>++) {
    <span class="k">for</span> (<span class="t">int</span> <span class="i">z</span> = <span class="n">0</span>; <span class="i">z</span> &lt; <span class="i">zSize</span>; <span class="i">z</span>++) {
      <span class="k">if</span> (<span class="i">matrix</span>[<span class="i">x</span>][<span class="i">y</span>][<span class="i">z</span>] == <span class="n">0</span>) {
        <span class="i">printf</span>(<span class="s">&quot;found&quot;</span>);
        <span class="k">goto</span> <span class="i">done</span>;
      }
    }
  }
}
<span class="i">done</span>:
</pre></div>
<aside name="break">
<p>Vous pourriez faire cela sans instructions <code>break</code><span class="em">&mdash;</span>elles-mêmes une construction de style goto limitée<span class="em">&mdash;</span>en insérant <code>!found &amp;&amp;</code> au début de la clause de condition de chaque boucle.</p>
</aside>
<p>Je suppose que ce que je n&rsquo;aime vraiment pas est que nous prenons des décisions de conception de langage et d&rsquo;ingénierie aujourd&rsquo;hui basées sur la peur. Peu de gens aujourd&rsquo;hui ont une compréhension subtile des problèmes et bénéfices de goto. Au lieu de cela, nous pensons juste qu&rsquo;il est &ldquo;considéré nuisible&rdquo;. Personnellement, je n&rsquo;ai jamais trouvé le dogme un bon point de départ pour un travail créatif de qualité.</p>
</div>

<footer>
<a href="appels-et-fonctions.html" class="next">
  Next Chapter: &ldquo;Appels et fonctions&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
