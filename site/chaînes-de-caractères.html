<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Chaînes de caractères &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Chaînes de caractères<small>19</small></a></h3>

<ul>
    <li><a href="#valeurs-et-objets"><small>19.1</small> Valeurs et Objets</a></li>
    <li><a href="#héritage-de-structure"><small>19.2</small> Héritage de Structure</a></li>
    <li><a href="#chaînes"><small>19.3</small> Chaînes</a></li>
    <li><a href="#opérations-sur-les-chaînes"><small>19.4</small> Opérations sur les Chaînes</a></li>
    <li><a href="#libérer-les-objets"><small>19.5</small> Libérer les Objets</a></li>
    <li><a href="#défis"><small>19.6</small> Défis</a></li>
    <li><a href="#note-de-conception--encodage-de-chaîne"><small>19.7</small> Note de Conception : Encodage de Chaîne</a></li>
</ul>


<div class="prev-next">
    <a href="types-de-valeurs.html" title="Types de valeurs" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="tables-de-hachage.html" title="Tables de hachage" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="types-de-valeurs.html" title="Types de valeurs" class="prev">←</a>
<a href="tables-de-hachage.html" title="Tables de hachage" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Chaînes de caractères<small>19</small></a></h3>

<ul>
    <li><a href="#valeurs-et-objets"><small>19.1</small> Valeurs et Objets</a></li>
    <li><a href="#héritage-de-structure"><small>19.2</small> Héritage de Structure</a></li>
    <li><a href="#chaînes"><small>19.3</small> Chaînes</a></li>
    <li><a href="#opérations-sur-les-chaînes"><small>19.4</small> Opérations sur les Chaînes</a></li>
    <li><a href="#libérer-les-objets"><small>19.5</small> Libérer les Objets</a></li>
    <li><a href="#défis"><small>19.6</small> Défis</a></li>
    <li><a href="#note-de-conception--encodage-de-chaîne"><small>19.7</small> Note de Conception : Encodage de Chaîne</a></li>
</ul>


<div class="prev-next">
    <a href="types-de-valeurs.html" title="Types de valeurs" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="tables-de-hachage.html" title="Tables de hachage" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">19</div>
  <h1>Chaînes de caractères</h1>

<blockquote>
<p>&ldquo;Ah ? Une petite aversion pour le travail manuel ?&rdquo; Le docteur haussa un sourcil.
&ldquo;Compréhensible, mais mal placé. On devrait chérir ces tâches terre-à-terre qui gardent le corps occupé mais laissent l&rsquo;esprit et le cœur libres.&rdquo; (1)</p>
<p><cite>Tad Williams, <em>The Dragonbone Chair</em></cite></p>
</blockquote>
<p>Notre petite VM peut représenter trois types de valeurs en ce moment : les nombres, les Booléens, et <code>nil</code>. Ces types deux choses importantes en commun : ils sont immuables et ils sont petits. Les nombres sont les plus grands, et ils tiennent toujours dans deux mots de 64 bits. C&rsquo;est un prix assez petit que nous pouvons nous permettre de payer pour toutes les valeurs, même les Booléens et les nils qui n&rsquo;ont pas besoin d&rsquo;autant d&rsquo;espace.</p>
<p>Les chaînes de caractères, malheureusement, ne sont pas si petites. Il n&rsquo;y a pas de longueur maximale pour une chaîne. Même si nous devions artificiellement la plafonner à quelque limite controuvée comme <span name="pascal">255</span> caractères, c&rsquo;est encore trop de mémoire à dépenser sur chaque valeur unique.</p>
<aside name="pascal">
<p>UCSD Pascal, une des premières implémentations de Pascal, avait cette limite exacte. Au lieu d&rsquo;utiliser un octet nul de terminaison pour indiquer la fin de la chaîne comme C, les chaînes Pascal commençaient avec une valeur de longueur. Puisque UCSD utilisait seulement un octet unique pour stocker la longueur, les chaînes ne pouvaient pas être plus longues que 255 caractères.</p><img src="image/strings/pstring.png" alt="La chaîne Pascal 'hello' avec un octet de longueur de 5 la précédant." />
</aside>
<p>Nous avons besoin d&rsquo;un moyen de supporter des valeurs dont les tailles varient, parfois grandement. C&rsquo;est exactement ce pour quoi l&rsquo;allocation dynamique sur le tas est conçue. Nous pouvons allouer autant d&rsquo;octets que nous en avons besoin. Nous recevons en retour un pointeur que nous utiliserons pour garder une trace de la valeur alors qu&rsquo;elle coule à travers la VM.</p>
<h2><a href="#valeurs-et-objets" id="valeurs-et-objets"><small>19&#8202;.&#8202;1</small>Valeurs et Objets</a></h2>
<p>Utiliser le tas pour des valeurs plus grandes, de taille variable et la pile pour celles plus petites, atomiques mène à une représentation à deux niveaux. Chaque valeur Lox que vous pouvez stocker dans une variable ou renvoyer d&rsquo;une expression sera une Value. Pour les petits types de taille fixe comme les nombres, la charge utile est stockée directement à l&rsquo;intérieur de la struct Value elle-même.</p>
<p>Si l&rsquo;objet est plus grand, ses données vivent sur le tas. Alors la charge utile de la Value est un <em>pointeur</em> vers ce blob de mémoire. Nous aurons éventuellement une poignée de types alloués sur le tas dans clox : chaînes, instances, fonctions, vous voyez l&rsquo;idée. Chaque type a ses propres données uniques, mais il y a aussi un état qu&rsquo;ils partagent tous que <a href="ramasse-miettes.html">notre futur ramasse-miettes</a> utilisera pour gérer leur mémoire.</p><img src="image/strings/value.png" class="wide" alt="Disposition des champs des valeurs nombre et obj." />
<p>Nous appellerons cette représentation commune <span name="short">&ldquo;Obj&rdquo;</span>. Chaque valeur Lox dont l&rsquo;état vit sur le tas est un Obj. Nous pouvons ainsi utiliser un unique nouveau cas <code>ValueType</code> pour référer à tous les types alloués sur le tas.</p>
<aside name="short">
<p>&ldquo;Obj&rdquo; est court pour &ldquo;objet&rdquo;, évidemment.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  VAL_NUMBER,
</pre><div class="source-file"><em>value.h</em><br>
in enum <em>ValueType</em></div>
<pre class="insert">  <span class="a">VAL_OBJ</span>
</pre><pre class="insert-after">} ValueType;
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, in enum <em>ValueType</em></div>

<p>Quand le type d&rsquo;une Value est <code>VAL_OBJ</code>, la charge utile est un pointeur vers la mémoire du tas, donc nous ajoutons un autre cas à l&rsquo;union pour ça.</p>
<div class="codehilite"><pre class="insert-before">    double number;
</pre><div class="source-file"><em>value.h</em><br>
in struct <em>Value</em></div>
<pre class="insert">    <span class="t">Obj</span>* <span class="i">obj</span>;
</pre><pre class="insert-after">  } as;<span name="as"> </span>
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, in struct <em>Value</em></div>

<p>Comme nous l&rsquo;avons fait avec les autres types de valeur, nous produisons une couple de macros utiles pour travailler avec les valeurs Obj.</p>
<div class="codehilite"><pre class="insert-before">#define IS_NUMBER(value)  ((value).type == VAL_NUMBER)
</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>Value</em></div>
<pre class="insert"><span class="a">#define IS_OBJ(value)     ((value).type == VAL_OBJ)</span>
</pre><pre class="insert-after">

#define AS_BOOL(value)    ((value).as.boolean)
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>Value</em></div>

<p>Cela évalue à <code>true</code> si la Value donnée est un Obj. Si c&rsquo;est le cas, nous pouvons utiliser ceci :</p>
<div class="codehilite"><pre class="insert-before">#define IS_OBJ(value)     ((value).type == VAL_OBJ)

</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert"><span class="a">#define AS_OBJ(value)     ((value).as.obj)</span>
</pre><pre class="insert-after">#define AS_BOOL(value)    ((value).as.boolean)
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>

<p>Elle extrait le pointeur Obj de la valeur. Nous pouvons aussi aller dans l&rsquo;autre sens.</p>
<div class="codehilite"><pre class="insert-before">#define NUMBER_VAL(value) ((Value){VAL_NUMBER, {.number = value}})
</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert"><span class="a">#define OBJ_VAL(object)   ((Value){VAL_OBJ, {.obj = (Obj*)object}})</span>
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>

<p>Cela prend un pointeur Obj nu et l&rsquo;enveloppe dans une Value complète.</p>
<h2><a href="#héritage-de-structure" id="héritage-de-structure"><small>19&#8202;.&#8202;2</small>Héritage de Structure</a></h2>
<p>Chaque valeur allouée sur le tas est un Obj, mais les <span name="objs">Objs</span> ne sont pas tous les mêmes. Pour les chaînes, nous avons besoin du tableau de caractères. Quand nous arriverons aux instances, elles auront besoin de leurs champs de données. Un objet fonction aura besoin de son morceau de bytecode. Comment gérons-nous différentes charges utiles et tailles ? Nous ne pouvons pas utiliser une autre union comme nous l&rsquo;avons fait pour Value puisque les tailles sont partout.</p>
<aside name="objs">
<p>Non, je ne sais pas comment prononcer &ldquo;objs&rdquo; non plus. J&rsquo;ai l&rsquo;impression qu&rsquo;il devrait y avoir une voyelle là-dedans quelque part.</p>
</aside>
<p>Au lieu de cela, nous utiliserons une autre technique. Elle existe depuis des lustres, au point que la spécification C taille un support spécifique pour elle, mais je ne sais pas si elle a un nom canonique. C&rsquo;est un exemple de <a href="https://en.wikipedia.org/wiki/Type_punning"><em>type punning</em></a>, mais ce terme est trop large. En l&rsquo;absence de meilleures idées, je l&rsquo;appellerai <strong>héritage de structure</strong>, parce qu&rsquo;elle repose sur des structs et suit grossièrement comment l&rsquo;héritage simple d&rsquo;état fonctionne dans les langages orientés objet.</p>
<p>Comme une union étiquetée, chaque Obj commence par un champ d&rsquo;étiquette (tag) qui identifie quel genre d&rsquo;objet c&rsquo;est<span class="em">&mdash;</span>chaîne, instance, etc. Suivant cela sont les champs de charge utile. Au lieu d&rsquo;une union avec des cas pour chaque type, chaque type est sa propre struct séparée. La partie délicate est comment traiter ces structs uniformément puisque C n&rsquo;a aucun concept d&rsquo;héritage ou de polymorphisme. J&rsquo;expliquerai cela bientôt, mais d&rsquo;abord sortons les trucs préliminaires du chemin.</p>
<p>Le nom &ldquo;Obj&rdquo; lui-même réfère à une struct qui contient l&rsquo;état partagé à travers tous les types d&rsquo;objet. C&rsquo;est un peu comme la &ldquo;classe de base&rdquo; pour les objets. À cause de certaines dépendances cycliques entre valeurs et objets, nous la déclarons de manière anticipée dans le module &ldquo;value&rdquo;.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;

</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert"><span class="k">typedef</span> <span class="k">struct</span> <span class="t">Obj</span> <span class="t">Obj</span>;

</pre><pre class="insert-after">typedef enum {
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>

<p>Et la définition réelle est dans un nouveau module.</p>
<div class="codehilite"><div class="source-file"><em>object.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_object_h</span>
<span class="a">#define clox_object_h</span>

<span class="a">#include &quot;common.h&quot;</span>
<span class="a">#include &quot;value.h&quot;</span>

<span class="k">struct</span> <span class="t">Obj</span> {
  <span class="t">ObjType</span> <span class="i">type</span>;
};

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, create new file</div>

<p>Pour l&rsquo;instant, elle contient seulement l&rsquo;étiquette de type. Sous peu, nous ajouterons d&rsquo;autres informations de comptabilité pour la gestion de la mémoire. L&rsquo;enum de type est ceci :</p>
<div class="codehilite"><pre class="insert-before">#include &quot;value.h&quot;
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">OBJ_STRING</span>,
} <span class="t">ObjType</span>;
</pre><pre class="insert-after">

struct Obj {
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Évidemment, cela sera plus utile dans les chapitres ultérieurs après que nous ayons ajouté plus de types alloués sur le tas. Puisque nous accéderons fréquemment à ces types d&rsquo;étiquette, cela vaut la peine de faire une petite macro qui extrait l&rsquo;étiquette de type d&rsquo;objet d&rsquo;une Value donnée.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;value.h&quot;
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert">

<span class="a">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)</span>
</pre><pre class="insert-after">

typedef enum {
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>C&rsquo;est notre fondation.</p>
<p>Maintenant, construisons les chaînes par-dessus. La charge utile pour les chaînes est définie dans une struct séparée. De nouveau, nous avons besoin de la déclarer de manière anticipée.</p>
<div class="codehilite"><pre class="insert-before">typedef struct Obj Obj;
</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert"><span class="k">typedef</span> <span class="k">struct</span> <span class="t">ObjString</span> <span class="t">ObjString</span>;
</pre><pre class="insert-after">

typedef enum {
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>

<p>La définition vit aux côtés d&rsquo;Obj.</p>
<div class="codehilite"><pre class="insert-before">};
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>Obj</em></div>
<pre class="insert">

<span class="k">struct</span> <span class="t">ObjString</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">int</span> <span class="i">length</span>;
  <span class="t">char</span>* <span class="i">chars</span>;
};
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>Obj</em></div>

<p>Un objet chaîne contient un tableau de caractères. Ceux-ci sont stockés dans un tableau séparé, alloué sur le tas pour que nous mettions de côté seulement autant de place que nécessaire pour chaque chaîne. Nous stockons aussi le nombre d&rsquo;octets dans le tableau. Ce n&rsquo;est pas strictement nécessaire mais nous permet de dire combien de mémoire est allouée pour la chaîne sans parcourir le tableau de caractères pour trouver le terminateur nul.</p>
<p>Parce qu&rsquo;ObjString est un Obj, il a aussi besoin de l&rsquo;état que tous les Objs partagent. Il accomplit cela en ayant son premier champ être un Obj. C spécifie que les champs de struct sont arrangés en mémoire dans l&rsquo;ordre où ils sont déclarés. Aussi, quand vous imbriquez des structs, les champs de la struct interne sont étendus juste sur place. Donc la mémoire pour Obj et pour ObjString ressemble à ceci :</p><img src="image/strings/obj.png" alt="La disposition mémoire pour les champs dans Obj et ObjString." />
<p>Notez comment les premiers octets d&rsquo;ObjString s&rsquo;alignent exactement avec Obj. Ce n&rsquo;est pas une coïncidence<span class="em">&mdash;</span>C le <span name="spec">mandate</span>. C&rsquo;est conçu pour permettre un motif intelligent : Vous pouvez prendre un pointeur vers une struct et le convertir en toute sécurité en un pointeur vers son premier champ et inversement.</p>
<aside name="spec">
<p>La partie clé de la spec est :</p>
<blockquote>
<p>&sect; 6.7.2.1 13</p>
<p>À l&rsquo;intérieur d&rsquo;un objet structure, les membres non-champs-de-bits et les unités dans lesquelles résident les champs-de-bits ont des adresses qui augmentent dans l&rsquo;ordre dans lequel ils sont déclarés. Un pointeur vers un objet structure, convenablement converti, pointe vers son membre initial (ou si ce membre est un champ-de-bits, alors vers l&rsquo;unité dans laquelle il réside), et vice versa. Il peut y avoir du remplissage sans nom à l&rsquo;intérieur d&rsquo;un objet structure, mais pas à son début.</p>
</blockquote>
</aside>
<p>Étant donné un <code>ObjString*</code>, vous pouvez le caster en toute sécurité en <code>Obj*</code> et ensuite accéder au champ <code>type</code> depuis lui. Chaque ObjString &ldquo;est&rdquo; un Obj dans le sens POO de &ldquo;est&rdquo;. Quand nous ajouterons plus tard d&rsquo;autres types d&rsquo;objet, chaque struct aura un Obj comme son premier champ. Tout code qui veut travailler avec tous les objets peut les traiter comme des <code>Obj*</code> de base et ignorer tous les autres champs qui peuvent arriver à suivre.</p>
<p>Vous pouvez aller dans l&rsquo;autre direction aussi. Étant donné un <code>Obj*</code>, vous pouvez le &ldquo;descendre&rdquo; (downcast) en un <code>ObjString*</code>. Bien sûr, vous devez vous assurer que le pointeur <code>Obj*</code> que vous avez pointe bien vers le champ <code>obj</code> d&rsquo;un ObjString réel. Sinon, vous réinterprétez de manière non sûre des bits aléatoires de mémoire. Pour détecter qu&rsquo;un tel cast est sûr, nous ajoutons une autre macro.</p>
<div class="codehilite"><pre class="insert-before">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert">

<span class="a">#define IS_STRING(value)       isObjType(value, OBJ_STRING)</span>
</pre><pre class="insert-after">

typedef enum {
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Elle prend une Value, pas un <code>Obj*</code> brut parce que la plupart du code dans la VM travaille avec des Values. Elle repose sur cette fonction en ligne :</p>
<div class="codehilite"><pre class="insert-before">};

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjString</em></div>
<pre class="insert"><span class="k">static</span> <span class="k">inline</span> <span class="t">bool</span> <span class="i">isObjType</span>(<span class="t">Value</span> <span class="i">value</span>, <span class="t">ObjType</span> <span class="i">type</span>) {
  <span class="k">return</span> <span class="a">IS_OBJ</span>(<span class="i">value</span>) &amp;&amp; <span class="a">AS_OBJ</span>(<span class="i">value</span>)-&gt;<span class="i">type</span> == <span class="i">type</span>;
}

</pre><pre class="insert-after">#endif
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>

<p>Quiz surprise : Pourquoi ne pas juste mettre le corps de cette fonction juste dans la macro ? Qu&rsquo;est-ce qui est différent à propos de celle-ci comparé aux autres ? Correct, c&rsquo;est parce que le corps utilise <code>value</code> deux fois. Une macro est étendue en insérant l&rsquo;<em>expression</em> argument chaque endroit où le nom du paramètre apparaît dans le corps. Si une macro utilise un paramètre plus d&rsquo;une fois, cette expression est évaluée de multiples fois.</p>
<p>C&rsquo;est mauvais si l&rsquo;expression a des effets de bord. Si nous mettions le corps de <code>isObjType()</code> dans la définition de macro et qu&rsquo;ensuite vous faisiez, disons,</p>
<div class="codehilite"><pre><span class="a">IS_STRING</span>(<span class="a">POP</span>())
</pre></div>
<p>alors cela dépilerait deux valeurs de la pile ! Utiliser une fonction corrige cela.</p>
<p>Tant que nous assurons que nous définissons l&rsquo;étiquette de type correctement chaque fois que nous créons un Obj de quelque type, cette macro nous dira quand il est sûr de caster une valeur vers un type d&rsquo;objet spécifique. Nous pouvons faire cela en utilisant celles-ci :</p>
<div class="codehilite"><pre class="insert-before">#define IS_STRING(value)       isObjType(value, OBJ_STRING)
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert">

<span class="a">#define AS_STRING(value)       ((ObjString*)AS_OBJ(value))</span>
<span class="a">#define AS_CSTRING(value)      (((ObjString*)AS_OBJ(value))-&gt;chars)</span>
</pre><pre class="insert-after">

typedef enum {
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Ces deux macros prennent une Value qui est attendue contenir un pointeur vers un ObjString valide sur le tas. La première renvoie le pointeur <code>ObjString*</code>. La seconde fait un pas à travers pour renvoyer le tableau de caractères lui-même, puisque c&rsquo;est souvent ce dont nous finirons par avoir besoin.</p>
<h2><a href="#chaînes" id="chaînes"><small>19&#8202;.&#8202;3</small>Chaînes</a></h2>
<p>OK, notre VM peut maintenant représenter des valeurs chaîne. Il est temps d&rsquo;ajouter les chaînes au langage lui-même. Comme d&rsquo;habitude, nous commençons dans le front end. Le lexer tokenise déjà les littéraux chaîne, donc c&rsquo;est au tour du parseur.</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_IDENTIFIER]    = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_STRING</span>]        = {<span class="i">string</span>,   <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_NUMBER]        = {number,   NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Quand le parseur touche un token chaîne, il appelle cette fonction de parsing :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>number</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">string</span>() {
  <span class="i">emitConstant</span>(<span class="a">OBJ_VAL</span>(<span class="i">copyString</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">start</span> + <span class="n">1</span>,
                                  <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">length</span> - <span class="n">2</span>)));
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>number</em>()</div>

<p>Cela prend les caractères de la chaîne <span name="escape">directement</span> du lexème. Les parties <code>+ 1</code> et <code>- 2</code> enlèvent les guillemets de tête et de traîne. Elle crée ensuite un objet chaîne, l&rsquo;enveloppe dans une Value, et le bourre dans la table de constantes.</p>
<aside name="escape">
<p>Si Lox supportait les séquences d&rsquo;échappement de chaîne comme <code>\n</code>, nous traduirions celles-ci ici. Puisqu&rsquo;il ne le fait pas, nous pouvons prendre les caractères tels qu&rsquo;ils sont.</p>
</aside>
<p>Pour créer la chaîne, nous utilisons <code>copyString()</code>, qui est déclarée dans <code>object.h</code>.</p>
<div class="codehilite"><pre class="insert-before">};

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjString</em></div>
<pre class="insert"><span class="t">ObjString</span>* <span class="i">copyString</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">chars</span>, <span class="t">int</span> <span class="i">length</span>);

</pre><pre class="insert-after">static inline bool isObjType(Value value, ObjType type) {
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>

<p>Le module compilateur a besoin d&rsquo;inclure cela.</p>
<div class="codehilite"><pre class="insert-before">#define clox_compiler_h

</pre><div class="source-file"><em>compiler.h</em></div>
<pre class="insert"><span class="a">#include &quot;object.h&quot;</span>
</pre><pre class="insert-after">#include &quot;vm.h&quot;
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em></div>

<p>Notre module &ldquo;object&rdquo; obtient un fichier d&rsquo;implémentation où nous définissons la nouvelle fonction.</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
create new file</div>
<pre><span class="a">#include &lt;stdio.h&gt;</span>
<span class="a">#include &lt;string.h&gt;</span>

<span class="a">#include &quot;memory.h&quot;</span>
<span class="a">#include &quot;object.h&quot;</span>
<span class="a">#include &quot;value.h&quot;</span>
<span class="a">#include &quot;vm.h&quot;</span>

<span class="t">ObjString</span>* <span class="i">copyString</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">chars</span>, <span class="t">int</span> <span class="i">length</span>) {
  <span class="t">char</span>* <span class="i">heapChars</span> = <span class="a">ALLOCATE</span>(<span class="t">char</span>, <span class="i">length</span> + <span class="n">1</span>);
  <span class="i">memcpy</span>(<span class="i">heapChars</span>, <span class="i">chars</span>, <span class="i">length</span>);
  <span class="i">heapChars</span>[<span class="i">length</span>] = <span class="s">&#39;\0&#39;</span>;
  <span class="k">return</span> <span class="i">allocateString</span>(<span class="i">heapChars</span>, <span class="i">length</span>);
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, create new file</div>

<p>D&rsquo;abord, nous allouons un nouveau tableau sur le tas, juste assez grand pour les caractères de la chaîne et le <span name="terminator">terminateur</span> de traîne, en utilisant cette macro de bas niveau qui alloue un tableau avec un type d&rsquo;élément donné et un compte :</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;

</pre><div class="source-file"><em>memory.h</em></div>
<pre class="insert"><span class="a">#define ALLOCATE(type, count) \</span>
<span class="a">    (type*)reallocate(NULL, 0, sizeof(type) * (count))</span>

</pre><pre class="insert-after">#define GROW_CAPACITY(capacity) \
</pre></div>
<div class="source-file-narrow"><em>memory.h</em></div>

<p>Une fois que nous avons le tableau, nous copions par-dessus les caractères depuis le lexème et le terminons.</p>
<aside name="terminator" class="bottom">
<p>Nous avons besoin de terminer la chaîne nous-mêmes parce que le lexème pointe à une plage de caractères à l&rsquo;intérieur de la chaîne source monolithique et n&rsquo;est pas terminé.</p>
<p>Puisque ObjString stocke la longueur explicitement, nous <em>pourrions</em> laisser le tableau de caractères non terminé, mais coller un terminateur à la fin nous coûte seulement un octet et nous laisse passer le tableau de caractères aux fonctions de bibliothèque standard C qui attendent une chaîne terminée.</p>
</aside>
<p>Vous pourriez vous demander pourquoi l&rsquo;ObjString ne peut pas juste pointer en retour vers les caractères originaux dans la chaîne source. Certains ObjStrings seront créés dynamiquement à l&rsquo;exécution comme résultat d&rsquo;opérations sur les chaînes comme la concaténation. Ces chaînes ont évidemment besoin d&rsquo;allouer dynamiquement de la mémoire pour les caractères, ce qui signifie que la chaîne a besoin de <em>libérer</em> cette mémoire quand elle n&rsquo;est plus nécessaire.</p>
<p>Si nous avions un ObjString pour un littéral chaîne, et essayions de libérer son tableau de caractères qui pointait dans la chaîne de code source originale, de mauvaises choses arriveraient. Donc, pour les littéraux, nous copions préventivement les caractères sur le tas. De cette façon, chaque ObjString possède de manière fiable son tableau de caractères et peut le libérer.</p>
<p>Le vrai travail de création d&rsquo;un objet chaîne se passe dans cette fonction :</p>
<div class="codehilite"><pre class="insert-before">#include &quot;vm.h&quot;

</pre><div class="source-file"><em>object.c</em></div>
<pre class="insert"><span class="k">static</span> <span class="t">ObjString</span>* <span class="i">allocateString</span>(<span class="t">char</span>* <span class="i">chars</span>, <span class="t">int</span> <span class="i">length</span>) {
  <span class="t">ObjString</span>* <span class="i">string</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjString</span>, <span class="a">OBJ_STRING</span>);
  <span class="i">string</span>-&gt;<span class="i">length</span> = <span class="i">length</span>;
  <span class="i">string</span>-&gt;<span class="i">chars</span> = <span class="i">chars</span>;
  <span class="k">return</span> <span class="i">string</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em></div>

<p>Elle crée un nouvel ObjString sur le tas et ensuite initialise ses champs. C&rsquo;est un peu comme un constructeur dans un langage POO. En tant que tel, elle appelle d&rsquo;abord le constructeur de &ldquo;classe de base&rdquo; pour initialiser l&rsquo;état Obj, utilisant une nouvelle macro.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;vm.h&quot;
</pre><div class="source-file"><em>object.c</em></div>
<pre class="insert">

<span class="a">#define ALLOCATE_OBJ(type, objectType) \</span>
<span class="a">    (type*)allocateObject(sizeof(type), objectType)</span>
</pre><pre class="insert-after">

static ObjString* allocateString(char* chars, int length) {
</pre></div>
<div class="source-file-narrow"><em>object.c</em></div>

<p><span name="factored">Comme</span> la macro précédente, celle-ci existe principalement pour éviter le besoin de caster de manière redondante un <code>void*</code> de retour vers le type désiré. La fonctionnalité réelle est ici :</p>
<aside name="factored">
<p>J&rsquo;admets que ce chapitre a une mer de fonctions aides et de macros à traverser. J&rsquo;essaie de garder le code joliment factorisé, mais cela mène à un éparpillement de minuscules fonctions. Elles payeront quand nous les réutiliserons plus tard.</p>
</aside>
<div class="codehilite"><pre class="insert-before">#define ALLOCATE_OBJ(type, objectType) \
    (type*)allocateObject(sizeof(type), objectType)
</pre><div class="source-file"><em>object.c</em></div>
<pre class="insert">

<span class="k">static</span> <span class="t">Obj</span>* <span class="i">allocateObject</span>(<span class="t">size_t</span> <span class="i">size</span>, <span class="t">ObjType</span> <span class="i">type</span>) {
  <span class="t">Obj</span>* <span class="i">object</span> = (<span class="t">Obj</span>*)<span class="i">reallocate</span>(<span class="a">NULL</span>, <span class="n">0</span>, <span class="i">size</span>);
  <span class="i">object</span>-&gt;<span class="i">type</span> = <span class="i">type</span>;
  <span class="k">return</span> <span class="i">object</span>;
}
</pre><pre class="insert-after">

static ObjString* allocateString(char* chars, int length) {
</pre></div>
<div class="source-file-narrow"><em>object.c</em></div>

<p>Elle alloue un objet de la taille donnée sur le tas. Notez que la taille n&rsquo;est <em>pas</em> juste la taille d&rsquo;Obj lui-même. L&rsquo;appelant passe le nombre d&rsquo;octets pour qu&rsquo;il y ait de la place pour les champs de charge utile supplémentaires nécessaires par le type d&rsquo;objet spécifique étant créé.</p>
<p>Ensuite elle initialise l&rsquo;état Obj<span class="em">&mdash;</span>pour l&rsquo;instant, c&rsquo;est juste l&rsquo;étiquette de type. Cette fonction revient à <code>allocateString()</code>, qui finit d&rsquo;initialiser les champs d&rsquo;ObjString. <span name="viola"><em>Voilà</em></span>, nous pouvons compiler et exécuter des littéraux chaîne.</p>
<aside name="viola"><img src="image/strings/viola.png" class="above" alt="Un alto." />
<p>Ne confondez pas &ldquo;voilà&rdquo; avec &ldquo;viola&rdquo;. L&rsquo;un signifie &ldquo;ça y est&rdquo; et l&rsquo;autre est un instrument à cordes, l&rsquo;enfant du milieu entre un violon et un violoncelle. Oui, j&rsquo;ai passé deux heures à dessiner un alto juste pour mentionner ça.</p>
</aside>
<h2><a href="#opérations-sur-les-chaînes" id="opérations-sur-les-chaînes"><small>19&#8202;.&#8202;4</small>Opérations sur les Chaînes</a></h2>
<p>Nos chaînes fantaisie sont là, mais elles ne font pas grand-chose encore. Une bonne première étape est de faire en sorte que le code d&rsquo;impression existant ne vomisse pas sur le nouveau type de valeur.</p>
<div class="codehilite"><pre class="insert-before">    case VAL_NUMBER: printf(&quot;%g&quot;, AS_NUMBER(value)); break;
</pre><div class="source-file"><em>value.c</em><br>
in <em>printValue</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">VAL_OBJ</span>: <span class="i">printObject</span>(<span class="i">value</span>); <span class="k">break</span>;
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, in <em>printValue</em>()</div>

<p>Si la valeur est un objet alloué sur le tas, elle défère à une fonction aide là-bas dans le module &ldquo;object&rdquo;.</p>
<div class="codehilite"><pre class="insert-before">ObjString* copyString(const char* chars, int length);
</pre><div class="source-file"><em>object.h</em><br>
add after <em>copyString</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">printObject</span>(<span class="t">Value</span> <span class="i">value</span>);
</pre><pre class="insert-after">

static inline bool isObjType(Value value, ObjType type) {
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after <em>copyString</em>()</div>

<p>L&rsquo;implémentation ressemble à ceci :</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>copyString</em>()</div>
<pre><span class="t">void</span> <span class="i">printObject</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="k">switch</span> (<span class="a">OBJ_TYPE</span>(<span class="i">value</span>)) {
    <span class="k">case</span> <span class="a">OBJ_STRING</span>:
      <span class="i">printf</span>(<span class="s">&quot;%s&quot;</span>, <span class="a">AS_CSTRING</span>(<span class="i">value</span>));
      <span class="k">break</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>copyString</em>()</div>

<p>Nous n&rsquo;avons qu&rsquo;un seul type d&rsquo;objet maintenant, mais cette fonction germera des cas switch additionnels dans les chapitres ultérieurs. Pour les objets chaîne, elle <span name="term-2">imprime</span> simplement le tableau de caractères comme une chaîne C.</p>
<aside name="term-2">
<p>Je vous avais dit que terminer la chaîne deviendrait utile.</p>
</aside>
<p>Les opérateurs d&rsquo;égalité ont aussi besoin de gérer avec grâce les chaînes. Considérez :</p>
<div class="codehilite"><pre><span class="s">&quot;string&quot;</span> == <span class="s">&quot;string&quot;</span>
</pre></div>
<p>Ce sont deux littéraux chaîne séparés. Le compilateur fera deux appels séparés à <code>copyString()</code>, créera deux objets ObjString distincts et les stockera comme deux constantes dans le morceau. Ce sont des objets différents dans le tas. Mais nos utilisateurs (et donc nous) s&rsquo;attendent à ce que les chaînes aient une égalité de valeur. L&rsquo;expression ci-dessus devrait évaluer à <code>true</code>. Cela exige un petit support spécial.</p>
<div class="codehilite"><pre class="insert-before">    case VAL_NUMBER: return AS_NUMBER(a) == AS_NUMBER(b);
</pre><div class="source-file"><em>value.c</em><br>
in <em>valuesEqual</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">VAL_OBJ</span>: {
      <span class="t">ObjString</span>* <span class="i">aString</span> = <span class="a">AS_STRING</span>(<span class="i">a</span>);
      <span class="t">ObjString</span>* <span class="i">bString</span> = <span class="a">AS_STRING</span>(<span class="i">b</span>);
      <span class="k">return</span> <span class="i">aString</span>-&gt;<span class="i">length</span> == <span class="i">bString</span>-&gt;<span class="i">length</span> &amp;&amp;
          <span class="i">memcmp</span>(<span class="i">aString</span>-&gt;<span class="i">chars</span>, <span class="i">bString</span>-&gt;<span class="i">chars</span>,
                 <span class="i">aString</span>-&gt;<span class="i">length</span>) == <span class="n">0</span>;
    }
</pre><pre class="insert-after">    default:         return false; // Unreachable.
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, in <em>valuesEqual</em>()</div>

<p>Si les deux valeurs sont toutes deux des chaînes, alors elles sont égales si leurs tableaux de caractères contiennent les mêmes caractères, indépendamment de si elles sont deux objets séparés ou exactement le même. Cela signifie bien que l&rsquo;égalité de chaîne est plus lente que l&rsquo;égalité sur les autres types puisqu&rsquo;elle doit parcourir la chaîne entière. Nous réviserons cela <a href="tables-de-hachage.html">plus tard</a>, mais cela nous donne la bonne sémantique pour l&rsquo;instant.</p>
<p>Finalement, afin d&rsquo;utiliser <code>memcmp()</code> et les nouveaux trucs dans le module &ldquo;object&rdquo;, nous avons besoin d&rsquo;une couple d&rsquo;includes. Ici :</p>
<div class="codehilite"><pre class="insert-before">#include &lt;stdio.h&gt;
</pre><div class="source-file"><em>value.c</em></div>
<pre class="insert"><span class="a">#include &lt;string.h&gt;</span>
</pre><pre class="insert-after">

#include &quot;memory.h&quot;
</pre></div>
<div class="source-file-narrow"><em>value.c</em></div>

<p>Et ici :</p>
<div class="codehilite"><pre class="insert-before">#include &lt;string.h&gt;

</pre><div class="source-file"><em>value.c</em></div>
<pre class="insert"><span class="a">#include &quot;object.h&quot;</span>
</pre><pre class="insert-after">#include &quot;memory.h&quot;
</pre></div>
<div class="source-file-narrow"><em>value.c</em></div>

<h3><a href="#concaténation" id="concaténation"><small>19&#8202;.&#8202;4&#8202;.&#8202;1</small>Concaténation</a></h3>
<p>Les langages adultes fournissent beaucoup d&rsquo;opérations pour travailler avec les chaînes<span class="em">&mdash;</span>accès aux caractères individuels, la longueur de la chaîne, changer la casse, diviser, joindre, chercher, etc. Quand vous implémentez votre langage, vous voudrez probablement tout ça. Mais pour ce livre, nous gardons les choses <em>très</em> minimales.</p>
<p>La seule opération intéressante que nous supportons sur les chaînes est <code>+</code>. Si vous utilisez cet opérateur sur deux objets chaîne, il produit une nouvelle chaîne qui est une concaténation des deux opérandes. Puisque Lox est dynamiquement typé, nous ne pouvons pas dire quel comportement est nécessaire à la compilation parce que nous ne connaissons pas les types des opérandes avant l&rsquo;exécution. Ainsi, l&rsquo;instruction <code>OP_ADD</code> inspecte dynamiquement les opérandes et choisit la bonne opération.</p>
<div class="codehilite"><pre class="insert-before">      case OP_LESS:     BINARY_OP(BOOL_VAL, &lt;); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_ADD</span>: {
        <span class="k">if</span> (<span class="a">IS_STRING</span>(<span class="i">peek</span>(<span class="n">0</span>)) &amp;&amp; <span class="a">IS_STRING</span>(<span class="i">peek</span>(<span class="n">1</span>))) {
          <span class="i">concatenate</span>();
        } <span class="k">else</span> <span class="k">if</span> (<span class="a">IS_NUMBER</span>(<span class="i">peek</span>(<span class="n">0</span>)) &amp;&amp; <span class="a">IS_NUMBER</span>(<span class="i">peek</span>(<span class="n">1</span>))) {
          <span class="t">double</span> <span class="i">b</span> = <span class="a">AS_NUMBER</span>(<span class="i">pop</span>());
          <span class="t">double</span> <span class="i">a</span> = <span class="a">AS_NUMBER</span>(<span class="i">pop</span>());
          <span class="i">push</span>(<span class="a">NUMBER_VAL</span>(<span class="i">a</span> + <span class="i">b</span>));
        } <span class="k">else</span> {
          <span class="i">runtimeError</span>(
              <span class="s">&quot;Operands must be two numbers or two strings.&quot;</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_SUBTRACT: BINARY_OP(NUMBER_VAL, -); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>Si les deux opérandes sont des chaînes, il concatène. S&rsquo;ils sont tous deux des nombres, il les additionne. Toute autre <span name="convert">combinaison</span> de types d&rsquo;opérande est une erreur d&rsquo;exécution.</p>
<aside name="convert" class="bottom">
<p>C&rsquo;est plus conservateur que la plupart des langages. Dans d&rsquo;autres langages, si un opérande est une chaîne, l&rsquo;autre peut être n&rsquo;importe quel type et il sera implicitement converti en une chaîne avant de concaténer les deux.</p>
<p>Je pense que c&rsquo;est une fonctionnalité correcte, mais exigerait d&rsquo;écrire du code fastidieux &ldquo;convertir en chaîne&rdquo; pour chaque type, donc je l&rsquo;ai laissée hors de Lox.</p>
</aside>
<p>Pour concaténer des chaînes, nous définissons une nouvelle fonction.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>isFalsey</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">concatenate</span>() {
  <span class="t">ObjString</span>* <span class="i">b</span> = <span class="a">AS_STRING</span>(<span class="i">pop</span>());
  <span class="t">ObjString</span>* <span class="i">a</span> = <span class="a">AS_STRING</span>(<span class="i">pop</span>());

  <span class="t">int</span> <span class="i">length</span> = <span class="i">a</span>-&gt;<span class="i">length</span> + <span class="i">b</span>-&gt;<span class="i">length</span>;
  <span class="t">char</span>* <span class="i">chars</span> = <span class="a">ALLOCATE</span>(<span class="t">char</span>, <span class="i">length</span> + <span class="n">1</span>);
  <span class="i">memcpy</span>(<span class="i">chars</span>, <span class="i">a</span>-&gt;<span class="i">chars</span>, <span class="i">a</span>-&gt;<span class="i">length</span>);
  <span class="i">memcpy</span>(<span class="i">chars</span> + <span class="i">a</span>-&gt;<span class="i">length</span>, <span class="i">b</span>-&gt;<span class="i">chars</span>, <span class="i">b</span>-&gt;<span class="i">length</span>);
  <span class="i">chars</span>[<span class="i">length</span>] = <span class="s">&#39;\0&#39;</span>;

  <span class="t">ObjString</span>* <span class="i">result</span> = <span class="i">takeString</span>(<span class="i">chars</span>, <span class="i">length</span>);
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">result</span>));
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>isFalsey</em>()</div>

<p>Elle est assez verbeuse, comme le code C qui travaille avec les chaînes tend à être. D&rsquo;abord, nous calculons la longueur de la chaîne résultat basée sur les longueurs des opérandes. Nous allouons un tableau de caractères pour le résultat et ensuite copions les deux moitiés dedans. Comme toujours, nous assurons soigneusement que la chaîne est terminée.</p>
<p>Afin d&rsquo;appeler <code>memcpy()</code>, la VM a besoin d&rsquo;un include.</p>
<div class="codehilite"><pre class="insert-before">#include &lt;stdio.h&gt;
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert"><span class="a">#include &lt;string.h&gt;</span>
</pre><pre class="insert-after">

#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>

<p>Finalement, nous produisons un ObjString pour contenir ces caractères. Cette fois nous utilisons une nouvelle fonction, <code>takeString()</code>.</p>
<div class="codehilite"><pre class="insert-before">};

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjString</em></div>
<pre class="insert"><span class="t">ObjString</span>* <span class="i">takeString</span>(<span class="t">char</span>* <span class="i">chars</span>, <span class="t">int</span> <span class="i">length</span>);
</pre><pre class="insert-after">ObjString* copyString(const char* chars, int length);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>

<p>L&rsquo;implémentation ressemble à ceci :</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>allocateString</em>()</div>
<pre><span class="t">ObjString</span>* <span class="i">takeString</span>(<span class="t">char</span>* <span class="i">chars</span>, <span class="t">int</span> <span class="i">length</span>) {
  <span class="k">return</span> <span class="i">allocateString</span>(<span class="i">chars</span>, <span class="i">length</span>);
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateString</em>()</div>

<p>La fonction <code>copyString()</code> précédente suppose qu&rsquo;elle ne <em>peut pas</em> prendre la propriété des caractères que vous passez dedans. Au lieu de cela, elle crée de manière conservatrice une copie des caractères sur le tas que l&rsquo;ObjString peut posséder. C&rsquo;est la bonne chose pour les littéraux chaîne où les caractères passés sont au milieu de la chaîne source.</p>
<p>Mais, pour la concaténation, nous avons déjà alloué dynamiquement un tableau de caractères sur le tas. Faire une autre copie de cela serait redondant (et signifierait que <code>concatenate()</code> doit se souvenir de libérer sa copie). Au lieu de cela, cette fonction réclame la propriété de la chaîne que vous lui donnez.</p>
<p>Comme d&rsquo;habitude, coudre cette fonctionnalité ensemble exige une couple d&rsquo;includes.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;debug.h&quot;
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert"><span class="a">#include &quot;object.h&quot;</span>
<span class="a">#include &quot;memory.h&quot;</span>
</pre><pre class="insert-after">#include &quot;vm.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>

<h2><a href="#libérer-les-objets" id="libérer-les-objets"><small>19&#8202;.&#8202;5</small>Libérer les Objets</a></h2>
<p>Contemplez cette expression à l&rsquo;apparence inoffensive :</p>
<div class="codehilite"><pre><span class="s">&quot;st&quot;</span> + <span class="s">&quot;ri&quot;</span> + <span class="s">&quot;ng&quot;</span>
</pre></div>
<p>Quand le compilateur mâche à travers ceci, il alloue un ObjString pour chacun de ces trois littéraux chaîne et les stocke dans la table de constantes du morceau et génère ce <span name="stack">bytecode</span> :</p>
<aside name="stack">
<p>Voici à quoi ressemble la pile après chaque instruction :</p><img src="image/strings/stack.png" alt="L'état de la pile à chaque instruction." />
</aside>
<div class="codehilite"><pre>0000    OP_CONSTANT         0 &quot;st&quot;
0002    OP_CONSTANT         1 &quot;ri&quot;
0004    OP_ADD
0005    OP_CONSTANT         2 &quot;ng&quot;
0007    OP_ADD
0008    OP_RETURN
</pre></div>
<p>Les deux premières instructions poussent <code>"st"</code> et <code>"ri"</code> sur la pile. Ensuite l&rsquo;<code>OP_ADD</code> dépile ceux-ci et les concatène. Cela alloue dynamiquement une nouvelle chaîne <code>"stri"</code> sur le tas. La VM pousse cela et ensuite pousse la constante <code>"ng"</code>. Le dernier <code>OP_ADD</code> dépile <code>"stri"</code> et <code>"ng"</code>, les concatène, et pousse le résultat : <code>"string"</code>. Super, c&rsquo;est ce que nous attendons.</p>
<p>Mais, attendez. Qu&rsquo;est-ce qui est arrivé à cette chaîne <code>"stri"</code> ? Nous l&rsquo;avons allouée dynamiquement, ensuite la VM l&rsquo;a jetée après l&rsquo;avoir concaténée avec <code>"ng"</code>. Nous l&rsquo;avons dépilée de la pile et n&rsquo;avons plus de référence vers elle, mais nous n&rsquo;avons jamais libéré sa mémoire. Nous avons nous-mêmes une fuite de mémoire classique.</p>
<p>Bien sûr, il est parfaitement correct pour le <em>programme Lox</em> d&rsquo;oublier les chaînes intermédiaires et de ne pas s&rsquo;inquiéter de les libérer. Lox gère automatiquement la mémoire pour le compte de l&rsquo;utilisateur. La responsabilité de gérer la mémoire ne <em>disparaît</em> pas. Au lieu de cela, elle tombe sur nos épaules en tant qu&rsquo;implémenteurs de VM.</p>
<p>La <span name="borrowed">solution</span> complète est un <a href="ramasse-miettes.html">ramasse-miettes</a> qui récupère la mémoire inutilisée pendant que le programme tourne. Nous avons d&rsquo;autres trucs à mettre en place avant que nous soyons prêts à tacler ce projet. Jusque-là, nous vivons sur du temps emprunté. Plus nous attendons pour ajouter le collecteur, plus il est dur à faire.</p>
<aside name="borrowed">
<p>J&rsquo;ai vu un certain nombre de gens implémenter de larges pans de leur langage avant d&rsquo;essayer de commencer sur le GC. Pour le genre de programmes jouets que vous lancez typiquement pendant qu&rsquo;un langage est développé, vous ne tombez en fait pas à court de mémoire avant d&rsquo;atteindre la fin du programme, donc cela vous mène étonnamment loin.</p>
<p>Mais cela sous-estime combien il est <em>dur</em> d&rsquo;ajouter un ramasse-miettes plus tard. Le collecteur <em>doit</em> assurer qu&rsquo;il peut trouver chaque bout de mémoire qui <em>est</em> encore utilisé de sorte qu&rsquo;il ne collecte pas des données vivantes. Il y a des centaines d&rsquo;endroits où une implémentation de langage peut écureuiller une référence vers quelque objet. Si vous ne les trouvez pas tous, vous obtenez des bugs cauchemardesques.</p>
<p>J&rsquo;ai vu des implémentations de langage mourir parce qu&rsquo;il était trop dur de mettre le GC dedans plus tard. Si votre langage a besoin d&rsquo;un GC, faites-le marcher aussi tôt que vous pouvez. C&rsquo;est une préoccupation transverse qui touche la base de code entière.</p>
</aside>
<p>Aujourd&rsquo;hui, nous devrions au moins faire le strict minimum : éviter de <em>fuiter</em> de la mémoire en nous assurant que la VM peut toujours trouver chaque objet alloué même si le programme Lox lui-même ne les référence plus. Il y a beaucoup de techniques sophistiquées que les gestionnaires de mémoire avancés utilisent pour allouer et suivre la mémoire pour les objets. Nous allons prendre l&rsquo;approche pratique la plus simple.</p>
<p>Nous créerons une liste chaînée qui stocke chaque Obj. La VM peut traverser cette liste pour trouver chaque objet unique qui a été alloué sur le tas, que le programme de l&rsquo;utilisateur ou la pile de la VM ait encore une référence vers lui ou non.</p>
<p>Nous pourrions définir une struct de nœud de liste chaînée séparée mais alors nous aurions à allouer ceux-là aussi. Au lieu de cela, nous utiliserons une <strong>liste intrusive</strong><span class="em">&mdash;</span>la struct Obj elle-même sera le nœud de liste chaînée. Chaque Obj obtient un pointeur vers le prochain Obj dans la chaîne.</p>
<div class="codehilite"><pre class="insert-before">struct Obj {
  ObjType type;
</pre><div class="source-file"><em>object.h</em><br>
in struct <em>Obj</em></div>
<pre class="insert">  <span class="k">struct</span> <span class="t">Obj</span>* <span class="i">next</span>;
</pre><pre class="insert-after">};
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>Obj</em></div>

<p>La VM stocke un pointeur vers la tête de la liste.</p>
<div class="codehilite"><pre class="insert-before">  Value* stackTop;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">Obj</span>* <span class="i">objects</span>;
</pre><pre class="insert-after">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>Quand nous initialisons la VM pour la première fois, il n&rsquo;y a pas d&rsquo;objets alloués.</p>
<div class="codehilite"><pre class="insert-before">  resetStack();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">  <span class="i">vm</span>.<span class="i">objects</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>Chaque fois que nous allouons un Obj, nous l&rsquo;insérons dans la liste.</p>
<div class="codehilite"><pre class="insert-before">  object-&gt;type = type;
</pre><div class="source-file"><em>object.c</em><br>
in <em>allocateObject</em>()</div>
<pre class="insert">

  <span class="i">object</span>-&gt;<span class="i">next</span> = <span class="i">vm</span>.<span class="i">objects</span>;
  <span class="i">vm</span>.<span class="i">objects</span> = <span class="i">object</span>;
</pre><pre class="insert-after">  return object;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>allocateObject</em>()</div>

<p>Puisque c&rsquo;est une liste chaînée simple, l&rsquo;endroit le plus facile pour l&rsquo;insérer est comme la tête. De cette façon, nous n&rsquo;avons pas besoin de stocker aussi un pointeur vers la queue et de le garder à jour.</p>
<p>Le module &ldquo;object&rdquo; utilise directement la variable globale <code>vm</code> du module &ldquo;vm&rdquo;, donc nous avons besoin d&rsquo;exposer ça extérieurement.</p>
<div class="codehilite"><pre class="insert-before">} InterpretResult;

</pre><div class="source-file"><em>vm.h</em><br>
add after enum <em>InterpretResult</em></div>
<pre class="insert"><span class="k">extern</span> <span class="a">VM</span> <span class="i">vm</span>;

</pre><pre class="insert-after">void initVM();
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after enum <em>InterpretResult</em></div>

<p>Éventuellement, le ramasse-miettes libérera la mémoire alors que la VM tourne encore. Mais, même alors, il y aura habituellement des objets inutilisés traînant encore en mémoire quand le programme de l&rsquo;utilisateur termine. La VM devrait libérer ceux-là aussi.</p>
<p>Il n&rsquo;y a pas de logique sophistiquée pour cela. Une fois que le programme est fini, nous pouvons libérer <em>chaque</em> objet. Nous pouvons et devrions implémenter cela maintenant.</p>
<div class="codehilite"><pre class="insert-before">void freeVM() {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>freeVM</em>()</div>
<pre class="insert">  <span class="i">freeObjects</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>freeVM</em>()</div>

<p>Cette fonction vide que nous avons définie <a href="machine-virtuelle.html#une-machine-d-exécution-d-instruction">il y a longtemps</a> fait finalement quelque chose ! Elle appelle ceci :</p>
<div class="codehilite"><pre class="insert-before">void* reallocate(void* pointer, size_t oldSize, size_t newSize);
</pre><div class="source-file"><em>memory.h</em><br>
add after <em>reallocate</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">freeObjects</span>();
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>memory.h</em>, add after <em>reallocate</em>()</div>

<p>Voici comment nous libérons les objets :</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
add after <em>reallocate</em>()</div>
<pre><span class="t">void</span> <span class="i">freeObjects</span>() {
  <span class="t">Obj</span>* <span class="i">object</span> = <span class="i">vm</span>.<span class="i">objects</span>;
  <span class="k">while</span> (<span class="i">object</span> != <span class="a">NULL</span>) {
    <span class="t">Obj</span>* <span class="i">next</span> = <span class="i">object</span>-&gt;<span class="i">next</span>;
    <span class="i">freeObject</span>(<span class="i">object</span>);
    <span class="i">object</span> = <span class="i">next</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>reallocate</em>()</div>

<p>C&rsquo;est une implémentation de manuel de CS 101 de parcourir une liste chaînée et de libérer ses nœuds. Pour chaque nœud, nous appelons :</p>
<div class="codehilite"><div class="source-file"><em>memory.c</em><br>
add after <em>reallocate</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">freeObject</span>(<span class="t">Obj</span>* <span class="i">object</span>) {
  <span class="k">switch</span> (<span class="i">object</span>-&gt;<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">OBJ_STRING</span>: {
      <span class="t">ObjString</span>* <span class="i">string</span> = (<span class="t">ObjString</span>*)<span class="i">object</span>;
      <span class="a">FREE_ARRAY</span>(<span class="t">char</span>, <span class="i">string</span>-&gt;<span class="i">chars</span>, <span class="i">string</span>-&gt;<span class="i">length</span> + <span class="n">1</span>);
      <span class="a">FREE</span>(<span class="t">ObjString</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>reallocate</em>()</div>

<p>Nous ne libérons pas seulement l&rsquo;Obj lui-même. Puisque certains types d&rsquo;objet allouent aussi d&rsquo;autre mémoire qu&rsquo;ils possèdent, nous avons aussi besoin d&rsquo;un peu de code spécifique au type pour gérer les besoins spéciaux de chaque type d&rsquo;objet. Ici, cela signifie que nous libérons le tableau de caractères et ensuite libérons l&rsquo;ObjString. Ceux-ci utilisent tous deux une dernière macro de gestion de la mémoire.</p>
<div class="codehilite"><pre class="insert-before">    (type*)reallocate(NULL, 0, sizeof(type) * (count))
</pre><div class="source-file"><em>memory.h</em></div>
<pre class="insert">

<span class="a">#define FREE(type, pointer) reallocate(pointer, sizeof(type), 0)</span>
</pre><pre class="insert-after">

#define GROW_CAPACITY(capacity) \
</pre></div>
<div class="source-file-narrow"><em>memory.h</em></div>

<p>C&rsquo;est un minuscule <span name="free">emballage</span> autour de <code>reallocate()</code> qui &ldquo;redimensionne&rdquo; une allocation à zéro octet.</p>
<aside name="free">
<p>Utiliser <code>reallocate()</code> pour libérer de la mémoire pourrait sembler inutile. Pourquoi ne pas juste appeler <code>free()</code> ? Plus tard, cela aidera la VM à suivre combien de mémoire est encore utilisée. Si toute allocation et libération passe par <code>reallocate()</code>, il est facile de garder un compte courant du nombre d&rsquo;octets de mémoire allouée.</p>
</aside>
<p>Comme d&rsquo;habitude, nous avons besoin d&rsquo;un include pour câbler tout ensemble.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;
</pre><div class="source-file"><em>memory.h</em></div>
<pre class="insert"><span class="a">#include &quot;object.h&quot;</span>
</pre><pre class="insert-after">

#define ALLOCATE(type, count) \
</pre></div>
<div class="source-file-narrow"><em>memory.h</em></div>

<p>Ensuite dans le fichier d&rsquo;implémentation :</p>
<div class="codehilite"><pre class="insert-before">#include &quot;memory.h&quot;
</pre><div class="source-file"><em>memory.c</em></div>
<pre class="insert"><span class="a">#include &quot;vm.h&quot;</span>
</pre><pre class="insert-after">

void* reallocate(void* pointer, size_t oldSize, size_t newSize) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em></div>

<p>Avec ceci, notre VM ne fuite plus de mémoire. Comme un bon programme C, elle nettoie son désordre avant de quitter. Mais elle ne libère aucuns objets pendant que la VM tourne. Plus tard, quand il sera possible d&rsquo;écrire des programmes Lox plus longs, la VM mangera de plus en plus de mémoire alors qu&rsquo;elle va, ne relâchant pas un seul octet jusqu&rsquo;à ce que le programme entier soit fini.</p>
<p>Nous n&rsquo;adresserons pas cela jusqu&rsquo;à ce que nous ayons ajouté <a href="ramasse-miettes.html">un vrai ramasse-miettes</a>, mais c&rsquo;est une grande étape. Nous avons maintenant l&rsquo;infrastructure pour supporter une variété de différentes sortes d&rsquo;objets alloués dynamiquement. Et nous avons utilisé cela pour ajouter les chaînes à clox, l&rsquo;un des types les plus utilisés dans la plupart des langages de programmation. Les chaînes à leur tour nous permettent de construire un autre type de données fondamental, spécialement dans les langages dynamiques : la vénérable <a href="tables-de-hachage.html">table de hachage</a>. Mais c&rsquo;est pour le prochain chapitre<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>19&#8202;.&#8202;6</small>Défis</a></h2>
<ol>
<li>
<p>Chaque chaîne exige deux allocations dynamiques séparées<span class="em">&mdash;</span>une pour l&rsquo;ObjString et une seconde pour le tableau de caractères. Accéder aux caractères depuis une valeur exige deux indirections de pointeur, ce qui peut être mauvais pour la performance. Une solution plus efficace repose sur une technique appelée <strong><a href="https://en.wikipedia.org/wiki/Flexible_array_member">membres de tableau flexibles</a></strong>. Utilisez cela pour stocker l&rsquo;ObjString et son tableau de caractères dans une allocation contiguë unique.</p>
</li>
<li>
<p>Quand nous créons l&rsquo;ObjString pour chaque littéral chaîne, nous copions les caractères sur le tas. De cette façon, quand la chaîne est plus tard libérée, nous savons qu&rsquo;il est sûr de libérer les caractères aussi.</p>
<p>C&rsquo;est une approche plus simple mais gaspille un peu de mémoire, ce qui pourrait être un problème sur des appareils très contraints. Au lieu de cela, nous pourrions garder une trace de quels ObjStrings possèdent leur tableau de caractères et lesquels sont des &ldquo;chaînes constantes&rdquo; qui pointent juste en retour vers la chaîne source originale ou quelque autre emplacement non libérable. Ajoutez le support pour cela.</p>
</li>
<li>
<p>Si Lox était votre langage, que lui feriez-vous faire quand un utilisateur essaie d&rsquo;utiliser <code>+</code> avec un opérande chaîne et l&rsquo;autre d&rsquo;un autre type ? Justifiez votre choix. Que font d&rsquo;autres langages ?</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--encodage-de-chaîne" id="note-de-conception--encodage-de-chaîne"><small>19&#8202;.&#8202;7</small>Note de Conception : Encodage de Chaîne</a></h2>
<p>Dans ce livre, j&rsquo;essaie de ne pas fuir les problèmes gnagnus que vous rencontrerez dans une vraie implémentation de langage. Nous pourrions ne pas toujours utiliser la solution la plus <em>sophistiquée</em><span class="em">&mdash;</span>c&rsquo;est un livre d&rsquo;intro après tout<span class="em">&mdash;</span>mais je ne pense pas qu&rsquo;il soit honnête de prétendre que le problème n&rsquo;existe pas du tout. Cependant, j&rsquo;ai contourné une énigme vraiment méchante : décider comment représenter les chaînes.</p>
<p>Il y a deux facettes à un encodage de chaîne :</p>
<ul>
<li>
<p><strong>Qu&rsquo;est-ce qu&rsquo;un &ldquo;caractère&rdquo; unique dans une chaîne ?</strong> Combien de valeurs différentes y a-t-il et que représentent-elles ? La première réponse standard largement adoptée à cela était <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>. Il vous donnait 127 valeurs de caractères différentes et spécifiait ce qu&rsquo;elles étaient. C&rsquo;était génial<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>si vous ne vous souciez que de l&rsquo;anglais. Bien qu&rsquo;il ait des caractères bizarres, la plupart oubliés comme &ldquo;séparateur d&rsquo;enregistrement&rdquo; et &ldquo;attente synchrone&rdquo;, il n&rsquo;a pas un seul trema, aigu, ou grave. Il ne peut pas représenter &ldquo;jalapeño&rdquo;, &ldquo;naïve&rdquo;, <span name="gruyere">&ldquo;Gruyère&rdquo;</span>, ou &ldquo;Mötley Crüe&rdquo;.</p>
<pre><code>&lt;aside name="gruyere"&gt;
</code></pre>
<p>Il va sans dire qu&rsquo;un langage qui ne laisse pas discuter de Gruyère ou de Mötley Crüe est un langage qui ne vaut pas la peine d&rsquo;être utilisé.</p>
<pre><code>&lt;/aside&gt;
</code></pre>
<p>Ensuite vint <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>. Initialement, il supportait 16 384 caractères différents (<strong>points de code</strong>), qui tenaient joliment dans 16 bits avec une couple de bits à épargner. Plus tard cela a grandi et grandi, et maintenant il y a bien plus de 100 000 points de code différents incluant de tels instruments vitaux de communication humaine comme 💩 (Caractère Unicode &lsquo;TAS DE CACA&rsquo;, <code>U+1F4A9</code>).</p>
<p>Même cette longue liste de points de code n&rsquo;est pas suffisante pour représenter chaque glyphe visible possible qu&rsquo;un langage pourrait supporter. Pour gérer cela, Unicode a aussi des <strong>caractères combinants</strong> qui modifient un point de code précédent. Par exemple, &ldquo;a&rdquo; suivi par le caractère combinant &ldquo;¨&rdquo; vous donne &ldquo;ä&rdquo;. (Pour rendre les choses plus confuses Unicode a <em>aussi</em> un point de code unique qui ressemble à &ldquo;ä&rdquo;.)</p>
<p>Si un utilisateur accède au quatrième &ldquo;caractère&rdquo; dans &ldquo;naïve&rdquo;, s&rsquo;attend-il à récupérer &ldquo;v&rdquo; ou &ldquo;¨&rdquo; ? Le premier signifie qu&rsquo;ils pensent à chaque point de code et son caractère combinant comme une unité unique<span class="em">&mdash;</span>ce que Unicode appelle un <strong>amas de graphèmes étendu</strong><span class="em">&mdash;</span>le dernier signifie qu&rsquo;ils pensent en points de code individuels. Auquel vos utilisateurs s&rsquo;attendent-ils ?</p>
</li>
<li>
<p><strong>Comment une unité unique est-elle représentée en mémoire ?</strong> La plupart des systèmes utilisant ASCII donnaient un octet unique à chaque caractère et laissaient le bit haut inutilisé. Unicode a une poignée d&rsquo;encodages communs. UTF-16 empaquette la plupart des points de code dans 16 bits. C&rsquo;était génial quand chaque point de code tenait dans cette taille. Quand cela a débordé, ils ont ajouté des <em>paires de substitution</em> qui utilisent de multiples unités de code de 16 bits pour représenter un point de code unique. UTF-32 est la prochaine évolution de UTF-16<span class="em">&mdash;</span>il donne un plein 32 bits à chaque point de code.</p>
<p>UTF-8 est plus complexe que l&rsquo;un ou l&rsquo;autre de ceux-ci. Il utilise un nombre variable d&rsquo;octets pour encoder un point de code. Les points de code de valeur plus basse tiennent dans moins d&rsquo;octets. Puisque chaque caractère peut occuper un nombre différent d&rsquo;octets, vous ne pouvez pas directement indexer dans la chaîne pour trouver un point de code spécifique. Si vous voulez, disons, le 10ème point de code, vous ne savez pas à combien d&rsquo;octets dans la chaîne c&rsquo;est sans marcher et décoder tous les précédents.</p>
</li>
</ul>
<p>Choisir une représentation de caractère et un encodage implique des compromis fondamentaux. Comme beaucoup de choses en ingénierie, il n&rsquo;y a pas de solution <span name="python">parfaite</span> :</p>
<aside name="python">
<p>Un exemple de combien ce problème est difficile vient de Python. La transition douloureusement longue de Python 2 à 3 est pénible surtout à cause de ses changements autour de l&rsquo;encodage de chaîne.</p>
</aside>
<ul>
<li>
<p>ASCII est efficace en mémoire et rapide, mais il jette les langages non-latins sur le côté.</p>
</li>
<li>
<p>UTF-32 est rapide et supporte toute la plage Unicode, mais gaspille beaucoup de mémoire étant donné que la plupart des points de code tendent à être dans la plage basse de valeurs, où un plein 32 bits n&rsquo;est pas nécessaire.</p>
</li>
<li>
<p>UTF-8 est efficace en mémoire et supporte toute la plage Unicode, mais son encodage à longueur variable le rend lent pour accéder à des points de code arbitraires.</p>
</li>
<li>
<p>UTF-16 est pire que tous ceux-là<span class="em">&mdash;</span>une conséquence laide d&rsquo;Unicode dépassant sa plage 16-bit antérieure. Il est moins efficace en mémoire que UTF-8 mais est toujours un encodage à longueur variable grâce aux paires de substitution. Évitez-le si vous pouvez. Hélas, si votre langage a besoin de tourner sur ou d&rsquo;interopérer avec le navigateur, la JVM, ou le CLR, vous pourriez être coincé avec, puisque ceux-ci utilisent tous UTF-16 pour leurs chaînes et vous ne voulez pas avoir à convertir chaque fois que vous passez une chaîne au système sous-jacent.</p>
</li>
</ul>
<p>Une option est de prendre l&rsquo;approche maximale et de faire la chose la &ldquo;plus juste&rdquo;. Supporter tous les points de code Unicode. En interne, sélectionner un encodage pour chaque chaîne basé sur son contenu<span class="em">&mdash;</span>utiliser ASCII si chaque point de code tient dans un octet, UTF-16 s&rsquo;il n&rsquo;y a pas de paires de substitution, etc. Fournir des APIs pour laisser les utilisateurs itérer sur à la fois les points de code et les amas de graphèmes étendus.</p>
<p>Cela couvre toutes vos bases mais est vraiment complexe. C&rsquo;est beaucoup à implémenter, déboguer, et optimiser. Quand on sérialise des chaînes ou qu&rsquo;on interopère avec d&rsquo;autres systèmes, vous avez à gérer tous les encodages. Les utilisateurs ont besoin de comprendre les deux APIs d&rsquo;indexation et savoir laquelle utiliser quand. C&rsquo;est l&rsquo;approche que les langages plus récents, gros tendent à prendre<span class="em">&mdash;</span>comme Raku et Swift.</p>
<p>Un compromis plus simple est de toujours encoder en utilisant UTF-8 et seulement exposer une API qui travaille avec les points de code. Pour les utilisateurs qui veulent travailler avec les amas de graphèmes, laissez-les utiliser une bibliothèque tierce pour cela. C&rsquo;est moins Latin-centrique qu&rsquo;ASCII mais pas beaucoup plus complexe. Vous perdez l&rsquo;indexation directe rapide par point de code, mais vous pouvez habituellement vivre sans cela ou vous permettre de le rendre <em>O(n)</em> au lieu de <em>O(1)</em>.</p>
<p>Si je concevais un gros langage de trait pour des gens écrivant de larges applications, j&rsquo;irais probablement avec l&rsquo;approche maximale. Pour mon petit langage de script embarqué <a href="http://wren.io">Wren</a>, je suis allé avec UTF-8 et les points de code.</p>
</div>

<footer>
<a href="tables-de-hachage.html" class="next">
  Next Chapter: &ldquo;Tables de hachage&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
