<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Une carte du territoire &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Une carte du territoire<small>2</small></a></h3>

<ul>
    <li><a href="#les-parties-d’un-langage"><small>2.1</small> Les parties d’un langage</a></li>
    <li><a href="#raccourcis-et-itinéraires-alternatifs"><small>2.2</small> Raccourcis et itinéraires alternatifs</a></li>
    <li><a href="#compilateurs-et-interpréteurs"><small>2.3</small> Compilateurs et interpréteurs</a></li>
    <li><a href="#notre-voyage"><small>2.4</small> Notre voyage</a></li>
    <li><a href="#défis"><small>2.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="introduction.html" title="Introduction" class="left">&larr;&nbsp;Previous</a>
    <a href="bienvenue.html" title="Bienvenue">&uarr;&nbsp;Up</a>
    <a href="le-langage-lox.html" title="Le langage Lox" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="introduction.html" title="Introduction" class="prev">←</a>
<a href="le-langage-lox.html" title="Le langage Lox" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Une carte du territoire<small>2</small></a></h3>

<ul>
    <li><a href="#les-parties-d’un-langage"><small>2.1</small> Les parties d’un langage</a></li>
    <li><a href="#raccourcis-et-itinéraires-alternatifs"><small>2.2</small> Raccourcis et itinéraires alternatifs</a></li>
    <li><a href="#compilateurs-et-interpréteurs"><small>2.3</small> Compilateurs et interpréteurs</a></li>
    <li><a href="#notre-voyage"><small>2.4</small> Notre voyage</a></li>
    <li><a href="#défis"><small>2.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="introduction.html" title="Introduction" class="left">&larr;&nbsp;Previous</a>
    <a href="bienvenue.html" title="Bienvenue">&uarr;&nbsp;Up</a>
    <a href="le-langage-lox.html" title="Le langage Lox" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">2</div>
  <h1>Une carte du territoire</h1>

<blockquote>
<p>Vous devez avoir une carte, même sommaire. Sinon, vous vous promenez partout.<br />
Dans <em>Le Seigneur des Anneaux</em>, je n’ai jamais fait aller quelqu’un plus loin qu’il ne pouvait le faire un jour donné.</p>
<p><cite>J. R. R. Tolkien</cite></p>
</blockquote>
<p>Nous ne voulons pas nous promener partout, donc avant de partir, parcourons le territoire tracé par les implémenteurs de langages précédents.<br />
Cela nous aidera à comprendre où nous allons et les routes alternatives que d’autres ont empruntées.  </p>
<p>Tout d’abord, permettez-moi d’établir une abréviation.<br />
Une grande partie de ce livre traite de l’<em>implémentation</em> d’un langage, ce qui est distinct du <em>langage lui-même</em> dans une sorte de forme idéale platonique.<br />
Des choses comme « pile », « bytecode » et « descente récursive » sont des rouages qu’une implémentation particulière pourrait utiliser.<br />
Du point de vue de l’utilisateur, tant que le mécanisme final suit fidèlement la spécification du langage, ce sont tous des détails d’implémentation.  </p>
<p>Nous allons passer beaucoup de temps sur ces détails, donc si je devais écrire « implémentation de langage » chaque fois que je les mentionne, je m’userais les doigts.<br />
À la place, j’utiliserai « langage » pour désigner soit un langage, soit une implémentation de celui-ci, ou les deux, sauf si la distinction importe.  </p>
<h2><a href="#les-parties-d’un-langage" id="les-parties-d’un-langage"><small>2&#8202;.&#8202;1</small>Les parties d’un langage</a></h2>
<p>Les ingénieurs construisent des langages de programmation depuis les âges sombres de l’informatique.<br />
Dès que nous avons pu parler aux ordinateurs, nous avons découvert que c’était trop difficile, et nous avons sollicité leur aide.<br />
Je trouve fascinant que, même si les machines d’aujourd’hui sont littéralement un million de fois plus rapides et disposent de plusieurs ordres de grandeur de stockage supplémentaires, la manière dont nous construisons les langages de programmation est pratiquement inchangée.  </p>
<p>Bien que la zone explorée par les concepteurs de langages soit vaste, les sentiers qu’ils ont tracés à travers elle sont <span name="dead">peu nombreux</span>.<br />
Tous les langages ne suivent pas exactement le même chemin — certains prennent un ou deux raccourcis — mais sinon, ils sont rassurants similaires, depuis le premier compilateur COBOL de l’amiral Rear Grace Hopper jusqu’à un langage tout chaud et nouveau transpilé vers JavaScript dont la « documentation » consiste entièrement en un seul README mal édité dans un dépôt Git quelque part.  </p>
<aside name="dead">
<p>Il y a certainement des impasses, de tristes petits cul-de-sacs de publications en informatique avec zéro citation et des optimisations aujourd’hui oubliées qui n’avaient de sens que lorsque la mémoire se mesurait en octets individuels.  </p>
</aside>
<p>Je visualise le réseau de chemins qu’une implémentation peut emprunter comme l’ascension d’une montagne.<br />
Vous commencez au bas avec le programme sous forme de texte brut, littéralement juste une chaîne de caractères.<br />
Chaque phase analyse le programme et le transforme en une représentation de plus haut niveau où la sémantique — ce que l’auteur veut que l’ordinateur fasse — devient plus apparente.  </p>
<p>Finalement, nous atteignons le sommet.<br />
Nous avons une vue d’ensemble du programme de l’utilisateur et pouvons voir ce que son code <em>signifie</em>.<br />
Nous commençons notre descente de l’autre côté de la montagne.<br />
Nous transformons cette représentation de plus haut niveau en formes de plus en plus bas niveau pour nous rapprocher de quelque chose que nous savons faire exécuter réellement par le CPU.  </p><img src="image/a-map-of-the-territory/mountain.png" alt="Les chemins bifurquants qu’un langage peut emprunter sur la montagne." class="wide" />
<p>Parcourons chacun de ces sentiers et points d’intérêt.<br />
Notre voyage commence à gauche avec le texte brut du code source de l’utilisateur :</p><img src="image/a-map-of-the-territory/string.png" alt="var average = (min + max) / 2;" />
<h3><a href="#analyse-lexicale" id="analyse-lexicale"><small>2&#8202;.&#8202;1&#8202;.&#8202;1</small>Analyse lexicale</a></h3>
<p>La première étape est <strong>l’analyse lexicale</strong>, aussi appelée <strong>lexing</strong>, ou (si vous essayez d’impressionner quelqu’un) <strong>analyse lexicale</strong>.<br />
Tout cela signifie à peu près la même chose.<br />
J’aime « lexing » parce que cela sonne comme quelque chose qu’un super-vilain maléfique ferait, mais j’utiliserai « analyse lexicale » car cela semble légèrement plus courant.  </p>
<p>Un <strong>scanner</strong> (ou <strong>lexer</strong>) prend le flux linéaire de caractères et les regroupe en une série de quelque chose de plus proche des <span name="word">« mots »</span>.<br />
Dans les langages de programmation, chacun de ces mots est appelé un <strong>token</strong>.<br />
Certains tokens sont des caractères uniques, comme <code>(</code> et <code>,</code>.<br />
D’autres peuvent comporter plusieurs caractères, comme les nombres (<code>123</code>), les littéraux de chaîne (<code>"hi!"</code>) et les identifiants (<code>min</code>).  </p>
<aside name="word">
<p>« Lexical » vient de la racine grecque « lex », qui signifie « mot ».  </p>
</aside>
<p>Certains caractères dans un fichier source ne signifient en réalité rien.<br />
Les espaces sont souvent insignifiants, et les commentaires, par définition, sont ignorés par le langage.<br />
Le scanner les élimine généralement, laissant une séquence propre de tokens significatifs.  </p><img src="image/a-map-of-the-territory/tokens.png" alt="[var] [average] [=] [(] [min] [+] [max] [)] [/] [2] [;]" />
<h3><a href="#analyse-syntaxique" id="analyse-syntaxique"><small>2&#8202;.&#8202;1&#8202;.&#8202;2</small>Analyse syntaxique</a></h3>
<p>L’étape suivante est <strong>l’analyse syntaxique</strong>.<br />
C’est là que notre syntaxe obtient une <strong>grammaire</strong> — la capacité de composer des expressions et instructions plus grandes à partir de parties plus petites.<br />
Avez-vous déjà schématisé des phrases en cours d’anglais ?<br />
Si oui, vous avez fait ce que fait un analyseur syntaxique, sauf que l’anglais possède des milliers et des milliers de « mots-clés » et une corne d’abondance d’ambiguïtés.<br />
Les langages de programmation sont beaucoup plus simples.  </p>
<p>Un <strong>analyseur syntaxique</strong> prend la séquence linéaire de tokens et construit une structure arborescente qui reflète la nature imbriquée de la grammaire.<br />
Ces arbres ont plusieurs noms différents — <strong>arbre de dérivation</strong> ou <strong>arbre syntaxique abstrait</strong> — selon la proximité avec la structure syntaxique brute du langage source.<br />
En pratique, les concepteurs de langages les appellent généralement <strong>arbres syntaxiques</strong>, <strong>AST</strong>, ou souvent simplement <strong>arbres</strong>.  </p><img src="image/a-map-of-the-territory/ast.png" alt="Un arbre syntaxique abstrait." />
<p>L’analyse syntaxique a une longue et riche histoire en informatique, étroitement liée à la communauté de l’intelligence artificielle.<br />
Beaucoup des techniques utilisées aujourd’hui pour analyser les langages de programmation ont été initialement conçues pour analyser les langages <em>humains</em> par des chercheurs en IA qui essayaient de faire parler les ordinateurs avec nous.  </p>
<p>Il s’avère que les langues humaines étaient trop désordonnées pour les grammaires rigides que ces analyseurs pouvaient gérer, mais elles convenaient parfaitement aux grammaires artificielles plus simples des langages de programmation.<br />
Hélas, nous, les humains imparfaits, parvenons encore à utiliser ces grammaires simples de manière incorrecte, donc le travail de l’analyseur inclut également de nous signaler quand nous le faisons en rapportant des <strong>erreurs de syntaxe</strong>.  </p>
<h3><a href="#analyse-statique" id="analyse-statique"><small>2&#8202;.&#8202;1&#8202;.&#8202;3</small>Analyse statique</a></h3>
<p>Les deux premières étapes sont assez similaires pour toutes les implémentations.<br />
Maintenant, les caractéristiques individuelles de chaque langage commencent à entrer en jeu.<br />
À ce stade, nous connaissons la structure syntaxique du code — par exemple quelles expressions sont imbriquées dans lesquelles — mais nous n’en savons pas beaucoup plus.  </p>
<p>Dans une expression comme <code>a + b</code>, nous savons que nous additionnons <code>a</code> et <code>b</code>, mais nous ne savons pas à quoi ces noms font référence.<br />
S’agit-il de variables locales ? Globales ? Où sont-elles définies ?  </p>
<p>Le premier type d’analyse que la plupart des langages effectuent s’appelle <strong>liaison</strong> ou <strong>résolution</strong>.<br />
Pour chaque <strong>identifiant</strong>, nous découvrons où ce nom est défini et relions les deux.<br />
C’est là que le concept de <strong>portée</strong> entre en jeu — la zone du code source où un certain nom peut être utilisé pour faire référence à une certaine déclaration.  </p>
<p>Si le langage est <span name="type">typé statiquement</span>, c’est à ce moment que nous effectuons le contrôle de type.<br />
Une fois que nous savons où <code>a</code> et <code>b</code> sont déclarés, nous pouvons également déterminer leurs types.<br />
Puis, si ces types ne supportent pas d’être additionnés entre eux, nous signalons une <strong>erreur de type</strong>.  </p>
<aside name="type">
<p>Le langage que nous construirons dans ce livre est typé dynamiquement, donc il effectuera son contrôle de type plus tard, à l’exécution.</p>
</aside>
<p>Respirez profondément. Nous avons atteint le sommet de la montagne et une vue panoramique du programme de l’utilisateur.<br />
Toutes ces informations sémantiques visibles depuis l’analyse doivent être stockées quelque part.<br />
Il y a plusieurs endroits où nous pouvons les placer :  </p>
<ul>
<li>
<p>Souvent, elles sont stockées directement comme des <strong>attributs</strong> sur l’arbre syntaxique lui-même — des champs supplémentaires dans les nœuds qui ne sont pas initialisés pendant l’analyse syntaxique mais qui sont remplis plus tard.  </p>
</li>
<li>
<p>Parfois, nous stockons les données dans une table de consultation à côté.<br />
En général, les clés de cette table sont des identifiants — noms de variables et de déclarations.<br />
Dans ce cas, nous l’appelons une <strong>table de symboles</strong> et les valeurs associées à chaque clé indiquent à quoi se réfère cet identifiant.  </p>
</li>
<li>
<p>L’outil de gestion le plus puissant consiste à transformer l’arbre en une toute nouvelle structure de données qui exprime plus directement la sémantique du code.<br />
C’est la section suivante.  </p>
</li>
</ul>
<p>Tout ce qui précède est considéré comme le <strong>front-end</strong> de l’implémentation.<br />
Vous pourriez deviner que tout ce qui suit est le <strong>back-end</strong>, mais non.<br />
À l’époque où les termes « front-end » et « back-end » ont été inventés, les compilateurs étaient beaucoup plus simples.<br />
Des chercheurs ultérieurs ont inventé de nouvelles phases à insérer entre les deux moitiés.<br />
Plutôt que de jeter les anciens termes, William Wulf et ses collègues ont regroupé ces nouvelles phases sous le nom charmant mais spatialement paradoxal de <strong>middle-end</strong>.  </p>
<h3><a href="#représentations-intermédiaires" id="représentations-intermédiaires"><small>2&#8202;.&#8202;1&#8202;.&#8202;4</small>Représentations intermédiaires</a></h3>
<p>Vous pouvez considérer le compilateur comme un pipeline où la tâche de chaque étape est d’organiser les données représentant le code de l’utilisateur de manière à simplifier la mise en œuvre de l’étape suivante.<br />
Le front-end du pipeline est spécifique au langage source dans lequel le programme est écrit.<br />
Le back-end concerne l’architecture finale sur laquelle le programme s’exécutera.  </p>
<p>Au milieu, le code peut être stocké dans une <span name="ir"><strong>représentation intermédiaire</strong></span> (<strong>IR</strong>) qui n’est pas strictement liée ni à la forme source ni à la forme destination (d’où le terme « intermédiaire »).<br />
Au lieu de cela, l’IR agit comme une interface entre ces deux langages.  </p>
<aside name="ir">
<p>Il existe quelques styles d’IR bien établis.<br />
Faites une recherche sur Internet pour « graphe de flux de contrôle », « affectation unique statique », « style de passage de continuation » et « code à trois adresses ».  </p>
</aside>
<p>Cela vous permet de supporter plusieurs langages sources et plateformes cibles avec moins d’effort.<br />
Disons que vous voulez implémenter des compilateurs pour Pascal, C et Fortran, et que vous voulez cibler x86, ARM, et, je ne sais pas, SPARC.<br />
Normalement, cela signifie que vous devez écrire <em>neuf</em> compilateurs complets : Pascal&rarr;x86, C&rarr;ARM, et chaque autre combinaison.  </p>
<p>Une <span name="gcc">représentation intermédiaire partagée</span> réduit cela de façon spectaculaire.<br />
Vous écrivez <em>un</em> front-end pour chaque langage source qui produit l’IR.<br />
Puis <em>un</em> back-end pour chaque architecture cible.<br />
Maintenant, vous pouvez combiner ces éléments pour obtenir toutes les combinaisons.  </p>
<aside name="gcc">
<p>Si vous vous êtes déjà demandé comment <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a> prend en charge tant de langages et architectures différents, comme Modula-3 sur Motorola 68k, vous savez maintenant.<br />
Les front-ends des langages ciblent une poignée d’IR, principalement <a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">GIMPLE</a> et <a href="https://gcc.gnu.org/onlinedocs/gccint/RTL.html">RTL</a>.<br />
Les back-ends cibles, comme celui pour 68k, prennent ensuite ces IR et produisent du code natif.  </p>
</aside>
<p>Il y a une autre grande raison pour laquelle nous pourrions vouloir transformer le code en une forme qui rend la sémantique plus apparente<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h3><a href="#optimisation" id="optimisation"><small>2&#8202;.&#8202;1&#8202;.&#8202;5</small>Optimisation</a></h3>
<p>Une fois que nous comprenons ce que signifie le programme de l&rsquo;utilisateur, nous pouvons le remplacer par un programme différent qui a les <em>mêmes sémantiques</em> mais qui les implémente plus efficacement — nous pouvons <strong>l&rsquo;optimiser</strong>.</p>
<p>Un exemple simple est le <strong>pliage de constantes</strong> : si une expression évalue toujours exactement la même valeur, nous pouvons effectuer l’évaluation à la compilation et remplacer le code de l’expression par son résultat. Si l’utilisateur a tapé ceci :</p>
<div class="codehilite"><pre><span class="i">pennyArea</span> = <span class="n">3.14159</span> * (<span class="n">0.75</span> / <span class="n">2</span>) * (<span class="n">0.75</span> / <span class="n">2</span>);
</pre></div>
<p>Nous pourrions effectuer tous ces calculs dans le compilateur et remplacer le code par :</p>
<div class="codehilite"><pre><span class="i">pennyArea</span> = <span class="n">0.4417860938</span>;
</pre></div>
<p>L’optimisation est une énorme partie du métier des langages de programmation. Beaucoup de hackers de langage passent leur carrière entière ici, tirant chaque goutte de performance possible de leurs compilateurs pour rendre leurs benchmarks légèrement plus rapides. Cela peut devenir une sorte d’obsession.</p>
<p>Nous allons surtout <span name="rathole">sauter par-dessus ce gouffre</span> dans ce livre. Beaucoup de langages à succès ont étonnamment peu d’optimisations à la compilation. Par exemple, Lua et CPython génèrent un code relativement non optimisé et concentrent la majeure partie de leurs efforts de performance sur le temps d’exécution.</p>
<aside name="rathole">
<p>Si vous ne pouvez pas résister à l’envie de mettre un pied dans ce gouffre, quelques mots-clés pour commencer sont « propagation de constantes », « élimination des sous-expressions communes », « mouvement de code invariant dans les boucles », « numérotation globale des valeurs », « réduction de force », « remplacement scalaire des agrégats », « élimination de code mort » et « déroulement de boucle ».</p>
</aside>
<h3><a href="#génération-de-code" id="génération-de-code"><small>2&#8202;.&#8202;1&#8202;.&#8202;6</small>Génération de code</a></h3>
<p>Nous avons appliqué toutes les optimisations possibles au programme de l’utilisateur. La dernière étape consiste à le convertir en une forme que la machine peut réellement exécuter. En d’autres termes, <strong>génération de code</strong> (ou <strong>code gen</strong>), où « code » fait généralement référence au type d’instructions primitives proches de l’assembleur qu’un CPU exécute, et non au type de « code source » qu’un humain voudrait lire.</p>
<p>Enfin, nous sommes dans le <strong>back end</strong>, descendant de l’autre côté de la montagne. À partir de maintenant, notre représentation du code devient de plus en plus primitive, comme une évolution à l’envers, à mesure que nous nous rapprochons de quelque chose que notre machine simple d’esprit peut comprendre.</p>
<p>Nous devons prendre une décision. Générons-nous des instructions pour un CPU réel ou pour un CPU virtuel ? Si nous générons du code machine réel, nous obtenons un exécutable que le système d’exploitation peut charger directement sur la puce. Le code natif est extrêmement rapide, mais le générer demande beaucoup de travail. Les architectures actuelles ont des tas d’instructions, des pipelines complexes et assez de <span name="aad">bagages historiques</span> pour remplir la soute d’un 747.</p>
<p>Parler le langage de la puce signifie également que votre compilateur est lié à une architecture spécifique. Si votre compilateur cible le code machine <a href="https://en.wikipedia.org/wiki/X86">x86</a>, il ne fonctionnera pas sur un appareil <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>. Dès les années 60, pendant l’explosion cambrienne des architectures informatiques, ce manque de portabilité constituait un obstacle réel.</p>
<aside name="aad">
<p>Par exemple, l’instruction <a href="http://www.felixcloutier.com/x86/AAD.html">AAD</a> (« ASCII Adjust AX Before Division ») vous permet d’effectuer une division, ce qui semble utile. Sauf que cette instruction prend, comme opérandes, deux chiffres décimaux codés en binaire empaquetés dans un seul registre 16 bits. Quand avez-vous eu besoin pour la dernière fois du BCD sur une machine 16 bits ?</p>
</aside>
<p>Pour contourner ce problème, des hackers comme Martin Richards et Niklaus Wirth, respectivement de BCPL et Pascal, ont fait en sorte que leurs compilateurs produisent du code pour une machine <em>virtuelle</em>. Au lieu d’instructions pour une puce réelle, ils produisaient du code pour une machine hypothétique et idéalisée. Wirth appelait cela le <strong>p-code</strong> pour <em>portable</em>, mais aujourd’hui, nous l’appelons généralement <strong>bytecode</strong> car chaque instruction est souvent longue d’un seul octet.</p>
<p>Ces instructions synthétiques sont conçues pour correspondre un peu plus étroitement à la sémantique du langage, et ne pas être trop liées aux particularités d’une architecture informatique spécifique et à son bagage historique accumulé. Vous pouvez les considérer comme un encodage binaire dense des opérations bas niveau du langage.</p>
<h3><a href="#machine-virtuelle" id="machine-virtuelle"><small>2&#8202;.&#8202;1&#8202;.&#8202;7</small>Machine virtuelle</a></h3>
<p>Si votre compilateur produit du bytecode, votre travail n’est pas terminé une fois cela fait. Comme aucune puce ne comprend ce bytecode, c’est à vous de le traduire. Là encore, vous avez deux options. Vous pouvez écrire un petit mini-compilateur pour chaque architecture cible qui convertit le bytecode en code natif pour cette machine. Vous devez encore travailler pour <span name="shared">chaque</span> puce que vous supportez, mais cette dernière étape est assez simple et vous permet de réutiliser le reste du pipeline du compilateur sur toutes les machines que vous supportez. Vous utilisez essentiellement votre bytecode comme représentation intermédiaire.</p>
<aside name="shared" class="bottom">
<p>Le principe de base ici est que plus vous poussez le travail spécifique à l’architecture vers le bas dans le pipeline, plus vous pouvez partager les phases précédentes entre architectures.</p>
<p>Il existe cependant une tension. Beaucoup d’optimisations, comme l’allocation de registres et la sélection d’instructions, fonctionnent mieux lorsqu’elles connaissent les forces et les capacités d’une puce spécifique. Déterminer quelles parties de votre compilateur peuvent être partagées et lesquelles devraient être spécifiques à la cible est un art.</p>
</aside>
<p>Ou vous pouvez écrire une <span name="vm"><strong>machine virtuelle</strong></span> (<strong>VM</strong>), un programme qui émule une puce hypothétique supportant votre architecture virtuelle à l’exécution. Exécuter du bytecode dans une VM est plus lent que de le traduire en code natif à l’avance, car chaque instruction doit être simulée à l’exécution à chaque fois qu’elle est exécutée. En retour, vous obtenez simplicité et portabilité. Implémentez votre VM en, par exemple, C, et vous pourrez exécuter votre langage sur n’importe quelle plateforme disposant d’un compilateur C. C’est ainsi que fonctionne le second interpréteur que nous construisons dans ce livre.</p>
<aside name="vm">
<p>Le terme « machine virtuelle » fait également référence à un type différent d’abstraction. Une <strong>machine virtuelle système</strong> émule une plateforme matérielle entière et un système d’exploitation en logiciel. C’est ainsi que vous pouvez jouer à des jeux Windows sur votre machine Linux, et comment les fournisseurs cloud offrent à leurs clients l’expérience utilisateur de contrôler leur propre « serveur » sans avoir besoin d’allouer physiquement des ordinateurs séparés pour chaque utilisateur.</p>
<p>Le type de VM dont nous parlerons dans ce livre sont des <strong>machines virtuelles de langage</strong> ou des <strong>machines virtuelles de processus</strong> si vous voulez être précis.</p>
</aside>
<h3><a href="#exécution" id="exécution"><small>2&#8202;.&#8202;1&#8202;.&#8202;8</small>Exécution</a></h3>
<p>Nous avons enfin transformé le programme de l&rsquo;utilisateur en une forme que nous pouvons exécuter. La dernière étape consiste à le lancer. Si nous l&rsquo;avons compilé en code machine, nous demandons simplement au système d&rsquo;exploitation de charger l&rsquo;exécutable et c&rsquo;est parti. Si nous l&rsquo;avons compilé en bytecode, nous devons démarrer la VM et y charger le programme.</p>
<p>Dans les deux cas, pour tous les langages de bas niveau sauf les plus simples, nous avons généralement besoin de certains services que notre langage fournit pendant que le programme s&rsquo;exécute. Par exemple, si le langage gère automatiquement la mémoire, nous avons besoin d&rsquo;un ramasse-miettes pour récupérer les morceaux inutilisés. Si notre langage supporte les tests &ldquo;instance of&rdquo; pour vérifier quel type d&rsquo;objet nous avons, alors nous avons besoin d&rsquo;une représentation pour suivre le type de chaque objet pendant l&rsquo;exécution.</p>
<p>Tout cela se passe à l&rsquo;exécution, donc on appelle cela, à juste titre, le <strong>runtime</strong>. Dans un langage entièrement compilé, le code implémentant le runtime est directement inséré dans l&rsquo;exécutable résultant. Dans, par exemple, <a href="https://golang.org/">Go</a>, chaque application compilée contient sa propre copie du runtime de Go directement intégrée. Si le langage s&rsquo;exécute à l&rsquo;intérieur d&rsquo;un interpréteur ou d&rsquo;une VM, alors le runtime y vit. C&rsquo;est ainsi que fonctionnent la plupart des implémentations de langages comme Java, Python et JavaScript.</p>
<h2><a href="#raccourcis-et-itinéraires-alternatifs" id="raccourcis-et-itinéraires-alternatifs"><small>2&#8202;.&#8202;2</small>Raccourcis et itinéraires alternatifs</a></h2>
<p>Voilà le long chemin couvrant toutes les phases possibles que vous pourriez implémenter. Beaucoup de langages parcourent tout le chemin, mais il existe quelques raccourcis et chemins alternatifs.</p>
<h3><a href="#compilateurs-&agrave;-passage-unique" id="compilateurs-&agrave;-passage-unique"><small>2&#8202;.&#8202;2&#8202;.&#8202;1</small>Compilateurs &agrave; passage unique</a></h3>
<p>Certains compilateurs simples intercalent analyse syntaxique, analyse sémantique et génération de code pour produire directement du code de sortie dans le parseur, sans jamais allouer d&rsquo;arbres syntaxiques ou d&rsquo;autres IR. Ces <span name="sdt"><strong>compilateurs à passage unique</strong></span> restreignent la conception du langage. Vous n&rsquo;avez pas de structures de données intermédiaires pour stocker des informations globales sur le programme, et vous ne revisitez aucune partie déjà analysée du code. Cela signifie qu&rsquo;au moment où vous voyez une expression, vous devez en savoir assez pour la compiler correctement.</p>
<aside name="sdt">
<p><a href="https://en.wikipedia.org/wiki/Syntax-directed_translation"><strong>Traduction dirigée par la syntaxe</strong></a> est une technique structurée pour construire ces compilateurs « tout-en-un ». Vous associez une <em>action</em> à chaque partie de la grammaire, généralement une qui génère du code de sortie. Puis, chaque fois que le parseur reconnaît ce morceau de syntaxe, il exécute l&rsquo;action, construisant le code cible règle par règle.</p>
</aside>
<p>Pascal et C ont été conçus autour de cette limitation. À l&rsquo;époque, la mémoire était si précieuse qu&rsquo;un compilateur ne pouvait même pas contenir un <em>fichier source</em> entier en mémoire, encore moins le programme complet. C&rsquo;est pourquoi la grammaire de Pascal exige que les déclarations de type apparaissent en premier dans un bloc. C&rsquo;est pourquoi, en C, vous ne pouvez pas appeler une fonction au-dessus du code qui la définit à moins d&rsquo;avoir une déclaration anticipée explicite indiquant au compilateur ce qu&rsquo;il doit savoir pour générer le code pour un appel à la fonction ultérieure.</p>
<h3><a href="#interpréteurs-par-parcours-darbre" id="interpréteurs-par-parcours-darbre"><small>2&#8202;.&#8202;2&#8202;.&#8202;2</small>Interpréteurs par parcours d&rsquo;arbre</a></h3>
<p>Certains langages commencent à exécuter le code juste après l&rsquo;avoir analysé en AST (avec peut-être un peu d&rsquo;analyse statique appliquée). Pour exécuter le programme, l&rsquo;interpréteur parcourt l&rsquo;arbre syntaxique branche par branche et feuille par feuille, évaluant chaque nœud au fur et à mesure.</p>
<p>Ce style d&rsquo;implémentation est courant pour les projets étudiants et les petits langages, mais n&rsquo;est pas largement utilisé pour les langages <span name="ruby">généralistes</span> car il tend à être lent. Certaines personnes utilisent le terme « interpréteur » uniquement pour ce type d&rsquo;implémentations, mais d&rsquo;autres définissent ce mot de manière plus générale, donc j&rsquo;utiliserai l&rsquo;expression incontestablement explicite <strong>interpréteur par parcours d&rsquo;arbre</strong> pour les désigner. Notre premier interpréteur fonctionne de cette manière.</p>
<aside name="ruby">
<p>Une exception notable est celle des premières versions de Ruby, qui étaient des parcours d&rsquo;arbre. À la version 1.9, l&rsquo;implémentation canonique de Ruby est passée de l&rsquo;original MRI (Matz&rsquo;s Ruby Interpreter) au YARV de Koichi Sasada (Yet Another Ruby VM). YARV est une machine virtuelle à bytecode.</p>
</aside>
<h3><a href="#transpileurs" id="transpileurs"><small>2&#8202;.&#8202;2&#8202;.&#8202;3</small>Transpileurs</a></h3>
<p><span name="gary">Écrire</span> un back-end complet pour un langage peut représenter beaucoup de travail. Si vous disposez déjà d&rsquo;une IR générique à cibler, vous pourriez y raccorder votre front-end. Sinon, il semble que vous soyez coincé. Mais que se passerait-il si vous traitiez un autre <em>langage source</em> comme s&rsquo;il s&rsquo;agissait d&rsquo;une représentation intermédiaire ?</p>
<p>Vous écrivez un front-end pour votre langage. Puis, dans le back-end, au lieu de faire tout le travail pour <em>abaisser</em> les sémantiques vers un langage cible primitif, vous produisez une chaîne de code source valide pour un autre langage à peu près aussi haut niveau que le vôtre. Ensuite, vous utilisez les outils de compilation existants pour <em>ce</em> langage comme échappatoire de la montagne pour descendre vers quelque chose que vous pouvez exécuter.</p>
<p>On appelait autrefois cela un <strong>compilateur source-à-source</strong> ou un <strong>transcompilateur</strong>. Après l&rsquo;essor des langages qui se compilent en JavaScript pour s&rsquo;exécuter dans le navigateur, le sobriquet hipster <strong>transpileur</strong> s&rsquo;est imposé.</p>
<aside name="gary">
<p>Le premier transcompilateur, XLT86, traduisait l&rsquo;assembleur 8080 en assembleur 8086. Cela peut sembler simple, mais gardez à l&rsquo;esprit que le 8080 était une puce 8 bits et le 8086 une puce 16 bits pouvant utiliser chaque registre comme une paire de registres 8 bits. XLT86 effectuait une analyse des flux de données pour suivre l&rsquo;utilisation des registres dans le programme source et les mapper efficacement à l&rsquo;ensemble de registres du 8086.</p>
<p>Il a été écrit par Gary Kildall, un héros tragique de l&rsquo;informatique s&rsquo;il en fut un. L&rsquo;un des premiers à reconnaître le potentiel des micro-ordinateurs, il a créé PL/M et CP/M, le premier langage de haut niveau et le premier OS pour ces machines.</p>
<p>C&rsquo;était un capitaine de mer, chef d&rsquo;entreprise, pilote agréé et motard. Un animateur TV avec le look à la Kris Kristofferson porté par les beaux barbus des années 80. Il a affronté Bill Gates et, comme beaucoup, a perdu, avant de rencontrer sa fin dans un bar de motards dans des circonstances mystérieuses. Il est mort trop jeune, mais il a certainement bien vécu avant cela.</p>
</aside>
<p>Alors que le premier transcompilateur traduisait un langage assembleur en un autre, aujourd&rsquo;hui, la plupart des transpileurs travaillent sur des langages de plus haut niveau. Après la propagation virale d&rsquo;UNIX sur diverses machines, une longue tradition de compilateurs produisant du C comme langage de sortie a commencé. Les compilateurs C étaient disponibles partout où UNIX était présent et produisaient un code efficace, donc cibler le C était un bon moyen de faire fonctionner votre langage sur de nombreuses architectures.</p>
<p>Les navigateurs web sont les &ldquo;machines&rdquo; d&rsquo;aujourd&rsquo;hui, et leur &ldquo;code machine&rdquo; est le JavaScript, donc de nos jours, il semble que <a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js">presque tous les langages existants</a> aient un compilateur ciblant JS puisque c&rsquo;est le <span name="js">principal</span> moyen d&rsquo;exécuter votre code dans un navigateur.</p>
<aside name="js">
<p>JS était autrefois le <em>seul</em> moyen d&rsquo;exécuter du code dans un navigateur. Grâce à <a href="https://github.com/webassembly/">WebAssembly</a>, les compilateurs disposent maintenant d&rsquo;un second langage de bas niveau qu&rsquo;ils peuvent cibler et qui s&rsquo;exécute sur le web.</p>
</aside>
<p>Le front-end<span class="em">&mdash;</span>scanner et parseur<span class="em">&mdash;</span>d&rsquo;un transpileur ressemble à celui des autres compilateurs. Ensuite, si le langage source n&rsquo;est qu&rsquo;une simple couche syntaxique sur le langage cible, il peut ignorer complètement l&rsquo;analyse et passer directement à la génération de la syntaxe équivalente dans le langage de destination.</p>
<p>Si les deux langages sont plus sémantiquement différents, vous verrez davantage de phases typiques d&rsquo;un compilateur complet, y compris l&rsquo;analyse et éventuellement l&rsquo;optimisation. Puis, lorsqu&rsquo;il s&rsquo;agit de génération de code, au lieu de produire un langage binaire comme le code machine, vous produisez une chaîne de code source (en fait, destination) grammaticalement correcte dans le langage cible.</p>
<p>Dans tous les cas, vous passez ensuite ce code résultant dans le pipeline de compilation existant du langage de sortie, et le tour est joué.</p>
<h3><a href="#compilation-juste-&agrave;-temps" id="compilation-juste-&agrave;-temps"><small>2&#8202;.&#8202;2&#8202;.&#8202;4</small>Compilation juste-&agrave;-temps</a></h3>
<p>Cette dernière option est moins un raccourci qu&rsquo;une escalade alpine dangereuse, mieux réservée aux experts. Le moyen le plus rapide d&rsquo;exécuter du code est de le compiler en code machine, mais vous ne savez peut-être pas quelle architecture la machine de votre utilisateur final supporte. Que faire ?</p>
<p>Vous pouvez faire la même chose que la HotSpot Java Virtual Machine (JVM), le Common Language Runtime (CLR) de Microsoft et la plupart des interpréteurs JavaScript. Sur la machine de l&rsquo;utilisateur final, lorsque le programme est chargé – soit à partir du code source dans le cas de JS, soit à partir d&rsquo;un bytecode indépendant de la plateforme pour la JVM et le CLR – vous le compilez en code natif pour l&rsquo;architecture que son ordinateur supporte. Naturellement, cela s&rsquo;appelle <strong>compilation juste-à-temps</strong>. La plupart des hackers disent simplement &ldquo;JIT&rdquo;, prononcé comme rime avec &ldquo;fit&rdquo;.</p>
<p>Les JIT les plus sophistiqués insèrent des hooks de profilage dans le code généré pour voir quelles zones sont les plus critiques en termes de performance et quel type de données y circule. Ensuite, au fil du temps, ils recompilent automatiquement ces <span name="hot">points chauds</span> avec des optimisations plus avancées.</p>
<aside name="hot">
<p>C&rsquo;est, bien sûr, exactement de là que la JVM HotSpot tire son nom.</p>
</aside>
<h2><a href="#compilateurs-et-interpréteurs" id="compilateurs-et-interpréteurs"><small>2&#8202;.&#8202;3</small>Compilateurs et interpréteurs</a></h2>
<p>Maintenant que je vous ai rempli la tête d&rsquo;un dictionnaire de jargon sur les langages de programmation, nous pouvons enfin aborder une question qui tourmente les codeurs depuis la nuit des temps : Quelle est la différence entre un compilateur et un interpréteur ?</p>
<p>Il s&rsquo;avère que c&rsquo;est comme demander la différence entre un fruit et un légume. Cela semble être un choix binaire, mais en réalité, &ldquo;fruit&rdquo; est un terme <em>botanique</em> et &ldquo;légume&rdquo; est <em>culinaire</em>. L&rsquo;un n&rsquo;implique pas strictement la négation de l&rsquo;autre. Il y a des fruits qui ne sont pas des légumes (pommes) et des légumes qui ne sont pas des fruits (carottes), mais aussi des plantes comestibles qui sont à la fois des fruits <em>et</em> des légumes, comme les tomates.</p>
<p><span name="veg"></span></p><img src="image/a-map-of-the-territory/plants.png" alt="Diagramme de Venn des plantes comestibles" />
<aside name="veg">
<p>Les arachides (qui ne sont même pas des noix) et les céréales comme le blé sont en réalité des fruits, mais j&rsquo;ai mal dessiné ce diagramme. Que voulez-vous que je dise, je suis ingénieur logiciel, pas botaniste. Je devrais probablement effacer le petit arachide, mais il est tellement mignon que je n&rsquo;y arrive pas.</p>
<p>Les <em>pignons de pin</em>, par contre, sont des aliments d&rsquo;origine végétale qui ne sont ni des fruits ni des légumes. Du moins d&rsquo;après ce que je peux dire.</p>
</aside>
<p>Revenons aux langages :</p>
<ul>
<li>
<p><strong>Compiler</strong> est une <em>technique d&rsquo;implémentation</em> qui consiste à traduire un langage source en une autre forme – généralement de bas niveau. Lorsque vous générez du bytecode ou du code machine, vous compilez. Lorsque vous transpilez vers un autre langage de haut niveau, vous compilez également.</p>
</li>
<li>
<p>Lorsque nous disons qu&rsquo;une implémentation de langage &ldquo;est un <strong>compilateur</strong>&rdquo;, nous voulons dire qu&rsquo;elle traduit le code source en une autre forme mais ne l&rsquo;exécute pas. L&rsquo;utilisateur doit prendre le résultat et l&rsquo;exécuter lui-même.</p>
</li>
<li>
<p>À l&rsquo;inverse, lorsque nous disons qu&rsquo;une implémentation &ldquo;est un <strong>interpréteur</strong>&rdquo;, nous voulons dire qu&rsquo;elle prend le code source et l&rsquo;exécute immédiatement. Elle exécute les programmes &ldquo;à partir du source&rdquo;.</p>
</li>
</ul>
<p>Comme pour les pommes et les oranges, certaines implémentations sont clairement des compilateurs et <em>pas</em> des interpréteurs. GCC et Clang prennent votre code C et le compilent en code machine. L&rsquo;utilisateur final exécute directement cet exécutable et peut ne jamais savoir quel outil a été utilisé pour le compiler. Ce sont donc des <em>compilateurs</em> pour le C.</p>
<p>Dans les versions plus anciennes de l&rsquo;implémentation canonique de Ruby de Matz, l&rsquo;utilisateur exécutait Ruby à partir du code source. L&rsquo;implémentation le parseait et l&rsquo;exécutait directement en parcourant l&rsquo;arbre syntaxique. Aucune autre traduction ne se produisait, ni en interne ni sous une forme visible par l&rsquo;utilisateur. C&rsquo;était donc définitivement un <em>interpréteur</em> pour Ruby.</p>
<p>Mais qu&rsquo;en est-il de CPython ? Lorsque vous exécutez votre programme Python avec lui, le code est analysé et converti en un format de bytecode interne, qui est ensuite exécuté dans la VM. Du point de vue de l&rsquo;utilisateur, il s&rsquo;agit clairement d&rsquo;un interpréteur – ils exécutent leur programme à partir du code source. Mais si vous regardez sous la peau écailleuse de CPython, vous verrez qu&rsquo;il y a définitivement un peu de compilation en cours.</p>
<p>La réponse est que c&rsquo;est <span name="go">les deux</span>. CPython <em>est</em> un interpréteur, et il <em>possède</em> un compilateur. En pratique, la plupart des langages de script fonctionnent de cette manière, comme vous pouvez le constater :</p>
<aside name="go">
<p>L’<a href="https://golang.org/">outil Go</a> est encore plus une curiosité horticole.<br />
Si vous exécutez <code>go build</code>, il compile votre code source Go en code machine et s’arrête.<br />
Si vous tapez <code>go run</code>, il fait cela, puis exécute immédiatement l’exécutable généré.  </p>
<p>Ainsi, <code>go</code> <em>est</em> un compilateur (vous pouvez l’utiliser comme un outil pour compiler du code sans l’exécuter),<br />
<em>est</em> un interpréteur (vous pouvez l’invoquer pour exécuter immédiatement un programme depuis le code source),<br />
et <em>contient</em> aussi un compilateur (quand vous l’utilisez comme interpréteur, il compile tout de même en interne).</p>
</aside><img src="image/a-map-of-the-territory/venn.png" alt="Un diagramme de Venn des compilateurs et interprètes" />
<p>La zone de chevauchement au centre est aussi l’endroit où vit notre second interpréteur,<br />
puisqu’il compile en interne vers du bytecode.<br />
Donc, même si ce livre est nominalement consacré aux interprètes,<br />
nous couvrirons aussi un peu de compilation.</p>
<h2><a href="#notre-voyage" id="notre-voyage"><small>2&#8202;.&#8202;4</small>Notre voyage</a></h2>
<p>Cela fait beaucoup d’informations à absorber d’un coup. Ne vous inquiétez pas.<br />
Ce n’est pas dans ce chapitre que vous êtes censé <em>comprendre</em> toutes ces pièces et parties.<br />
Je veux simplement que vous sachiez qu’elles existent et comment elles s’articulent grossièrement.  </p>
<p>Cette carte devrait vous être utile quand vous explorerez le territoire au-delà du chemin guidé que nous suivons ici.<br />
J’aimerais vous laisser avec l’envie de partir seul à l’aventure et d’errer partout sur cette montagne.  </p>
<p>Mais, pour l’instant, il est temps que notre propre voyage commence.<br />
Serrez vos lacets, ajustez votre sac, et venez avec moi.<br />
À partir de <span name="here">maintenant</span>, tout ce sur quoi vous devez vous concentrer, c’est le chemin juste devant vous.</p>
<aside name="here">
<p>Désormais, je promets d’atténuer un peu la métaphore de la montagne.</p>
</aside>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>2&#8202;.&#8202;5</small>Défis</a></h2>
<ol>
<li>
<p>Choisissez une implémentation open source d’un langage que vous aimez.<br />
Téléchargez le code source et explorez-le.<br />
Essayez de trouver le code qui implémente le scanner et l’analyseur syntaxique.<br />
Sont-ils écrits à la main, ou générés avec des outils comme Lex et Yacc ?<br />
(Les fichiers <code>.l</code> ou <code>.y</code> suggèrent généralement cette dernière option.)</p>
</li>
<li>
<p>La compilation juste-à-temps a tendance à être la manière la plus rapide d’implémenter des langages dynamiques,<br />
mais tous ne l’utilisent pas. Quelles raisons peut-on avoir de <em>ne pas</em> utiliser le JIT ?</p>
</li>
<li>
<p>La plupart des implémentations de Lisp qui compilent vers du C contiennent aussi un interpréteur<br />
leur permettant d’exécuter du code Lisp à la volée. Pourquoi ?</p>
</li>
</ol>
</div>

<footer>
<a href="le-langage-lox.html" class="next">
  Next Chapter: &ldquo;Le langage Lox&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
