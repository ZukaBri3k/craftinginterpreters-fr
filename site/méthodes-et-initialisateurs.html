<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Méthodes et initialisateurs &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Méthodes et initialisateurs<small>28</small></a></h3>

<ul>
    <li><a href="#déclarations-de-méthode"><small>28.1</small> Déclarations de Méthode</a></li>
    <li><a href="#références-de-méthode"><small>28.2</small> Références de Méthode</a></li>
    <li><a href="#this"><small>28.3</small> This</a></li>
    <li><a href="#initialisateurs-dinstance"><small>28.4</small> Initialisateurs d&#x27;Instance</a></li>
    <li><a href="#invocations-optimisées"><small>28.5</small> Invocations Optimisées</a></li>
    <li><a href="#défis"><small>28.6</small> Défis</a></li>
    <li><a href="#note-de-conception--budget-de-nouveauté"><small>28.7</small> Note de Conception : Budget de Nouveauté</a></li>
</ul>


<div class="prev-next">
    <a href="classes-et-instances.html" title="Classes et instances" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="super-classes.html" title="Super-classes" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="classes-et-instances.html" title="Classes et instances" class="prev">←</a>
<a href="super-classes.html" title="Super-classes" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Méthodes et initialisateurs<small>28</small></a></h3>

<ul>
    <li><a href="#déclarations-de-méthode"><small>28.1</small> Déclarations de Méthode</a></li>
    <li><a href="#références-de-méthode"><small>28.2</small> Références de Méthode</a></li>
    <li><a href="#this"><small>28.3</small> This</a></li>
    <li><a href="#initialisateurs-dinstance"><small>28.4</small> Initialisateurs d&#x27;Instance</a></li>
    <li><a href="#invocations-optimisées"><small>28.5</small> Invocations Optimisées</a></li>
    <li><a href="#défis"><small>28.6</small> Défis</a></li>
    <li><a href="#note-de-conception--budget-de-nouveauté"><small>28.7</small> Note de Conception : Budget de Nouveauté</a></li>
</ul>


<div class="prev-next">
    <a href="classes-et-instances.html" title="Classes et instances" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="super-classes.html" title="Super-classes" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">28</div>
  <h1>Méthodes et initialisateurs</h1>

<blockquote>
<p>Quand vous êtes sur la piste de danse, il n&rsquo;y a rien à faire sauf danser.</p>
<p><cite>Umberto Eco, <em>La Mystérieuse Flamme de la reine Loana</em></cite></p>
</blockquote>
<p>Il est temps pour notre machine virtuelle d&rsquo;amener ses objets naissants à la vie avec du comportement. Cela signifie des méthodes et des appels de méthode. Et, puisqu&rsquo;ils sont une sorte spéciale de méthode, des initialisateurs aussi.</p>
<p>Tout cela est un territoire familier de notre précédent interpréteur jlox. Ce qui est nouveau dans ce second voyage est une optimisation importante que nous implémenterons pour rendre les appels de méthode plus de sept fois plus rapides que notre performance de base. Mais avant que nous arrivions à ce plaisir, nous devons faire fonctionner les trucs de base.</p>
<h2><a href="#déclarations-de-méthode" id="déclarations-de-méthode"><small>28&#8202;.&#8202;1</small>Déclarations de Méthode</a></h2>
<p>Nous ne pouvons pas optimiser les appels de méthode avant que nous ayons des appels de méthode, et nous ne pouvons pas appeler des méthodes sans avoir de méthodes à appeler, donc nous commencerons avec les déclarations.</p>
<h3><a href="#représenter-les-méthodes" id="représenter-les-méthodes"><small>28&#8202;.&#8202;1&#8202;.&#8202;1</small>Représenter les méthodes</a></h3>
<p>Nous commençons habituellement dans le compilateur, mais sortons le modèle objet d&rsquo;abord cette fois. La représentation runtime pour les méthodes dans clox est similaire à celle de jlox. Chaque classe stocke une table de hachage de méthodes. Les clés sont les noms de méthode, et chaque valeur est une ObjClosure pour le corps de la méthode.</p>
<div class="codehilite"><pre class="insert-before">typedef struct {
  Obj obj;
  ObjString* name;
</pre><div class="source-file"><em>object.h</em><br>
in struct <em>ObjClass</em></div>
<pre class="insert">  <span class="t">Table</span> <span class="i">methods</span>;
</pre><pre class="insert-after">} ObjClass;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>ObjClass</em></div>

<p>Une toute nouvelle classe commence avec une table de méthode vide.</p>
<div class="codehilite"><pre class="insert-before">  klass-&gt;name = name;<span name="klass"> </span>
</pre><div class="source-file"><em>object.c</em><br>
in <em>newClass</em>()</div>
<pre class="insert">  <span class="i">initTable</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>);
</pre><pre class="insert-after">  return klass;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>newClass</em>()</div>

<p>La structure ObjClass possède la mémoire pour cette table, donc quand le gestionnaire de mémoire désalloue une classe, la table devrait être libérée aussi.</p>
<div class="codehilite"><pre class="insert-before">    case OBJ_CLASS: {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">      <span class="t">ObjClass</span>* <span class="i">klass</span> = (<span class="t">ObjClass</span>*)<span class="i">object</span>;
      <span class="i">freeTable</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>);
</pre><pre class="insert-after">      FREE(ObjClass, object);
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>En parlant de gestionnaires de mémoire, le GC a besoin de tracer à travers les classes dans la table de méthode. Si une classe est encore atteignable (probablement à travers quelque instance), alors toutes ses méthodes ont certainement besoin de rester dans les parages aussi.</p>
<div class="codehilite"><pre class="insert-before">      markObject((Obj*)klass-&gt;name);
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert">      <span class="i">markTable</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>);
</pre><pre class="insert-after">      break;
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>Nous utilisons la fonction <code>markTable()</code> existante, qui trace à travers la chaîne clé et la valeur dans chaque entrée de table.</p>
<p>Stocker les méthodes d&rsquo;une classe est assez familier venant de jlox. La partie différente est comment cette table devient peuplée. Notre interpréteur précédent avait accès au nœud AST entier pour la déclaration de classe et toutes les méthodes qu&rsquo;elle contenait. À l&rsquo;exécution, l&rsquo;interpréteur parcourait simplement cette liste de déclarations.</p>
<p>Maintenant chaque pièce d&rsquo;information que le compilateur veut expédier vers le runtime doit se faufiler à travers l&rsquo;interface d&rsquo;une série plate d&rsquo;instructions bytecode. Comment prenons-nous une déclaration de classe, qui peut contenir un ensemble arbitrairement grand de méthodes, et la représentons-nous comme du bytecode ? Sautons vers le compilateur et découvrons-le.</p>
<h3><a href="#compiler-les-déclarations-de-méthode" id="compiler-les-déclarations-de-méthode"><small>28&#8202;.&#8202;1&#8202;.&#8202;2</small>Compiler les déclarations de méthode</a></h3>
<p>Le dernier chapitre nous a laissés avec un compilateur qui analyse les classes mais permet seulement un corps vide. Maintenant nous insérons un peu de code pour compiler une série de déclarations de méthode entre les accolades.</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_LEFT_BRACE, &quot;Expect '{' before class body.&quot;);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>classDeclaration</em>()</div>
<pre class="insert">  <span class="k">while</span> (!<span class="i">check</span>(<span class="a">TOKEN_RIGHT_BRACE</span>) &amp;&amp; !<span class="i">check</span>(<span class="a">TOKEN_EOF</span>)) {
    <span class="i">method</span>();
  }
</pre><pre class="insert-after">  consume(TOKEN_RIGHT_BRACE, &quot;Expect '}' after class body.&quot;);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>

<p>Lox n&rsquo;a pas de déclarations de champ, donc tout ce qui est avant l&rsquo;accolade fermante à la fin du corps de classe doit être une méthode. Nous arrêtons de compiler les méthodes quand nous frappons cette accolade finale ou si nous atteignons la fin du fichier. Cette dernière vérification assure que notre compilateur ne reste pas coincé dans une boucle infinie si l&rsquo;utilisateur oublie accidentellement l&rsquo;accolade fermante.</p>
<p>La partie délicate avec la compilation d&rsquo;une déclaration de classe est qu&rsquo;une classe peut déclarer n&rsquo;importe quel nombre de méthodes. D&rsquo;une manière ou d&rsquo;une autre le runtime a besoin de rechercher et lier toutes celles-ci. Ce serait beaucoup à empaqueter dans une seule instruction <code>OP_CLASS</code>. Au lieu de cela, le bytecode que nous générons pour une déclaration de classe divisera le processus en une <span name="series"><em>série</em></span> d&rsquo;instructions. Le compilateur émet déjà une instruction <code>OP_CLASS</code> qui crée un nouvel objet ObjClass vide. Ensuite il émet des instructions pour stocker la classe dans une variable avec son nom.</p>
<aside name="series">
<p>Nous avons fait quelque chose de similaire pour les fermetures. L&rsquo;instruction <code>OP_CLOSURE</code> a besoin de connaître le type et l&rsquo;index pour chaque upvalue capturée. Nous avons encodé cela utilisant une série de pseudo-instructions suivant l&rsquo;instruction <code>OP_CLOSURE</code> principale<span class="em">&mdash;</span>fondamentalement un nombre variable d&rsquo;opérandes. La VM traite tous ces octets supplémentaires immédiatement lors de l&rsquo;interprétation de l&rsquo;instruction <code>OP_CLOSURE</code>.</p>
<p>Ici notre approche est un peu différente parce que de la perspective de la VM, chaque instruction pour définir une méthode est une opération autonome séparée. L&rsquo;une ou l&rsquo;autre approche fonctionnerait. Une pseudo-instruction de taille variable est possiblement marginalement plus rapide, mais les déclarations de classe sont rarement dans des boucles chaudes, donc cela n&rsquo;importe pas beaucoup.</p>
</aside>
<p>Maintenant, pour chaque déclaration de méthode, nous émettons une nouvelle instruction <code>OP_METHOD</code> qui ajoute une méthode unique à cette classe. Quand toutes les instructions <code>OP_METHOD</code> ont exécuté, nous sommes laissés avec une classe pleinement formée. Alors que l&rsquo;utilisateur voit une déclaration de classe comme une opération atomique unique, la VM l&rsquo;implémente comme une série de mutations.</p>
<p>Pour définir une nouvelle méthode, la VM a besoin de trois choses :</p>
<ol>
<li>
<p>Le nom de la méthode.</p>
</li>
<li>
<p>La fermeture pour le corps de la méthode.</p>
</li>
<li>
<p>La classe à laquelle lier la méthode.</p>
</li>
</ol>
<p>Nous écrirons incrémentalement le code du compilateur pour voir comment tout cela passe au runtime, commençant ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>function</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">method</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="s">&quot;Expect method name.&quot;</span>);
  <span class="t">uint8_t</span> <span class="i">constant</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);
  <span class="i">emitBytes</span>(<span class="a">OP_METHOD</span>, <span class="i">constant</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>function</em>()</div>

<p>Comme <code>OP_GET_PROPERTY</code> et d&rsquo;autres instructions qui ont besoin de noms à l&rsquo;exécution, le compilateur ajoute le lexème du jeton nom de méthode à la table des constantes, récupérant un index de table. Ensuite nous émettons une instruction <code>OP_METHOD</code> avec cet index comme l&rsquo;opérande. C&rsquo;est le nom. Ensuite est le corps de la méthode :</p>
<div class="codehilite"><pre class="insert-before">  uint8_t constant = identifierConstant(&amp;parser.previous);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>method</em>()</div>
<pre class="insert">

  <span class="t">FunctionType</span> <span class="i">type</span> = <span class="a">TYPE_FUNCTION</span>;
  <span class="i">function</span>(<span class="i">type</span>);
</pre><pre class="insert-after">  emitBytes(OP_METHOD, constant);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>method</em>()</div>

<p>Nous utilisons le même assistant <code>function()</code> que nous avons écrit pour compiler les déclarations de fonction. Cette fonction utilitaire compile la liste de paramètres subséquente et le corps de la fonction. Ensuite elle émet le code pour créer une ObjClosure et la laisser sur le sommet de la pile. À l&rsquo;exécution, la VM trouvera la fermeture là.</p>
<p>Dernier est la classe à laquelle lier la méthode. Où la VM peut-elle trouver cela ? Malheureusement, au moment où nous atteignons l&rsquo;instruction <code>OP_METHOD</code>, nous ne savons pas où elle est. Elle <span name="global">pourrait</span> être sur la pile, si l&rsquo;utilisateur a déclaré la classe dans une portée locale. Mais une déclaration de classe de niveau supérieur finit avec l&rsquo;ObjClass dans la table des variables globales.</p>
<aside name="global">
<p>Si Lox supportait de déclarer les classes seulement au niveau supérieur, la VM pourrait supposer que toute classe pourrait être trouvée en la cherchant directement depuis la table des variables globales. Hélas, parce que nous supportons les classes locales, nous avons besoin de gérer ce cas aussi.</p>
</aside>
<p>Ne craignez rien. Le compilateur connaît le <em>nom</em> de la classe. Nous pouvons le capturer juste après avoir consommé son jeton.</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_IDENTIFIER, &quot;Expect class name.&quot;);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>classDeclaration</em>()</div>
<pre class="insert">  <span class="t">Token</span> <span class="i">className</span> = <span class="i">parser</span>.<span class="i">previous</span>;
</pre><pre class="insert-after">  uint8_t nameConstant = identifierConstant(&amp;parser.previous);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>

<p>Et nous savons qu&rsquo;aucune autre déclaration avec ce nom ne pourrait possiblement masquer la classe. Donc nous faisons la réparation facile. Avant que nous commencions à lier les méthodes, nous émettons tout code qui est nécessaire pour charger la classe de retour sur le sommet de la pile.</p>
<div class="codehilite"><pre class="insert-before">  defineVariable(nameConstant);

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>classDeclaration</em>()</div>
<pre class="insert">  <span class="i">namedVariable</span>(<span class="i">className</span>, <span class="k">false</span>);
</pre><pre class="insert-after">  consume(TOKEN_LEFT_BRACE, &quot;Expect '{' before class body.&quot;);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>

<p>Juste avant de compiler le corps de classe, nous <span name="load">appelons</span> <code>namedVariable()</code>. Cette fonction aide génère du code pour charger une variable avec le nom donné sur la pile. Ensuite nous compilons les méthodes.</p>
<aside name="load">
<p>L&rsquo;appel précédent à <code>defineVariable()</code> dépile la classe, donc cela semble idiot d&rsquo;appeler <code>namedVariable()</code> pour la charger juste de retour sur la pile. Pourquoi ne pas simplement la laisser sur la pile en premier lieu ? Nous pourrions, mais dans le <a href="superclasses.html">prochain chapitre</a> nous insérerons du code entre ces deux appels pour supporter l&rsquo;héritage. À ce point, il sera plus simple si la classe ne traîne pas sur la pile.</p>
</aside>
<p>Cela signifie que quand nous exécutons chaque instruction <code>OP_METHOD</code>, la pile a la fermeture de la méthode sur le sommet avec la classe juste sous elle. Une fois que nous avons atteint la fin des méthodes, nous n&rsquo;avons plus besoin de la classe et disons à la VM de la dépiler de la pile.</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_RIGHT_BRACE, &quot;Expect '}' after class body.&quot;);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>classDeclaration</em>()</div>
<pre class="insert">  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>

<p>Mettant tout cela ensemble, voici une déclaration de classe exemple à jeter au compilateur :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Brunch</span> {
  <span class="i">bacon</span>() {}
  <span class="i">eggs</span>() {}
}
</pre></div>
<p>Donné cela, voici ce que le compilateur génère et comment ces instructions affectent la pile à l&rsquo;exécution :</p><img src="image/methods-and-initializers/method-instructions.png" alt="La série d'instructions bytecode pour une déclaration de classe avec deux méthodes." />
<p>Tout ce qui reste pour nous est d&rsquo;implémenter le runtime pour cette nouvelle instruction <code>OP_METHOD</code>.</p>
<h3><a href="#exécuter-les-déclarations-de-méthode" id="exécuter-les-déclarations-de-méthode"><small>28&#8202;.&#8202;1&#8202;.&#8202;3</small>Exécuter les déclarations de méthode</a></h3>
<p>D&rsquo;abord nous définissons l&rsquo;opcode.</p>
<div class="codehilite"><pre class="insert-before">  OP_CLASS,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_METHOD</span>
</pre><pre class="insert-after">} OpCode;
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Nous le désassemblons comme d&rsquo;autres instructions qui ont des opérandes constants chaîne.</p>
<div class="codehilite"><pre class="insert-before">    case OP_CLASS:
      return constantInstruction(&quot;OP_CLASS&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_METHOD</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_METHOD&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    default:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Et là-bas dans l&rsquo;interpréteur, nous ajoutons un nouveau cas aussi.</p>
<div class="codehilite"><pre class="insert-before">        break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_METHOD</span>:
        <span class="i">defineMethod</span>(<span class="a">READ_STRING</span>());
        <span class="k">break</span>;
</pre><pre class="insert-after">    }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Là, nous lisons le nom de la méthode depuis la table des constantes et le passons ici :</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>closeUpvalues</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">defineMethod</span>(<span class="t">ObjString</span>* <span class="i">name</span>) {
  <span class="t">Value</span> <span class="i">method</span> = <span class="i">peek</span>(<span class="n">0</span>);
  <span class="t">ObjClass</span>* <span class="i">klass</span> = <span class="a">AS_CLASS</span>(<span class="i">peek</span>(<span class="n">1</span>));
  <span class="i">tableSet</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>, <span class="i">name</span>, <span class="i">method</span>);
  <span class="i">pop</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>closeUpvalues</em>()</div>

<p>La fermeture de méthode est au sommet de la pile, au-dessus de la classe à laquelle elle sera liée. Nous lisons ces deux emplacements de pile et stockons la fermeture dans la table de méthode de la classe. Ensuite nous dépilons la fermeture puisque nous en avons fini avec elle.</p>
<p>Notez que nous ne faisons aucune vérification de type à l&rsquo;exécution sur la fermeture ou l&rsquo;objet classe. Cet appel <code>AS_CLASS()</code> est sûr parce que le compilateur lui-même a généré le code qui cause la classe d&rsquo;être dans cet emplacement de pile. La VM <span name="verify">fait confiance</span> à son propre compilateur.</p>
<aside name="verify">
<p>La VM fait confiance que les instructions qu&rsquo;elle exécute sont valides parce que le <em>seul</em> moyen d&rsquo;amener du code à l&rsquo;interpréteur bytecode est en passant par le propre compilateur de clox. Beaucoup de VMs bytecode, comme la JVM et CPython, supportent l&rsquo;exécution de bytecode qui a été compilé séparément. Cela mène à une histoire de sécurité différente. Du bytecode fabriqué malicieusement pourrait faire planter la VM ou pire.</p>
<p>Pour empêcher cela, la JVM fait une passe de vérification de bytecode avant qu&rsquo;elle n&rsquo;exécute tout code chargé. CPython dit que c&rsquo;est à l&rsquo;utilisateur de s&rsquo;assurer que tout bytecode qu&rsquo;il exécute est sûr.</p>
</aside>
<p>Après que la série d&rsquo;instructions <code>OP_METHOD</code> est finie et que le <code>OP_POP</code> a dépilé la classe, nous aurons une classe avec une table de méthode joliment peuplée, prête à commencer à faire des choses. L&rsquo;étape suivante est de tirer ces méthodes de retour en dehors et de les utiliser.</p>
<h2><a href="#références-de-méthode" id="références-de-méthode"><small>28&#8202;.&#8202;2</small>Références de Méthode</a></h2>
<p>La plupart du temps, les méthodes sont accédées et immédiatement appelées, menant à cette syntaxe familière :</p>
<div class="codehilite"><pre><span class="i">instance</span>.<span class="i">method</span>(<span class="i">argument</span>);
</pre></div>
<p>Mais rappelez-vous, dans Lox et quelques autres langages, ces deux étapes sont distinctes et peuvent être séparées.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">closure</span> = <span class="i">instance</span>.<span class="i">method</span>;
<span class="i">closure</span>(<span class="i">argument</span>);
</pre></div>
<p>Puisque les utilisateurs <em>peuvent</em> séparer les opérations, nous devons les implémenter séparément. La première étape est d&rsquo;utiliser notre syntaxe de propriété pointée existante pour accéder à une méthode définie sur la classe de l&rsquo;instance. Cela devrait renvoyer quelque sorte d&rsquo;objet que l&rsquo;utilisateur peut alors appeler comme une fonction.</p>
<p>L&rsquo;approche évidente est de chercher la méthode dans la table de méthode de la classe et de retourner l&rsquo;ObjClosure associée avec ce nom. Mais nous devons aussi nous souvenir que quand vous accédez à une méthode, <code>this</code> devient lié à l&rsquo;instance depuis laquelle la méthode a été accédée. Voici l&rsquo;exemple de <a href="classes.html#methods-on-classes">quand nous avons ajouté les méthodes à jlox</a> :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Person</span> {
  <span class="i">sayName</span>() {
    <span class="k">print</span> <span class="k">this</span>.<span class="i">name</span>;
  }
}

<span class="k">var</span> <span class="i">jane</span> = <span class="t">Person</span>();
<span class="i">jane</span>.<span class="i">name</span> = <span class="s">&quot;Jane&quot;</span>;

<span class="k">var</span> <span class="i">method</span> = <span class="i">jane</span>.<span class="i">sayName</span>;
<span class="i">method</span>(); <span class="c">// ?</span>
</pre></div>
<p>Ceci devrait afficher &ldquo;Jane&rdquo;, donc l&rsquo;objet retourné par <code>.sayName</code> a besoin de se souvenir d&rsquo;une manière ou d&rsquo;une autre de l&rsquo;instance depuis laquelle il a été accédé quand il sera plus tard appelé. Dans jlox, nous avions implémenté cette &ldquo;mémoire&rdquo; en utilisant la classe Environment allouée sur le tas existante de l&rsquo;interpréteur, qui gérait tout le stockage de variable.</p>
<p>Notre VM à bytecode a une architecture plus complexe pour stocker l&rsquo;état. <a href="variables-locales.html#représenter-les-variables-locales">Les variables locales et les temporaires</a> sont sur la pile, <a href="variables-globales.html#déclarations-de-variable">les globales</a> sont dans une table de hachage, et les variables dans les fermetures utilisent des <a href="closures.html#upvalues">upvalues</a>. Cela nécessite une solution quelque peu plus complexe pour suivre le receveur d&rsquo;une méthode dans clox, et un nouveau type runtime.</p>
<h3><a href="#méthodes-liées" id="méthodes-liées"><small>28&#8202;.&#8202;2&#8202;.&#8202;1</small>Méthodes liées</a></h3>
<p>Quand l&rsquo;utilisateur exécute un accès méthode, nous trouverons la fermeture pour cette méthode et l&rsquo;envelopperons dans un nouvel objet <span name="bound">&ldquo;méthode liée&rdquo;</span> (bound method) qui suit l&rsquo;instance depuis laquelle la méthode a été accédée. Cet objet lié peut être appelé plus tard comme une fonction. Quand invoqué, la VM fera quelques manigances pour câbler <code>this</code> pour pointer vers le receveur à l&rsquo;intérieur du corps de la méthode.</p>
<aside name="bound">
<p>J&rsquo;ai pris le nom &ldquo;méthode liée&rdquo; de CPython. Python se comporte similairement à Lox ici, et j&rsquo;ai utilisé son implémentation pour l&rsquo;inspiration.</p>
</aside>
<p>Voici le nouveau type d&rsquo;objet :</p>
<div class="codehilite"><pre class="insert-before">} ObjInstance;

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjInstance</em></div>
<pre class="insert"><span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">Value</span> <span class="i">receiver</span>;
  <span class="t">ObjClosure</span>* <span class="i">method</span>;
} <span class="t">ObjBoundMethod</span>;

</pre><pre class="insert-after">ObjClass* newClass(ObjString* name);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjInstance</em></div>

<p>Il enveloppe le receveur et la fermeture de méthode ensemble. Le type du receveur est Value même si les méthodes peuvent être appelées seulement sur des ObjInstances. Puisque la VM ne se soucie pas de quel genre de receveur elle a de toute façon, utiliser Value signifie que nous n&rsquo;avons pas à continuer de convertir le pointeur en arrière vers une Value quand il est passé à des fonctions plus générales.</p>
<p>La nouvelle structure implique le code standard habituel auquel vous êtes habitué maintenant. Un nouveau cas dans l&rsquo;énumération de type objet :</p>
<div class="codehilite"><pre class="insert-before">typedef enum {
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_BOUND_METHOD</span>,
</pre><pre class="insert-after">  OBJ_CLASS,
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>Une macro pour vérifier le type d&rsquo;une valeur :</p>
<div class="codehilite"><pre class="insert-before">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define IS_BOUND_METHOD(value) isObjType(value, OBJ_BOUND_METHOD)</span>
</pre><pre class="insert-after">#define IS_CLASS(value)        isObjType(value, OBJ_CLASS)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Une autre macro pour caster la valeur vers un pointeur ObjBoundMethod :</p>
<div class="codehilite"><pre class="insert-before">#define IS_STRING(value)       isObjType(value, OBJ_STRING)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define AS_BOUND_METHOD(value) ((ObjBoundMethod*)AS_OBJ(value))</span>
</pre><pre class="insert-after">#define AS_CLASS(value)        ((ObjClass*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Une fonction pour créer une nouvelle ObjBoundMethod :</p>
<div class="codehilite"><pre class="insert-before">} ObjBoundMethod;

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjBoundMethod</em></div>
<pre class="insert"><span class="t">ObjBoundMethod</span>* <span class="i">newBoundMethod</span>(<span class="t">Value</span> <span class="i">receiver</span>,
                               <span class="t">ObjClosure</span>* <span class="i">method</span>);
</pre><pre class="insert-after">ObjClass* newClass(ObjString* name);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjBoundMethod</em></div>

<p>Et une implémentation de cette fonction ici :</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>allocateObject</em>()</div>
<pre><span class="t">ObjBoundMethod</span>* <span class="i">newBoundMethod</span>(<span class="t">Value</span> <span class="i">receiver</span>,
                               <span class="t">ObjClosure</span>* <span class="i">method</span>) {
  <span class="t">ObjBoundMethod</span>* <span class="i">bound</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjBoundMethod</span>,
                                       <span class="a">OBJ_BOUND_METHOD</span>);
  <span class="i">bound</span>-&gt;<span class="i">receiver</span> = <span class="i">receiver</span>;
  <span class="i">bound</span>-&gt;<span class="i">method</span> = <span class="i">method</span>;
  <span class="k">return</span> <span class="i">bound</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateObject</em>()</div>

<p>La fonction de type constructeur stocke simplement la fermeture et le receveur donnés. Quand la méthode liée n&rsquo;est plus nécessaire, nous la libérons.</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_BOUND_METHOD</span>:
      <span class="a">FREE</span>(<span class="t">ObjBoundMethod</span>, <span class="i">object</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_CLASS: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>La méthode liée a une couple de références, mais elle ne les <em>possède</em> pas, donc elle ne libère rien sauf elle-même. Cependant, ces références sont bien tracées par le ramasse-miettes.</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_BOUND_METHOD</span>: {
      <span class="t">ObjBoundMethod</span>* <span class="i">bound</span> = (<span class="t">ObjBoundMethod</span>*)<span class="i">object</span>;
      <span class="i">markValue</span>(<span class="i">bound</span>-&gt;<span class="i">receiver</span>);
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">bound</span>-&gt;<span class="i">method</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_CLASS: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>Ceci <span name="trace">assure</span> qu&rsquo;une poignée vers une méthode garde le receveur dans les parages en mémoire pour que <code>this</code> puisse encore trouver l&rsquo;objet quand vous invoquez la poignée plus tard. Nous traçons aussi la fermeture de méthode.</p>
<aside name="trace">
<p>Tracer la fermeture de méthode n&rsquo;est pas vraiment nécessaire. Le receveur est une ObjInstance, qui a un pointeur vers son ObjClass, qui a une table pour toutes les méthodes. Mais cela semble douteux pour moi d&rsquo;une certaine manière vague d&rsquo;avoir ObjBoundMethod qui compte sur cela.</p>
</aside>
<p>La dernière opération que tous les objets supportent est l&rsquo;affichage.</p>
<div class="codehilite"><pre class="insert-before">  switch (OBJ_TYPE(value)) {
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_BOUND_METHOD</span>:
      <span class="i">printFunction</span>(<span class="a">AS_BOUND_METHOD</span>(<span class="i">value</span>)-&gt;<span class="i">method</span>-&gt;<span class="i">function</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_CLASS:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p>Une méthode liée s&rsquo;affiche exactement de la même façon qu&rsquo;une fonction. De la perspective de l&rsquo;utilisateur, une méthode liée <em>est</em> une fonction. C&rsquo;est un objet qu&rsquo;ils peuvent appeler. Nous n&rsquo;exposons pas que la VM implémente les méthodes liées utilisant un type d&rsquo;objet différent.</p>
<aside name="party"><img src="image/methods-and-initializers/party-hat.png" alt="Un chapeau de fête." />
</aside>
<p>Mettez votre chapeau de <span name="party">fête</span> parce que nous venons d&rsquo;atteindre une petite étape importante. ObjBoundMethod est le tout dernier type runtime à ajouter à clox. Vous avez écrit vos dernières macros <code>IS_</code> et <code>AS_</code>. Nous sommes seulement à quelques chapitres de la fin du livre, et nous nous approchons d&rsquo;une VM complète.</p>
<h3><a href="#accéder-aux-méthodes" id="accéder-aux-méthodes"><small>28&#8202;.&#8202;2&#8202;.&#8202;2</small>Accéder aux méthodes</a></h3>
<p>Faisons faire quelque chose à notre nouveau type d&rsquo;objet. Les méthodes sont accédées utilisant la même syntaxe de propriété &ldquo;point&rdquo; que nous avons implémentée dans le dernier chapitre. Le compilateur analyse déjà les bonnes expressions et émet des instructions <code>OP_GET_PROPERTY</code> pour elles. Les seuls changements que nous avons besoin de faire sont dans le runtime.</p>
<p>Quand une instruction d&rsquo;accès propriété s&rsquo;exécute, l&rsquo;instance est au sommet de la pile. Le travail de l&rsquo;instruction est de trouver un champ ou une méthode avec le nom donné et remplacer le sommet de la pile avec la propriété accédée.</p>
<p>L&rsquo;interpréteur gère déjà les champs, donc nous étendons simplement le cas <code>OP_GET_PROPERTY</code> avec une autre section.</p>
<div class="codehilite"><pre class="insert-before">          pop(); // Instance.
          push(value);
          break;
        }

</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 2 lines</div>
<pre class="insert">        <span class="k">if</span> (!<span class="i">bindMethod</span>(<span class="i">instance</span>-&gt;<span class="i">klass</span>, <span class="i">name</span>)) {
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="k">break</span>;
</pre><pre class="insert-after">      }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>

<p>Nous insérons ceci après le code pour chercher un champ sur l&rsquo;instance receveur. Les champs prennent la priorité sur et masquent les méthodes, donc nous cherchons un champ d&rsquo;abord. Si l&rsquo;instance n&rsquo;a pas de champ avec le nom de propriété donné, alors le nom peut faire référence à une méthode.</p>
<p>Nous prenons la classe de l&rsquo;instance et la passons à un nouvel assistant <code>bindMethod()</code>. Si cette fonction trouve une méthode, elle place la méthode sur la pile et renvoie <code>true</code>. Sinon elle renvoie <code>false</code> pour indiquer qu&rsquo;une méthode avec ce nom n&rsquo;a pas pu être trouvée. Puisque le nom n&rsquo;était pas aussi un champ, cela signifie que nous avons une erreur d&rsquo;exécution, qui avorte l&rsquo;interpréteur.</p>
<p>Voici la bonne marchandise :</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>callValue</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">bindMethod</span>(<span class="t">ObjClass</span>* <span class="i">klass</span>, <span class="t">ObjString</span>* <span class="i">name</span>) {
  <span class="t">Value</span> <span class="i">method</span>;
  <span class="k">if</span> (!<span class="i">tableGet</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>, <span class="i">name</span>, &amp;<span class="i">method</span>)) {
    <span class="i">runtimeError</span>(<span class="s">&quot;Undefined property &#39;%s&#39;.&quot;</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
    <span class="k">return</span> <span class="k">false</span>;
  }

  <span class="t">ObjBoundMethod</span>* <span class="i">bound</span> = <span class="i">newBoundMethod</span>(<span class="i">peek</span>(<span class="n">0</span>),
                                         <span class="a">AS_CLOSURE</span>(<span class="i">method</span>));
  <span class="i">pop</span>();
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">bound</span>));
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>callValue</em>()</div>

<p>D&rsquo;abord nous cherchons une méthode avec le nom donné dans la table de méthode de la classe. Si nous n&rsquo;en trouvons pas une, nous rapportons une erreur d&rsquo;exécution et évacuons. Sinon, nous prenons la méthode et l&rsquo;enveloppons dans une nouvelle ObjBoundMethod. Nous attrapons le receveur depuis sa maison au sommet de la pile. Finalement, nous dépilons l&rsquo;instance et remplaçons le sommet de la pile avec la méthode liée.</p>
<p>Par exemple :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Brunch</span> {
  <span class="i">eggs</span>() {}
}

<span class="k">var</span> <span class="i">brunch</span> = <span class="t">Brunch</span>();
<span class="k">var</span> <span class="i">eggs</span> = <span class="i">brunch</span>.<span class="i">eggs</span>;
</pre></div>
<p>Voici ce qui arrive quand la VM exécute l&rsquo;appel <code>bindMethod()</code> pour l&rsquo;expression <code>brunch.eggs</code> :</p><img src="image/methods-and-initializers/bind-method.png" alt="Les changements de pile causés par bindMethod()." />
<p>C&rsquo;est beaucoup de machinerie sous le capot, mais de la perspective de l&rsquo;utilisateur, ils obtiennent simplement une fonction qu&rsquo;ils peuvent appeler.</p>
<h3><a href="#appeler-les-méthodes" id="appeler-les-méthodes"><small>28&#8202;.&#8202;2&#8202;.&#8202;3</small>Appeler les méthodes</a></h3>
<p>Les utilisateurs peuvent déclarer des méthodes sur des classes, les accéder sur des instances, et obtenir des méthodes liées sur la pile. Ils ne peuvent juste rien <span name="do"><em>faire</em></span> d&rsquo;utile avec ces objets méthode liée. L&rsquo;opération que nous manquons est de les appeler. Les appels sont implémentés dans <code>callValue()</code>, donc nous ajoutons un cas là pour le nouveau type d&rsquo;objet.</p>
<aside name="do">
<p>Une méthode liée <em>est</em> une valeur de première classe, donc ils peuvent la stocker dans des variables, la passer à des fonctions, et faire autrement des trucs de &ldquo;valeur&rdquo; avec elle.</p>
</aside>
<div class="codehilite"><pre class="insert-before">    switch (OBJ_TYPE(callee)) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>callValue</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OBJ_BOUND_METHOD</span>: {
        <span class="t">ObjBoundMethod</span>* <span class="i">bound</span> = <span class="a">AS_BOUND_METHOD</span>(<span class="i">callee</span>);
        <span class="k">return</span> <span class="i">call</span>(<span class="i">bound</span>-&gt;<span class="i">method</span>, <span class="i">argCount</span>);
      }
</pre><pre class="insert-after">      case OBJ_CLASS: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>

<p>Nous tirons la fermeture brute de retour hors de l&rsquo;ObjBoundMethod et utilisons l&rsquo;assistant <code>call()</code> existant pour commencer une invocation de cette fermeture en empilant une CallFrame pour elle sur la pile d&rsquo;appels. C&rsquo;est tout ce qu&rsquo;il faut pour être capable d&rsquo;exécuter ce programme Lox :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Scone</span> {
  <span class="i">topping</span>(<span class="i">first</span>, <span class="i">second</span>) {
    <span class="k">print</span> <span class="s">&quot;scone with &quot;</span> + <span class="i">first</span> + <span class="s">&quot; and &quot;</span> + <span class="i">second</span>;
  }
}

<span class="k">var</span> <span class="i">scone</span> = <span class="t">Scone</span>();
<span class="i">scone</span>.<span class="i">topping</span>(<span class="s">&quot;berries&quot;</span>, <span class="s">&quot;cream&quot;</span>);
</pre></div>
<p>C&rsquo;est trois grandes étapes. Nous pouvons déclarer, accéder, et invoquer des méthodes. Mais quelque chose manque. Nous sommes allés à tout ce problème pour envelopper la fermeture de méthode dans un objet qui lie le receveur, mais quand nous invoquons la méthode, nous n&rsquo;utilisons pas ce receveur du tout.</p>
<h2><a href="#this" id="this"><small>28&#8202;.&#8202;3</small>This</a></h2>
<p>La raison pour laquelle les méthodes liées ont besoin de garder une prise sur le receveur est pour qu&rsquo;il puisse être accédé à l&rsquo;intérieur du corps de la méthode. Lox expose le receveur d&rsquo;une méthode à travers des expressions <code>this</code>. Il est temps pour un peu de nouvelle syntaxe. Le lexer traite déjà <code>this</code> comme un type de jeton spécial, donc la première étape est de câbler ce jeton dans la table d&rsquo;analyse.</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_SUPER]         = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_THIS</span>]          = {<span class="i">this_</span>,    <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_TRUE]          = {literal,  NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<aside name="this">
<p>Le souligné à la fin du nom de la fonction d&rsquo;analyseur est parce que <code>this</code> est un mot réservé en C++ et nous supportons de compiler clox comme C++.</p>
</aside>
<p>Quand l&rsquo;analyseur rencontre un <code>this</code> en position préfixe, il répartit vers une nouvelle fonction d&rsquo;analyseur.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>variable</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">this_</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="i">variable</span>(<span class="k">false</span>);
}<span name="this"> </span>
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>variable</em>()</div>

<p>Nous appliquerons la même technique d&rsquo;implémentation pour <code>this</code> dans clox que nous avons utilisée dans jlox. Nous traitons <code>this</code> comme une variable locale de portée lexicale dont la valeur devient magiquement initialisée. Le compiler comme une variable locale signifie que nous obtenons beaucoup de comportement gratuitement. En particulier, les fermetures à l&rsquo;intérieur d&rsquo;une méthode qui référencent <code>this</code> feront la bonne chose et captureront le receveur dans une upvalue.</p>
<p>Quand la fonction d&rsquo;analyseur est appelée, le jeton <code>this</code> a juste été consommé et est stocké comme le jeton précédent. Nous appelons notre fonction <code>variable()</code> existante qui compile les expressions d&rsquo;identifiant comme des accès de variable. Elle prend un seul paramètre Booléen pour si le compilateur devrait chercher un opérateur <code>=</code> suivant et analyser un setter. Vous ne pouvez pas assigner à <code>this</code>, donc nous passons <code>false</code> pour interdire cela.</p>
<p>La fonction <code>variable()</code> ne se soucie pas que <code>this</code> a son propre type de jeton et n&rsquo;est pas un identifiant. Elle est contente de traiter le lexème &ldquo;this&rdquo; comme s&rsquo;il était un nom de variable et ensuite le chercher utilisant la machinerie de résolution de portée existante. En ce moment, cette recherche échouera parce que nous n&rsquo;avons jamais déclaré une variable dont le nom est &ldquo;this&rdquo;. Il est temps de penser à où le receveur devrait vivre en mémoire.</p>
<p>Au moins jusqu&rsquo;à ce qu&rsquo;ils soient capturés par des fermetures, clox stocke chaque variable locale sur la pile de la VM. Le compilateur garde la trace de quels slots dans la fenêtre de pile de la fonction sont possédés par quelles variables locales. Si vous vous souvenez, le compilateur met de côté l&rsquo;emplacement de pile zéro en déclarant une variable locale dont le nom est une chaîne vide.</p>
<p>Pour les appels de fonction, cet emplacement finit par contenir la fonction étant appelée. Puisque l&rsquo;emplacement n&rsquo;a aucun nom, le corps de fonction ne l&rsquo;accède jamais. Vous pouvez deviner où cela va. Pour les appels de <em>méthode</em>, nous pouvons réutiliser cet emplacement pour stocker le receveur. L&rsquo;emplacement zéro stockera l&rsquo;instance à laquelle <code>this</code> est lié. Afin de compiler les expressions <code>this</code>, le compilateur a simplement besoin de donner le bon nom à cette variable locale.</p>
<div class="codehilite"><pre class="insert-before">  local-&gt;isCaptured = false;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>initCompiler</em>()<br>
replace 2 lines</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">type</span> != <span class="a">TYPE_FUNCTION</span>) {
    <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">start</span> = <span class="s">&quot;this&quot;</span>;
    <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">length</span> = <span class="n">4</span>;
  } <span class="k">else</span> {
    <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">start</span> = <span class="s">&quot;&quot;</span>;
    <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">length</span> = <span class="n">0</span>;
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>(), replace 2 lines</div>

<p>Nous voulons faire ceci seulement pour les méthodes. Les déclarations de fonction n&rsquo;ont pas de <code>this</code>. Et, en fait, elles <em>ne doivent pas</em> déclarer une variable nommée &ldquo;this&rdquo;, pour que si vous écrivez une expression <code>this</code> à l&rsquo;intérieur d&rsquo;une déclaration de fonction qui est elle-même à l&rsquo;intérieur d&rsquo;une méthode, le <code>this</code> se résout correctement vers le receveur de la méthode extérieure.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Nested</span> {
  <span class="i">method</span>() {
    <span class="k">fun</span> <span class="i">function</span>() {
      <span class="k">print</span> <span class="k">this</span>;
    }

    <span class="i">function</span>();
  }
}

<span class="t">Nested</span>().<span class="i">method</span>();
</pre></div>
<p>Ce programme devrait afficher &ldquo;Nested instance&rdquo;. Pour décider quel nom donner à l&rsquo;emplacement local zéro, le compilateur a besoin de savoir s&rsquo;il compile une déclaration de fonction ou de méthode, donc nous ajoutons un nouveau cas à notre énumération FunctionType pour distinguer les méthodes.</p>
<div class="codehilite"><pre class="insert-before">  TYPE_FUNCTION,
</pre><div class="source-file"><em>compiler.c</em><br>
in enum <em>FunctionType</em></div>
<pre class="insert">  <span class="a">TYPE_METHOD</span>,
</pre><pre class="insert-after">  TYPE_SCRIPT
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in enum <em>FunctionType</em></div>

<p>Quand nous compilons une méthode, nous utilisons ce type.</p>
<div class="codehilite"><pre class="insert-before">  uint8_t constant = identifierConstant(&amp;parser.previous);

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>method</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">FunctionType</span> <span class="i">type</span> = <span class="a">TYPE_METHOD</span>;
</pre><pre class="insert-after">  function(type);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>method</em>(), replace 1 line</div>

<p>Maintenant nous pouvons correctement compiler les références à la variable spéciale &ldquo;this&rdquo;, et le compilateur émettra les bonnes instructions <code>OP_GET_LOCAL</code> pour l&rsquo;accéder. Les fermetures peuvent même capturer <code>this</code> et stocker le receveur dans des upvalues. Plutôt cool.</p>
<p>Sauf qu&rsquo;à l&rsquo;exécution, le receveur n&rsquo;est pas réellement <em>dans</em> l&rsquo;emplacement zéro. L&rsquo;interpréteur ne tient pas sa part du marché encore. Voici la réparation :</p>
<div class="codehilite"><pre class="insert-before">      case OBJ_BOUND_METHOD: {
        ObjBoundMethod* bound = AS_BOUND_METHOD(callee);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>callValue</em>()</div>
<pre class="insert">        <span class="i">vm</span>.<span class="i">stackTop</span>[-<span class="i">argCount</span> - <span class="n">1</span>] = <span class="i">bound</span>-&gt;<span class="i">receiver</span>;
</pre><pre class="insert-after">        return call(bound-&gt;method, argCount);
      }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>

<p>Quand une méthode est appelée, le sommet de la pile contient tous les arguments, et ensuite juste sous ceux-ci est la fermeture de la méthode appelée. C&rsquo;est là que l&rsquo;emplacement zéro dans la nouvelle CallFrame sera. Cette ligne de code insère le receveur dans cet emplacement. Par exemple, donné un appel de méthode comme ceci :</p>
<div class="codehilite"><pre><span class="i">scone</span>.<span class="i">topping</span>(<span class="s">&quot;berries&quot;</span>, <span class="s">&quot;cream&quot;</span>);
</pre></div>
<p>Nous calculons l&rsquo;emplacement pour stocker le receveur comme ceci :</p><img src="image/methods-and-initializers/closure-slot.png" alt="Sautant par-dessus les emplacements de pile argument pour trouver l'emplacement contenant la fermeture." />
<p>Le <code>-argCount</code> saute passé les arguments et le <code>- 1</code> ajuste pour le fait que <code>stackTop</code> pointe juste <em>après</em> le dernier emplacement de pile utilisé.</p>
<h3><a href="#mauvais-usage-de-this" id="mauvais-usage-de-this"><small>28&#8202;.&#8202;3&#8202;.&#8202;1</small>Mauvais usage de this</a></h3>
<p>Notre VM supporte maintenant que les utilisateurs utilisent <em>correctement</em> <code>this</code>, mais nous devons aussi nous assurer qu&rsquo;elle gère proprement les utilisateurs utilisant <em>mal</em> <code>this</code>. Lox dit que c&rsquo;est une erreur de compilation pour une expression <code>this</code> d&rsquo;apparaître en dehors du corps d&rsquo;une méthode. Ces deux mauvais usages devraient être attrapés par le compilateur :</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="k">this</span>; <span class="c">// Au niveau supérieur.</span>

<span class="k">fun</span> <span class="i">notMethod</span>() {
  <span class="k">print</span> <span class="k">this</span>; <span class="c">// Dans une fonction.</span>
}
</pre></div>
<p>Donc comment le compilateur sait-il s&rsquo;il est à l&rsquo;intérieur d&rsquo;une méthode ? La réponse évidente est de regarder le FunctionType du Compiler courant. Nous avons juste ajouté un cas d&rsquo;énumération là pour traiter les méthodes spécialement. Cependant, cela ne gérerait pas correctement le code comme l&rsquo;exemple plus tôt où vous êtes à l&rsquo;intérieur d&rsquo;une fonction qui est, elle-même, imbriquée à l&rsquo;intérieur d&rsquo;une méthode.</p>
<p>Nous pourrions essayer de résoudre &ldquo;this&rdquo; et ensuite rapporter une erreur s&rsquo;il n&rsquo;a été trouvé dans aucune des portées lexicales environnantes. Cela fonctionnerait, mais nécessiterait de remanier un tas de code, puisque pour l&rsquo;instant le code pour résoudre une variable la considère implicitement comme un accès global si aucune déclaration n&rsquo;est trouvée.</p>
<p>Dans le prochain chapitre, nous aurons besoin d&rsquo;information sur la classe englobante la plus proche. Si nous avions cela, nous pourrions l&rsquo;utiliser ici pour déterminer si nous sommes à l&rsquo;intérieur d&rsquo;une méthode. Donc nous pouvons aussi bien rendre la vie de nos futurs nous-mêmes un peu plus facile et mettre cette machinerie en place maintenant.</p>
<div class="codehilite"><pre class="insert-before">Compiler* current = NULL;
</pre><div class="source-file"><em>compiler.c</em><br>
add after variable <em>current</em></div>
<pre class="insert"><span class="t">ClassCompiler</span>* <span class="i">currentClass</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">

static Chunk* currentChunk() {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>current</em></div>

<p>Cette variable de module pointe vers une structure représentant la classe courante, la plus intérieure, étant compilée. Le nouveau type ressemble à ceci :</p>
<div class="codehilite"><pre class="insert-before">} Compiler;
</pre><div class="source-file"><em>compiler.c</em><br>
add after struct <em>Compiler</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> <span class="t">ClassCompiler</span> {
  <span class="k">struct</span> <span class="t">ClassCompiler</span>* <span class="i">enclosing</span>;
} <span class="t">ClassCompiler</span>;
</pre><pre class="insert-after">

Parser parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>Compiler</em></div>

<p>Pour l&rsquo;instant nous stockons seulement un pointeur vers le ClassCompiler pour la classe englobante, s&rsquo;il y en a une. Imbriquer une déclaration de classe à l&rsquo;intérieur d&rsquo;une méthode dans quelque autre classe est une chose peu commune à faire, mais Lox le supporte. Juste comme la structure Compiler, cela signifie que ClassCompiler forme une liste liée depuis la classe la plus intérieure courante étant compilée vers l&rsquo;extérieur à travers toutes les classes englobantes.</p>
<p>Si nous ne sommes pas à l&rsquo;intérieur d&rsquo;une déclaration de classe du tout, la variable de module <code>currentClass</code> est <code>NULL</code>. Quand le compilateur commence à compiler une classe, il empile un nouveau ClassCompiler sur cette pile liée implicite.</p>
<div class="codehilite"><pre class="insert-before">  defineVariable(nameConstant);

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>classDeclaration</em>()</div>
<pre class="insert">  <span class="t">ClassCompiler</span> <span class="i">classCompiler</span>;
  <span class="i">classCompiler</span>.<span class="i">enclosing</span> = <span class="i">currentClass</span>;
  <span class="i">currentClass</span> = &amp;<span class="i">classCompiler</span>;

</pre><pre class="insert-after">  namedVariable(className, false);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>

<p>La mémoire pour la structure ClassCompiler vit juste sur la pile C, une capacité pratique que nous obtenons en écrivant notre compilateur utilisant la descente récursive. À la fin du corps de classe, nous dépilons ce compilateur de la pile et restaurons celui englobant.</p>
<div class="codehilite"><pre class="insert-before">  emitByte(OP_POP);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>classDeclaration</em>()</div>
<pre class="insert">

  <span class="i">currentClass</span> = <span class="i">currentClass</span>-&gt;<span class="i">enclosing</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>

<p>Quand un corps de classe le plus extérieur finit, <code>enclosing</code> sera <code>NULL</code>, donc ceci réinitialise <code>currentClass</code> à <code>NULL</code>. Ainsi, pour voir si nous sommes à l&rsquo;intérieur d&rsquo;une classe<span class="em">&mdash;</span>et par conséquent à l&rsquo;intérieur d&rsquo;une méthode<span class="em">&mdash;</span>nous vérifions simplement cette variable de module.</p>
<div class="codehilite"><pre class="insert-before">static void this_(bool canAssign) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>this_</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">currentClass</span> == <span class="a">NULL</span>) {
    <span class="i">error</span>(<span class="s">&quot;Can&#39;t use &#39;this&#39; outside of a class.&quot;</span>);
    <span class="k">return</span>;
  }

</pre><pre class="insert-after">  variable(false);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>this_</em>()</div>

<p>Avec cela, <code>this</code> en dehors d&rsquo;une classe est correctement interdit. Maintenant nos méthodes se sentent vraiment comme des <em>méthodes</em> dans le sens orienté objet. Accéder au receveur leur permet d&rsquo;affecter l&rsquo;instance sur laquelle vous avez appelé la méthode. Nous y arrivons !</p>
<h2><a href="#initialisateurs-dinstance" id="initialisateurs-dinstance"><small>28&#8202;.&#8202;4</small>Initialisateurs d&rsquo;Instance</a></h2>
<p>La raison pour laquelle les langages orientés objet lient l&rsquo;état et le comportement ensemble<span class="em">&mdash;</span>un des principes fondamentaux du paradigme<span class="em">&mdash;</span>est pour s&rsquo;assurer que les objets sont toujours dans un état valide, significatif. Quand le seul moyen de toucher à l&rsquo;état d&rsquo;un objet est <span name="through">à travers</span> ses méthodes, les méthodes peuvent s&rsquo;assurer que rien ne tourne mal. Mais cela présume que l&rsquo;objet est <em>déjà</em> dans un état propre. Qu&rsquo;en est-il quand il est d&rsquo;abord créé ?</p>
<aside name="through">
<p>Bien sûr, Lox laisse bien le code extérieur accéder directement et modifier les champs d&rsquo;une instance sans passer par ses méthodes. C&rsquo;est différent de Ruby et Smalltalk, qui encapsulent complètement l&rsquo;état à l&rsquo;intérieur des objets. Notre langage de script jouet, hélas, n&rsquo;est pas si principiel.</p>
</aside>
<p>Les langages orientés objet assurent que les tout nouveaux objets sont proprement configurés à travers des constructeurs, qui produisent à la fois une nouvelle instance et initialisent son état. Dans Lox, le runtime alloue les nouvelles instances brutes, et une classe peut déclarer un initialisateur pour configurer tous champs. Les initialisateurs fonctionnent surtout comme des méthodes normales, avec quelques ajustements :</p>
<ol>
<li>
<p>Le runtime invoque automatiquement la méthode initialisateur chaque fois qu&rsquo;une instance d&rsquo;une classe est créée.</p>
</li>
<li>
<p>L&rsquo;appelant qui construit une instance obtient toujours l&rsquo;instance de <span name="return">retour</span> après que l&rsquo;initialisateur finit, indépendamment de ce que la fonction initialisateur elle-même renvoie. La méthode initialisateur n&rsquo;a pas besoin de retourner explicitement <code>this</code>.</p>
</li>
<li>
<p>En fait, il est <em>interdit</em> à un initialisateur de retourner toute valeur puisque la valeur ne serait jamais vue de toute façon.</p>
</li>
</ol>
<aside name="return">
<p>C&rsquo;est comme si l&rsquo;initialisateur était implicitement enveloppé dans un paquet de code comme ceci :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">create</span>(<span class="i">klass</span>) {
  <span class="k">var</span> <span class="i">obj</span> = <span class="i">newInstance</span>(<span class="i">klass</span>);
  <span class="i">obj</span>.<span class="i">init</span>();
  <span class="k">return</span> <span class="i">obj</span>;
}
</pre></div>
<p>Notez comment la valeur renvoyée par <code>init()</code> est jetée.</p>
</aside>
<p>Maintenant que nous supportons les méthodes, pour ajouter les initialisateurs, nous avons simplement besoin d&rsquo;implémenter ces trois règles spéciales. Nous irons dans l&rsquo;ordre.</p>
<h3><a href="#invoquer-les-initialisateurs" id="invoquer-les-initialisateurs"><small>28&#8202;.&#8202;4&#8202;.&#8202;1</small>Invoquer les initialisateurs</a></h3>
<p>D&rsquo;abord, appeler automatiquement <code>init()</code> sur les nouvelles instances :</p>
<div class="codehilite"><pre class="insert-before">        vm.stackTop[-argCount - 1] = OBJ_VAL(newInstance(klass));
</pre><div class="source-file"><em>vm.c</em><br>
in <em>callValue</em>()</div>
<pre class="insert">        <span class="t">Value</span> <span class="i">initializer</span>;
        <span class="k">if</span> (<span class="i">tableGet</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>, <span class="i">vm</span>.<span class="i">initString</span>,
                     &amp;<span class="i">initializer</span>)) {
          <span class="k">return</span> <span class="i">call</span>(<span class="a">AS_CLOSURE</span>(<span class="i">initializer</span>), <span class="i">argCount</span>);
        }
</pre><pre class="insert-after">        return true;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>

<p>Après que le runtime alloue la nouvelle instance, nous cherchons une méthode <code>init()</code> sur la classe. Si nous en trouvons une, nous initions un appel vers elle. Cela empile une nouvelle CallFrame pour la fermeture de l&rsquo;initialisateur. Disons que nous exécutons ce programme :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Brunch</span> {
  <span class="i">init</span>(<span class="i">food</span>, <span class="i">drink</span>) {}
}

<span class="t">Brunch</span>(<span class="s">&quot;eggs&quot;</span>, <span class="s">&quot;coffee&quot;</span>);
</pre></div>
<p>Quand la VM exécute l&rsquo;appel à <code>Brunch()</code>, cela va comme ceci :</p><img src="image/methods-and-initializers/init-call-frame.png" alt="Les fenêtres de pile alignées pour l'appel Brunch() et la méthode init() correspondante vers laquelle il transfère." />
<p>Tous arguments passés à la classe quand nous l&rsquo;avons appelée sont encore assis sur la pile au-dessus de l&rsquo;instance. La nouvelle CallFrame pour la méthode <code>init()</code> partage cette fenêtre de pile, donc ces arguments sont implicitement transférés à l&rsquo;initialisateur.</p>
<p>Lox n&rsquo;exige pas qu&rsquo;une classe définisse un initialisateur. Si omis, le runtime renvoie simplement la nouvelle instance non initialisée. Cependant, s&rsquo;il n&rsquo;y a pas de méthode <code>init()</code>, alors cela n&rsquo;a aucun sens de passer des arguments à la classe lors de la création de l&rsquo;instance. Nous faisons de cela une erreur.</p>
<div class="codehilite"><pre class="insert-before">          return call(AS_CLOSURE(initializer), argCount);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>callValue</em>()</div>
<pre class="insert">        } <span class="k">else</span> <span class="k">if</span> (<span class="i">argCount</span> != <span class="n">0</span>) {
          <span class="i">runtimeError</span>(<span class="s">&quot;Expected 0 arguments but got %d.&quot;</span>,
                       <span class="i">argCount</span>);
          <span class="k">return</span> <span class="k">false</span>;
</pre><pre class="insert-after">        }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>

<p>Quand la classe <em>fournit</em> bien un initialisateur, nous avons aussi besoin de nous assurer que le nombre d&rsquo;arguments passés correspond à l&rsquo;arité de l&rsquo;initialisateur. Heureusement, l&rsquo;assistant <code>call()</code> fait cela pour nous déjà.</p>
<p>Pour appeler l&rsquo;initialisateur, le runtime cherche la méthode <code>init()</code> par nom. Nous voulons que cela soit rapide puisque cela arrive chaque fois qu&rsquo;une instance est construite. Cela signifie qu&rsquo;il serait bon de prendre avantage de l&rsquo;internement de chaînes que nous avons déjà implémenté. Pour faire cela, la VM crée une ObjString pour &ldquo;init&rdquo; et la réutilise. La chaîne vit juste dans la structure VM.</p>
<div class="codehilite"><pre class="insert-before">  Table strings;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">ObjString</span>* <span class="i">initString</span>;
</pre><pre class="insert-after">  ObjUpvalue* openUpvalues;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>Nous créons et internons la chaîne quand la VM démarre.</p>
<div class="codehilite"><pre class="insert-before">  initTable(&amp;vm.strings);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">

  <span class="i">vm</span>.<span class="i">initString</span> = <span class="i">copyString</span>(<span class="s">&quot;init&quot;</span>, <span class="n">4</span>);
</pre><pre class="insert-after">

  defineNative(&quot;clock&quot;, clockNative);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>Nous voulons qu&rsquo;elle reste dans les parages, donc le GC la considère comme une racine.</p>
<div class="codehilite"><pre class="insert-before">  markCompilerRoots();
</pre><div class="source-file"><em>memory.c</em><br>
in <em>markRoots</em>()</div>
<pre class="insert">  <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">vm</span>.<span class="i">initString</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markRoots</em>()</div>

<p>Regardez attentivement. Voyez-vous un bug attendant d&rsquo;arriver ? Non ? C&rsquo;est un subtil. Le ramasse-miettes lit maintenant <code>vm.initString</code>. Ce champ est initialisé à partir du résultat de l&rsquo;appel <code>copyString()</code>. Mais copier une chaîne alloue de la mémoire, ce qui peut déclencher un GC. Si le collecteur courrait juste au mauvais moment, il lirait <code>vm.initString</code> avant qu&rsquo;il ait été initialisé. Donc, d&rsquo;abord nous mettons le champ à zéro.</p>
<div class="codehilite"><pre class="insert-before">  initTable(&amp;vm.strings);

</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">  <span class="i">vm</span>.<span class="i">initString</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">  vm.initString = copyString(&quot;init&quot;, 4);

</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>Nous effaçons le pointeur quand la VM s&rsquo;éteint puisque la ligne suivante la libérera.</p>
<div class="codehilite"><pre class="insert-before">  freeTable(&amp;vm.strings);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>freeVM</em>()</div>
<pre class="insert">  <span class="i">vm</span>.<span class="i">initString</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">  freeObjects();
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>freeVM</em>()</div>

<p>OK, cela nous laisse appeler les initialisateurs.</p>
<h3><a href="#valeurs-de-retour-dinitialisateur" id="valeurs-de-retour-dinitialisateur"><small>28&#8202;.&#8202;4&#8202;.&#8202;2</small>Valeurs de retour d&rsquo;initialisateur</a></h3>
<p>L&rsquo;étape suivante est de s&rsquo;assurer que construire une instance d&rsquo;une classe avec un initialisateur renvoie toujours la nouvelle instance, et non <code>nil</code> ou quoi que ce soit que le corps de l&rsquo;initialisateur renvoie. En ce moment, si une classe définit un initialisateur, alors quand une instance est construite, la VM empile un appel à cet initialisateur sur la pile CallFrame. Ensuite elle continue juste sa route.</p>
<p>L&rsquo;invocation de l&rsquo;utilisateur sur la classe pour créer l&rsquo;instance se complétera quand cette méthode initialisateur retournera, et laissera sur la pile quelle que soit la valeur que l&rsquo;initialisateur y met. Cela signifie que sauf si l&rsquo;utilisateur prend soin de mettre <code>return this;</code> à la fin de l&rsquo;initialisateur, aucune instance ne sortira. Pas très utile.</p>
<p>Pour réparer cela, chaque fois que le front end compile une méthode initialisateur, il émettra du bytecode différent à la fin du corps pour retourner <code>this</code> depuis la méthode au lieu de l&rsquo;implicite <code>nil</code> habituel que la plupart des fonctions retournent. Afin de faire <em>cela</em>, le compilateur a besoin de savoir réellement quand il compile un initialisateur. Nous détectons cela en vérifiant si le nom de la méthode que nous compilons est &ldquo;init&rdquo;.</p>
<div class="codehilite"><pre class="insert-before">  FunctionType type = TYPE_METHOD;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>method</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">length</span> == <span class="n">4</span> &amp;&amp;
      <span class="i">memcmp</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">start</span>, <span class="s">&quot;init&quot;</span>, <span class="n">4</span>) == <span class="n">0</span>) {
    <span class="i">type</span> = <span class="a">TYPE_INITIALIZER</span>;
  }

</pre><pre class="insert-after">  function(type);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>method</em>()</div>

<p>Nous définissons un nouveau type de fonction pour distinguer les initialisateurs des autres méthodes.</p>
<div class="codehilite"><pre class="insert-before">  TYPE_FUNCTION,
</pre><div class="source-file"><em>compiler.c</em><br>
in enum <em>FunctionType</em></div>
<pre class="insert">  <span class="a">TYPE_INITIALIZER</span>,
</pre><pre class="insert-after">  TYPE_METHOD,
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in enum <em>FunctionType</em></div>

<p>Chaque fois que le compilateur émet le retour implicite à la fin d&rsquo;un corps, nous vérifions le type pour décider si insérer le comportement spécifique à l&rsquo;initialisateur.</p>
<div class="codehilite"><pre class="insert-before">static void emitReturn() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>emitReturn</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">type</span> == <span class="a">TYPE_INITIALIZER</span>) {
    <span class="i">emitBytes</span>(<span class="a">OP_GET_LOCAL</span>, <span class="n">0</span>);
  } <span class="k">else</span> {
    <span class="i">emitByte</span>(<span class="a">OP_NIL</span>);
  }

</pre><pre class="insert-after">  emitByte(OP_RETURN);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>emitReturn</em>(), replace 1 line</div>

<p>Dans un initialisateur, au lieu d&rsquo;empiler <code>nil</code> sur la pile avant de retourner, nous chargeons l&rsquo;emplacement zéro, qui contient l&rsquo;instance. Cette fonction <code>emitReturn()</code> est aussi appelée lors de la compilation d&rsquo;une instruction <code>return</code> sans valeur, donc ceci gère aussi correctement les cas où l&rsquo;utilisateur fait un retour précoce à l&rsquo;intérieur de l&rsquo;initialisateur.</p>
<h3><a href="#retours-incorrects-dans-les-initialisateurs" id="retours-incorrects-dans-les-initialisateurs"><small>28&#8202;.&#8202;4&#8202;.&#8202;3</small>Retours incorrects dans les initialisateurs</a></h3>
<p>La dernière étape, le dernier élément dans notre liste de fonctionnalités spéciales des initialisateurs, est de faire une erreur d&rsquo;essayer de retourner quoi que ce soit d&rsquo;<em>autre</em> depuis un initialisateur. Maintenant que le compilateur suit le type de méthode, c&rsquo;est direct.</p>
<div class="codehilite"><pre class="insert-before">  if (match(TOKEN_SEMICOLON)) {
    emitReturn();
  } else {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>returnStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">type</span> == <span class="a">TYPE_INITIALIZER</span>) {
      <span class="i">error</span>(<span class="s">&quot;Can&#39;t return a value from an initializer.&quot;</span>);
    }

</pre><pre class="insert-after">    expression();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>returnStatement</em>()</div>

<p>Nous rapportons une erreur si une instruction <code>return</code> dans un initialisateur a une valeur. Nous allons quand même de l&rsquo;avant et compilons la valeur après pour que le compilateur ne soit pas confus par l&rsquo;expression traînante et rapporte un tas d&rsquo;erreurs en cascade.</p>
<p>À part l&rsquo;héritage, auquel nous arriverons <a href="superclasses.html">bientôt</a>, nous avons maintenant un système de classe assez complet fonctionnant dans clox.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">CoffeeMaker</span> {
  <span class="i">init</span>(<span class="i">coffee</span>) {
    <span class="k">this</span>.<span class="i">coffee</span> = <span class="i">coffee</span>;
  }

  <span class="i">brew</span>() {
    <span class="k">print</span> <span class="s">&quot;Enjoy your cup of &quot;</span> + <span class="k">this</span>.<span class="i">coffee</span>;

    <span class="c">// No reusing the grounds!</span>
    <span class="k">this</span>.<span class="i">coffee</span> = <span class="k">nil</span>;
  }
}

<span class="k">var</span> <span class="i">maker</span> = <span class="t">CoffeeMaker</span>(<span class="s">&quot;coffee and chicory&quot;</span>);
<span class="i">maker</span>.<span class="i">brew</span>();
</pre></div>
<p>Plutôt fantaisiste pour un programme C qui tiendrait sur une vieille disquette <span name="floppy">souple</span>.</p>
<aside name="floppy">
<p>Je reconnais que &ldquo;disquette souple&rdquo; peut ne plus être une référence de taille utile pour les générations actuelles de programmeurs. Peut-être aurais-je dû dire &ldquo;quelques tweets&rdquo; ou quelque chose.</p>
</aside>
<h2><a href="#invocations-optimisées" id="invocations-optimisées"><small>28&#8202;.&#8202;5</small>Invocations Optimisées</a></h2>
<p>Notre VM implémente correctement la sémantique du langage pour les appels de méthodes et les initialisateurs. Nous pourrions arrêter ici. Mais la raison principale pour laquelle nous construisons une entière seconde implémentation de Lox à partir de zéro est pour exécuter plus vite que notre vieil interpréteur Java. En ce moment, les appels de méthode même dans clox sont lents.</p>
<p>La sémantique de Lox définit une invocation de méthode comme deux opérations<span class="em">&mdash;</span>accéder à la méthode et ensuite appeler le résultat. Notre VM doit supporter celles-ci comme des opérations séparées parce que l&rsquo;utilisateur <em>peut</em> les séparer. Vous pouvez accéder une méthode sans l&rsquo;appeler et ensuite invoquer la méthode liée plus tard. Rien de ce que nous avons implémenté jusqu&rsquo;ici n&rsquo;est inutile.</p>
<p>Mais <em>toujours</em> exécuter celles-ci comme des opérations séparées a un coût significatif. Chaque fois qu&rsquo;un programme Lox accède et invoque une méthode, le runtime alloue sur le tas une nouvelle ObjBoundMethod, initialise ses champs, ensuite les tire juste de retour en dehors. Plus tard, le GC doit passer du temps à libérer toutes ces méthodes liées éphémères.</p>
<p>La plupart du temps, un programme Lox accède une méthode et ensuite l&rsquo;appelle immédiatement. La méthode liée est créée par une instruction bytecode et ensuite consommée par la toute suivante. En fait, c&rsquo;est si immédiat que le compilateur peut même textuellement <em>voir</em> que cela arrive<span class="em">&mdash;</span>un accès de propriété pointé suivi par une parenthèse ouvrante est très probablement un appel de méthode.</p>
<p>Puisque nous pouvons reconnaître cette paire d&rsquo;opérations au moment de la compilation, nous avons l&rsquo;opportunité d&rsquo;émettre une <span name="super">nouvelle, instruction spéciale</span> qui performe un appel de méthode optimisé.</p>
<p>Nous commençons dans la fonction qui compile les expressions de propriété pointées.</p>
<aside name="super" class="bottom">
<p>Si vous passez assez de temps à regarder votre VM à bytecode courir, vous remarquerez qu&rsquo;elle exécute souvent la même série d&rsquo;instructions bytecode l&rsquo;une après l&rsquo;autre. Une technique d&rsquo;optimisation classique est de définir une nouvelle instruction unique appelée une <strong>superinstruction</strong> qui fusionne celles-ci en une seule instruction avec le même comportement que la séquence entière.</p>
<p>Une des plus grandes pertes de performance dans un interpréteur bytecode est le surcoût de décoder et répartir chaque instruction. Fusionner plusieurs instructions en une élimine un peu de cela.</p>
<p>Le défi est de déterminer <em>quelles</em> séquences d&rsquo;instruction sont assez communes pour bénéficier de cette optimisation. Chaque nouvelle superinstruction réclame un opcode pour son propre usage et il y en a seulement tant à distribuer. Ajoutez-en trop, et vous aurez besoin d&rsquo;un encodage plus large pour les opcodes, ce qui augmente alors la taille du code et rend le décodage de <em>toutes</em> les instructions plus lent.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  if (canAssign &amp;&amp; match(TOKEN_EQUAL)) {
    expression();
    emitBytes(OP_SET_PROPERTY, name);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>dot</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_LEFT_PAREN</span>)) {
    <span class="t">uint8_t</span> <span class="i">argCount</span> = <span class="i">argumentList</span>();
    <span class="i">emitBytes</span>(<span class="a">OP_INVOKE</span>, <span class="i">name</span>);
    <span class="i">emitByte</span>(<span class="i">argCount</span>);
</pre><pre class="insert-after">  } else {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>dot</em>()</div>

<p>Après que le compilateur a analysé le nom de propriété, nous cherchons une parenthèse gauche. Si nous en matchons une, nous basculons vers un nouveau chemin de code. Là, nous compilons la liste d&rsquo;arguments exactement comme nous le faisons lors de la compilation d&rsquo;une expression d&rsquo;appel. Ensuite nous émettons une nouvelle instruction unique <code>OP_INVOKE</code>. Elle prend deux opérandes :</p>
<ol>
<li>
<p>L&rsquo;index du nom de propriété dans la table des constantes.</p>
</li>
<li>
<p>Le nombre d&rsquo;arguments passés à la méthode.</p>
</li>
</ol>
<p>En d&rsquo;autres termes, cette instruction unique combine les opérandes des instructions <code>OP_GET_PROPERTY</code> et <code>OP_CALL</code> qu&rsquo;elle remplace, dans cet ordre. C&rsquo;est vraiment une fusion de ces deux instructions. Définissons-la.</p>
<div class="codehilite"><pre class="insert-before">  OP_CALL,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_INVOKE</span>,
</pre><pre class="insert-after">  OP_CLOSURE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Et ajoutons-la au désassembleur :</p>
<div class="codehilite"><pre class="insert-before">    case OP_CALL:
      return byteInstruction(&quot;OP_CALL&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_INVOKE</span>:
      <span class="k">return</span> <span class="i">invokeInstruction</span>(<span class="s">&quot;OP_INVOKE&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>C&rsquo;est un nouveau format d&rsquo;instruction spécial, donc elle a besoin d&rsquo;un peu de logique de désassemblage personnalisée.</p>
<div class="codehilite"><div class="source-file"><em>debug.c</em><br>
add after <em>constantInstruction</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">invokeInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>,
                                <span class="t">int</span> <span class="i">offset</span>) {
  <span class="t">uint8_t</span> <span class="i">constant</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>];
  <span class="t">uint8_t</span> <span class="i">argCount</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">2</span>];
  <span class="i">printf</span>(<span class="s">&quot;%-16s (%d args) %4d &#39;&quot;</span>, <span class="i">name</span>, <span class="i">argCount</span>, <span class="i">constant</span>);
  <span class="i">printValue</span>(<span class="i">chunk</span>-&gt;<span class="i">constants</span>.<span class="i">values</span>[<span class="i">constant</span>]);
  <span class="i">printf</span>(<span class="s">&quot;&#39;</span><span class="e">\n</span><span class="s">&quot;</span>);
  <span class="k">return</span> <span class="i">offset</span> + <span class="n">3</span>;
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>constantInstruction</em>()</div>

<p>Nous lisons les deux opérandes et ensuite affichons à la fois le nom de la méthode et le compte d&rsquo;arguments. Là-bas dans la boucle de répartition bytecode de l&rsquo;interpréteur est où la vraie action commence.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_INVOKE</span>: {
        <span class="t">ObjString</span>* <span class="i">method</span> = <span class="a">READ_STRING</span>();
        <span class="t">int</span> <span class="i">argCount</span> = <span class="a">READ_BYTE</span>();
        <span class="k">if</span> (!<span class="i">invoke</span>(<span class="i">method</span>, <span class="i">argCount</span>)) {
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>La plupart du travail arrive dans <code>invoke()</code>, auquel nous arriverons. Ici, nous cherchons le nom de la méthode depuis le premier opérande et ensuite lisons l&rsquo;opérande compte d&rsquo;arguments. Ensuite nous passons la main à <code>invoke()</code> pour faire le gros du travail. Cette fonction renvoie <code>true</code> si l&rsquo;invocation réussit. Comme d&rsquo;habitude, un retour <code>false</code> signifie qu&rsquo;une erreur d&rsquo;exécution s&rsquo;est produite. Nous vérifions cela ici et avortons l&rsquo;interpréteur si le désastre a frappé.</p>
<p>Finalement, supposant que l&rsquo;invocation a réussi, alors il y a une nouvelle CallFrame sur la pile, donc nous rafraîchissons notre copie mise en cache du cadre courant dans <code>frame</code>.</p>
<p>Le travail intéressant arrive ici :</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>callValue</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">invoke</span>(<span class="t">ObjString</span>* <span class="i">name</span>, <span class="t">int</span> <span class="i">argCount</span>) {
  <span class="t">Value</span> <span class="i">receiver</span> = <span class="i">peek</span>(<span class="i">argCount</span>);
  <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">AS_INSTANCE</span>(<span class="i">receiver</span>);
  <span class="k">return</span> <span class="i">invokeFromClass</span>(<span class="i">instance</span>-&gt;<span class="i">klass</span>, <span class="i">name</span>, <span class="i">argCount</span>);
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>callValue</em>()</div>

<p>D&rsquo;abord nous attrapons le receveur hors de la pile. Les arguments passés à la méthode sont au-dessus de lui sur la pile, donc nous regardons ce nombre d&rsquo;emplacements plus bas. Ensuite c&rsquo;est une simple affaire de caster l&rsquo;objet vers une instance et invoquer la méthode sur lui.</p>
<p>Cela suppose bien que l&rsquo;objet <em>est</em> une instance. Comme avec les instructions <code>OP_GET_PROPERTY</code>, nous avons aussi besoin de gérer le cas où un utilisateur essaie incorrectement d&rsquo;appeler une méthode sur une valeur du mauvais type.</p>
<div class="codehilite"><pre class="insert-before">  Value receiver = peek(argCount);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>invoke</em>()</div>
<pre class="insert">

  <span class="k">if</span> (!<span class="a">IS_INSTANCE</span>(<span class="i">receiver</span>)) {
    <span class="i">runtimeError</span>(<span class="s">&quot;Only instances have methods.&quot;</span>);
    <span class="k">return</span> <span class="k">false</span>;
  }

</pre><pre class="insert-after">  ObjInstance* instance = AS_INSTANCE(receiver);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>invoke</em>()</div>

<p><span name="helper">C&rsquo;est</span> une erreur d&rsquo;exécution, donc nous rapportons cela et évacuons. Sinon, nous obtenons la classe de l&rsquo;instance et sautons vers cette autre nouvelle fonction utilitaire :</p>
<aside name="helper">
<p>Comme vous pouvez le deviner maintenant, nous divisons ce code en une fonction séparée parce que nous allons le réutiliser plus tard<span class="em">&mdash;</span>dans ce cas pour les appels <code>super</code>.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>callValue</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">invokeFromClass</span>(<span class="t">ObjClass</span>* <span class="i">klass</span>, <span class="t">ObjString</span>* <span class="i">name</span>,
                            <span class="t">int</span> <span class="i">argCount</span>) {
  <span class="t">Value</span> <span class="i">method</span>;
  <span class="k">if</span> (!<span class="i">tableGet</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>, <span class="i">name</span>, &amp;<span class="i">method</span>)) {
    <span class="i">runtimeError</span>(<span class="s">&quot;Undefined property &#39;%s&#39;.&quot;</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
    <span class="k">return</span> <span class="k">false</span>;
  }
  <span class="k">return</span> <span class="i">call</span>(<span class="a">AS_CLOSURE</span>(<span class="i">method</span>), <span class="i">argCount</span>);
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>callValue</em>()</div>

<p>Cette fonction combine la logique de comment la VM implémente les instructions <code>OP_GET_PROPERTY</code> et <code>OP_CALL</code>, dans cet ordre. D&rsquo;abord nous cherchons la méthode par nom dans la table de méthode de la classe. Si nous n&rsquo;en trouvons pas une, nous rapportons cette erreur d&rsquo;exécution et sortons.</p>
<p>Sinon, nous prenons la fermeture de la méthode et empilons un appel à elle sur la pile CallFrame. Nous n&rsquo;avons pas besoin d&rsquo;allouer sur le tas et initialiser une ObjBoundMethod. En fait, nous n&rsquo;avons même pas besoin de <span name="juggle">jongler</span> quoi que ce soit sur la pile. Le receveur et les arguments de méthode sont déjà juste où ils ont besoin d&rsquo;être.</p>
<aside name="juggle">
<p>C&rsquo;est une raison clé <em>pourquoi</em> nous utilisons l&rsquo;emplacement de pile zéro pour stocker le receveur<span class="em">&mdash;</span>c&rsquo;est comment l&rsquo;appelant organise déjà la pile pour un appel de méthode. Une convention d&rsquo;appel efficace est une partie importante de l&rsquo;histoire de performance d&rsquo;une VM à bytecode.</p>
</aside>
<p>Si vous démarrez la VM et exécutez un petit programme qui appelle des méthodes maintenant, vous devriez voir le comportement exactement identique comme avant. Mais, si nous avons fait notre travail correctement, la <em>performance</em> devrait être beaucoup améliorée. J&rsquo;ai écrit un petit microbenchmark qui fait un lot de 10 000 appels de méthode. Ensuite il teste combien de ces lots il peut exécuter en 10 secondes. Sur mon ordinateur, sans la nouvelle instruction <code>OP_INVOKE</code>, il est passé à travers 1 089 lots. Avec cette nouvelle optimisation, il a fini 8 324 lots dans le même temps. C&rsquo;est <em>7,6 fois plus rapide</em>, ce qui est une énorme amélioration quand il s&rsquo;agit d&rsquo;optimisation de langage de programmation.</p>
<p><span name="pat"></span></p>
<aside name="pat">
<p>Nous ne devrions pas nous taper dans le dos <em>trop</em> fermement. Cette amélioration de performance est relative à notre propre implémentation d&rsquo;appel de méthode non optimisée qui était assez lente. Faire une allocation tas pour chaque appel de méthode unique ne va gagner aucune course.</p>
</aside><img src="image/methods-and-initializers/benchmark.png" alt="Graphique à barres comparant les deux résultats de benchmark." />
<h3><a href="#invoquer-les-champs" id="invoquer-les-champs"><small>28&#8202;.&#8202;5&#8202;.&#8202;1</small>Invoquer les champs</a></h3>
<p>Le crédo fondamental de l&rsquo;optimisation est : &ldquo;Tu ne briseras pas la correction.&rdquo; Les <span name="monte">utilisateurs</span> aiment quand une implémentation de langage leur donne une réponse plus vite, mais seulement si c&rsquo;est la <em>bonne</em> réponse. Hélas, notre implémentation d&rsquo;invocations de méthode plus rapides échoue à soutenir ce principe :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Oops</span> {
  <span class="i">init</span>() {
    <span class="k">fun</span> <span class="i">f</span>() {
      <span class="k">print</span> <span class="s">&quot;not a method&quot;</span>;
    }

    <span class="k">this</span>.<span class="i">field</span> = <span class="i">f</span>;
  }
}

<span class="k">var</span> <span class="i">oops</span> = <span class="t">Oops</span>();
<span class="i">oops</span>.<span class="i">field</span>();
</pre></div>
<p>La dernière ligne ressemble à un appel de méthode. Le compilateur pense qu&rsquo;elle l&rsquo;est et émet consciencieusement une instruction <code>OP_INVOKE</code> pour elle. Cependant, elle ne l&rsquo;est pas. Ce qui arrive réellement est un accès de <em>champ</em> qui renvoie une fonction qui est ensuite appelée. En ce moment, au lieu d&rsquo;exécuter cela correctement, notre VM rapporte une erreur d&rsquo;exécution quand elle ne peut pas trouver une méthode nommée &ldquo;field&rdquo;.</p>
<aside name="monte">
<p>Il y a des cas où les utilisateurs peuvent être satisfaits quand un programme renvoie parfois la mauvaise réponse en retour pour tourner significativement plus vite ou avec une meilleure borne sur la performance. Ceux-ci sont le champ des <a href="https://fr.wikipedia.org/wiki/M%C3%A9thode_de_Monte-Carlo"><strong>algorithmes de Monte Carlo</strong></a>. Pour certains cas d&rsquo;utilisation, c&rsquo;est un bon compromis.</p>
<p>La partie importante, cependant, est que l&rsquo;utilisateur <em>choisit</em> d&rsquo;appliquer un de ces algorithmes. Nous implémenteurs de langage ne pouvons pas unilatéralement décider de sacrifier la correction de leur programme.</p>
</aside>
<p>Plus tôt, quand nous avons implémenté <code>OP_GET_PROPERTY</code>, nous gérions à la fois les accès de champ et de méthode. Pour écraser ce nouveau bug, nous avons besoin de faire la même chose pour <code>OP_INVOKE</code>.</p>
<div class="codehilite"><pre class="insert-before">  ObjInstance* instance = AS_INSTANCE(receiver);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>invoke</em>()</div>
<pre class="insert">

  <span class="t">Value</span> <span class="i">value</span>;
  <span class="k">if</span> (<span class="i">tableGet</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>, <span class="i">name</span>, &amp;<span class="i">value</span>)) {
    <span class="i">vm</span>.<span class="i">stackTop</span>[-<span class="i">argCount</span> - <span class="n">1</span>] = <span class="i">value</span>;
    <span class="k">return</span> <span class="i">callValue</span>(<span class="i">value</span>, <span class="i">argCount</span>);
  }

</pre><pre class="insert-after">  return invokeFromClass(instance-&gt;klass, name, argCount);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>invoke</em>()</div>

<p>Réparation assez simple. Avant de chercher une méthode sur la classe de l&rsquo;instance, nous cherchons un champ avec le même nom. Si nous trouvons un champ, alors nous le stockons sur la pile à la place du receveur, <em>sous</em> la liste d&rsquo;arguments. C&rsquo;est comme ça que <code>OP_GET_PROPERTY</code> se comporte puisque cette dernière instruction exécute avant qu&rsquo;une liste parenthesée subséquente d&rsquo;arguments ait été évaluée.</p>
<p>Ensuite nous essayons d&rsquo;appeler la valeur de ce champ comme l&rsquo;appelable qu&rsquo;elle est avec espoir. L&rsquo;assistant <code>callValue()</code> vérifiera le type de la valeur et l&rsquo;appellera comme approprié ou rapportera une erreur d&rsquo;exécution si la valeur du champ n&rsquo;est pas un type appelable comme une fermeture.</p>
<p>C&rsquo;est tout ce qu&rsquo;il faut pour rendre notre optimisation pleinement sûre. Nous sacrifions un peu de performance, malheureusement. Mais c&rsquo;est le prix que vous avez à payer parfois. Vous devenez occasionnellement frustré par des optimisations que vous <em>pourriez</em> faire si seulement le langage ne permettait pas quelque cas limite ennuyeux. Mais, en tant qu&rsquo;<span name="designer">implémenteurs</span> de langage, nous devons jouer le jeu qu&rsquo;on nous donne.</p>
<aside name="designer">
<p>En tant que <em>designers</em> de langage, notre rôle est très différent. Si nous contrôlons le langage lui-même, nous pouvons parfois choisir de restreindre ou changer le langage de façons qui permettent des optimisations. Les utilisateurs veulent des langages expressifs, mais ils veulent aussi des implémentations rapides. Parfois c&rsquo;est une bonne conception de langage de sacrifier un peu de puissance si vous pouvez leur donner de la perf en retour.</p>
</aside>
<p>Le code que nous avons écrit ici suit un motif typique en optimisation :</p>
<ol>
<li>
<p>Reconnaître une opération commune ou une séquence d&rsquo;opérations qui est critique pour la performance. Dans ce cas, c&rsquo;est un accès méthode suivi par un appel.</p>
</li>
<li>
<p>Ajouter une implémentation optimisée de ce motif. C&rsquo;est notre instruction <code>OP_INVOKE</code>.</p>
</li>
<li>
<p>Garder le code optimisé avec quelque logique conditionnelle qui valide que le motif s&rsquo;applique réellement. S&rsquo;il le fait, rester sur le chemin rapide. Sinon, se replier sur un comportement non optimisé plus lent mais plus robuste. Ici, cela signifie vérifier que nous appelons réellement une méthode et n&rsquo;accédons pas à un champ.</p>
</li>
</ol>
<p>Comme votre travail de langage bouge de faire fonctionner l&rsquo;implémentation <em>du tout</em> à la faire fonctionner <em>plus vite</em>, vous vous trouverez dépensant de plus en plus de temps à chercher des motifs comme celui-ci et ajoutant des optimisations gardées pour eux. Les ingénieurs VM à plein temps passent beaucoup de leur carrière dans cette boucle.</p>
<p>Mais nous pouvons arrêter ici pour l&rsquo;instant. Avec cela, clox supporte maintenant la plupart des fonctionnalités d&rsquo;un langage de programmation orienté objet, et avec une performance respectable.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>28&#8202;.&#8202;6</small>Défis</a></h2>
<ol>
<li>
<p>La recherche dans la table de hachage pour trouver la méthode <code>init()</code> d&rsquo;une classe est à temps constant, mais encore passablement lente. Implémentez quelque chose de plus rapide. Écrivez un benchmark et mesurez la différence de performance.</p>
</li>
<li>
<p>Dans un langage typé dynamiquement comme Lox, un site d&rsquo;appel unique peut invoquer une variété de méthodes sur un nombre de classes à travers l&rsquo;exécution d&rsquo;un programme. Même ainsi, en pratique, la plupart du temps un site d&rsquo;appel finit par appeler la méthode exactement identique sur la classe exactement identique pour la durée de l&rsquo;exécution. La plupart des appels ne sont pas réellement polymorphes même si le langage dit qu&rsquo;ils peuvent l&rsquo;être.</p>
<p>Comment les implémentations de langage avancées optimisent basées sur cette observation ?</p>
</li>
<li>
<p>Lors de l&rsquo;interprétation d&rsquo;une instruction <code>OP_INVOKE</code>, la VM doit faire deux recherches dans la table de hachage. D&rsquo;abord, elle cherche un champ qui pourrait masquer une méthode, et seulement si cela échoue cherche-t-elle une méthode. La première vérification est rarement utile<span class="em">&mdash;</span>la plupart des champs ne contiennent pas de fonctions. Mais elle est <em>nécessaire</em> parce que le langage dit que les champs et les méthodes sont accédés utilisant la même syntaxe, et les champs masquent les méthodes.</p>
<p>C&rsquo;est un <em>choix</em> de langage qui affecte la performance de notre implémentation. Était-ce le bon choix ? Si Lox était votre langage, que feriez-vous ?</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--budget-de-nouveauté" id="note-de-conception--budget-de-nouveauté"><small>28&#8202;.&#8202;7</small>Note de Conception : Budget de Nouveauté</a></h2>
<p>Je me souviens encore de la première fois que j&rsquo;ai écrit un minuscule programme BASIC sur un TRS-80 et fait faire à un ordinateur quelque chose qu&rsquo;il n&rsquo;avait pas fait avant. Cela se sentait comme un super-pouvoir. La première fois que j&rsquo;ai bricolé juste assez d&rsquo;un analyseur et interpréteur pour me laisser écrire un minuscule programme dans <em>mon propre langage</em> qui faisait faire une chose à un ordinateur était comme une sorte de méta-super-pouvoir d&rsquo;ordre supérieur. C&rsquo;était et reste un sentiment merveilleux.</p>
<p>J&rsquo;ai réalisé que je pouvais concevoir un langage qui ressemblait et se comportait comme je choisissais. C&rsquo;était comme si j&rsquo;étais allé à une école privée qui exigeait des uniformes toute ma vie et ensuite un jour transféré à une école publique où je pouvais porter ce que je voulais. Je n&rsquo;ai pas besoin d&rsquo;utiliser des accolades pour les blocs ? Je peux utiliser quelque chose d&rsquo;autre qu&rsquo;un signe égal pour l&rsquo;assignation ? Je peux faire des objets sans classes ? Héritage multiple <em>et</em> multi-méthodes ? Un langage dynamique qui surcharge statiquement, par arité ?</p>
<p>Naturellement, j&rsquo;ai pris cette liberté et couru avec. J&rsquo;ai pris les décisions de conception de langage les plus bizarres, les plus arbitraires. Des apostrophes pour les génériques. Pas de virgules entre les arguments. Résolution de surcharge qui peut échouer à l&rsquo;exécution. J&rsquo;ai fait les choses différemment juste pour l&rsquo;amour de la différence.</p>
<p>C&rsquo;est une expérience très amusante que je recommande hautement. Nous avons besoin de plus de langages de programmation bizarres, d&rsquo;avant-garde. Je veux voir plus de langages d&rsquo;art. Je fais encore des langages jouets excentriques pour le plaisir parfois.</p>
<p><em>Cependant</em>, si votre but est le succès où &ldquo;succès&rdquo; est défini comme un grand nombre d&rsquo;utilisateurs, alors vos priorités doivent être différentes. Dans ce cas, votre but primaire est d&rsquo;avoir votre langage chargé dans les cerveaux d&rsquo;autant de gens que possible. C&rsquo;est <em>vraiment dur</em>. Cela prend beaucoup d&rsquo;effort humain de bouger la syntaxe et la sémantique d&rsquo;un langage d&rsquo;un ordinateur dans des trillions de neurones.</p>
<p>Les programmeurs sont naturellement conservateurs avec leur temps et prudents sur quels langages valent la peine d&rsquo;être uploadés dans leur matière grise. Ils ne veulent pas perdre leur temps sur un langage qui finit par ne pas leur être utile. En tant que designer de langage, votre but est ainsi de leur donner autant de puissance de langage que vous pouvez avec aussi peu d&rsquo;apprentissage requis que possible.</p>
<p>Une approche naturelle est la <em>simplicité</em>. Moins votre langage a de concepts et fonctionnalités, moins il y a de volume total de trucs à apprendre. C&rsquo;est une des raisons pour lesquelles les langages de <span name="dynamic">script</span> minimaux trouvent souvent le succès même s&rsquo;ils ne sont pas aussi puissants que les gros langages industriels<span class="em">&mdash;</span>ils sont plus faciles pour démarrer avec, et une fois qu&rsquo;ils sont dans le cerveau de quelqu&rsquo;un, l&rsquo;utilisateur veut continuer de les utiliser.</p>
<aside name="dynamic">
<p>En particulier, c&rsquo;est un gros avantage des langages typés dynamiquement. Un langage statique exige que vous appreniez <em>deux</em> langages<span class="em">&mdash;</span>la sémantique d&rsquo;exécution et le système de type statique<span class="em">&mdash;</span>avant que vous puissiez arriver au point où vous faites faire des trucs à l&rsquo;ordinateur. Les langages dynamiques exigent que vous appreniez seulement la première.</p>
<p>Éventuellement, les programmes deviennent assez gros pour que la valeur de l&rsquo;analyse statique paie pour l&rsquo;effort d&rsquo;apprendre ce second langage statique, mais la proposition de valeur n&rsquo;est pas aussi évidente au départ.</p>
</aside>
<p>Le problème avec la simplicité est que couper simplement des fonctionnalités sacrifie souvent la puissance et l&rsquo;expressivité. Il y a un art de trouver des fonctionnalités qui frappent au-dessus de leur poids, mais souvent les langages minimaux font simplement moins.</p>
<p>Il y a un autre chemin qui évite beaucoup de ce problème. Le truc est de réaliser qu&rsquo;un utilisateur n&rsquo;a pas à charger votre langage entier dans sa tête, <em>juste la partie qu&rsquo;il n&rsquo;a pas déjà dedans</em>. Comme j&rsquo;ai mentionné dans une <a href="parsing-expressions.html#design-note">note de conception plus tôt</a>, apprendre est à propos de transférer le <em>delta</em> entre ce qu&rsquo;ils savent déjà et ce qu&rsquo;ils ont besoin de savoir.</p>
<p>Beaucoup d&rsquo;utilisateurs potentiels de votre langage connaissent déjà quelque autre langage de programmation. Toutes fonctionnalités que votre langage partage avec ce langage sont essentiellement &ldquo;gratuites&rdquo; quand il s&rsquo;agit d&rsquo;apprendre. C&rsquo;est déjà dans leur tête, ils ont juste à reconnaître que votre langage fait la même chose.</p>
<p>En d&rsquo;autres termes, la <em>familiarité</em> est un autre outil clé pour abaisser le coût d&rsquo;adoption de votre langage. Bien sûr, si vous maximisez pleinement cet attribut, le résultat final est un langage qui est complètement identique à un existant. Ce n&rsquo;est pas une recette pour le succès, parce qu&rsquo;à ce point il n&rsquo;y a aucune incitation pour les utilisateurs de passer à votre langage du tout.</p>
<p>Donc vous devez bien fournir quelques différences irrésistibles. Quelques choses que votre langage peut faire que d&rsquo;autres langages ne peuvent pas, ou au moins ne peuvent pas faire aussi bien. Je crois que c&rsquo;est un des actes d&rsquo;équilibre fondamentaux de la conception de langage : la similarité aux autres langages abaisse le coût d&rsquo;apprentissage, tandis que la divergence élève les avantages irrésistibles.</p>
<p>Je pense à cet acte d&rsquo;équilibre en termes d&rsquo;un <span name="idiosyncracy"><strong>budget de nouveauté</strong></span>, ou comme Steve Klabnik l&rsquo;appelle, un &ldquo;[budget d&rsquo;étrangeté][]&rdquo;. Les utilisateurs ont un seuil bas pour la quantité totale de nouveaux trucs qu&rsquo;ils sont prêts à accepter pour apprendre un nouveau langage. Excédez cela, et ils ne se montreront pas.</p>
<aside name="idiosyncracy">
<p>Un concept lié en psychologie est le <a href="https://en.wikipedia.org/wiki/Idiosyncrasy_credit"><strong>crédit d&rsquo;idiosyncrasie</strong></a>, l&rsquo;idée que d&rsquo;autres gens en société vous accordent une quantité finie de déviations des normes sociales. Vous gagnez du crédit en vous intégrant et en faisant des choses de l&rsquo;intra-groupe, que vous pouvez ensuite dépenser sur des activités excentriques qui feraient autrement lever les sourcils. En d&rsquo;autres termes, démontrer que vous êtes &ldquo;un des bons&rdquo; vous donne une licence pour lever votre drapeau de monstre, mais seulement jusqu&rsquo;à un certain point.</p>
</aside>
<p>Chaque fois que vous ajoutez quelque chose de nouveau à votre langage que d&rsquo;autres langages n&rsquo;ont pas, ou chaque fois que votre langage fait quelque chose que d&rsquo;autres langages font d&rsquo;une manière différente, vous dépensez un peu de ce budget. C&rsquo;est OK<span class="em">&mdash;</span>vous <em>devez</em> le dépenser pour rendre votre langage irrésistible. Mais votre but est de le dépenser <em>sagement</em>. Pour chaque fonctionnalité ou différence, demandez-vous combien de puissance irrésistible elle ajoute à votre langage et ensuite évaluez critiquement si elle paie son chemin. Le changement est-il si précieux qu&rsquo;il vaut la peine de brûler un peu de votre budget de nouveauté ?</p>
<p>En pratique, je trouve que cela signifie que vous finissez par être assez conservateur avec la syntaxe et plus aventureux avec la sémantique. Aussi amusant que ce soit de mettre un nouveau changement de vêtements, échanger les accolades avec quelque autre délimiteur de bloc est très peu probable d&rsquo;ajouter beaucoup de vraie puissance au langage, mais cela dépense bien un peu de nouveauté. Il est dur pour les différences de syntaxe de porter leur poids.</p>
<p>D&rsquo;un autre côté, de nouvelles sémantiques peuvent significativement augmenter la puissance du langage. Multi-méthodes, mixins, traits, réflexion, types dépendants, métaprogrammation à l&rsquo;exécution, etc. peuvent radicalement augmenter le niveau de ce qu&rsquo;un utilisateur peut faire avec le langage.</p>
<p>Hélas, être conservateur comme ça n&rsquo;est pas aussi amusant que de juste tout changer. Mais c&rsquo;est à vous de décider si vous voulez chasser le succès grand public ou non en premier lieu. Nous n&rsquo;avons pas tous besoin d&rsquo;être des groupes pop radio-amicaux. Si vous voulez que votre langage soit comme du free jazz ou du drone metal et êtes heureux avec la taille d&rsquo;audience proportionnellement plus petite (mais probablement plus dévouée), allez-y.</p>
</div>

<footer>
<a href="super-classes.html" class="next">
  Next Chapter: &ldquo;Super-classes&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
