<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Variables globales &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Variables globales<small>21</small></a></h3>

<ul>
    <li><a href="#instructions"><small>21.1</small> Instructions</a></li>
    <li><a href="#déclarations-de-variable"><small>21.2</small> Déclarations de Variable</a></li>
    <li><a href="#lecture-des-variables"><small>21.3</small> Lecture des Variables</a></li>
    <li><a href="#affectation"><small>21.4</small> Affectation</a></li>
    <li><a href="#défis"><small>21.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="tables-de-hachage.html" title="Tables de hachage" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="variables-locales.html" title="Variables locales" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="tables-de-hachage.html" title="Tables de hachage" class="prev">←</a>
<a href="variables-locales.html" title="Variables locales" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Variables globales<small>21</small></a></h3>

<ul>
    <li><a href="#instructions"><small>21.1</small> Instructions</a></li>
    <li><a href="#déclarations-de-variable"><small>21.2</small> Déclarations de Variable</a></li>
    <li><a href="#lecture-des-variables"><small>21.3</small> Lecture des Variables</a></li>
    <li><a href="#affectation"><small>21.4</small> Affectation</a></li>
    <li><a href="#défis"><small>21.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="tables-de-hachage.html" title="Tables de hachage" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="variables-locales.html" title="Variables locales" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">21</div>
  <h1>Variables globales</h1>

<blockquote>
<p>Si seulement l&rsquo;on pouvait inventer quelque chose pour mettre les souvenirs en flacon, comme les parfums. Pour qu&rsquo;ils ne se dissipent jamais, pour qu&rsquo;ils ne s&rsquo;éventent jamais. Et puis, quand on le voudrait, la bouteille pourrait être débouchée, et ce serait comme revivre le moment tout à nouveau.</p>
<p><cite>Daphne du Maurier, <em>Rebecca</em></cite></p>
</blockquote>
<p>Le <a href="tables-de-hachage.html">chapitre précédent</a> était une longue exploration d&rsquo;une grosse structure de données fondamentale, profonde de l&rsquo;informatique. Lourd sur la théorie et le concept. Il peut y avoir eu quelques discussions sur la notation grand-O et les algorithmes. Ce chapitre a moins de prétentions intellectuelles. Il n&rsquo;y a pas de grandes idées à apprendre. Au lieu de cela, c&rsquo;est une poignée de tâches d&rsquo;ingénierie directes. Une fois que nous les aurons complétées, notre machine virtuelle supportera les variables.</p>
<p>En fait, elle supportera seulement les variables <em>globales</em>. Les locales arrivent dans le [chapitre suivant][]. Dans jlox, nous avons réussi à les fourrer toutes les deux dans un seul chapitre parce que nous avons utilisé la même technique d&rsquo;implémentation pour toutes les variables. Nous avons construit une chaîne d&rsquo;environnements, un pour chaque portée, tout le chemin jusqu&rsquo;au sommet. C&rsquo;était un moyen simple et propre d&rsquo;apprendre comment gérer l&rsquo;état.</p>
<p>Mais c&rsquo;est aussi <em>lent</em>. Allouer une nouvelle table de hachage chaque fois que vous entrez dans un bloc ou appelez une fonction n&rsquo;est pas la route vers une VM rapide. Étant donné combien de code est concerné par l&rsquo;utilisation de variables, si les variables vont lentement, tout va lentement. Pour clox, nous améliorerons cela en utilisant une stratégie bien plus efficace pour les variables <span name="different">locales</span>, mais les globales ne sont pas aussi facilement optimisées.</p>
<aside name="different">
<p>C&rsquo;est une méta-stratégie commune dans les implémentations de langage sophistiquées. Souvent, la même fonctionnalité de langage aura de multiples techniques d&rsquo;implémentation, chacune réglée pour différents modèles d&rsquo;utilisation. Par exemple, les VMs JavaScript ont souvent une représentation plus rapide pour les objets qui sont utilisés plus comme des instances de classes comparé à d&rsquo;autres objets dont l&rsquo;ensemble de propriétés est modifié plus librement. Les compilateurs C et C++ ont habituellement une variété de façons de compiler les instructions <code>switch</code> basées sur le nombre de cas et comment les valeurs de cas sont densément empaquetées.</p>
</aside>
<p>Un rafraîchissement rapide sur la sémantique de Lox : Les variables globales dans Lox sont &ldquo;liées tardivement&rdquo; (late bound), ou résolues dynamiquement. Cela signifie que vous pouvez compiler un morceau de code qui fait référence à une variable globale avant qu&rsquo;elle soit définie. Tant que le code ne s&rsquo;<em>exécute</em> pas avant que la définition arrive, tout va bien. En pratique, cela signifie que vous pouvez faire référence à des variables ultérieures à l&rsquo;intérieur du corps de fonctions.</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">showVariable</span>() {
  <span class="k">print</span> <span class="i">global</span>;
}

<span class="k">var</span> <span class="i">global</span> = <span class="s">&quot;after&quot;</span>;
<span class="i">showVariable</span>();
</pre></div>
<p>Du code comme celui-ci pourrait sembler étrange, mais c&rsquo;est pratique pour définir des fonctions mutuellement récursives. Cela joue aussi plus gentiment avec le REPL. Vous pouvez écrire une petite fonction en une ligne, puis définir la variable qu&rsquo;elle utilise dans la suivante.</p>
<p>Les variables locales fonctionnent différemment. Puisque la déclaration d&rsquo;une variable locale se produit <em>toujours</em> avant qu&rsquo;elle soit utilisée, la VM peut les résoudre au moment de la compilation, même dans un simple compilateur à une passe. Cela nous laissera utiliser une représentation plus intelligente pour les locales. Mais c&rsquo;est pour le chapitre suivant. Juste maintenant, inquiétons-nous seulement des globales.</p>
<h2><a href="#instructions" id="instructions"><small>21&#8202;.&#8202;1</small>Instructions</a></h2>
<p>Les variables viennent à l&rsquo;existence en utilisant des déclarations de variable, ce qui signifie que maintenant est aussi le moment d&rsquo;ajouter le support pour les instructions à notre compilateur. Si vous vous rappelez, Lox sépare les instructions en deux catégories. Les &ldquo;Déclarations&rdquo; sont ces instructions qui lient un nouveau nom à une valeur. Les autres sortes d&rsquo;instructions<span class="em">&mdash;</span>contrôle de flux, print, etc.<span class="em">&mdash;</span>sont juste appelées &ldquo;instructions&rdquo;. Nous interdisons les déclarations directement à l&rsquo;intérieur des instructions de contrôle de flux, comme ceci :</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">monday</span>) <span class="k">var</span> <span class="i">croissant</span> = <span class="s">&quot;yes&quot;</span>; <span class="c">// Erreur.</span>
</pre></div>
<p>Le permettre soulèverait des questions confuses autour de la portée de la variable. Donc, comme d&rsquo;autres langages, nous l&rsquo;interdisons syntaxiquement en ayant une règle de grammaire séparée pour le sous-ensemble d&rsquo;instructions qui <em>sont</em> permises à l&rsquo;intérieur d&rsquo;un corps de contrôle de flux.</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">forStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">returnStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;
</pre></div>
<p>Ensuite nous utilisons une règle séparée pour le niveau supérieur d&rsquo;un script et à l&rsquo;intérieur d&rsquo;un bloc.</p>
<div class="codehilite"><pre><span class="i">declaration</span>    → <span class="i">classDecl</span>
               | <span class="i">funDecl</span>
               | <span class="i">varDecl</span>
               | <span class="i">statement</span> ;
</pre></div>
<p>La règle <code>declaration</code> contient les instructions qui déclarent des noms, et inclut aussi <code>statement</code> pour que tous les types d&rsquo;instruction soient permis. Puisque <code>block</code> lui-même est dans <code>statement</code>, vous pouvez mettre des déclarations <span name="parens">à l&rsquo;intérieur</span> d&rsquo;une construction de contrôle de flux en les nichant à l&rsquo;intérieur d&rsquo;un bloc.</p>
<aside name="parens">
<p>Les blocs fonctionnent un peu comme les parenthèses le font pour les expressions. Un bloc vous laisse mettre les instructions de déclaration à &ldquo;priorité plus basse&rdquo; dans des endroits où seulement une instruction non déclarative à &ldquo;priorité plus haute&rdquo; est permise.</p>
</aside>
<p>Dans ce chapitre, nous couvrirons seulement une couple d&rsquo;instructions et une déclaration.</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span> ;

<span class="i">declaration</span>    → <span class="i">varDecl</span>
               | <span class="i">statement</span> ;
</pre></div>
<p>Jusqu&rsquo;à maintenant, notre VM considérait un &ldquo;programme&rdquo; comme étant une expression unique puisque c&rsquo;est tout ce que nous pouvions analyser et compiler. Dans une implémentation complète de Lox, un programme est une séquence de déclarations. Nous sommes prêts à supporter cela maintenant.</p>
<div class="codehilite"><pre class="insert-before">  advance();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()<br>
replace 2 lines</div>
<pre class="insert">

  <span class="k">while</span> (!<span class="i">match</span>(<span class="a">TOKEN_EOF</span>)) {
    <span class="i">declaration</span>();
  }

</pre><pre class="insert-after">  endCompiler();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>(), replace 2 lines</div>

<p>Nous continuons de compiler des déclarations jusqu&rsquo;à ce que nous touchions la fin du fichier source. Nous compilons une déclaration unique en utilisant ceci :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">declaration</span>() {
  <span class="i">statement</span>();
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<p>Nous arriverons aux déclarations de variable plus tard dans le chapitre, donc pour l&rsquo;instant, nous transférons simplement à <code>statement()</code>.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>declaration</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">statement</span>() {
  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_PRINT</span>)) {
    <span class="i">printStatement</span>();
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>declaration</em>()</div>

<p>Les blocs peuvent contenir des déclarations, et les instructions de contrôle de flux peuvent contenir d&rsquo;autres instructions. Cela signifie que ces deux fonctions seront éventuellement récursives. Nous pouvons aussi bien écrire les déclarations anticipées maintenant.</p>
<div class="codehilite"><pre class="insert-before">static void expression();
</pre><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">statement</span>();
<span class="k">static</span> <span class="t">void</span> <span class="i">declaration</span>();
</pre><pre class="insert-after">static ParseRule* getRule(TokenType type);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<h3><a href="#instructions-print" id="instructions-print"><small>21&#8202;.&#8202;1&#8202;.&#8202;1</small>Instructions Print</a></h3>
<p>Nous avons deux types d&rsquo;instruction à supporter dans ce chapitre. Commençons avec les instructions <code>print</code>, qui commencent, assez naturellement, avec un jeton <code>print</code>. Nous détectons cela en utilisant cette fonction aide :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>consume</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">match</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="k">if</span> (!<span class="i">check</span>(<span class="i">type</span>)) <span class="k">return</span> <span class="k">false</span>;
  <span class="i">advance</span>();
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>consume</em>()</div>

<p>Vous pouvez la reconnaître de jlox. Si le jeton courant a le type donné, nous consommons le jeton et renvoyons <code>true</code>. Sinon nous laissons le jeton tranquille et renvoyons <code>false</code>. Cette fonction <span name="turtles">aide</span> est implémentée en termes de cette autre aide :</p>
<aside name="turtles">
<p>Ce sont des aides tout le long !</p>
</aside>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>consume</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">check</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="k">return</span> <span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span> == <span class="i">type</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>consume</em>()</div>

<p>La fonction <code>check()</code> renvoie <code>true</code> si le jeton courant a le type donné. Cela semble un peu <span name="read">bête</span> d&rsquo;envelopper ceci dans une fonction, mais nous l&rsquo;utiliserons plus tard, et je pense que de courtes fonctions nommées par des verbes comme celle-ci rendent l&rsquo;analyseur plus facile à lire.</p>
<aside name="read">
<p>Cela semble trivial, mais les analyseurs écrits à la main pour des langages non-jouets deviennent assez gros. Quand vous avez des milliers de lignes de code, une fonction utilitaire qui transforme deux lignes en une et rend le résultat un peu plus lisible gagne facilement son pain.</p>
</aside>
<p>Si nous avons bien correspondu au jeton <code>print</code>, alors nous compilons le reste de l&rsquo;instruction ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">printStatement</span>() {
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after value.&quot;</span>);
  <span class="i">emitByte</span>(<span class="a">OP_PRINT</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<p>Une instruction <code>print</code> évalue une expression et imprime le résultat, donc nous analysons et compilons d&rsquo;abord cette expression. La grammaire attend un point-virgule après cela, donc nous le consommons. Finalement, nous émettons une nouvelle instruction pour imprimer le résultat.</p>
<div class="codehilite"><pre class="insert-before">  OP_NEGATE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_PRINT</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>À l&rsquo;exécution, nous exécutons cette instruction comme ceci :</p>
<div class="codehilite"><pre class="insert-before">        break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_PRINT</span>: {
        <span class="i">printValue</span>(<span class="i">pop</span>());
        <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Quand l&rsquo;interpréteur atteint cette instruction, il a déjà exécuté le code pour l&rsquo;expression, laissant la valeur résultat au sommet de la pile. Maintenant nous la dépilons simplement et l&rsquo;imprimons.</p>
<p>Notez que nous ne poussons rien d&rsquo;autre après cela. C&rsquo;est une différence clé entre les expressions et les instructions dans la VM. Chaque instruction bytecode a un <span name="effect"><strong>effet de pile</strong></span> qui décrit comment l&rsquo;instruction modifie la pile. Par exemple, <code>OP_ADD</code> dépile deux valeurs et en empile une, laissant la pile un élément plus petit qu&rsquo;avant.</p>
<aside name="effect">
<p>La pile est un élément plus courte après un <code>OP_ADD</code>, donc son effet est -1 :</p><img src="image/global-variables/stack-effect.png" alt="L'effet de pile d'une instruction OP_ADD." />
</aside>
<p>Vous pouvez sommer les effets de pile d&rsquo;une série d&rsquo;instructions pour obtenir leur effet total. Quand vous ajoutez les effets de pile de la série d&rsquo;instructions compilées depuis n&rsquo;importe quelle expression complète, cela totalisera un. Chaque expression laisse une valeur résultat sur la pile.</p>
<p>Le bytecode pour une instruction entière a un effet de pile total de zéro. Puisqu&rsquo;une instruction ne produit aucune valeur, elle laisse ultimement la pile inchangée, bien qu&rsquo;elle utilise bien sûr la pile pendant qu&rsquo;elle fait son truc. C&rsquo;est important parce que quand nous arriverons au contrôle de flux et aux boucles, un programme pourrait exécuter une longue série d&rsquo;instructions. Si chaque instruction grandissait ou rétrécissait la pile, elle pourrait éventuellement déborder ou sous-déborder.</p>
<p>Pendant que nous sont dans la boucle de l&rsquo;interpréteur, nous devrions supprimer un peu de code.</p>
<div class="codehilite"><pre class="insert-before">      case OP_RETURN: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 2 lines</div>
<pre class="insert">        <span class="c">// Exit interpreter.</span>
</pre><pre class="insert-after">        return INTERPRET_OK;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>

<p>Quand la VM compilait et évaluait seulement une expression unique, nous avions du code temporaire dans <code>OP_RETURN</code> pour sortir la valeur. Maintenant que nous avons des instructions et <code>print</code>, nous n&rsquo;avons plus besoin de ça. Nous sommes une <span name="return">étape</span> plus près de l&rsquo;implémentation complète de clox.</p>
<aside name="return">
<p>Nous sommes seulement une étape plus près, cependant. Nous revisiterons <code>OP_RETURN</code> encore quand nous ajouterons les fonctions. Juste maintenant, elle sort de la boucle de l&rsquo;interpréteur entière.</p>
</aside>
<p>Comme d&rsquo;habitude, une nouvelle instruction a besoin de support dans le désassembleur.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_NEGATE&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_PRINT</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_PRINT&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>C&rsquo;est notre instruction <code>print</code>. Si vous voulez, donnez-lui un essai :</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="n">1</span> + <span class="n">2</span>;
<span class="k">print</span> <span class="n">3</span> * <span class="n">4</span>;
</pre></div>
<p>Excitant ! OK, peut-être pas palpitant, mais nous pouvons construire des scripts qui contiennent autant d&rsquo;instructions que nous voulons maintenant, ce qui ressemble à du progrès.</p>
<h3><a href="#instructions-dexpression" id="instructions-dexpression"><small>21&#8202;.&#8202;1&#8202;.&#8202;2</small>Instructions d&rsquo;expression</a></h3>
<p>Attendez de voir la prochaine instruction. Si nous ne voyons <em>pas</em> un mot-clé <code>print</code>, alors nous devons être en train de regarder une instruction d&rsquo;expression.</p>
<div class="codehilite"><pre class="insert-before">    printStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> {
    <span class="i">expressionStatement</span>();
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>C&rsquo;est analysé comme ceci :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">expressionStatement</span>() {
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after expression.&quot;</span>);
  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<p>Une &ldquo;instruction d&rsquo;expression&rdquo; est simplement une expression suivie par un point-virgule. C&rsquo;est comment vous écrivez une expression dans un contexte où une instruction est attendue. Habituellement, c&rsquo;est pour que vous puissiez appeler une fonction ou évaluer une affectation pour son effet de bord, comme ceci :</p>
<div class="codehilite"><pre><span class="i">brunch</span> = <span class="s">&quot;quiche&quot;</span>;
<span class="i">eat</span>(<span class="i">brunch</span>);
</pre></div>
<p>Sémantiquement, une instruction d&rsquo;expression évalue l&rsquo;expression et jette le résultat. Le compilateur encode directement ce comportement. Il compile l&rsquo;expression, et ensuite émet une instruction <code>OP_POP</code>.</p>
<div class="codehilite"><pre class="insert-before">  OP_FALSE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_POP</span>,
</pre><pre class="insert-after">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Comme le nom l&rsquo;implique, cette instruction dépile la valeur du sommet de la pile et l&rsquo;oublie.</p>
<div class="codehilite"><pre class="insert-before">      case OP_FALSE: push(BOOL_VAL(false)); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_POP</span>: <span class="i">pop</span>(); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nous pouvons la désassembler aussi.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_FALSE&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_POP</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_POP&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Les instructions d&rsquo;expression ne sont pas très utiles encore puisque nous ne pouvons créer aucune expression qui a des effets de bord, mais elles seront essentielles quand nous <a href="appels-et-fonctions.html">ajouterons les fonctions plus tard</a>. La <span name="majority">majorité</span> des instructions dans du code du monde réel dans des langages comme C sont des instructions d&rsquo;expression.</p>
<aside name="majority">
<p>D&rsquo;après mon compte, 80 des 149 instructions, dans la version de &ldquo;compiler.c&rdquo; que nous avons à la fin de ce chapitre sont des instructions d&rsquo;expression.</p>
</aside>
<h3><a href="#synchronisation-derreur" id="synchronisation-derreur"><small>21&#8202;.&#8202;1&#8202;.&#8202;3</small>Synchronisation d&rsquo;erreur</a></h3>
<p>Pendant que nous faisons ce travail initial dans le compilateur, nous pouvons nous occuper d&rsquo;une affaire non résolue que nous avons laissée <a href="compilation-des-expressions.html#gérer-les-erreurs-de-syntaxe">plusieurs chapitres en arrière</a>. Comme jlox, clox utilise la récupération d&rsquo;erreur en mode panique pour minimiser le nombre d&rsquo;erreurs de compilation en cascade qu&rsquo;il rapporte. Le compilateur sort du mode panique quand il atteint un point de synchronisation. Pour Lox, nous avons choisi les frontières d&rsquo;instruction comme point. Maintenant que nous avons des instructions, nous pouvons implémenter la synchronisation.</p>
<div class="codehilite"><pre class="insert-before">  statement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declaration</em>()</div>
<pre class="insert">

  <span class="k">if</span> (<span class="i">parser</span>.<span class="i">panicMode</span>) <span class="i">synchronize</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>()</div>

<p>Si nous touchons une erreur de compilation en analysant l&rsquo;instruction précédente, nous entrons en mode panique. Quand cela arrive, après l&rsquo;instruction nous commençons à synchroniser.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>printStatement</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">synchronize</span>() {
  <span class="i">parser</span>.<span class="i">panicMode</span> = <span class="k">false</span>;

  <span class="k">while</span> (<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span> != <span class="a">TOKEN_EOF</span>) {
    <span class="k">if</span> (<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span> == <span class="a">TOKEN_SEMICOLON</span>) <span class="k">return</span>;
    <span class="k">switch</span> (<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span>) {
      <span class="k">case</span> <span class="a">TOKEN_CLASS</span>:
      <span class="k">case</span> <span class="a">TOKEN_FUN</span>:
      <span class="k">case</span> <span class="a">TOKEN_VAR</span>:
      <span class="k">case</span> <span class="a">TOKEN_FOR</span>:
      <span class="k">case</span> <span class="a">TOKEN_IF</span>:
      <span class="k">case</span> <span class="a">TOKEN_WHILE</span>:
      <span class="k">case</span> <span class="a">TOKEN_PRINT</span>:
      <span class="k">case</span> <span class="a">TOKEN_RETURN</span>:
        <span class="k">return</span>;

      <span class="k">default</span>:
        ; <span class="c">// Do nothing.</span>
    }

    <span class="i">advance</span>();
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>printStatement</em>()</div>

<p>Nous sautons les jetons indistinctement jusqu&rsquo;à ce que nous atteignions quelque chose qui ressemble à une frontière d&rsquo;instruction. Nous reconnaissons la frontière en cherchant un jeton précédent qui peut finir une instruction, comme un point-virgule. Ou nous chercherons un jeton ultérieur qui commence une instruction, habituellement un des mots-clés de contrôle de flux ou de déclaration.</p>
<h2><a href="#déclarations-de-variable" id="déclarations-de-variable"><small>21&#8202;.&#8202;2</small>Déclarations de Variable</a></h2>
<p>Être simplement capable d&rsquo;<em>imprimer</em> ne gagne aucun prix à votre langage à la <span name="fair">foire</span> aux langages de programmation, alors passons à quelque chose d&rsquo;un peu plus ambitieux et mettons les variables en marche. Il y a trois opérations que nous avons besoin de supporter :</p>
<aside name="fair">
<p>Je ne peux pas m&rsquo;empêcher d&rsquo;imaginer une &ldquo;foire aux langages&rdquo; comme une sorte de truc campagnard. Des rangées de stands doublés de paille pleins de bébés langages se <em>meuh</em>glant et se <em>bêê</em>lant l&rsquo;un à l&rsquo;autre.</p>
</aside>
<ul>
<li>Déclarer une nouvelle variable en utilisant une instruction <code>var</code>.</li>
<li>Accéder à la valeur d&rsquo;une variable en utilisant une expression identifiant.</li>
<li>Stocker une nouvelle valeur dans une variable existante en utilisant une expression d&rsquo;affectation.</li>
</ul>
<p>Nous ne pouvons faire aucune des deux dernières avant d&rsquo;avoir quelques variables, donc nous commençons avec les déclarations.</p>
<div class="codehilite"><pre class="insert-before">static void declaration() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declaration</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_VAR</span>)) {
    <span class="i">varDeclaration</span>();
  } <span class="k">else</span> {
    <span class="i">statement</span>();
  }
</pre><pre class="insert-after">

  if (parser.panicMode) synchronize();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>(), replace 1 line</div>

<p>La fonction d&rsquo;analyse bouche-trou que nous avons esquissée pour la règle grammaticale de déclaration a une vraie production maintenant. Si nous correspondons à un jeton <code>var</code>, nous sautons ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">varDeclaration</span>() {
  <span class="t">uint8_t</span> <span class="i">global</span> = <span class="i">parseVariable</span>(<span class="s">&quot;Expect variable name.&quot;</span>);

  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">expression</span>();
  } <span class="k">else</span> {
    <span class="i">emitByte</span>(<span class="a">OP_NIL</span>);
  }
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>,
          <span class="s">&quot;Expect &#39;;&#39; after variable declaration.&quot;</span>);

  <span class="i">defineVariable</span>(<span class="i">global</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<p>Le mot-clé est suivi par le nom de la variable. C&rsquo;est compilé par <code>parseVariable()</code>, à laquelle nous arriverons dans une seconde. Ensuite nous cherchons un <code>=</code> suivi par une expression initialisatrice. Si l&rsquo;utilisateur n&rsquo;initialise pas la variable, le compilateur l&rsquo;initialise implicitement à <span name="nil"><code>nil</code></span> en émettant une instruction <code>OP_NIL</code>. De toute façon, nous attendons que l&rsquo;instruction soit terminée par un point-virgule.</p>
<aside name="nil" class="bottom">
<p>Essentiellement, le compilateur désucre une déclaration de variable comme :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span>;
</pre></div>
<p>en :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="k">nil</span>;
</pre></div>
<p>Le code qu&rsquo;il génère pour la première est identique à ce qu&rsquo;il produit pour la dernière.</p>
</aside>
<p>Il y a deux nouvelles fonctions ici pour travailler avec les variables et les identifiants. Voici la première :</p>
<div class="codehilite"><pre class="insert-before">static void parsePrecedence(Precedence precedence);

</pre><div class="source-file"><em>compiler.c</em><br>
add after <em>parsePrecedence</em>()</div>
<pre class="insert"><span class="k">static</span> <span class="t">uint8_t</span> <span class="i">parseVariable</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">errorMessage</span>) {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="i">errorMessage</span>);
  <span class="k">return</span> <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parsePrecedence</em>()</div>

<p>Elle exige que le prochain jeton soit un identifiant, qu&rsquo;elle consomme et envoie ici :</p>
<div class="codehilite"><pre class="insert-before">static void parsePrecedence(Precedence precedence);

</pre><div class="source-file"><em>compiler.c</em><br>
add after <em>parsePrecedence</em>()</div>
<pre class="insert"><span class="k">static</span> <span class="t">uint8_t</span> <span class="i">identifierConstant</span>(<span class="t">Token</span>* <span class="i">name</span>) {
  <span class="k">return</span> <span class="i">makeConstant</span>(<span class="a">OBJ_VAL</span>(<span class="i">copyString</span>(<span class="i">name</span>-&gt;<span class="i">start</span>,
                                         <span class="i">name</span>-&gt;<span class="i">length</span>)));
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parsePrecedence</em>()</div>

<p>Cette fonction prend le jeton donné et ajoute son léxème à la table des constantes du fragment comme une chaîne. Elle renvoie ensuite l&rsquo;index de cette constante dans la table des constantes.</p>
<p>Les variables globales sont cherchées <em>par nom</em> à l&rsquo;exécution. Cela signifie que la VM<span class="em">&mdash;</span>la boucle de l&rsquo;interpréteur bytecode<span class="em">&mdash;</span>a besoin d&rsquo;accéder au nom. Une chaîne entière est trop grosse pour fourrer dans le flux de bytecode comme opérande. Au lieu de cela, nous stockons la chaîne dans la table des constantes et l&rsquo;instruction fait ensuite référence au nom par son index dans la table.</p>
<p>Cette fonction renvoie cet index tout le chemin jusqu&rsquo;à <code>varDeclaration()</code> qui le remet plus tard à ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>parseVariable</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">defineVariable</span>(<span class="t">uint8_t</span> <span class="i">global</span>) {
  <span class="i">emitBytes</span>(<span class="a">OP_DEFINE_GLOBAL</span>, <span class="i">global</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parseVariable</em>()</div>

<p><span name="helper">Ceci</span> sort l&rsquo;instruction bytecode qui définit la nouvelle variable et stocke sa valeur initiale. L&rsquo;index du nom de la variable dans la table des constantes est l&rsquo;opérande de l&rsquo;instruction. Comme d&rsquo;habitude dans une VM à pile, nous émettons cette instruction en dernier. À l&rsquo;exécution, nous exécutons le code pour l&rsquo;initialisateur de la variable d&rsquo;abord. Cela laisse la valeur sur la pile. Ensuite cette instruction prend cette valeur et la stocke au loin pour plus tard.</p>
<aside name="helper">
<p>Je sais que certaines de ces fonctions semblent assez inutiles en ce moment. Mais nous en tirerons plus de kilométrage alors que nous ajouterons plus de fonctionnalités de langage pour travailler avec les noms. Les déclarations de fonction et de classe déclarent toutes deux de nouvelles variables, et les expressions de variable et d&rsquo;affectation y accèdent.</p>
</aside>
<p>Là-bas dans le runtime, nous commençons avec cette nouvelle instruction :</p>
<div class="codehilite"><pre class="insert-before">  OP_POP,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_DEFINE_GLOBAL</span>,
</pre><pre class="insert-after">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Grâce à notre table de hachage pratique, l&rsquo;implémentation n&rsquo;est pas trop dure.</p>
<div class="codehilite"><pre class="insert-before">      case OP_POP: pop(); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_DEFINE_GLOBAL</span>: {
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();
        <span class="i">tableSet</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="i">name</span>, <span class="i">peek</span>(<span class="n">0</span>));
        <span class="i">pop</span>();
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nous obtenons le nom de la variable depuis la table des constantes. Ensuite nous <span name="pop">prenons</span> la valeur du sommet de la pile et la stockons dans une table de hachage avec ce nom comme clé.</p>
<aside name="pop">
<p>Notez que nous ne <em>dépilons</em> pas la valeur avant <em>après</em> l&rsquo;avoir ajoutée à la table de hachage. Cela assure que la VM peut toujours trouver la valeur si un ramasse-miettes est déclenché juste au milieu de son ajout à la table de hachage. C&rsquo;est une possibilité distincte puisque la table de hachage exige une allocation dynamique quand elle redimensionne.</p>
</aside>
<p>Ce code ne vérifie pas pour voir si la clé est déjà dans la table. Lox est assez lâche avec les variables globales et vous laisse les redéfinir sans erreur. C&rsquo;est utile dans une session REPL, donc la VM supporte cela en écrasant simplement la valeur si la clé se trouve être déjà dans la table de hachage.</p>
<p>Il y a une autre petite macro aide :</p>
<div class="codehilite"><pre class="insert-before">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#define READ_STRING() AS_STRING(READ_CONSTANT())</span>
</pre><pre class="insert-after">#define BINARY_OP(valueType, op) \
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Elle lit un opérande d&rsquo;un octet depuis le fragment de bytecode. Elle traite cela comme un index dans la table des constantes du fragment et renvoie la chaîne à cet index. Elle ne vérifie pas que la valeur <em>est</em> une chaîne<span class="em">&mdash;</span>elle la caste juste indistinctement. C&rsquo;est sûr parce que le compilateur n&rsquo;émet jamais une instruction qui fait référence à une constante non-chaîne.</p>
<p>Parce que nous nous soucions de l&rsquo;hygiène lexicale, nous indéfinissons aussi cette macro à la fin de la fonction interpret.</p>
<div class="codehilite"><pre class="insert-before">#undef READ_CONSTANT
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#undef READ_STRING</span>
</pre><pre class="insert-after">#undef BINARY_OP
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Je continue de dire &ldquo;la table de hachage&rdquo;, mais nous n&rsquo;en avons pas réellement une encore. Nous avons besoin d&rsquo;un endroit pour stocker ces globales. Puisque nous voulons qu&rsquo;elles persistent aussi longtemps que clox tourne, nous les stockons juste dans la VM.</p>
<div class="codehilite"><pre class="insert-before">  Value* stackTop;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">Table</span> <span class="i">globals</span>;
</pre><pre class="insert-after">  Table strings;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>Comme nous l&rsquo;avons fait avec la table des chaînes, nous avons besoin d&rsquo;initialiser la table de hachage à un état valide quand la VM démarre.</p>
<div class="codehilite"><pre class="insert-before">  vm.objects = NULL;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">

  <span class="i">initTable</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>);
</pre><pre class="insert-after">  initTable(&amp;vm.strings);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>Et nous la <span name="tear">démolissons</span> quand nous sortons.</p>
<aside name="tear">
<p>Le processus libérera tout à la sortie, mais cela semble indigne d&rsquo;exiger du système d&rsquo;exploitation de nettoyer notre désordre.</p>
</aside>
<div class="codehilite"><pre class="insert-before">void freeVM() {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>freeVM</em>()</div>
<pre class="insert">  <span class="i">freeTable</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>);
</pre><pre class="insert-after">  freeTable(&amp;vm.strings);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>freeVM</em>()</div>

<p>Comme d&rsquo;habitude, nous voulons être capables de désassembler la nouvelle instruction aussi.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_POP&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_DEFINE_GLOBAL</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_DEFINE_GLOBAL&quot;</span>, <span class="i">chunk</span>,
                                 <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Et avec cela, nous pouvons définir des variables globales. Pas que les utilisateurs puissent <em>dire</em> qu&rsquo;ils l&rsquo;ont fait, parce qu&rsquo;ils ne peuvent pas réellement les <em>utiliser</em>. Donc réparons ça ensuite.</p>
<h2><a href="#lecture-des-variables" id="lecture-des-variables"><small>21&#8202;.&#8202;3</small>Lecture des Variables</a></h2>
<p>Comme dans chaque langage de programmation de tous les temps, nous accédons à la valeur d&rsquo;une variable en utilisant son nom. Nous accrochons les jetons identifiants à l&rsquo;analyseur d&rsquo;expression ici :</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_LESS_EQUAL]    = {NULL,     binary, PREC_COMPARISON},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_IDENTIFIER</span>]    = {<span class="i">variable</span>, <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_STRING]        = {string,   NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Cela appelle cette nouvelle fonction d&rsquo;analyseur :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>string</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">variable</span>() {
  <span class="i">namedVariable</span>(<span class="i">parser</span>.<span class="i">previous</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>string</em>()</div>

<p>Comme avec les déclarations, il y a une couple de minuscules fonctions aides qui semblent inutiles maintenant mais deviendront plus utiles dans les chapitres ultérieurs. Je promets.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>string</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">namedVariable</span>(<span class="t">Token</span> <span class="i">name</span>) {
  <span class="t">uint8_t</span> <span class="i">arg</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">name</span>);
  <span class="i">emitBytes</span>(<span class="a">OP_GET_GLOBAL</span>, <span class="i">arg</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>string</em>()</div>

<p>Ceci appelle la même fonction <code>identifierConstant()</code> d&rsquo;avant pour prendre le jeton identifiant donné et ajouter son léxème à la table des constantes du fragment comme une chaîne. Tout ce qui reste est d&rsquo;émettre une instruction qui charge la variable globale avec ce nom. Voici l&rsquo;instruction :</p>
<div class="codehilite"><pre class="insert-before">  OP_POP,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_GET_GLOBAL</span>,
</pre><pre class="insert-after">  OP_DEFINE_GLOBAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Là-bas dans l&rsquo;interpréteur, l&rsquo;implémentation reflète <code>OP_DEFINE_GLOBAL</code>.</p>
<div class="codehilite"><pre class="insert-before">      case OP_POP: pop(); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GET_GLOBAL</span>: {
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();
        <span class="t">Value</span> <span class="i">value</span>;
        <span class="k">if</span> (!<span class="i">tableGet</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="i">name</span>, &amp;<span class="i">value</span>)) {
          <span class="i">runtimeError</span>(<span class="s">&quot;Undefined variable &#39;%s&#39;.&quot;</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="i">push</span>(<span class="i">value</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_DEFINE_GLOBAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nous tirons l&rsquo;index de la table des constantes de l&rsquo;opérande de l&rsquo;instruction et obtenons le nom de la variable. Ensuite nous utilisons cela comme une clé pour chercher la valeur de la variable dans la table de hachage des globales.</p>
<p>Si la clé n&rsquo;est pas présente dans la table de hachage, cela signifie que cette variable globale n&rsquo;a jamais été définie. C&rsquo;est une erreur d&rsquo;exécution dans Lox, donc nous la rapportons et sortons de la boucle de l&rsquo;interpréteur si cela arrive. Sinon, nous prenons la valeur et la poussons sur la pile.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_POP&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_GET_GLOBAL</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_GET_GLOBAL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_DEFINE_GLOBAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Un petit peu de désassemblage, et nous avons fini. Notre interpréteur est maintenant capable de faire tourner du code comme ceci :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">beverage</span> = <span class="s">&quot;cafe au lait&quot;</span>;
<span class="k">var</span> <span class="i">breakfast</span> = <span class="s">&quot;beignets with &quot;</span> + <span class="i">beverage</span>;
<span class="k">print</span> <span class="i">breakfast</span>;
</pre></div>
<p>Il y a seulement une opération restante.</p>
<h2><a href="#affectation" id="affectation"><small>21&#8202;.&#8202;4</small>Affectation</a></h2>
<p>À travers ce livre, j&rsquo;ai essayé de vous garder sur un chemin assez sûr et facile. Je n&rsquo;évite pas les <em>problèmes</em> durs, mais j&rsquo;essaie de ne pas rendre les <em>solutions</em> plus complexes qu&rsquo;elles ont besoin de l&rsquo;être. Hélas, d&rsquo;autres choix de conception dans notre compilateur <span name="jlox">bytecode</span> rendent l&rsquo;affectation ennuyeuse à implémenter.</p>
<aside name="jlox">
<p>Si vous vous rappelez, l&rsquo;affectation était assez facile dans jlox.</p>
</aside>
<p>Notre VM bytecode utilise un compilateur à une passe. Il analyse et génère du bytecode à la volée sans aucun AST intermédiaire. Dès qu&rsquo;il reconnaît un morceau de syntaxe, il émet du code pour lui. L&rsquo;affectation ne s&rsquo;ajuste pas naturellement à cela. Considérez :</p>
<div class="codehilite"><pre><span class="i">menu</span>.<span class="i">brunch</span>(<span class="i">sunday</span>).<span class="i">beverage</span> = <span class="s">&quot;mimosa&quot;</span>;
</pre></div>
<p>Dans ce code, l&rsquo;analyseur ne réalise pas que <code>menu.brunch(sunday).beverage</code> est la cible d&rsquo;une affectation et pas une expression normale jusqu&rsquo;à ce qu&rsquo;il atteigne <code>=</code>, beaucoup de jetons après le premier <code>menu</code>. D&rsquo;ici là, le compilateur a déjà émis du bytecode pour le truc entier.</p>
<p>Le problème n&rsquo;est pas aussi grave qu&rsquo;il pourrait paraître, cependant. Regardez comment l&rsquo;analyseur voit cet exemple :</p><img src="image/global-variables/setter.png" alt="L'instruction 'menu.brunch(sunday).beverage = &quot;mimosa&quot;', montrant que 'menu.brunch(sunday)' est une expression." />
<p>Même si la partie <code>.beverage</code> ne doit pas être compilée comme une expression get, tout à la gauche du <code>.</code> est une expression, avec la sémantique d&rsquo;expression normale. La partie <code>menu.brunch(sunday)</code> peut être compilée et exécutée comme d&rsquo;habitude.</p>
<p>Heureusement pour nous, les seules différences sémantiques sur le côté gauche d&rsquo;une affectation apparaissent à la toute fin la plus à droite des jetons, précédant immédiatement le <code>=</code>. Même si le receveur d&rsquo;un setter peut être une expression arbitrairement longue, la partie dont le comportement diffère d&rsquo;une expression get est seulement l&rsquo;identifiant traînant, qui est juste avant le <code>=</code>. Nous n&rsquo;avons pas besoin de beaucoup d&rsquo;anticipation pour réaliser que <code>beverage</code> devrait être compilé comme une expression set et pas un getter.</p>
<p>Les variables sont encore plus faciles puisqu&rsquo;elles sont juste un identifiant nu unique avant un <code>=</code>. L&rsquo;idée alors est que juste <em>avant</em> de compiler une expression qui peut aussi être utilisée comme une cible d&rsquo;affectation, nous cherchons un jeton <code>=</code> ultérieur. Si nous en voyons un, nous le compilons comme une affectation ou un setter au lieu d&rsquo;un accès de variable ou un getter.</p>
<p>Nous n&rsquo;avons pas de setters dont nous inquiéter encore, donc tout ce que nous avons besoin de gérer sont les variables.</p>
<div class="codehilite"><pre class="insert-before">  uint8_t arg = identifierConstant(&amp;name);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">

  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">expression</span>();
    <span class="i">emitBytes</span>(<span class="a">OP_SET_GLOBAL</span>, <span class="i">arg</span>);
  } <span class="k">else</span> {
    <span class="i">emitBytes</span>(<span class="a">OP_GET_GLOBAL</span>, <span class="i">arg</span>);
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>Dans la fonction d&rsquo;analyse pour les expressions identifiants, nous cherchons un signe égal après l&rsquo;identifiant. Si nous en trouvons un, au lieu d&rsquo;émettre du code pour un accès de variable, nous compilons la valeur affectée et ensuite émettons une instruction d&rsquo;affectation.</p>
<p>C&rsquo;est la dernière instruction que nous avons besoin d&rsquo;ajouter dans ce chapitre.</p>
<div class="codehilite"><pre class="insert-before">  OP_DEFINE_GLOBAL,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_SET_GLOBAL</span>,
</pre><pre class="insert-after">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Comme vous vous y attendriez, son comportement à l&rsquo;exécution est similaire à définir une nouvelle variable.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_SET_GLOBAL</span>: {
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();
        <span class="k">if</span> (<span class="i">tableSet</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="i">name</span>, <span class="i">peek</span>(<span class="n">0</span>))) {
          <span class="i">tableDelete</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="i">name</span>);<span name="delete"> </span>
          <span class="i">runtimeError</span>(<span class="s">&quot;Undefined variable &#39;%s&#39;.&quot;</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>La différence principale est ce qui arrive quand la clé n&rsquo;existe pas déjà dans la table de hachage des globales. Si la variable n&rsquo;a pas été définie encore, c&rsquo;est une erreur d&rsquo;exécution d&rsquo;essayer de lui assigner. Lox <a href="instructions-et-état.html#note-de-conception">ne fait pas de déclaration de variable implicite</a>.</p>
<aside name="delete">
<p>L&rsquo;appel à <code>tableSet()</code> stocke la valeur dans la table des variables globales même si la variable n&rsquo;était pas précédemment définie. Ce fait est visible dans une session REPL, puisqu&rsquo;elle continue de tourner même après que l&rsquo;erreur d&rsquo;exécution a été rapportée. Donc nous prenons soin aussi de supprimer cette valeur zombie de la table.</p>
</aside>
<p>L&rsquo;autre différence est que régler une variable ne dépile pas la valeur de la pile. Rappelez-vous, l&rsquo;affectation est une expression, donc elle a besoin de laisser cette valeur là au cas où l&rsquo;affectation est nichée à l&rsquo;intérieur de quelque plus grande expression.</p>
<p>Ajoutez un soupçon de désassemblage :</p>
<div class="codehilite"><pre class="insert-before">      return constantInstruction(&quot;OP_DEFINE_GLOBAL&quot;, chunk,
                                 offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_SET_GLOBAL</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_SET_GLOBAL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Donc nous avons fini, pas vrai ? Eh bien<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>pas tout à fait. Nous avons fait une erreur ! Jetez un coup d&rsquo;œil à :</p>
<div class="codehilite"><pre><span class="i">a</span> * <span class="i">b</span> = <span class="i">c</span> + <span class="i">d</span>;
</pre></div>
<p>Selon la grammaire de Lox, <code>=</code> a la précédence la plus basse, donc cela devrait être analysé grossièrement comme :</p><img src="image/global-variables/ast-good.png" alt="L'analyse attendue, comme '(a * b) = (c + d)'." />
<p>Évidemment, <code>a * b</code> n&rsquo;est pas une cible d&rsquo;affectation <span name="do">valide</span>, donc cela devrait être une erreur de syntaxe. Mais voici ce que notre analyseur fait :</p>
<aside name="do">
<p>Ne serait-ce pas dingue si <code>a * b</code> <em>était</em> une cible d&rsquo;affectation valide, cependant ? Vous pourriez imaginer quelque langage algèbre-esque qui essayait de diviser la valeur affectée d&rsquo;une manière raisonnable et de la distribuer à <code>a</code> et <code>b</code><span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>c&rsquo;est probablement une idée terrible.</p>
</aside>
<ol>
<li>D&rsquo;abord, <code>parsePrecedence()</code> analyse <code>a</code> en utilisant l&rsquo;analyseur préfixe <code>variable()</code>.</li>
<li>Après cela, il entre dans la boucle d&rsquo;analyse infixe.</li>
<li>Il atteint le <code>*</code> et appelle <code>binary()</code>.</li>
<li>Cela appelle récursivement <code>parsePrecedence()</code> pour analyser l&rsquo;opérande de main droite.</li>
<li>Cela appelle <code>variable()</code> encore pour analyser <code>b</code>.</li>
<li>À l&rsquo;intérieur de cet appel à <code>variable()</code>, il cherche un <code>=</code> traînant. Il en voit un et analyse ainsi le reste de la ligne comme une affectation.</li>
</ol>
<p>En d&rsquo;autres termes, l&rsquo;analyseur voit le code ci-dessus comme :</p><img src="image/global-variables/ast-bad.png" alt="L'analyse réelle, comme 'a * (b = c + d)'." />
<p>Nous avons gâché la gestion de précédence parce que <code>variable()</code> ne prend pas en compte la précédence de l&rsquo;expression environnante qui contient la variable. Si la variable se trouve être le côté main droite d&rsquo;un opérateur infixe, ou l&rsquo;opérande d&rsquo;un opérateur unaire, alors cette expression contenante est de trop haute précédence pour permettre le <code>=</code>.</p>
<p>Pour réparer cela, <code>variable()</code> devrait chercher et consommer le <code>=</code> seulement s&rsquo;il est dans le contexte d&rsquo;une expression à basse précédence. Le code qui connaît la précédence courante est, assez logiquement, <code>parsePrecedence()</code>. La fonction <code>variable()</code> n&rsquo;a pas besoin de connaître le niveau réel. Elle se soucie juste que la précédence soit assez basse pour permettre l&rsquo;affectation, donc nous passons ce fait dedans comme un Booléen.</p>
<div class="codehilite"><pre class="insert-before">    error(&quot;Expect expression.&quot;);
    return;
  }

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parsePrecedence</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">bool</span> <span class="i">canAssign</span> = <span class="i">precedence</span> &lt;= <span class="a">PREC_ASSIGNMENT</span>;
  <span class="i">prefixRule</span>(<span class="i">canAssign</span>);
</pre><pre class="insert-after">

  while (precedence &lt;= getRule(parser.current.type)-&gt;precedence) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>(), replace 1 line</div>

<p>Puisque l&rsquo;affectation est l&rsquo;expression à la plus basse précédence, la seule fois où nous permettons une affectation est quand nous analysons une expression d&rsquo;affectation ou une expression de niveau supérieur comme dans une instruction d&rsquo;expression. Ce drapeau fait son chemin vers la fonction analyseur ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>variable</em>()<br>
replace 3 lines</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">variable</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="i">namedVariable</span>(<span class="i">parser</span>.<span class="i">previous</span>, <span class="i">canAssign</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>variable</em>(), replace 3 lines</div>

<p>Qui le passe à travers un nouveau paramètre :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">namedVariable</span>(<span class="t">Token</span> <span class="i">name</span>, <span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  uint8_t arg = identifierConstant(&amp;name);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>namedVariable</em>(), replace 1 line</div>

<p>Et ensuite l&rsquo;utilise finalement ici :</p>
<div class="codehilite"><pre class="insert-before">  uint8_t arg = identifierConstant(&amp;name);

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">canAssign</span> &amp;&amp; <span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
</pre><pre class="insert-after">    expression();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>C&rsquo;est beaucoup de plomberie pour obtenir littéralement un bit de donnée au bon endroit dans le compilateur, mais arrivé il est. Si la variable est nichée à l&rsquo;intérieur de quelque expression avec une précédence plus haute, <code>canAssign</code> sera <code>false</code> et cela ignorera le <code>=</code> même s&rsquo;il y en a un là. Ensuite <code>namedVariable()</code> renvoie, et l&rsquo;exécution fait éventuellement son chemin en retour vers <code>parsePrecedence()</code>.</p>
<p>Et alors ? Que fait le compilateur avec notre exemple cassé d&rsquo;avant ? Juste maintenant, <code>variable()</code> ne consommera pas le <code>=</code>, donc ce sera le jeton courant. Le compilateur renvoie en retour vers <code>parsePrecedence()</code> depuis l&rsquo;analyseur préfixe <code>variable()</code> et essaie ensuite d&rsquo;entrer dans la boucle d&rsquo;analyse infixe. Il n&rsquo;y a pas de fonction d&rsquo;analyse associée avec <code>=</code>, donc il saute cette boucle.</p>
<p>Ensuite <code>parsePrecedence()</code> renvoie silencieusement en retour vers l&rsquo;appelant. Cela n&rsquo;est pas juste non plus. Si le <code>=</code> ne se fait pas consommer comme partie de l&rsquo;expression, rien d&rsquo;autre ne va le consommer. C&rsquo;est une erreur et nous devrions la rapporter.</p>
<div class="codehilite"><pre class="insert-before">    infixRule();
  }
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parsePrecedence</em>()</div>
<pre class="insert">

  <span class="k">if</span> (<span class="i">canAssign</span> &amp;&amp; <span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">error</span>(<span class="s">&quot;Invalid assignment target.&quot;</span>);
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>()</div>

<p>Avec cela, le programme mauvais précédent obtient correctement une erreur au moment de la compilation. OK, <em>maintenant</em> avons-nous fini ? Toujours pas tout à fait. Voyez, nous passons un argument à une des fonctions d&rsquo;analyse. Mais ces fonctions sont stockées dans une table de pointeurs de fonction, donc toutes les fonctions d&rsquo;analyse ont besoin d&rsquo;avoir le même type. Même si la plupart des fonctions d&rsquo;analyse ne supportent pas d&rsquo;être utilisées comme une cible d&rsquo;affectation<span class="em">&mdash;</span>les setters sont la <span name="index">seule</span> autre<span class="em">&mdash;</span>notre compilateur C amical exige qu&rsquo;elles acceptent <em>toutes</em> le paramètre.</p>
<aside name="index">
<p>Si Lox avait des tableaux et des opérateurs indice comme <code>array[index]</code> alors un <code>[</code> infixe permettrait aussi l&rsquo;affectation pour supporter <code>array[index] = value</code>.</p>
</aside>
<p>Donc nous allons finir ce chapitre avec un peu de sale boulot. D&rsquo;abord, allons de l&rsquo;avant et passons le drapeau aux fonctions d&rsquo;analyse infixes.</p>
<div class="codehilite"><pre class="insert-before">    ParseFn infixRule = getRule(parser.previous.type)-&gt;infix;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parsePrecedence</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">infixRule</span>(<span class="i">canAssign</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>(), replace 1 line</div>

<p>Nous aurons besoin de ça pour les setters éventuellement. Ensuite nous réparerons le typedef pour le type de fonction.</p>
<div class="codehilite"><pre class="insert-before">} Precedence;

</pre><div class="source-file"><em>compiler.c</em><br>
add after enum <em>Precedence</em><br>
replace 1 line</div>
<pre class="insert"><span class="k">typedef</span> <span class="t">void</span> (*<span class="t">ParseFn</span>)(<span class="t">bool</span> <span class="i">canAssign</span>);
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after enum <em>Precedence</em>, replace 1 line</div>

<p>Et un peu de code complètement ennuyeux pour accepter ce paramètre dans toutes nos fonctions d&rsquo;analyse existantes. Ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>binary</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">binary</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  TokenType operatorType = parser.previous.type;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>binary</em>(), replace 1 line</div>

<p>Et ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>literal</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">literal</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  switch (parser.previous.type) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>literal</em>(), replace 1 line</div>

<p>Et ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>grouping</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">grouping</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  expression();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>grouping</em>(), replace 1 line</div>

<p>Et ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>number</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">number</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  double value = strtod(parser.previous.start, NULL);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>number</em>(), replace 1 line</div>

<p>Et ici aussi :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>string</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">string</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  emitConstant(OBJ_VAL(copyString(parser.previous.start + 1,
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>string</em>(), replace 1 line</div>

<p>Et, finalement :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>unary</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">unary</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after">  TokenType operatorType = parser.previous.type;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>unary</em>(), replace 1 line</div>

<p>Ouf ! Nous sommes de retour à un programme C que nous pouvons compiler. Démarrez-le et maintenant vous pouvez faire tourner ceci :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">breakfast</span> = <span class="s">&quot;beignets&quot;</span>;
<span class="k">var</span> <span class="i">beverage</span> = <span class="s">&quot;cafe au lait&quot;</span>;
<span class="i">breakfast</span> = <span class="s">&quot;beignets with &quot;</span> + <span class="i">beverage</span>;

<span class="k">print</span> <span class="i">breakfast</span>;
</pre></div>
<p>Cela commence à ressembler à du vrai code pour un langage réel !</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>21&#8202;.&#8202;5</small>Défis</a></h2>
<ol>
<li>
<p>Le compilateur ajoute le nom d&rsquo;une variable globale à la table des constantes comme une chaîne chaque fois qu&rsquo;un identifiant est rencontré. Il crée une nouvelle constante chaque fois, même si ce nom de variable est déjà dans un emplacement précédent dans la table des constantes. C&rsquo;est gaspilleur dans les cas où la même variable est référencée de multiples fois par la même fonction. Cela, à son tour, augmente les chances de remplir la table des constantes et de tomber à court d&rsquo;emplacements puisque nous permettons seulement 256 constantes dans un fragment unique.</p>
<p>Optimisez cela. Comment votre optimisation affecte-t-elle la performance du compilateur comparée au runtime ? Est-ce le bon compromis ?</p>
</li>
<li>
<p>Chercher une variable globale par nom dans une table de hachage chaque fois qu&rsquo;elle est utilisée est assez lent, même avec une bonne table de hachage. Pouvez-vous trouver un moyen plus efficace de stocker et accéder aux variables globales sans changer la sémantique ?</p>
</li>
<li>
<p>En tournant dans le REPL, un utilisateur pourrait écrire une fonction qui fait référence à une variable globale inconnue. Ensuite, dans la ligne suivante, il déclare la variable. Lox devrait gérer cela gracieusement en ne rapportant pas une erreur de compilation &ldquo;variable inconnue&rdquo; quand la fonction est d&rsquo;abord définie.</p>
<p>Mais quand un utilisateur fait tourner un <em>script</em> Lox, le compilateur a accès au texte complet du programme entier avant que du code soit tourné. Considérez ce programme :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">useVar</span>() {
  <span class="k">print</span> <span class="i">oops</span>;
}

<span class="k">var</span> <span class="i">ooops</span> = <span class="s">&quot;too many o&#39;s!&quot;</span>;
</pre></div>
<p>Ici, nous pouvons dire statiquement que <code>oops</code> ne sera pas définie parce qu&rsquo;il n&rsquo;y a <em>aucune</em> déclaration de cette globale nulle part dans le programme. Notez que <code>useVar()</code> n&rsquo;est jamais appelée non plus, donc même si la variable n&rsquo;est pas définie, aucune erreur d&rsquo;exécution ne se produira parce qu&rsquo;elle n&rsquo;est jamais utilisée non plus.</p>
<p>Nous pourrions rapporter des erreurs comme celle-ci comme des erreurs de compilation, au moins en tournant depuis un script. Pensez-vous que nous devrions ? Justifiez votre réponse. Que font d&rsquo;autres langages de script que vous connaissez ?</p>
</li>
</ol>
</div>

<footer>
<a href="variables-locales.html" class="next">
  Next Chapter: &ldquo;Variables locales&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
