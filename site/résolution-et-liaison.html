<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Résolution et liaison &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Résolution et liaison<small>11</small></a></h3>

<ul>
    <li><a href="#portée-statique"><small>11.1</small> Portée Statique</a></li>
    <li><a href="#analyse-sémantique"><small>11.2</small> Analyse Sémantique</a></li>
    <li><a href="#une-classe-résolveur"><small>11.3</small> Une Classe Résolveur</a></li>
    <li><a href="#interpréter-les-variables-résolues"><small>11.4</small> Interpréter les Variables Résolues</a></li>
    <li><a href="#erreurs-de-résolution"><small>11.5</small> Erreurs de Résolution</a></li>
    <li><a href="#défis"><small>11.6</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="fonctions.html" title="Fonctions" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="classes.html" title="Classes" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="fonctions.html" title="Fonctions" class="prev">←</a>
<a href="classes.html" title="Classes" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Résolution et liaison<small>11</small></a></h3>

<ul>
    <li><a href="#portée-statique"><small>11.1</small> Portée Statique</a></li>
    <li><a href="#analyse-sémantique"><small>11.2</small> Analyse Sémantique</a></li>
    <li><a href="#une-classe-résolveur"><small>11.3</small> Une Classe Résolveur</a></li>
    <li><a href="#interpréter-les-variables-résolues"><small>11.4</small> Interpréter les Variables Résolues</a></li>
    <li><a href="#erreurs-de-résolution"><small>11.5</small> Erreurs de Résolution</a></li>
    <li><a href="#défis"><small>11.6</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="fonctions.html" title="Fonctions" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="classes.html" title="Classes" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">11</div>
  <h1>Résolution et liaison</h1>

<blockquote>
<p>Une fois de temps en temps vous vous trouvez dans une situation étrange. Vous y entrez par
degrés et de la façon la plus naturelle mais, quand vous êtes juste au milieu de
celle-ci, vous êtes soudainement étonné et vous demandez comment diable tout cela est
arrivé.</p>
<p><cite>Thor Heyerdahl, <em>Kon-Tiki</em></cite></p>
</blockquote>
<p>Oh, non ! Notre implémentation de langage prend l&rsquo;eau ! Il y a longtemps quand nous avons <a href="statements-and-state.html">ajouté les variables et les blocs</a>, nous avions une portée propre et étanche. Mais quand nous avons <a href="functions.html">plus tard ajouté les fermetures</a>, un trou s&rsquo;est ouvert dans notre interpréteur autrefois imperméable. La plupart des vrais programmes sont peu susceptibles de glisser à travers ce trou, mais en tant qu&rsquo;implémenteurs de langage, nous faisons le vœu sacré de nous soucier de la correction même dans les coins les plus profonds, les plus humides de la sémantique.</p>
<p>Nous passerons ce chapitre entier à explorer cette fuite, et ensuite à la colmater soigneusement. Dans le processus, nous gagnerons une compréhension plus rigoureuse de la portée lexicale telle qu&rsquo;utilisée par Lox et d&rsquo;autres langages dans la tradition C. Nous aurons aussi une chance d&rsquo;apprendre à propos de l&rsquo;<em>analyse sémantique</em><span class="em">&mdash;</span>une technique puissante pour extraire du sens du code source de l&rsquo;utilisateur sans avoir à l&rsquo;exécuter.</p>
<h2><a href="#portée-statique" id="portée-statique"><small>11&#8202;.&#8202;1</small>Portée Statique</a></h2>
<p>Un rafraîchissement rapide : Lox, comme la plupart des langages modernes, utilise une portée <em>lexicale</em>. Cela signifie que vous pouvez deviner à quelle déclaration un nom de variable fait référence juste en lisant le texte du programme. Par exemple :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;externe&quot;</span>;
{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;interne&quot;</span>;
  <span class="k">print</span> <span class="i">a</span>;
}
</pre></div>
<p>Ici, nous savons que le <code>a</code> qui est imprimé est la variable déclarée sur la ligne précédente, et non la globale. Exécuter le programme n&rsquo;affecte pas<span class="em">&mdash;</span>ne <em>peut pas</em> affecter<span class="em">&mdash;</span>cela. Les règles de portée font partie de la sémantique <em>statique</em> du langage, ce qui est pourquoi elles sont aussi appelées <em>portée statique</em>.</p>
<p>Je n&rsquo;ai pas épelé ces règles de portée, mais maintenant est le moment pour la <span name="precise">précision</span> :</p>
<aside name="precise">
<p>Ceci n&rsquo;est toujours nulle part aussi précis qu&rsquo;une vraie spécification de langage. Ces docs doivent être si explicites que même un Martien ou un programmeur carrément malicieux serait forcé d&rsquo;implémenter la sémantique correcte pourvu qu&rsquo;il suive la lettre de la spec.</p>
<p>Cette exactitude est importante quand un langage peut être implémenté par des entreprises concurrentes qui veulent que leur produit soit incompatible avec les autres pour verrouiller les clients sur leur plateforme. Pour ce livre, nous pouvons heureusement ignorer ces types de manigances louches.</p>
</aside>
<p><strong>Un usage de variable fait référence à la déclaration précédente avec le même nom dans la portée la plus interne qui entoure l&rsquo;expression où la variable est utilisée.</strong></p>
<p>Il y a beaucoup à déballer là-dedans :</p>
<ul>
<li>
<p>Je dis &ldquo;usage de variable&rdquo; au lieu de &ldquo;expression de variable&rdquo; pour couvrir à la fois les expressions de variable et les affectations. De même avec &ldquo;expression où la variable est utilisée&rdquo;.</p>
</li>
<li>
<p>&ldquo;Précédente&rdquo; signifie apparaissant avant <em>dans le texte du programme</em>.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;externe&quot;</span>;
{
  <span class="k">print</span> <span class="i">a</span>;
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;interne&quot;</span>;
}
</pre></div>
<p>Ici, le <code>a</code> qui est imprimé est l&rsquo;externe puisqu&rsquo;il apparaît <span name="hoisting">avant</span> l&rsquo;instruction <code>print</code> qui l&rsquo;utilise. Dans la plupart des cas, dans du code en ligne droite, la déclaration précédant dans le <em>texte</em> précédera aussi l&rsquo;usage dans le <em>temps</em>. Mais ce n&rsquo;est pas toujours vrai. Comme nous le verrons, les fonctions peuvent différer un morceau de code de telle sorte que son exécution <em>temporelle dynamique</em> ne reflète plus l&rsquo;ordre <em>textuel statique</em>.</p>
<pre><code>&lt;aside name="hoisting"&gt;
</code></pre>
<p>En JavaScript, les variables déclarées utilisant <code>var</code> sont implicitement &ldquo;hissées&rdquo; (hoisted) au début du bloc. Tout usage de ce nom dans le bloc fera référence à cette variable, même si l&rsquo;usage apparaît avant la déclaration. Quand vous écrivez ceci en JavaScript :</p>
<div class="codehilite"><pre>{
    <span class="i">console</span>.<span class="i">log</span>(<span class="i">a</span>);
    <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;valeur&quot;</span>;
}
</pre></div>
<p>Cela se comporte comme :</p>
<div class="codehilite"><pre>{
    <span class="k">var</span> <span class="i">a</span>; <span class="c">// Hissage.</span>
    <span class="i">console</span>.<span class="i">log</span>(<span class="i">a</span>);
    <span class="i">a</span> = <span class="s">&quot;valeur&quot;</span>;
}
</pre></div>
<p>Cela signifie que dans certains cas vous pouvez lire une variable avant que son initialiseur ait tourné<span class="em">&mdash;</span>une source ennuyeuse de bugs. La syntaxe alternative <code>let</code> pour déclarer des variables a été ajoutée plus tard pour adresser ce problème.</p>
<pre><code>&lt;/aside&gt;
</code></pre>
</li>
<li>
<p>&ldquo;La plus interne&rdquo; est là à cause de notre bon ami le masquage (shadowing). Il peut y avoir plus d&rsquo;une variable avec le nom donné dans les portées environnantes, comme dans :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;externe&quot;</span>;
{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;interne&quot;</span>;
  <span class="k">print</span> <span class="i">a</span>;
}
</pre></div>
<p>Notre règle désambiguïse ce cas en disant que la portée la plus interne gagne.</p>
</li>
</ul>
<p>Puisque cette règle ne fait aucune mention d&rsquo;aucun comportement à l&rsquo;exécution, elle implique qu&rsquo;une expression de variable fait toujours référence à la même déclaration à travers l&rsquo;exécution entière du programme. Notre interpréteur jusqu&rsquo;ici implémente <em>surtout</em> la règle correctement. Mais quand nous avons ajouté les fermetures, une erreur s&rsquo;est glissée.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;global&quot;</span>;
{
  <span class="k">fun</span> <span class="i">showA</span>() {
    <span class="k">print</span> <span class="i">a</span>;
  }

  <span class="i">showA</span>();
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;bloc&quot;</span>;
  <span class="i">showA</span>();
}
</pre></div>
<p><span name="tricky">Avant</span> que vous ne tapiez ceci et l&rsquo;exécutiez, décidez ce que vous pensez qu&rsquo;il <em>devrait</em> imprimer.</p>
<aside name="tricky">
<p>Je sais, c&rsquo;est un programme totalement pathologique, artificiel. C&rsquo;est juste <em>bizarre</em>. Aucune personne raisonnable n&rsquo;écrirait jamais de code comme ça. Hélas, plus de votre vie que vous ne l&rsquo;attendriez sera passée à gérer des snippets bizarres de code comme ça si vous restez dans le jeu des langages de programmation pour longtemps.</p>
</aside>
<p>OK<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>vous l&rsquo;avez ? Si vous êtes familier avec les fermetures dans d&rsquo;autres langages, vous attendrez qu&rsquo;il imprime &ldquo;global&rdquo; deux fois. Le premier appel à <code>showA()</code> devrait définitivement imprimer &ldquo;global&rdquo; puisque nous n&rsquo;avons même pas encore atteint la déclaration du <code>a</code> interne. Et par notre règle qu&rsquo;une expression de variable se résout toujours à la même variable, cela implique que le second appel à <code>showA()</code> devrait imprimer la même chose.</p>
<p>Hélas, il imprime :</p>
<div class="codehilite"><pre>global
bloc
</pre></div>
<p>Laissez-moi souligner que ce programme ne réassigne jamais aucune variable et contient seulement une seule instruction <code>print</code>. Pourtant, d&rsquo;une certaine manière, cette instruction <code>print</code> pour une variable jamais assignée imprime deux valeurs différentes à différents points dans le temps. Nous avons définitivement cassé quelque chose quelque part.</p>
<h3><a href="#portées-et-environnements-mutables" id="portées-et-environnements-mutables"><small>11&#8202;.&#8202;1&#8202;.&#8202;1</small>Portées et environnements mutables</a></h3>
<p>Dans notre interpréteur, les environnements sont la manifestation dynamique des portées statiques. Les deux restent la plupart du temps synchronisés l&rsquo;un avec l&rsquo;autre<span class="em">&mdash;</span>nous créons un nouvel environnement quand nous entrons dans une nouvelle portée, et le jetons quand nous quittons la portée. Il y a une autre opération que nous effectuons sur les environnements : lier une variable dans l&rsquo;un d&rsquo;eux. C&rsquo;est là que notre bug réside.</p>
<p>Parcourons cet exemple problématique et voyons à quoi ressemblent les environnements à chaque étape. D&rsquo;abord, nous déclarons <code>a</code> dans la portée globale.</p><img src="image/resolving-and-binding/environment-1.png" alt="L'environnement global avec 'a' défini dedans." />
<p>Cela nous donne un seul environnement avec une seule variable dedans. Ensuite nous entrons dans le bloc et exécutons la déclaration de <code>showA()</code>.</p><img src="image/resolving-and-binding/environment-2.png" alt="Un environnement de bloc lié à celui global." />
<p>Nous obtenons un nouvel environnement pour le bloc. Dans celui-ci, nous déclarons un nom, <code>showA</code>, qui est lié à l&rsquo;objet LoxFunction que nous créons pour représenter la fonction. Cet objet a un champ <code>closure</code> qui capture l&rsquo;environnement où la fonction a été déclarée, donc il a une référence en arrière vers l&rsquo;environnement pour le bloc.</p>
<p>Maintenant nous appelons <code>showA()</code>.</p><img src="image/resolving-and-binding/environment-3.png" alt="Un environnement vide pour le corps de showA() lié aux deux précédents. 'a' est résolu dans l'environnement global." />
<p>L&rsquo;interpréteur crée dynamiquement un nouvel environnement pour le corps de la fonction <code>showA()</code>. Il est vide puisque cette fonction ne déclare aucune variable. Le parent de cet environnement est la fermeture de la fonction<span class="em">&mdash;</span>l&rsquo;environnement du bloc externe.</p>
<p>À l&rsquo;intérieur du corps de <code>showA()</code>, nous imprimons la valeur de <code>a</code>. L&rsquo;interpréteur cherche cette valeur en parcourant la chaîne d&rsquo;environnements. Il va tout le chemin jusqu&rsquo;à l&rsquo;environnement global avant de la trouver là et d&rsquo;imprimer <code>"global"</code>. Super.</p>
<p>Ensuite, nous déclarons le second <code>a</code>, cette fois à l&rsquo;intérieur du bloc.</p><img src="image/resolving-and-binding/environment-4.png" alt="L'environnement de bloc a à la fois 'a' et 'showA' maintenant." />
<p>C&rsquo;est dans le même bloc<span class="em">&mdash;</span>la même portée<span class="em">&mdash;</span>que <code>showA()</code>, donc il va dans le même environnement, qui est aussi le même environnement auquel la fermeture de <code>showA()</code> fait référence. C&rsquo;est là que ça devient intéressant. Nous appelons <code>showA()</code> à nouveau.</p><img src="image/resolving-and-binding/environment-5.png" alt="Un environnement vide pour le corps de showA() lié aux deux précédents. 'a' est résolu dans l'environnement de bloc." />
<p>Nous créons un nouvel environnement vide pour le corps de <code>showA()</code> encore une fois, le branchons à cette fermeture, et lançons le corps. Quand l&rsquo;interpréteur parcourt la chaîne d&rsquo;environnements pour trouver <code>a</code>, il découvre maintenant le <em>nouveau</em> <code>a</code> dans l&rsquo;environnement de bloc. Bouh.</p>
<p>J&rsquo;ai choisi d&rsquo;implémenter les environnements d&rsquo;une façon dont j&rsquo;espérais qu&rsquo;elle s&rsquo;accorderait avec votre intuition informelle autour des portées. Nous avons tendance à considérer tout le code à l&rsquo;intérieur d&rsquo;un bloc comme étant à l&rsquo;intérieur de la même portée, donc notre interpréteur utilise un seul environnement pour représenter cela. Chaque environnement est une table de hachage mutable. Quand une nouvelle variable locale est déclarée, elle est ajoutée à l&rsquo;environnement existant pour cette portée.</p>
<p>Cette intuition, comme beaucoup dans la vie, n&rsquo;est pas tout à fait juste. Un bloc n&rsquo;est pas nécessairement tout la même portée. Considérez :</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span>;
  <span class="c">// 1.</span>
  <span class="k">var</span> <span class="i">b</span>;
  <span class="c">// 2.</span>
}
</pre></div>
<p>À la première ligne marquée, seul <code>a</code> est dans la portée. À la seconde ligne, les deux <code>a</code> et <code>b</code> le sont. Si vous définissez une &ldquo;portée&rdquo; comme étant un ensemble de déclarations, alors celles-ci ne sont clairement pas la même portée<span class="em">&mdash;</span>elles ne contiennent pas les mêmes déclarations. C&rsquo;est comme si chaque instruction <code>var</code> <span name="split">scindait</span> le bloc en deux portées séparées, la portée avant que la variable ne soit déclarée et celle après, qui inclut la nouvelle variable.</p>
<aside name="split">
<p>Certains langages rendent cette scission explicite. En Scheme et ML, quand vous déclarez une variable locale utilisant <code>let</code>, vous délimitez aussi le code subséquent où la nouvelle variable est dans la portée. Il n&rsquo;y a pas de &ldquo;reste du bloc&rdquo; implicite.</p>
</aside>
<p>Mais dans notre implémentation, les environnements agissent bien comme si le bloc entier était une seule portée, juste une portée qui change au fil du temps. Les fermetures n&rsquo;aiment pas ça. Quand une fonction est déclarée, elle capture une référence à l&rsquo;environnement courant. La fonction <em>devrait</em> capturer un instantané figé de l&rsquo;environnement <em>tel qu&rsquo;il existait au moment où la fonction a été déclarée</em>. Mais au lieu de cela, dans le code Java, elle a une référence à l&rsquo;objet environnement mutable réel. Quand une variable est plus tard déclarée dans la portée à laquelle cet environnement correspond, la fermeture voit la nouvelle variable, même si la déclaration ne précède <em>pas</em> la fonction.</p>
<h3><a href="#environnements-persistants" id="environnements-persistants"><small>11&#8202;.&#8202;1&#8202;.&#8202;2</small>Environnements persistants</a></h3>
<p>Il y a un style de programmation qui utilise ce qu&rsquo;on appelle des <strong>structures de données persistantes</strong>. Contrairement aux structures de données molles avec lesquelles vous êtes familier en programmation impérative, une structure de données persistante ne peut jamais être directement modifiée. Au lieu de cela, toute &ldquo;modification&rdquo; à une structure existante produit un <span name="copy">tout</span> nouvel objet qui contient toutes les données originales et la nouvelle modification. L&rsquo;original est laissé inchangé.</p>
<aside name="copy">
<p>Cela sonne comme si ça pouvait gaspiller des tonnes de mémoire et de temps à copier la structure pour chaque opération. En pratique, les structures de données persistantes partagent la plupart de leurs données entre les différentes &ldquo;copies&rdquo;.</p>
</aside>
<p>Si nous devions appliquer cette technique à Environment, alors chaque fois que vous déclariez une variable cela renverrait un <em>nouvel</em> environnement qui contenait toutes les variables précédemment déclarées avec le nouveau nom. Déclarer une variable ferait la &ldquo;scission&rdquo; implicite où vous avez un environnement avant que la variable ne soit déclarée et un après :</p><img src="image/resolving-and-binding/split.png" alt="Environnements séparés avant et après que la variable soit déclarée." />
<p>Une fermeture retient une référence à l&rsquo;instance Environment en jeu quand la fonction a été déclarée. Puisque toutes les déclarations ultérieures dans ce bloc produiraient de nouveaux objets Environment, la fermeture ne verrait pas les nouvelles variables et notre bug serait corrigé.</p>
<p>C&rsquo;est une façon légitime de résoudre le problème, et c&rsquo;est la façon classique d&rsquo;implémenter les environnements dans les interpréteurs Scheme. Nous pourrions faire cela pour Lox, mais cela signifierait revenir en arrière et changer une pile de code existant.</p>
<p>Je ne vous traînerai pas à travers ça. Nous garderons la façon dont nous représentons les environnements la même. Au lieu de rendre les données plus statiquement structurées, nous cuirons la résolution statique dans l&rsquo;<em>opération</em> d&rsquo;accès elle-même.</p>
<h2><a href="#analyse-sémantique" id="analyse-sémantique"><small>11&#8202;.&#8202;2</small>Analyse Sémantique</a></h2>
<p>Notre interpréteur <strong>résout</strong> une variable<span class="em">&mdash;</span>traque à quelle déclaration elle fait référence<span class="em">&mdash;</span>chaque fois que l&rsquo;expression de variable est évaluée. Si cette variable est emmaillotée à l&rsquo;intérieur d&rsquo;une boucle qui tourne mille fois, cette variable est re-résolue mille fois.</p>
<p>Nous savons que la portée statique signifie qu&rsquo;un usage de variable se résout toujours à la même déclaration, ce qui peut être déterminé juste en regardant le texte. Étant donné cela, pourquoi le faisons-nous dynamiquement à chaque fois ? Le faire n&rsquo;ouvre pas seulement le trou qui mène à notre bug ennuyeux, c&rsquo;est aussi inutilement lent.</p>
<p>Une meilleure solution est de résoudre chaque utilisation de variable <em>une fois</em>. Écrire un morceau de code qui inspecte le programme de l&rsquo;utilisateur, trouve chaque variable mentionnée, et devine à quelle déclaration chacune fait référence. Ce processus est un exemple d&rsquo;une <strong>analyse sémantique</strong>. Là où un parseur dit seulement si un programme est grammaticalement correct (une analyse <em>syntaxique</em>), l&rsquo;analyse sémantique va plus loin et commence à deviner ce que les pièces du programme signifient réellement. Dans ce cas, notre analyse résoudra les liaisons de variables. Nous saurons non seulement qu&rsquo;une expression <em>est</em> une variable, mais <em>quelle</em> variable elle est.</p>
<p>Il y a beaucoup de façons dont nous pourrions stocker la liaison entre une variable et sa déclaration. Quand nous arriverons à l&rsquo;interpréteur C pour Lox, nous aurons une façon <em>beaucoup</em> plus efficace de stocker et d&rsquo;accéder aux variables locales. Mais pour jlox, je veux minimiser les dommages collatéraux que nous infligeons à notre base de code existante. Je détesterais jeter un tas de code surtout bon.</p>
<p>Au lieu de cela, nous stockerons la résolution d&rsquo;une façon qui tire le meilleur parti de notre classe Environment existante. Rappelez-vous comment les accès de <code>a</code> sont interprétés dans l&rsquo;exemple problématique.</p><img src="image/resolving-and-binding/environment-3.png" alt="Un environnement vide pour le corps de showA() lié aux deux précédents. 'a' est résolu dans l'environnement global." />
<p>Dans la première évaluation (correcte), nous regardons trois environnements dans la chaîne avant de trouver la déclaration globale de <code>a</code>. Ensuite, quand le <code>a</code> interne est plus tard déclaré dans une portée de bloc, il masque le global.</p><img src="image/resolving-and-binding/environment-5.png" alt="Un environnement vide pour le corps de showA() lié aux deux précédents. 'a' est résolu dans l'environnement de bloc." />
<p>La recherche suivante parcourt la chaîne, trouve <code>a</code> dans le <em>second</em> environnement et s&rsquo;arrête là. Chaque environnement correspond à une seule portée lexicale où les variables sont déclarées. Si nous pouvions nous assurer qu&rsquo;une recherche de variable parcourait toujours le <em>même</em> nombre de liens dans la chaîne d&rsquo;environnement, cela assurerait qu&rsquo;elle trouve la même variable dans la même portée à chaque fois.</p>
<p>Pour &ldquo;résoudre&rdquo; un usage de variable, nous avons seulement besoin de calculer à combien de &ldquo;sauts&rdquo; la variable déclarée sera dans la chaîne d&rsquo;environnement. La question intéressante est <em>quand</em> faire ce calcul<span class="em">&mdash;</span>ou, mis différemment, où dans l&rsquo;implémentation de notre interpréteur bourrons-nous le code pour cela ?</p>
<p>Puisque nous calculons une propriété statique basée sur la structure du code source, la réponse évidente est dans le parseur. C&rsquo;est la maison traditionnelle, et c&rsquo;est où nous la mettrons plus tard dans clox. Cela marcherait ici aussi, mais je veux une excuse pour vous montrer une autre technique. Nous écrirons notre résolveur comme une passe séparée.</p>
<h3><a href="#une-passe-de-résolution-de-variable" id="une-passe-de-résolution-de-variable"><small>11&#8202;.&#8202;2&#8202;.&#8202;1</small>Une passe de résolution de variable</a></h3>
<p>Après que le parseur produit l&rsquo;arbre syntaxique, mais avant que l&rsquo;interpréteur ne commence à l&rsquo;exécuter, nous ferons une seule marche sur l&rsquo;arbre pour résoudre toutes les variables qu&rsquo;il contient. Des passes supplémentaires entre le parsing et l&rsquo;exécution sont courantes. Si Lox avait des types statiques, nous pourrions glisser un vérificateur de type là-dedans. Les optimisations sont souvent implémentées dans des passes séparées comme ça aussi. Fondamentalement, tout travail qui ne repose pas sur l&rsquo;état qui est seulement disponible à l&rsquo;exécution peut être fait de cette façon.</p>
<p>Notre passe de résolution de variable fonctionne comme une sorte de mini-interpréteur. Elle parcourt l&rsquo;arbre, visitant chaque nœud, mais une analyse statique est différente d&rsquo;une exécution dynamique :</p>
<ul>
<li>
<p><strong>Il n&rsquo;y a pas d&rsquo;effets de bord.</strong> Quand l&rsquo;analyse statique visite une instruction print, elle n&rsquo;imprime rien réellement. Les appels aux fonctions natives ou autres opérations qui atteignent le monde extérieur sont bouchonnés et n&rsquo;ont aucun effet.</p>
</li>
<li>
<p><strong>Il n&rsquo;y a pas de contrôle de flux.</strong> Les boucles sont visitées seulement <span name="fix">une fois</span>. Les deux branches sont visitées dans les instructions <code>if</code>. Les opérateurs logiques ne sont pas court-circuités.</p>
</li>
</ul>
<aside name="fix">
<p>La résolution de variable touche chaque nœud une fois, donc sa performance est <em>O(n)</em> où <em>n</em> est le nombre de nœuds d&rsquo;arbre syntaxique. Des analyses plus sophistiquées peuvent avoir une plus grande complexité, mais la plupart sont soigneusement conçues pour être linéaires ou pas loin de l&rsquo;être. C&rsquo;est un faux pas embarrassant si votre compilateur devient exponentiellement plus lent à mesure que le programme de l&rsquo;utilisateur grandit.</p>
</aside>
<h2><a href="#une-classe-résolveur" id="une-classe-résolveur"><small>11&#8202;.&#8202;3</small>Une Classe Résolveur</a></h2>
<p>Comme tout en Java, notre passe de résolution de variable est incarnée dans une classe.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.HashMap</span>;
<span class="k">import</span> <span class="i">java.util.List</span>;
<span class="k">import</span> <span class="i">java.util.Map</span>;
<span class="k">import</span> <span class="i">java.util.Stack</span>;

<span class="k">class</span> <span class="t">Resolver</span> <span class="k">implements</span> <span class="t">Expr</span>.<span class="t">Visitor</span>&lt;<span class="t">Void</span>&gt;, <span class="t">Stmt</span>.<span class="t">Visitor</span>&lt;<span class="t">Void</span>&gt; {
  <span class="k">private</span> <span class="k">final</span> <span class="t">Interpreter</span> <span class="i">interpreter</span>;

  <span class="t">Resolver</span>(<span class="t">Interpreter</span> <span class="i">interpreter</span>) {
    <span class="k">this</span>.<span class="i">interpreter</span> = <span class="i">interpreter</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, create new file</div>

<p>Puisque le résolveur a besoin de visiter chaque nœud dans l&rsquo;arbre syntaxique, il implémente l&rsquo;abstraction visiteur que nous avons déjà en place. Seuls quelques types de nœuds sont intéressants quand il s&rsquo;agit de résoudre les variables :</p>
<ul>
<li>
<p>Une instruction de bloc introduit une nouvelle portée pour les instructions qu&rsquo;elle contient.</p>
</li>
<li>
<p>Une déclaration de fonction introduit une nouvelle portée pour son corps et lie ses paramètres dans cette portée.</p>
</li>
<li>
<p>Une déclaration de variable ajoute une nouvelle variable à la portée courante.</p>
</li>
<li>
<p>Les expressions de variable et d&rsquo;affectation ont besoin d&rsquo;avoir leurs variables résolues.</p>
</li>
</ul>
<p>Le reste des nœuds ne fait rien de spécial, mais nous avons toujours besoin d&rsquo;implémenter des méthodes visit pour eux qui traversent dans leurs sous-arbres. Même si une expression <code>+</code> n&rsquo;a <em>elle-même</em> aucune variable à résoudre, l&rsquo;un ou l&rsquo;autre de ses opérandes pourrait en avoir.</p>
<h3><a href="#résoudre-les-blocs" id="résoudre-les-blocs"><small>11&#8202;.&#8202;3&#8202;.&#8202;1</small>Résoudre les blocs</a></h3>
<p>Nous commençons avec les blocs puisqu&rsquo;ils créent les portées locales où toute la magie se produit.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>Resolver</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitBlockStmt</span>(<span class="t">Stmt</span>.<span class="t">Block</span> <span class="i">stmt</span>) {
    <span class="i">beginScope</span>();
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">statements</span>);
    <span class="i">endScope</span>();
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>Resolver</em>()</div>

<p>Ceci commence une nouvelle portée, traverse dans les instructions à l&rsquo;intérieur du bloc, et ensuite jette la portée. Le truc fun vit dans ces méthodes assistantes. Nous commençons avec la simple.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>Resolver</em>()</div>
<pre>  <span class="t">void</span> <span class="i">resolve</span>(<span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">statements</span>) {
    <span class="k">for</span> (<span class="t">Stmt</span> <span class="i">statement</span> : <span class="i">statements</span>) {
      <span class="i">resolve</span>(<span class="i">statement</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>Resolver</em>()</div>

<p>Ceci parcourt une liste d&rsquo;instructions et résout chacune. Elle appelle à son tour :</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitBlockStmt</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">resolve</span>(<span class="t">Stmt</span> <span class="i">stmt</span>) {
    <span class="i">stmt</span>.<span class="i">accept</span>(<span class="k">this</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitBlockStmt</em>()</div>

<p>Pendant que nous y sommes, ajoutons une autre surcharge dont nous aurons besoin plus tard pour résoudre une expression.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>resolve</em>(Stmt stmt)</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">resolve</span>(<span class="t">Expr</span> <span class="i">expr</span>) {
    <span class="i">expr</span>.<span class="i">accept</span>(<span class="k">this</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>resolve</em>(Stmt stmt)</div>

<p>Ces méthodes sont similaires aux méthodes <code>evaluate()</code> et <code>execute()</code> dans Interpreter<span class="em">&mdash;</span>elles se retournent et appliquent le pattern Visitor au nœud d&rsquo;arbre syntaxique donné.</p>
<p>Le vrai comportement intéressant est autour des portées. Une nouvelle portée de bloc est créée comme ceci :</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>resolve</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">beginScope</span>() {
    <span class="i">scopes</span>.<span class="i">push</span>(<span class="k">new</span> <span class="t">HashMap</span>&lt;<span class="t">String</span>, <span class="t">Boolean</span>&gt;());
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>resolve</em>()</div>

<p>Les portées lexicales s&rsquo;imbriquent à la fois dans l&rsquo;interpréteur et le résolveur. Elles se comportent comme une pile. L&rsquo;interpréteur implémente cette pile en utilisant une liste chaînée<span class="em">&mdash;</span>la chaîne d&rsquo;objets Environment. Dans le résolveur, nous utilisons une Stack Java réelle.</p>
<div class="codehilite"><pre class="insert-before">  private final Interpreter interpreter;
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in class <em>Resolver</em></div>
<pre class="insert">  <span class="k">private</span> <span class="k">final</span> <span class="t">Stack</span>&lt;<span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">Boolean</span>&gt;&gt; <span class="i">scopes</span> = <span class="k">new</span> <span class="t">Stack</span>&lt;&gt;();
</pre><pre class="insert-after">

  Resolver(Interpreter interpreter) {
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in class <em>Resolver</em></div>

<p>Ce champ garde une trace de la pile de portées actuellement, uh, dans la portée. Chaque élément dans la pile est une Map représentant une seule portée de bloc. Les clés, comme dans Environment, sont des noms de variable. Les valeurs sont des Booléens, pour une raison que j&rsquo;expliquerai bientôt.</p>
<p>La pile de portée est seulement utilisée pour les portées de bloc locales. Les variables déclarées au niveau supérieur dans la portée globale ne sont pas suivies par le résolveur puisqu&rsquo;elles sont plus dynamiques dans Lox. Quand nous résolvons une variable, si nous ne pouvons pas la trouver dans la pile de portées locales, nous supposons qu&rsquo;elle doit être globale.</p>
<p>Puisque les portées sont stockées dans une pile explicite, en sortir une est direct.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>beginScope</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">endScope</span>() {
    <span class="i">scopes</span>.<span class="i">pop</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>beginScope</em>()</div>

<p>Maintenant nous pouvons empiler et dépiler une pile de portées vides. Mettons des choses dedans.</p>
<h3><a href="#résoudre-les-déclarations-de-variable" id="résoudre-les-déclarations-de-variable"><small>11&#8202;.&#8202;3&#8202;.&#8202;2</small>Résoudre les déclarations de variable</a></h3>
<p>Résoudre une déclaration de variable ajoute une nouvelle entrée à la map de la portée la plus interne actuelle. Cela semble simple, mais il y a une petite danse que nous devons faire.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitBlockStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitVarStmt</span>(<span class="t">Stmt</span>.<span class="t">Var</span> <span class="i">stmt</span>) {
    <span class="i">declare</span>(<span class="i">stmt</span>.<span class="i">name</span>);
    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">initializer</span> != <span class="k">null</span>) {
      <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">initializer</span>);
    }
    <span class="i">define</span>(<span class="i">stmt</span>.<span class="i">name</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitBlockStmt</em>()</div>

<p>Nous divisons la liaison en deux étapes, déclarer puis définir, afin de gérer des cas limites drôles comme celui-ci :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;externe&quot;</span>;
{
  <span class="k">var</span> <span class="i">a</span> = <span class="i">a</span>;
}
</pre></div>
<p>Qu&rsquo;arrive-t-il quand l&rsquo;initialiseur pour une variable locale fait référence à une variable avec le même nom que la variable étant déclarée ? Nous avons quelques options :</p>
<ol>
<li>
<p><strong>Lancer l&rsquo;initialiseur, puis mettre la nouvelle variable dans la portée.</strong> Ici, la nouvelle locale <code>a</code> serait initialisée avec &ldquo;externe&rdquo;, la valeur de la <em>globale</em>. En d&rsquo;autres termes, la déclaration précédente se &ldquo;désucrerait&rdquo; en :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">temp</span> = <span class="i">a</span>; <span class="c">// Lance l&#39;initialiseur.</span>
<span class="k">var</span> <span class="i">a</span>;        <span class="c">// Déclare la variable.</span>
<span class="i">a</span> = <span class="i">temp</span>;     <span class="c">// L&#39;initialise.</span>
</pre></div>
</li>
<li>
<p><strong>Mettre la nouvelle variable dans la portée, puis lancer l&rsquo;initialiseur.</strong> Cela signifie que vous pourriez observer une variable avant qu&rsquo;elle soit initialisée, donc nous aurions besoin de deviner quelle valeur elle aurait alors. Probablement <code>nil</code>. Cela signifie que la nouvelle locale <code>a</code> serait ré-initialisée à sa propre valeur implicitement initialisée, <code>nil</code>. Maintenant le &ldquo;désucrage&rdquo; ressemblerait à :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span>; <span class="c">// Définit la variable.</span>
<span class="i">a</span> = <span class="i">a</span>; <span class="c">// Lance l&#39;initialiseur.</span>
</pre></div>
</li>
<li>
<p><strong>Faire une erreur de référencer une variable dans son initialiseur.</strong> Faire échouer l&rsquo;interpréteur soit à la compilation soit à l&rsquo;exécution si un initialiseur mentionne la variable étant initialisée.</p>
</li>
</ol>
<p>Est-ce que l&rsquo;une ou l&rsquo;autre de ces deux premières options ressemble à quelque chose qu&rsquo;un utilisateur <em>veut</em> réellement ? Le masquage est rare et souvent une erreur, donc initialiser une variable masquante basée sur la valeur de la masquée semble peu susceptible d&rsquo;être délibéré.</p>
<p>La seconde option est encore moins utile. La nouvelle variable aura <em>toujours</em> la valeur <code>nil</code>. Il n&rsquo;y a jamais aucun intérêt à la mentionner par son nom. Vous pourriez utiliser un <code>nil</code> explicite à la place.</p>
<p>Puisque les deux premières options sont susceptibles de masquer des erreurs utilisateur, nous prendrons la troisième. De plus, nous en ferons une erreur de compilation au lieu d&rsquo;une à l&rsquo;exécution. De cette façon, l&rsquo;utilisateur est alerté du problème avant qu&rsquo;aucun code ne soit lancé.</p>
<p>Afin de faire cela, alors que nous visitons les expressions, nous avons besoin de savoir si nous sommes à l&rsquo;intérieur de l&rsquo;initialiseur pour une certaine variable. Nous faisons cela en divisant la liaison en deux étapes. La première est de la <strong>déclarer</strong>.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>endScope</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">declare</span>(<span class="t">Token</span> <span class="i">name</span>) {
    <span class="k">if</span> (<span class="i">scopes</span>.<span class="i">isEmpty</span>()) <span class="k">return</span>;

    <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">Boolean</span>&gt; <span class="i">scope</span> = <span class="i">scopes</span>.<span class="i">peek</span>();
    <span class="i">scope</span>.<span class="i">put</span>(<span class="i">name</span>.<span class="i">lexeme</span>, <span class="k">false</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>endScope</em>()</div>

<p>La déclaration ajoute la variable à la portée la plus interne pour qu&rsquo;elle masque toute externe et pour que nous sachions que la variable existe. Nous la marquons comme &ldquo;pas encore prête&rdquo; en liant son nom à <code>false</code> dans la map de portée. La valeur associée à une clé dans la map de portée représente si oui ou non nous avons fini de résoudre l&rsquo;initialiseur de cette variable.</p>
<p>Après avoir déclaré la variable, nous résolvons son expression d&rsquo;initialiseur dans cette même portée où la nouvelle variable existe maintenant mais est indisponible. Une fois que l&rsquo;expression d&rsquo;initialiseur est finie, la variable est prête pour le prime time. Nous faisons cela en la <strong>définissant</strong>.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>declare</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">define</span>(<span class="t">Token</span> <span class="i">name</span>) {
    <span class="k">if</span> (<span class="i">scopes</span>.<span class="i">isEmpty</span>()) <span class="k">return</span>;
    <span class="i">scopes</span>.<span class="i">peek</span>().<span class="i">put</span>(<span class="i">name</span>.<span class="i">lexeme</span>, <span class="k">true</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>declare</em>()</div>

<p>Nous mettons la valeur de la variable dans la map de portée à <code>true</code> pour la marquer comme pleinement initialisée et disponible pour l&rsquo;utilisation. Elle est vivante !</p>
<h3><a href="#résoudre-les-expressions-de-variable" id="résoudre-les-expressions-de-variable"><small>11&#8202;.&#8202;3&#8202;.&#8202;3</small>Résoudre les expressions de variable</a></h3>
<p>Les déclarations de variable<span class="em">&mdash;</span>et les déclarations de fonction, auxquelles nous arriverons<span class="em">&mdash;</span>écrivent dans les maps de portée. Ces maps sont lues quand nous résolvons les expressions de variable.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitVarStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitVariableExpr</span>(<span class="t">Expr</span>.<span class="t">Variable</span> <span class="i">expr</span>) {
    <span class="k">if</span> (!<span class="i">scopes</span>.<span class="i">isEmpty</span>() &amp;&amp;
        <span class="i">scopes</span>.<span class="i">peek</span>().<span class="i">get</span>(<span class="i">expr</span>.<span class="i">name</span>.<span class="i">lexeme</span>) == <span class="t">Boolean</span>.<span class="i">FALSE</span>) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">expr</span>.<span class="i">name</span>,
          <span class="s">&quot;Can&#39;t read local variable in its own initializer.&quot;</span>);
    }

    <span class="i">resolveLocal</span>(<span class="i">expr</span>, <span class="i">expr</span>.<span class="i">name</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitVarStmt</em>()</div>

<p>D&rsquo;abord, nous vérifions pour voir si la variable est accédée à l&rsquo;intérieur de son propre initialiseur. C&rsquo;est là que les valeurs dans la map de portée entrent en jeu. Si la variable existe dans la portée courante mais que sa valeur est <code>false</code>, cela signifie que nous l&rsquo;avons déclarée mais pas encore définie. Nous rapportons cette erreur.</p>
<p>Après cette vérification, nous résolvons réellement la variable elle-même en utilisant cet assistant :</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>define</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">resolveLocal</span>(<span class="t">Expr</span> <span class="i">expr</span>, <span class="t">Token</span> <span class="i">name</span>) {
    <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">scopes</span>.<span class="i">size</span>() - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
      <span class="k">if</span> (<span class="i">scopes</span>.<span class="i">get</span>(<span class="i">i</span>).<span class="i">containsKey</span>(<span class="i">name</span>.<span class="i">lexeme</span>)) {
        <span class="i">interpreter</span>.<span class="i">resolve</span>(<span class="i">expr</span>, <span class="i">scopes</span>.<span class="i">size</span>() - <span class="n">1</span> - <span class="i">i</span>);
        <span class="k">return</span>;
      }
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>define</em>()</div>

<p>Ceci ressemble, pour une bonne raison, beaucoup au code dans Environment pour évaluer une variable. Nous commençons à la portée la plus interne et travaillons vers l&rsquo;extérieur, cherchant dans chaque map un nom correspondant. Si nous trouvons la variable, nous la résolvons, en passant le nombre de portées entre la portée la plus interne courante et la portée où la variable a été trouvée. Donc, si la variable a été trouvée dans la portée courante, nous passons 0. Si c&rsquo;est dans la portée immédiatement englobante, 1. Vous avez l&rsquo;idée.</p>
<p>Si nous parcourons toutes les portées de bloc et ne trouvons jamais la variable, nous la laissons non résolue et supposons qu&rsquo;elle est globale. Nous arriverons à l&rsquo;implémentation de cette méthode <code>resolve()</code> un peu plus tard. Pour l&rsquo;instant, continuons à mouliner à travers les autres nœuds de syntaxe.</p>
<h3><a href="#résoudre-les-expressions-daffectation" id="résoudre-les-expressions-daffectation"><small>11&#8202;.&#8202;3&#8202;.&#8202;4</small>Résoudre les expressions d&rsquo;affectation</a></h3>
<p>L&rsquo;autre expression qui référence une variable est l&rsquo;affectation. En résoudre une ressemble à ceci :</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitVarStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitAssignExpr</span>(<span class="t">Expr</span>.<span class="t">Assign</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">value</span>);
    <span class="i">resolveLocal</span>(<span class="i">expr</span>, <span class="i">expr</span>.<span class="i">name</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitVarStmt</em>()</div>

<p>D&rsquo;abord, nous résolvons l&rsquo;expression pour la valeur assignée au cas où elle contient aussi des références à d&rsquo;autres variables. Ensuite nous utilisons notre méthode <code>resolveLocal()</code> existante pour résoudre la variable à qui on assigne.</p>
<h3><a href="#résoudre-les-déclarations-de-fonction" id="résoudre-les-déclarations-de-fonction"><small>11&#8202;.&#8202;3&#8202;.&#8202;5</small>Résoudre les déclarations de fonction</a></h3>
<p>Finalement, les fonctions. Les fonctions lient à la fois des noms et introduisent une portée. Le nom de la fonction elle-même est lié dans la portée environnante où la fonction est déclarée. Quand nous entrons dans le corps de la fonction, nous lions aussi ses paramètres dans cette portée de fonction interne.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitBlockStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitFunctionStmt</span>(<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">stmt</span>) {
    <span class="i">declare</span>(<span class="i">stmt</span>.<span class="i">name</span>);
    <span class="i">define</span>(<span class="i">stmt</span>.<span class="i">name</span>);

    <span class="i">resolveFunction</span>(<span class="i">stmt</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitBlockStmt</em>()</div>

<p>Similaire à <code>visitVariableStmt()</code>, nous déclarons et définissons le nom de la fonction dans la portée courante. Contrairement aux variables, cependant, nous définissons le nom avidement, avant de résoudre le corps de la fonction. Cela laisse une fonction faire référence récursivement à elle-même à l&rsquo;intérieur de son propre corps.</p>
<p>Ensuite nous résolvons le corps de la fonction en utilisant ceci :</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>resolve</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">resolveFunction</span>(<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">function</span>) {
    <span class="i">beginScope</span>();
    <span class="k">for</span> (<span class="t">Token</span> <span class="i">param</span> : <span class="i">function</span>.<span class="i">params</span>) {
      <span class="i">declare</span>(<span class="i">param</span>);
      <span class="i">define</span>(<span class="i">param</span>);
    }
    <span class="i">resolve</span>(<span class="i">function</span>.<span class="i">body</span>);
    <span class="i">endScope</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>resolve</em>()</div>

<p>C&rsquo;est une méthode séparée puisque nous l&rsquo;utiliserons aussi pour résoudre les méthodes Lox quand nous ajouterons les classes plus tard. Elle crée une nouvelle portée pour le corps et ensuite lie les variables pour chacun des paramètres de la fonction.</p>
<p>Une fois que c&rsquo;est prêt, elle résout le corps de la fonction dans cette portée. C&rsquo;est différent de comment l&rsquo;interpréteur gère les déclarations de fonction. À l&rsquo;<em>exécution</em>, déclarer une fonction ne fait rien avec le corps de la fonction. Le corps n&rsquo;est pas touché jusqu&rsquo;à plus tard quand la fonction est appelée. Dans une analyse <em>statique</em>, nous traversons immédiatement dans le corps ici et maintenant.</p>
<h3><a href="#résoudre-les-autres-nœuds-darbre-syntaxique" id="résoudre-les-autres-nœuds-darbre-syntaxique"><small>11&#8202;.&#8202;3&#8202;.&#8202;6</small>Résoudre les autres nœuds d&rsquo;arbre syntaxique</a></h3>
<p>Cela couvre les coins intéressants des grammaires. Nous gérons chaque endroit où une variable est déclarée, lue, ou écrite, et chaque endroit où une portée est créée ou détruite. Même s&rsquo;ils ne sont pas affectés par la résolution de variable, nous avons aussi besoin de méthodes visit pour tous les autres nœuds d&rsquo;arbre syntaxique afin de récurser dans leurs sous-arbres. <span name="boring">Désolé</span> ce morceau est ennuyeux, mais supportez-moi. Nous allons aller genre &ldquo;de haut en bas&rdquo; et commencer avec les instructions.</p>
<aside name="boring">
<p>J&rsquo;ai bien dit que le livre aurait chaque ligne de code unique pour ces interpréteurs. Je n&rsquo;ai pas dit qu&rsquo;elles seraient toutes excitantes.</p>
</aside>
<p>Une instruction d&rsquo;expression contient une seule expression à traverser.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitBlockStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitExpressionStmt</span>(<span class="t">Stmt</span>.<span class="t">Expression</span> <span class="i">stmt</span>) {
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">expression</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitBlockStmt</em>()</div>

<p>Une instruction if a une expression pour sa condition et une ou deux instructions pour les branches.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitFunctionStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitIfStmt</span>(<span class="t">Stmt</span>.<span class="t">If</span> <span class="i">stmt</span>) {
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">condition</span>);
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">thenBranch</span>);
    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">elseBranch</span> != <span class="k">null</span>) <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">elseBranch</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitFunctionStmt</em>()</div>

<p>Ici, nous voyons comment la résolution est différente de l&rsquo;interprétation. Quand nous résolvons une instruction <code>if</code>, il n&rsquo;y a pas de contrôle de flux. Nous résolvons la condition et les <em>deux</em> branches. Là où une exécution dynamique entre seulement dans la branche qui <em>est</em> lancée, une analyse statique est conservatrice<span class="em">&mdash;</span>elle analyse toute branche qui <em>pourrait</em> être lancée. Puisque l&rsquo;une ou l&rsquo;autre pourrait être atteinte à l&rsquo;exécution, nous résolvons les deux.</p>
<p>Comme les instructions d&rsquo;expression, une instruction <code>print</code> contient une seule sous-expression.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitIfStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitPrintStmt</span>(<span class="t">Stmt</span>.<span class="t">Print</span> <span class="i">stmt</span>) {
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">expression</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitIfStmt</em>()</div>

<p>Même affaire pour return.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitPrintStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitReturnStmt</span>(<span class="t">Stmt</span>.<span class="t">Return</span> <span class="i">stmt</span>) {
    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">value</span> != <span class="k">null</span>) {
      <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">value</span>);
    }

    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitPrintStmt</em>()</div>

<p>Comme dans les instructions <code>if</code>, avec une instruction <code>while</code>, nous résolvons sa condition et résolvons le corps exactement une fois.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitVarStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitWhileStmt</span>(<span class="t">Stmt</span>.<span class="t">While</span> <span class="i">stmt</span>) {
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">condition</span>);
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">body</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitVarStmt</em>()</div>

<p>Cela couvre toutes les instructions. Passons aux expressions<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<p>Notre vieil ami l&rsquo;expression binaire. Nous traversons dedans et résolvons les deux opérandes.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitAssignExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitBinaryExpr</span>(<span class="t">Expr</span>.<span class="t">Binary</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">left</span>);
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">right</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitAssignExpr</em>()</div>

<p>Les appels sont similaires<span class="em">&mdash;</span>nous parcourons la liste d&rsquo;arguments et les résolvons tous. La chose étant appelée est aussi une expression (habituellement une expression de variable), donc cela se fait résoudre aussi.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitBinaryExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitCallExpr</span>(<span class="t">Expr</span>.<span class="t">Call</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">callee</span>);

    <span class="k">for</span> (<span class="t">Expr</span> <span class="i">argument</span> : <span class="i">expr</span>.<span class="i">arguments</span>) {
      <span class="i">resolve</span>(<span class="i">argument</span>);
    }

    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitBinaryExpr</em>()</div>

<p>Les parenthèses sont faciles.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitCallExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitGroupingExpr</span>(<span class="t">Expr</span>.<span class="t">Grouping</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">expression</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitCallExpr</em>()</div>

<p>Les littéraux sont les plus faciles de tous.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitGroupingExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitLiteralExpr</span>(<span class="t">Expr</span>.<span class="t">Literal</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitGroupingExpr</em>()</div>

<p>Une expression littérale ne mentionne aucune variable et ne contient aucune sous-expression donc il n&rsquo;y a pas de travail à faire.</p>
<p>Puisqu&rsquo;une analyse statique ne fait aucun contrôle de flux ou court-circuitage, les expressions logiques sont exactement les mêmes que les autres opérateurs binaires.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitLiteralExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitLogicalExpr</span>(<span class="t">Expr</span>.<span class="t">Logical</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">left</span>);
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">right</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitLiteralExpr</em>()</div>

<p>Et, finalement, le dernier nœud. Nous résolvons son unique opérande.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitLogicalExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitUnaryExpr</span>(<span class="t">Expr</span>.<span class="t">Unary</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">right</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitLogicalExpr</em>()</div>

<p>Avec toutes ces méthodes visit, le compilateur Java devrait être satisfait que Resolver implémente pleinement Stmt.Visitor et Expr.Visitor. Maintenant est un bon moment pour prendre une pause, prendre un en-cas, peut-être une petite sieste.</p>
<h2><a href="#interpréter-les-variables-résolues" id="interpréter-les-variables-résolues"><small>11&#8202;.&#8202;4</small>Interpréter les Variables Résolues</a></h2>
<p>Voyons à quoi notre résolveur est bon. Chaque fois qu&rsquo;il visite une variable, il dit à l&rsquo;interpréteur combien de portées il y a entre la portée courante et la portée où la variable est définie. À l&rsquo;exécution, cela correspond exactement au nombre d&rsquo;<em>environnements</em> entre le courant et l&rsquo;englobant où l&rsquo;interpréteur peut trouver la valeur de la variable. Le résolveur passe ce nombre à l&rsquo;interpréteur en appelant ceci :</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>execute</em>()</div>
<pre>  <span class="t">void</span> <span class="i">resolve</span>(<span class="t">Expr</span> <span class="i">expr</span>, <span class="t">int</span> <span class="i">depth</span>) {
    <span class="i">locals</span>.<span class="i">put</span>(<span class="i">expr</span>, <span class="i">depth</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>execute</em>()</div>

<p>Nous voulons stocker l&rsquo;information de résolution quelque part pour que nous puissions l&rsquo;utiliser quand l&rsquo;expression de variable ou d&rsquo;affectation est plus tard exécutée, mais où ? Un endroit évident est juste dans le nœud d&rsquo;arbre syntaxique lui-même. C&rsquo;est une approche correcte, et c&rsquo;est où beaucoup de compilateurs stockent les résultats d&rsquo;analyses comme celle-ci.</p>
<p>Nous pourrions faire cela, mais cela exigerait de trifouiller avec notre générateur d&rsquo;arbre syntaxique. Au lieu de cela, nous prendrons une autre approche courante et le stockerons sur le <span name="side">côté</span> dans une map qui associe chaque nœud d&rsquo;arbre syntaxique avec ses données résolues.</p>
<aside name="side">
<p>Je <em>pense</em> que j&rsquo;ai entendu cette map être appelée une &ldquo;table latérale&rdquo; (side table) puisque c&rsquo;est une structure de données tabulaire qui stocke des données séparément des objets auxquels elle se rapporte. Mais chaque fois que j&rsquo;essaie de Googler ce terme, j&rsquo;obtiens des pages sur des meubles.</p>
</aside>
<p>Les outils interactifs comme les IDEs re-parsent et re-résolvent souvent incrémentalement des parties du programme de l&rsquo;utilisateur. Il peut être difficile de trouver tous les bouts d&rsquo;état qui ont besoin d&rsquo;être recalculés quand ils se cachent dans le feuillage de l&rsquo;arbre syntaxique. Un bénéfice de stocker ces données en dehors des nœuds est que cela rend facile de les <em>jeter</em><span class="em">&mdash;</span>effacez simplement la map.</p>
<div class="codehilite"><pre class="insert-before">  private Environment environment = globals;
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in class <em>Interpreter</em></div>
<pre class="insert">  <span class="k">private</span> <span class="k">final</span> <span class="t">Map</span>&lt;<span class="t">Expr</span>, <span class="t">Integer</span>&gt; <span class="i">locals</span> = <span class="k">new</span> <span class="t">HashMap</span>&lt;&gt;();
</pre><pre class="insert-after">

  Interpreter() {
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in class <em>Interpreter</em></div>

<p>Vous pourriez penser que nous aurions besoin d&rsquo;une sorte de structure d&rsquo;arbre imbriquée pour éviter d&rsquo;être confus quand il y a plusieurs expressions qui référencent la même variable, mais chaque nœud d&rsquo;expression est son propre objet Java avec sa propre identité unique. Une seule map monolithique n&rsquo;a aucun mal à les garder séparés.</p>
<p>Comme d&rsquo;habitude, utiliser une collection exige de nous d&rsquo;importer une paire de noms.</p>
<div class="codehilite"><pre class="insert-before">import java.util.ArrayList;
</pre><div class="source-file"><em>lox/Interpreter.java</em></div>
<pre class="insert"><span class="k">import</span> <span class="i">java.util.HashMap</span>;
</pre><pre class="insert-after">import java.util.List;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em></div>

<p>Et :</p>
<div class="codehilite"><pre class="insert-before">import java.util.List;
</pre><div class="source-file"><em>lox/Interpreter.java</em></div>
<pre class="insert"><span class="k">import</span> <span class="i">java.util.Map</span>;
</pre><pre class="insert-after">

class Interpreter implements Expr.Visitor&lt;Object&gt;,
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em></div>

<h3><a href="#accéder-&agrave;-une-variable-résolue" id="accéder-&agrave;-une-variable-résolue"><small>11&#8202;.&#8202;4&#8202;.&#8202;1</small>Accéder &agrave; une variable résolue</a></h3>
<p>Notre interpréteur a maintenant accès à la localisation résolue de chaque variable. Finalement, nous arrivons à faire usage de cela. Nous remplaçons la méthode visit pour les expressions de variable par ceci :</p>
<div class="codehilite"><pre class="insert-before">  public Object visitVariableExpr(Expr.Variable expr) {
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitVariableExpr</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="k">return</span> <span class="i">lookUpVariable</span>(<span class="i">expr</span>.<span class="i">name</span>, <span class="i">expr</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitVariableExpr</em>(), replace 1 line</div>

<p>Cela délègue à :</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitVariableExpr</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Object</span> <span class="i">lookUpVariable</span>(<span class="t">Token</span> <span class="i">name</span>, <span class="t">Expr</span> <span class="i">expr</span>) {
    <span class="t">Integer</span> <span class="i">distance</span> = <span class="i">locals</span>.<span class="i">get</span>(<span class="i">expr</span>);
    <span class="k">if</span> (<span class="i">distance</span> != <span class="k">null</span>) {
      <span class="k">return</span> <span class="i">environment</span>.<span class="i">getAt</span>(<span class="i">distance</span>, <span class="i">name</span>.<span class="i">lexeme</span>);
    } <span class="k">else</span> {
      <span class="k">return</span> <span class="i">globals</span>.<span class="i">get</span>(<span class="i">name</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitVariableExpr</em>()</div>

<p>Il y a une paire de choses qui se passent ici. D&rsquo;abord, nous cherchons la distance résolue dans la map. Rappelez-vous que nous avons résolu seulement les variables <em>locales</em>. Les globales sont traitées spécialement et ne finissent pas dans la map (d&rsquo;où le nom <code>locals</code>). Donc, si nous ne trouvons pas une distance dans la map, elle doit être globale. Dans ce cas, nous la cherchons, dynamiquement, directement dans l&rsquo;environnement global. Cela lance une erreur d&rsquo;exécution si la variable n&rsquo;est pas définie.</p>
<p>Si nous <em>obtenons</em> une distance, nous avons une variable locale, et nous arrivons à tirer avantage des résultats de notre analyse statique. Au lieu d&rsquo;appeler <code>get()</code>, nous appelons cette nouvelle méthode sur Environment :</p>
<div class="codehilite"><div class="source-file"><em>lox/Environment.java</em><br>
add after <em>define</em>()</div>
<pre>  <span class="t">Object</span> <span class="i">getAt</span>(<span class="t">int</span> <span class="i">distance</span>, <span class="t">String</span> <span class="i">name</span>) {
    <span class="k">return</span> <span class="i">ancestor</span>(<span class="i">distance</span>).<span class="i">values</span>.<span class="i">get</span>(<span class="i">name</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, add after <em>define</em>()</div>

<p>La vieille méthode <code>get()</code> parcourt dynamiquement la chaîne d&rsquo;environnements englobants, récurant chacun pour voir si la variable pourrait se cacher là-dedans quelque part. Mais maintenant nous savons exactement quel environnement dans la chaîne aura la variable. Nous l&rsquo;atteignons en utilisant cette méthode assistante :</p>
<div class="codehilite"><div class="source-file"><em>lox/Environment.java</em><br>
add after <em>define</em>()</div>
<pre>  <span class="t">Environment</span> <span class="i">ancestor</span>(<span class="t">int</span> <span class="i">distance</span>) {
    <span class="t">Environment</span> <span class="i">environment</span> = <span class="k">this</span>;
    <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">distance</span>; <span class="i">i</span>++) {
      <span class="i">environment</span> = <span class="i">environment</span>.<span class="i">enclosing</span>;<span name="coupled"> </span>
    }

    <span class="k">return</span> <span class="i">environment</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, add after <em>define</em>()</div>

<p>Ceci marche un nombre fixe de sauts vers le haut de la chaîne parente et renvoie l&rsquo;environnement là. Une fois que nous avons cela, <code>getAt()</code> renvoie simplement la valeur de la variable dans la map de cet environnement. Il n&rsquo;a même pas à vérifier pour voir si la variable est là<span class="em">&mdash;</span>nous savons qu&rsquo;elle le sera parce que le résolveur l&rsquo;a déjà trouvée avant.</p>
<aside name="coupled">
<p>La façon dont l&rsquo;interpréteur suppose que la variable est dans cette map ressemble à voler à l&rsquo;aveugle. Le code de l&rsquo;interpréteur fait confiance à ce que le résolveur a fait son travail et a résolu la variable correctement. Cela implique un couplage profond entre ces deux classes. Dans le résolveur, chaque ligne de code qui touche une portée doit avoir sa correspondance exacte dans l&rsquo;interpréteur pour modifier un environnement.</p>
<p>J&rsquo;ai senti ce couplage de première main parce qu&rsquo;alors que j&rsquo;écrivais le code pour le livre, je suis tombé sur une paire de bugs subtils où le code du résolveur et de l&rsquo;interpréteur étaient légèrement désynchronisés. Traquer ceux-là était difficile. Un outil pour rendre cela plus facile est d&rsquo;avoir l&rsquo;interpréteur ASSERT explicitement<span class="em">&mdash;</span>en utilisant les instructions assert de Java ou un autre outil de validation<span class="em">&mdash;</span>le contrat qu&rsquo;il attend que le résolveur ait déjà soutenu.</p>
</aside>
<h3><a href="#assigner-&agrave;-une-variable-résolue" id="assigner-&agrave;-une-variable-résolue"><small>11&#8202;.&#8202;4&#8202;.&#8202;2</small>Assigner &agrave; une variable résolue</a></h3>
<p>Nous pouvons aussi utiliser une variable en l&rsquo;assignant. Les changements pour visiter une expression d&rsquo;affectation sont similaires.</p>
<div class="codehilite"><pre class="insert-before">  public Object visitAssignExpr(Expr.Assign expr) {
    Object value = evaluate(expr.value);
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitAssignExpr</em>()<br>
replace 1 line</div>
<pre class="insert">

    <span class="t">Integer</span> <span class="i">distance</span> = <span class="i">locals</span>.<span class="i">get</span>(<span class="i">expr</span>);
    <span class="k">if</span> (<span class="i">distance</span> != <span class="k">null</span>) {
      <span class="i">environment</span>.<span class="i">assignAt</span>(<span class="i">distance</span>, <span class="i">expr</span>.<span class="i">name</span>, <span class="i">value</span>);
    } <span class="k">else</span> {
      <span class="i">globals</span>.<span class="i">assign</span>(<span class="i">expr</span>.<span class="i">name</span>, <span class="i">value</span>);
    }

</pre><pre class="insert-after">    return value;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitAssignExpr</em>(), replace 1 line</div>

<p>Encore une fois, nous cherchons la distance de portée de la variable. Si non trouvée, nous supposons qu&rsquo;elle est globale et la gérons de la même façon qu&rsquo;avant. Sinon, nous appelons cette nouvelle méthode :</p>
<div class="codehilite"><div class="source-file"><em>lox/Environment.java</em><br>
add after <em>getAt</em>()</div>
<pre>  <span class="t">void</span> <span class="i">assignAt</span>(<span class="t">int</span> <span class="i">distance</span>, <span class="t">Token</span> <span class="i">name</span>, <span class="t">Object</span> <span class="i">value</span>) {
    <span class="i">ancestor</span>(<span class="i">distance</span>).<span class="i">values</span>.<span class="i">put</span>(<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, add after <em>getAt</em>()</div>

<p>Comme <code>getAt()</code> est à <code>get()</code>, <code>assignAt()</code> est à <code>assign()</code>. Elle parcourt un nombre fixe d&rsquo;environnements, et ensuite bourre la nouvelle valeur dans cette map.</p>
<p>Ce sont les seuls changements à Interpreter. C&rsquo;est pourquoi j&rsquo;ai choisi une représentation pour nos données résolues qui était minimalement invasive. Tout le reste des nœuds continue de fonctionner comme ils le faisaient avant. Même le code pour modifier les environnements est inchangé.</p>
<h3><a href="#lancer-le-résolveur" id="lancer-le-résolveur"><small>11&#8202;.&#8202;4&#8202;.&#8202;3</small>Lancer le résolveur</a></h3>
<p>Nous avons besoin de <em>lancer</em> réellement le résolveur, cependant. Nous insérons la nouvelle passe après que le parseur ait fait sa magie.</p>
<div class="codehilite"><pre class="insert-before">    // Stop if there was a syntax error.
    if (hadError) return;

</pre><div class="source-file"><em>lox/Lox.java</em><br>
in <em>run</em>()</div>
<pre class="insert">    <span class="t">Resolver</span> <span class="i">resolver</span> = <span class="k">new</span> <span class="t">Resolver</span>(<span class="i">interpreter</span>);
    <span class="i">resolver</span>.<span class="i">resolve</span>(<span class="i">statements</span>);

</pre><pre class="insert-after">    interpreter.interpret(statements);
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>run</em>()</div>

<p>Nous ne lançons pas le résolveur s&rsquo;il y a des erreurs de parsing. Si le code a une erreur de syntaxe, il ne va jamais tourner, donc il y a peu de valeur à le résoudre. Si la syntaxe est propre, nous disons au résolveur de faire son truc. Le résolveur a une référence à l&rsquo;interpréteur et pousse les données de résolution directement dedans alors qu&rsquo;il marche sur les variables. Quand l&rsquo;interpréteur tourne ensuite, il a tout ce dont il a besoin.</p>
<p>Au moins, c&rsquo;est vrai si le résolveur <em>réussit</em>. Mais qu&rsquo;en est-il des erreurs pendant la résolution ?</p>
<h2><a href="#erreurs-de-résolution" id="erreurs-de-résolution"><small>11&#8202;.&#8202;5</small>Erreurs de Résolution</a></h2>
<p>Puisque nous faisons une passe d&rsquo;analyse sémantique, nous avons une opportunité de rendre la sémantique de Lox plus précise, et d&rsquo;aider les utilisateurs à attraper des bugs tôt avant de lancer leur code. Jetez un œil à ce mauvais garçon :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">bad</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;premier&quot;</span>;
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;second&quot;</span>;
}
</pre></div>
<p>Nous permettons bien de déclarer plusieurs variables avec le même nom dans la portée <em>globale</em>, mais faire ainsi dans une portée locale est probablement une erreur. S&rsquo;ils savaient que la variable existait déjà, ils l&rsquo;auraient assignée au lieu d&rsquo;utiliser <code>var</code>. Et s&rsquo;ils ne savaient <em>pas</em> qu&rsquo;elle existait, ils n&rsquo;avaient probablement pas l&rsquo;intention d&rsquo;écraser la précédente.</p>
<p>Nous pouvons détecter cette erreur statiquement pendant la résolution.</p>
<div class="codehilite"><pre class="insert-before">    Map&lt;String, Boolean&gt; scope = scopes.peek();
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>declare</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">scope</span>.<span class="i">containsKey</span>(<span class="i">name</span>.<span class="i">lexeme</span>)) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">name</span>,
          <span class="s">&quot;Already a variable with this name in this scope.&quot;</span>);
    }

</pre><pre class="insert-after">    scope.put(name.lexeme, false);
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>declare</em>()</div>

<p>Quand nous déclarons une variable dans une portée locale, nous connaissons déjà les noms de chaque variable précédemment déclarée dans cette même portée. Si nous voyons une collision, nous rapportons une erreur.</p>
<h3><a href="#erreurs-de-retour-invalide" id="erreurs-de-retour-invalide"><small>11&#8202;.&#8202;5&#8202;.&#8202;1</small>Erreurs de retour invalide</a></h3>
<p>Voici un autre petit script méchant :</p>
<div class="codehilite"><pre><span class="k">return</span> <span class="s">&quot;au niveau supérieur&quot;</span>;
</pre></div>
<p>Ceci exécute une instruction <code>return</code>, mais ce n&rsquo;est même pas à l&rsquo;intérieur d&rsquo;une fonction du tout. C&rsquo;est du code de niveau supérieur. Je ne sais pas ce que l&rsquo;utilisateur <em>pense</em> qu&rsquo;il va arriver, mais je ne pense pas que nous voulons que Lox permette cela.</p>
<p>Nous pouvons étendre le résolveur pour détecter cela statiquement. Tout comme nous suivons les portées alors que nous parcourons l&rsquo;arbre, nous pouvons suivre si oui ou non le code que nous visitons actuellement est à l&rsquo;intérieur d&rsquo;une déclaration de fonction.</p>
<div class="codehilite"><pre class="insert-before">  private final Stack&lt;Map&lt;String, Boolean&gt;&gt; scopes = new Stack&lt;&gt;();
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in class <em>Resolver</em></div>
<pre class="insert">  <span class="k">private</span> <span class="t">FunctionType</span> <span class="i">currentFunction</span> = <span class="t">FunctionType</span>.<span class="i">NONE</span>;
</pre><pre class="insert-after">

  Resolver(Interpreter interpreter) {
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in class <em>Resolver</em></div>

<p>Au lieu d&rsquo;un Booléen nu, nous utilisons cet enum drôle :</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>Resolver</em>()</div>
<pre>  <span class="k">private</span> <span class="k">enum</span> <span class="t">FunctionType</span> {
    <span class="i">NONE</span>,
    <span class="i">FUNCTION</span>
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>Resolver</em>()</div>

<p>Cela semble un peu bête maintenant, mais nous lui ajouterons une paire de cas en plus plus tard et alors cela aura plus de sens. Quand nous résolvons une déclaration de fonction, nous passons cela dedans.</p>
<div class="codehilite"><pre class="insert-before">    define(stmt.name);

</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitFunctionStmt</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">resolveFunction</span>(<span class="i">stmt</span>, <span class="t">FunctionType</span>.<span class="i">FUNCTION</span>);
</pre><pre class="insert-after">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitFunctionStmt</em>(), replace 1 line</div>

<p>Là-bas dans <code>resolveFunction()</code>, nous prenons ce paramètre et le stockons dans le champ avant de résoudre le corps.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
method <em>resolveFunction</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">private</span> <span class="t">void</span> <span class="i">resolveFunction</span>(
      <span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">function</span>, <span class="t">FunctionType</span> <span class="i">type</span>) {
    <span class="t">FunctionType</span> <span class="i">enclosingFunction</span> = <span class="i">currentFunction</span>;
    <span class="i">currentFunction</span> = <span class="i">type</span>;

</pre><pre class="insert-after">    beginScope();
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, method <em>resolveFunction</em>(), replace 1 line</div>

<p>Nous planquons la valeur précédente du champ dans une variable locale d&rsquo;abord. Rappelez-vous, Lox a des fonctions locales, donc vous pouvez imbriquer des déclarations de fonction arbitrairement profondément. Nous avons besoin de suivre non seulement que nous sommes dans une fonction, mais dans <em>combien</em> nous sommes.</p>
<p>Nous pourrions utiliser une pile explicite de valeurs FunctionType pour cela, mais au lieu de cela nous ferons du ferroutage sur la JVM. Nous stockons la valeur précédente dans une locale sur la pile Java. Quand nous avons fini de résoudre le corps de la fonction, nous restaurons le champ à cette valeur.</p>
<div class="codehilite"><pre class="insert-before">    endScope();
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>resolveFunction</em>()</div>
<pre class="insert">    <span class="i">currentFunction</span> = <span class="i">enclosingFunction</span>;
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>resolveFunction</em>()</div>

<p>Maintenant que nous pouvons toujours dire si oui ou non nous sommes à l&rsquo;intérieur d&rsquo;une déclaration de fonction, nous vérifions cela quand nous résolvons une instruction <code>return</code>.</p>
<div class="codehilite"><pre class="insert-before">  public Void visitReturnStmt(Stmt.Return stmt) {
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitReturnStmt</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">currentFunction</span> == <span class="t">FunctionType</span>.<span class="i">NONE</span>) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">stmt</span>.<span class="i">keyword</span>, <span class="s">&quot;Can&#39;t return from top-level code.&quot;</span>);
    }

</pre><pre class="insert-after">    if (stmt.value != null) {
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitReturnStmt</em>()</div>

<p>Propre, non ?</p>
<p>Il y a une pièce de plus. De retour dans la classe principale Lox qui coud tout ensemble, nous faisons attention de ne pas lancer l&rsquo;interpréteur si des erreurs de parsing sont rencontrées. Cette vérification tourne <em>avant</em> le résolveur pour que nous n&rsquo;essayions pas de résoudre du code syntaxiquement invalide.</p>
<p>Mais nous avons aussi besoin de sauter l&rsquo;interpréteur s&rsquo;il y a des erreurs de résolution, donc nous ajoutons <em>une autre</em> vérification.</p>
<div class="codehilite"><pre class="insert-before">    resolver.resolve(statements);
</pre><div class="source-file"><em>lox/Lox.java</em><br>
in <em>run</em>()</div>
<pre class="insert">

    <span class="c">// Stop if there was a resolution error.</span>
    <span class="k">if</span> (<span class="i">hadError</span>) <span class="k">return</span>;
</pre><pre class="insert-after">

    interpreter.interpret(statements);
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>run</em>()</div>

<p>Vous pourriez imaginer faire beaucoup d&rsquo;autres analyses ici. Par exemple, si nous ajoutions des instructions <code>break</code> à Lox, nous voudrions probablement nous assurer qu&rsquo;elles sont uniquement utilisées à l&rsquo;intérieur de boucles.</p>
<p>Nous pourrions aller plus loin et rapporter des avertissements pour du code qui n&rsquo;est pas nécessairement <em>faux</em> mais n&rsquo;est probablement pas utile. Par exemple, beaucoup d&rsquo;IDEs avertiront si vous avez du code inatteignable après une instruction <code>return</code>, ou une variable locale dont la valeur n&rsquo;est jamais lue. Tout cela serait assez facile à ajouter à notre passe de visite statique, ou comme des passes <span name="separate">séparées</span>.</p>
<aside name="separate">
<p>Le choix de combien d&rsquo;analyses différentes regrouper dans une seule passe est difficile. Beaucoup de petites passes isolées, chacune avec sa propre responsabilité, sont plus simples à implémenter et maintenir. Cependant, il y a un coût réel à l&rsquo;exécution à traverser l&rsquo;arbre syntaxique lui-même, donc empaqueter plusieurs analyses dans une seule passe est habituellement plus rapide.</p>
</aside>
<p>Mais, pour l&rsquo;instant, nous resterons avec cette quantité limitée d&rsquo;analyse. La partie importante est que nous avons corrigé ce bizarre bug de cas limite ennuyeux, bien qu&rsquo;il puisse être surprenant que cela ait pris autant de travail pour le faire.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>11&#8202;.&#8202;6</small>Défis</a></h2>
<ol>
<li>
<p>Pourquoi est-il sûr de définir avidement la variable liée au nom d&rsquo;une fonction quand d&rsquo;autres variables doivent attendre jusqu&rsquo;après qu&rsquo;elles soient initialisées avant qu&rsquo;elles puissent être utilisées ?</p>
</li>
<li>
<p>Comment d&rsquo;autres langages que vous connaissez gèrent-ils les variables locales qui font référence au même nom dans leur initialiseur, comme :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;externe&quot;</span>;
{
  <span class="k">var</span> <span class="i">a</span> = <span class="i">a</span>;
}
</pre></div>
<p>Est-ce une erreur d&rsquo;exécution ? Erreur de compilation ? Autorisé ? Traitent-ils les variables globales différemment ? Êtes-vous d&rsquo;accord avec leurs choix ? Justifiez votre réponse.</p>
</li>
<li>
<p>Étendez le résolveur pour rapporter une erreur si une variable locale n&rsquo;est jamais utilisée.</p>
</li>
<li>
<p>Notre résolveur calcule dans <em>quel</em> environnement la variable est trouvée, mais elle est toujours cherchée par nom dans cette map. Une représentation d&rsquo;environnement plus efficace stockerait les variables locales dans un tableau et les chercherait par index.</p>
<p>Étendez le résolveur pour associer un index unique pour chaque variable locale déclarée dans une portée. Quand vous résolvez un accès de variable, cherchez à la fois la portée dans laquelle la variable est et son index et stockez cela. Dans l&rsquo;interpréteur, utilisez cela pour accéder rapidement à une variable par son index au lieu d&rsquo;utiliser une map.</p>
</li>
</ol>
</div>

<footer>
<a href="classes.html" class="next">
  Next Chapter: &ldquo;Classes&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
