<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Types de valeurs &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Types de valeurs<small>18</small></a></h3>

<ul>
    <li><a href="#unions-étiquetées"><small>18.1</small> Unions Étiquetées</a></li>
    <li><a href="#valeurs-lox-et-valeurs-c"><small>18.2</small> Valeurs Lox et Valeurs C</a></li>
    <li><a href="#nombres-typés-dynamiquement"><small>18.3</small> Nombres Typés Dynamiquement</a></li>
    <li><a href="#deux-nouveaux-types"><small>18.4</small> Deux Nouveaux Types</a></li>
    <li><a href="#défis"><small>18.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="compilation-des-expressions.html" title="Compilation des expressions" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="chaînes-de-caractères.html" title="Chaînes de caractères" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="compilation-des-expressions.html" title="Compilation des expressions" class="prev">←</a>
<a href="chaînes-de-caractères.html" title="Chaînes de caractères" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Types de valeurs<small>18</small></a></h3>

<ul>
    <li><a href="#unions-étiquetées"><small>18.1</small> Unions Étiquetées</a></li>
    <li><a href="#valeurs-lox-et-valeurs-c"><small>18.2</small> Valeurs Lox et Valeurs C</a></li>
    <li><a href="#nombres-typés-dynamiquement"><small>18.3</small> Nombres Typés Dynamiquement</a></li>
    <li><a href="#deux-nouveaux-types"><small>18.4</small> Deux Nouveaux Types</a></li>
    <li><a href="#défis"><small>18.5</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="compilation-des-expressions.html" title="Compilation des expressions" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="chaînes-de-caractères.html" title="Chaînes de caractères" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">18</div>
  <h1>Types de valeurs</h1>

<blockquote>
<p>Quand tu es un Ours de Très Peu de Cerveau, et que tu Penses à des Choses, tu trouves parfois qu&rsquo;une Chose qui semblait très Chosifiée à l&rsquo;intérieur de toi est tout à fait différente quand elle sort à l&rsquo;air libre et que d&rsquo;autres personnes la regardent.</p>
<p><cite>A. A. Milne, <em>Winnie l&rsquo;Ourson</em></cite></p>
</blockquote>
<p>Les quelques chapitres passés étaient énormes, remplis de techniques complexes et de pages de code. Dans ce chapitre, il n&rsquo;y a qu&rsquo;un seul nouveau concept à apprendre et un éparpillement de code simple. Vous avez mérité un répit.</p>
<p>Lox est <span name="unityped">dynamiquement</span> typé. Une variable unique peut contenir un Booléen, un nombre, ou une chaîne de caractères à différents points dans le temps. Au moins, c&rsquo;est l&rsquo;idée. En ce moment, dans clox, toutes les valeurs sont des nombres. À la fin du chapitre, il supportera aussi les Booléens et <code>nil</code>. Bien que ceux-ci ne soient pas super intéressants, ils nous forcent à comprendre comment notre représentation de valeur peut gérer dynamiquement différents types.</p>
<aside name="unityped">
<p>Il y a une troisième catégorie à côté de typé statiquement et typé dynamiquement : <strong>unitypé</strong>. Dans ce paradigme, toutes les variables ont un type unique, généralement un entier de registre machine. Les langages unitypés ne sont pas communs aujourd&rsquo;hui, mais certains Forths et BCPL, le langage qui a inspiré C, fonctionnaient comme ceci.</p>
<p>À ce moment précis, clox est unitypé.</p>
</aside>
<h2><a href="#unions-étiquetées" id="unions-étiquetées"><small>18&#8202;.&#8202;1</small>Unions Étiquetées</a></h2>
<p>La chose sympa à propos de travailler en C est que nous pouvons construire nos structures de données depuis les bits bruts. La mauvaise chose est que nous <em>devons</em> faire cela. C ne vous donne pas grand-chose gratuitement à la compilation et encore moins à l&rsquo;exécution. Pour autant que C soit concerné, l&rsquo;univers est un tableau indifférencié d&rsquo;octets. C&rsquo;est à nous de décider combien de ces octets utiliser et ce qu&rsquo;ils signifient.</p>
<p>Afin de choisir une représentation de valeur, nous avons besoin de répondre à deux questions clés :</p>
<ol>
<li>
<p><strong>Comment représentons-nous le type d&rsquo;une valeur ?</strong> Si vous essayez de, disons, multiplier un nombre par <code>true</code>, nous avons besoin de détecter cette erreur à l&rsquo;exécution et de la rapporter. Afin de faire cela, nous avons besoin d&rsquo;être capables de dire quel est le type d&rsquo;une valeur.</p>
</li>
<li>
<p><strong>Comment stockons-nous la valeur elle-même ?</strong> Nous avons besoin non seulement d&rsquo;être capables de dire que trois est un nombre, mais qu&rsquo;il est différent du nombre quatre. Je sais, ça semble évident, pas vrai ? Mais nous opérons à un niveau où il est bon d&rsquo;épeler ces choses.</p>
</li>
</ol>
<p>Puisque nous ne faisons pas juste concevoir ce langage mais le construisons nous-mêmes, en répondant à ces deux questions nous devons aussi garder en tête la quête éternelle de l&rsquo;implémenteur : le faire <em>efficacement</em>.</p>
<p>Les hackers de langage au fil des années ont trouvé une variété de façons intelligentes d&rsquo;empaqueter les informations ci-dessus dans aussi peu de bits que possible. Pour l&rsquo;instant, nous commencerons avec la solution la plus simple et classique : une <strong>union étiquetée</strong>. Une valeur contient deux parties : une étiquette de type (ou &ldquo;tag&rdquo;), et une charge utile pour la valeur réelle. Pour stocker le type de la valeur, nous définissons un enum pour chaque sorte de valeur que la VM supporte.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;

</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert"><span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">VAL_BOOL</span>,
  <span class="a">VAL_NIL</span>,<span name="user-types"> </span>
  <span class="a">VAL_NUMBER</span>,
} <span class="t">ValueType</span>;

</pre><pre class="insert-after">typedef double Value;
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>

<aside name="user-types">
<p>Les cas ici couvrent chaque sorte de valeur qui a un <em>support intégré dans la VM</em>. Quand nous en arriverons à ajouter des classes au langage, chaque classe que l&rsquo;utilisateur définit n&rsquo;a pas besoin de sa propre entrée dans cet enum. Pour autant que la VM soit concernée, chaque instance d&rsquo;une classe est du même type : &ldquo;instance&rdquo;.</p>
<p>En d&rsquo;autres termes, c&rsquo;est la notion de &ldquo;type&rdquo; de la VM, pas celle de l&rsquo;utilisateur.</p>
</aside>
<p>Pour l&rsquo;instant, nous avons seulement une couple de cas, mais cela grandira alors que nous ajouterons les chaînes, fonctions, et classes à clox. En plus du type, nous avons aussi besoin de stocker les données pour la valeur<span class="em">&mdash;</span>le <code>double</code> pour un nombre, <code>true</code> ou <code>false</code> pour un Booléen. Nous pourrions définir une struct avec des champs pour chaque type possible.</p><img src="image/types-of-values/struct.png" alt="Une struct avec deux champs posés l'un à côté de l'autre en mémoire." />
<p>Mais c&rsquo;est un gaspillage de mémoire. Une valeur ne peut pas être simultanément à la fois un nombre et un Booléen. Donc à n&rsquo;importe quel point dans le temps, seulement un de ces champs sera utilisé. C vous laisse optimiser cela en définissant une <span name="sum">union</span>. Une union ressemble à une struct sauf que tous ses champs se chevauchent en mémoire.</p>
<aside name="sum">
<p>Si vous êtes familier avec un langage dans la famille ML, les structs et unions en C reflètent grossièrement la différence entre types produits et types sommes, entre tuples et types de données algébriques.</p>
</aside><img src="image/types-of-values/union.png" alt="Une union avec deux champs se chevauchant en mémoire." />
<p>La taille d&rsquo;une union est la taille de son plus grand champ. Puisque les champs réutilisent tous les mêmes bits, vous devez être très prudent quand vous travaillez avec eux. Si vous stockez des données en utilisant un champ et qu&rsquo;ensuite vous y accédez en utilisant un <span name="reinterpret">autre</span>, vous réinterpréterez ce que les bits sous-jacents signifient.</p>
<aside name="reinterpret">
<p>Utiliser une union pour interpréter des bits comme différents types est la quintessence du C. Cela ouvre un nombre d&rsquo;optimisations intelligentes et vous laisse couper et désosser chaque octet de mémoire de façons que les langages à mémoire sûre interdisent. Mais c&rsquo;est aussi sauvagement peu sûr et sciera joyeusement vos doigts si vous ne faites pas attention.</p>
</aside>
<p>Comme le nom &ldquo;union étiquetée&rdquo; l&rsquo;implique, notre nouvelle représentation de valeur combine ces deux parties en une struct unique.</p>
<div class="codehilite"><pre class="insert-before">} ValueType;

</pre><div class="source-file"><em>value.h</em><br>
add after enum <em>ValueType</em><br>
replace 1 line</div>
<pre class="insert"><span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">ValueType</span> <span class="i">type</span>;
  <span class="k">union</span> {
    <span class="t">bool</span> <span class="i">boolean</span>;
    <span class="t">double</span> <span class="i">number</span>;
  } <span class="i">as</span>;<span name="as"> </span>
} <span class="t">Value</span>;
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after enum <em>ValueType</em>, replace 1 line</div>

<p>Il y a un champ pour l&rsquo;étiquette de type, et ensuite un second champ contenant l&rsquo;union de toutes les valeurs sous-jacentes. Sur une machine 64-bit avec un compilateur C typique, la disposition ressemble à ceci :</p>
<aside name="as">
<p>Un hacker de langage intelligent m&rsquo;a donné l&rsquo;idée d&rsquo;utiliser &ldquo;as&rdquo; pour le nom du champ union parce que cela se lit joliment, presque comme un cast, quand vous tirez les diverses valeurs hors de là.</p>
</aside><img src="image/types-of-values/value.png" alt="La struct value complète, avec les champs type et as l'un à côté de l'autre en mémoire." />
<p>L&rsquo;étiquette de type de quatre octets vient en premier, ensuite l&rsquo;union. La plupart des architectures préfèrent que les valeurs soient alignées à leur taille. Puisque le champ union contient un double de huit octets, le compilateur ajoute quatre octets de <span name="pad">remplissage</span> (padding) après le champ type pour garder ce double sur la frontière de huit octets la plus proche. Cela signifie que nous dépensons effectivement huit octets sur l&rsquo;étiquette de type, qui a seulement besoin de représenter un nombre entre zéro et trois. Nous pourrions bourrer l&rsquo;enum dans une taille plus petite, mais tout ce que ça ferait serait d&rsquo;augmenter le remplissage.</p>
<aside name="pad">
<p>Nous pourrions déplacer le champ d&rsquo;étiquette <em>après</em> l&rsquo;union, mais cela n&rsquo;aide pas beaucoup non plus. Chaque fois que nous créons un tableau de Values<span class="em">&mdash;</span>ce qui est où la plupart de notre utilisation mémoire pour les Values sera<span class="em">&mdash;</span>le compilateur C insérera ce même remplissage <em>entre</em> chaque Value pour garder les doubles alignés.</p>
</aside>
<p>Donc nos Values font 16 octets, ce qui semble un peu grand. Nous améliorerons cela <a href="optimisation.html">plus tard</a>. En attendant, elles sont toujours assez petites pour stocker sur la pile C et passer par valeur. La sémantique de Lox permet cela parce que les seuls types que nous supportons jusqu&rsquo;ici sont <strong>immuables</strong>. Si nous passons une copie d&rsquo;une Value contenant le nombre trois à quelque fonction, nous n&rsquo;avons pas besoin de nous inquiéter que l&rsquo;appelant voie des modifications à la valeur. Vous ne pouvez pas &ldquo;modifier&rdquo; trois. C&rsquo;est trois pour toujours.</p>
<h2><a href="#valeurs-lox-et-valeurs-c" id="valeurs-lox-et-valeurs-c"><small>18&#8202;.&#8202;2</small>Valeurs Lox et Valeurs C</a></h2>
<p>C&rsquo;est notre nouvelle représentation de valeur, mais nous n&rsquo;avons pas fini. Pour l&rsquo;instant, le reste de clox suppose que Value est un alias pour <code>double</code>. Nous avons du code qui fait un cast C direct de l&rsquo;un à l&rsquo;autre. Ce code est tout cassé maintenant. Si triste.</p>
<p>Avec notre nouvelle représentation, une Value peut <em>contenir</em> un double, mais elle n&rsquo;est pas <em>équivalente</em> à lui. Il y a une étape de conversion obligatoire pour aller de l&rsquo;un à l&rsquo;autre. Nous devons passer à travers le code et insérer ces conversions pour faire marcher clox de nouveau.</p>
<p>Nous implémenterons ces conversions comme une poignée de macros, une pour chaque type et opération. D&rsquo;abord, pour promouvoir une valeur C native en une Value clox :</p>
<div class="codehilite"><pre class="insert-before">} Value;
</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>Value</em></div>
<pre class="insert">

<span class="a">#define BOOL_VAL(value)   ((Value){VAL_BOOL, {.boolean = value}})</span>
<span class="a">#define NIL_VAL           ((Value){VAL_NIL, {.number = 0}})</span>
<span class="a">#define NUMBER_VAL(value) ((Value){VAL_NUMBER, {.number = value}})</span>
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>Value</em></div>

<p>Chacune de celles-ci prend une valeur C du type approprié et produit une Value qui a la bonne étiquette de type et contient la valeur sous-jacente. Ceci hisse les valeurs typées statiquement vers l&rsquo;univers typé dynamiquement de clox. Afin de <em>faire</em> quoi que ce soit avec une Value, cependant, nous avons besoin de la dépaqueter et d&rsquo;obtenir la valeur C en retour.</p>
<div class="codehilite"><pre class="insert-before">} Value;
</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>Value</em></div>
<pre class="insert">

<span class="a">#define AS_BOOL(value)    ((value).as.boolean)</span>
<span class="a">#define AS_NUMBER(value)  ((value).as.number)</span>
</pre><pre class="insert-after">

#define BOOL_VAL(value)   ((Value){VAL_BOOL, {.boolean = value}})
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>Value</em></div>

<aside name="as-null">
<p>Il n&rsquo;y a pas de macro <code>AS_NIL</code> parce qu&rsquo;il n&rsquo;y a qu&rsquo;une seule valeur <code>nil</code>, donc une Value avec le type <code>VAL_NIL</code> ne porte aucune donnée supplémentaire.</p>
</aside>
<p><span name="as-null">Ces</span> macros vont dans la direction opposée. Étant donné une Value du bon type, elles la déballent et renvoient la valeur C brute correspondante. La partie &ldquo;bon type&rdquo; est importante ! Ces macros accèdent directement aux champs de l&rsquo;union. Si nous devions faire quelque chose comme :</p>
<div class="codehilite"><pre><span class="t">Value</span> <span class="i">value</span> = <span class="a">BOOL_VAL</span>(<span class="k">true</span>);
<span class="t">double</span> <span class="i">number</span> = <span class="a">AS_NUMBER</span>(<span class="i">value</span>);
</pre></div>
<p>Alors nous pourrions ouvrir un portail fumant vers le Royaume des Ombres. Ce n&rsquo;est pas sûr d&rsquo;utiliser n&rsquo;importe laquelle des macros <code>AS_</code> à moins que nous sachions que la Value contient le type approprié. À cette fin, nous définissons quelques dernières macros pour vérifier le type d&rsquo;une Value.</p>
<div class="codehilite"><pre class="insert-before">} Value;
</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>Value</em></div>
<pre class="insert">

<span class="a">#define IS_BOOL(value)    ((value).type == VAL_BOOL)</span>
<span class="a">#define IS_NIL(value)     ((value).type == VAL_NIL)</span>
<span class="a">#define IS_NUMBER(value)  ((value).type == VAL_NUMBER)</span>
</pre><pre class="insert-after">

#define AS_BOOL(value)    ((value).as.boolean)
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>Value</em></div>

<p><span name="universe">Ces</span> macros renvoient <code>true</code> si la Value a ce type. Chaque fois que nous appelons une des macros <code>AS_</code>, nous avons besoin de la garder derrière un appel à une de celles-ci d&rsquo;abord. Avec ces huit macros, nous pouvons maintenant navetter les données en toute sécurité entre le monde dynamique de Lox et celui statique de C.</p>
<aside name="universe"><img src="image/types-of-values/universe.png" alt="Le firmament C terrestre avec les cieux Lox au-dessus." />
<p>Les macros <code>_VAL</code> lèvent une valeur C dans les cieux. Les macros <code>AS_</code> la ramènent en bas.</p>
</aside>
<h2><a href="#nombres-typés-dynamiquement" id="nombres-typés-dynamiquement"><small>18&#8202;.&#8202;3</small>Nombres Typés Dynamiquement</a></h2>
<p>Nous avons notre représentation de valeur et les outils pour convertir vers et depuis elle. Tout ce qui reste pour faire tourner clox de nouveau est de piocher à travers le code et de fixer chaque endroit où les données bougent à travers cette frontière. C&rsquo;est une de ces sections du livre qui n&rsquo;est pas exactement époustouflante, mais j&rsquo;ai promis que je vous montrerais chaque ligne de code unique, donc nous y voici.</p>
<p>Les premières valeurs que nous créons sont les constantes générées quand nous compilons les littéraux nombre. Après avoir converti le lexème en un double C, nous l&rsquo;enveloppons simplement dans une Value avant de le stocker dans la table de constantes.</p>
<div class="codehilite"><pre class="insert-before">  double value = strtod(parser.previous.start, NULL);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>number</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">emitConstant</span>(<span class="a">NUMBER_VAL</span>(<span class="i">value</span>));
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>number</em>(), replace 1 line</div>

<p>Là-bas dans le runtime, nous avons une fonction pour imprimer les valeurs.</p>
<div class="codehilite"><pre class="insert-before">void printValue(Value value) {
</pre><div class="source-file"><em>value.c</em><br>
in <em>printValue</em>()<br>
replace 1 line</div>
<pre class="insert"> <span class="i">printf</span>(<span class="s">&quot;%g&quot;</span>, <span class="a">AS_NUMBER</span>(<span class="i">value</span>));
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, in <em>printValue</em>(), replace 1 line</div>

<p>Juste avant que nous envoyions la Value à <code>printf()</code>, nous la déballons et extrayons la valeur double. Nous revisiterons cette fonction sous peu pour ajouter les autres types, mais faisons marcher notre code existant d&rsquo;abord.</p>
<h3><a href="#négation-unaire-et-erreurs-dexécution" id="négation-unaire-et-erreurs-dexécution"><small>18&#8202;.&#8202;3&#8202;.&#8202;1</small>Négation unaire et erreurs d&rsquo;exécution</a></h3>
<p>La prochaine opération la plus simple est la négation unaire. Elle dépile une valeur, la nie, et pousse le résultat. Maintenant que nous avons d&rsquo;autres types de valeurs (ou que nous en aurons bientôt), nous ne pouvons plus supposer que l&rsquo;opérande est un nombre. L&rsquo;utilisateur pourrait tout aussi bien faire :</p>
<div class="codehilite"><pre><span class="k">print</span> -<span class="k">false</span>; <span class="c">// Euh...</span>
</pre></div>
<p>Nous avons besoin de gérer cela avec grâce, ce qui signifie qu&rsquo;il est temps pour les <em>erreurs d&rsquo;exécution</em>. Avant d&rsquo;effectuer une opération qui exige un certain type, nous avons besoin de nous assurer que la Value <em>est</em> de ce type.</p>
<p>Pour la négation unaire, la vérification ressemble à ceci :</p>
<div class="codehilite"><pre class="insert-before">      case OP_DIVIDE:   BINARY_OP(/); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_NEGATE</span>:
        <span class="k">if</span> (!<span class="a">IS_NUMBER</span>(<span class="i">peek</span>(<span class="n">0</span>))) {
          <span class="i">runtimeError</span>(<span class="s">&quot;Operand must be a number.&quot;</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="i">push</span>(<span class="a">NUMBER_VAL</span>(-<span class="a">AS_NUMBER</span>(<span class="i">pop</span>())));
        <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>D&rsquo;abord, nous vérifions pour voir si la Value au sommet de la pile est un nombre. Si ce n&rsquo;est pas le cas, nous rapportons l&rsquo;erreur d&rsquo;exécution et <span name="halt">arrêtons</span> l&rsquo;interpréteur. Sinon, nous continuons. Seulement après cette validation nous déballons l&rsquo;opérande, le nions, emballons le résultat et le poussons.</p>
<aside name="halt">
<p>L&rsquo;approche de Lox pour la gestion d&rsquo;erreur est plutôt<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span><em>austère</em>. Toutes les erreurs sont fatales et arrêtent immédiatement l&rsquo;interpréteur. Il n&rsquo;y a aucun moyen pour le code utilisateur de récupérer d&rsquo;une erreur. Si Lox était un vrai langage, ce serait une des premières choses que je remédierais.</p>
</aside>
<p>Pour accéder à la Value, nous utilisons une nouvelle petite fonction.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>pop</em>()</div>
<pre><span class="k">static</span> <span class="t">Value</span> <span class="i">peek</span>(<span class="t">int</span> <span class="i">distance</span>) {
  <span class="k">return</span> <span class="i">vm</span>.<span class="i">stackTop</span>[-<span class="n">1</span> - <span class="i">distance</span>];
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>pop</em>()</div>

<p>Elle renvoie une Value depuis la pile mais ne la <span name="peek">dépile</span> pas. L&rsquo;argument <code>distance</code> est à quelle distance du sommet de la pile regarder : zéro est le sommet, un est un emplacement en dessous, etc.</p>
<aside name="peek">
<p>Pourquoi ne pas juste dépiler l&rsquo;opérande et ensuite le valider ? Nous pourrions faire ça. Dans les chapitres ultérieurs, il sera important de laisser les opérandes sur la pile pour assurer que le ramasse-miettes peut les trouver si une collection est déclenchée au milieu de l&rsquo;opération. Je fais la même chose ici surtout par habitude.</p>
</aside>
<p>Nous rapportons l&rsquo;erreur d&rsquo;exécution en utilisant une nouvelle fonction dont nous tirerons beaucoup de profit sur le reste du livre.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>resetStack</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">runtimeError</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">format</span>, ...) {
  <span class="t">va_list</span> <span class="i">args</span>;
  <span class="i">va_start</span>(<span class="i">args</span>, <span class="i">format</span>);
  <span class="i">vfprintf</span>(<span class="i">stderr</span>, <span class="i">format</span>, <span class="i">args</span>);
  <span class="i">va_end</span>(<span class="i">args</span>);
  <span class="i">fputs</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">stderr</span>);

  <span class="t">size_t</span> <span class="i">instruction</span> = <span class="i">vm</span>.<span class="i">ip</span> - <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span> - <span class="n">1</span>;
  <span class="t">int</span> <span class="i">line</span> = <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">lines</span>[<span class="i">instruction</span>];
  <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;[line %d] in script</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">line</span>);
  <span class="i">resetStack</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>resetStack</em>()</div>

<p>Vous avez certainement <em>appelé</em> des fonctions variadiques<span class="em">&mdash;</span>celles qui prennent un nombre variable d&rsquo;arguments<span class="em">&mdash;</span>en C avant : <code>printf()</code> en est une. Mais vous pourriez ne pas avoir <em>défini</em> la vôtre. Ce livre n&rsquo;est pas un <span name="tutorial">tutoriel</span> C, donc je vais survoler ça ici, mais basiquement le trucs <code>...</code> et <code>va_list</code> nous laisse passer un nombre arbitraire d&rsquo;arguments à <code>runtimeError()</code>. Elle transfère ceux-là à <code>vfprintf()</code>, qui est la saveur de <code>printf()</code> qui prend une <code>va_list</code> explicite.</p>
<aside name="tutorial">
<p>Si vous cherchez un tutoriel C, j&rsquo;adore <em><a href="https://www.cs.princeton.edu/~bwk/cbook.html">Le Langage de Programmation C</a></em>, habituellement appelé &ldquo;K&amp;R&rdquo; en l&rsquo;honneur de ses auteurs. Il n&rsquo;est pas entièrement à jour, mais la qualité de l&rsquo;écriture fait plus que compenser cela.</p>
</aside>
<p>Les appelants peuvent passer une chaîne de format à <code>runtimeError()</code> suivie par un nombre d&rsquo;arguments, juste comme ils peuvent quand ils appellent <code>printf()</code> directement. <code>runtimeError()</code> formate et imprime ensuite ces arguments. Nous ne prendrons pas avantage de cela dans ce chapitre, mais les chapitres plus tardifs produiront des messages d&rsquo;erreur d&rsquo;exécution formatés qui contiennent d&rsquo;autres données.</p>
<p>Après avoir montré le message d&rsquo;erreur espérons-le utile, nous disons à l&rsquo;utilisateur quelle <span name="stack">ligne</span> de leur code était exécutée quand l&rsquo;erreur s&rsquo;est produite. Puisque nous avons laissé les tokens derrière dans le compilateur, nous cherchons la ligne dans l&rsquo;information de débogage compilée dans le morceau. Si notre compilateur a fait son travail correctement, cela correspond à la ligne de code source à partir de laquelle le bytecode a été compilé.</p>
<p>Nous regardons dans le tableau de lignes de débogage du morceau en utilisant l&rsquo;index d&rsquo;instruction bytecode courant <em>moins un</em>. C&rsquo;est parce que l&rsquo;interpréteur avance au-delà de chaque instruction avant de l&rsquo;exécuter. Donc, au point où nous appelons <code>runtimeError()</code>, l&rsquo;instruction échouée est la précédente.</p>
<aside name="stack">
<p>Juste montrer la ligne immédiate où l&rsquo;erreur s&rsquo;est produite ne fournit pas beaucoup de contexte. Mieux serait une trace de pile complète. Mais nous n&rsquo;avons même pas de fonction à appeler encore, donc il n&rsquo;y a pas de pile d&rsquo;appels à tracer.</p>
</aside>
<p>Afin d&rsquo;utiliser <code>va_list</code> et les macros pour travailler avec elle, nous avons besoin d&rsquo;apporter un en-tête standard.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add to top of file</div>
<pre class="insert"><span class="a">#include &lt;stdarg.h&gt;</span>
</pre><pre class="insert-after">#include &lt;stdio.h&gt;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add to top of file</div>

<p>Avec ceci, notre VM peut non seulement faire la bonne chose quand nous nions des nombres (comme elle le faisait avant que nous la cassions), mais elle gère aussi avec grâce les tentatives erronées de nier d&rsquo;autres types (que nous n&rsquo;avons pas encore, mais quand même).</p>
<h3><a href="#opérateurs-arithmétiques-binaires" id="opérateurs-arithmétiques-binaires"><small>18&#8202;.&#8202;3&#8202;.&#8202;2</small>Opérateurs arithmétiques binaires</a></h3>
<p>Nous avons notre machinerie d&rsquo;erreur d&rsquo;exécution en place maintenant, donc réparer les opérateurs binaires est plus facile même s&rsquo;ils sont plus complexes. Nous supportons quatre opérateurs binaires aujourd&rsquo;hui : <code>+</code>, <code>-</code>, <code>*</code>, et <code>/</code>. La seule différence entre eux est quel opérateur C sous-jacent ils utilisent. Pour minimiser le code redondant entre les quatre opérateurs, nous avons emballé la communalité dans une grosse macro préprocesseur qui prend le token opérateur comme paramètre.</p>
<p>Cette macro semblait un peu excessive il y a <a href="machine-virtuelle.html#opérateurs-binaires">quelques chapitres</a>, mais nous tirons profit d&rsquo;elle aujourd&rsquo;hui. Elle nous laisse ajouter la vérification de type et les conversions nécessaires en un seul endroit.</p>
<div class="codehilite"><pre class="insert-before">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 6 lines</div>
<pre class="insert"><span class="a">#define BINARY_OP(valueType, op) \</span>
<span class="a">    do { \</span>
<span class="a">      if (!IS_NUMBER(peek(0)) || !IS_NUMBER(peek(1))) { \</span>
<span class="a">        runtimeError(&quot;Operands must be numbers.&quot;); \</span>
<span class="a">        return INTERPRET_RUNTIME_ERROR; \</span>
<span class="a">      } \</span>
<span class="a">      double b = AS_NUMBER(pop()); \</span>
<span class="a">      double a = AS_NUMBER(pop()); \</span>
<span class="a">      push(valueType(a op b)); \</span>
<span class="a">    } while (false)</span>
</pre><pre class="insert-after">

  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 6 lines</div>

<p>Ouais, je réalise que c&rsquo;est un monstre de macro. Ce n&rsquo;est pas ce que je considérerais normalement comme une bonne pratique C, mais roulons avec. Les changements sont similaires à ce que nous avons fait pour la négation unaire. D&rsquo;abord, nous vérifions que les deux opérandes sont tous deux des nombres. Si l&rsquo;un ou l&rsquo;autre ne l&rsquo;est pas, nous rapportons une erreur d&rsquo;exécution et tirons le levier du siège éjectable.</p>
<p>Si les opérandes sont bons, nous les dépilons tous les deux et les déballons. Ensuite nous appliquons l&rsquo;opérateur donné, emballons le résultat, et le repoussons sur la pile. Notez que nous n&rsquo;emballons pas le résultat en utilisant directement <code>NUMBER_VAL()</code>. Au lieu de cela, l&rsquo;emballeur à utiliser est passé comme un <span name="macro">paramètre</span> macro. Pour nos opérateurs arithmétiques existants, le résultat est un nombre, donc nous passons la macro <code>NUMBER_VAL</code>.</p>
<aside name="macro">
<p>Saviez-vous que vous pouvez passer des macros comme paramètres à des macros ? Maintenant vous savez !</p>
</aside>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 4 lines</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_ADD</span>:      <span class="a">BINARY_OP</span>(<span class="a">NUMBER_VAL</span>, +); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_SUBTRACT</span>: <span class="a">BINARY_OP</span>(<span class="a">NUMBER_VAL</span>, -); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_MULTIPLY</span>: <span class="a">BINARY_OP</span>(<span class="a">NUMBER_VAL</span>, *); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_DIVIDE</span>:   <span class="a">BINARY_OP</span>(<span class="a">NUMBER_VAL</span>, /); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 4 lines</div>

<p>Bientôt, je vous montrerai pourquoi nous avons fait de la macro d&rsquo;emballage un argument.</p>
<h2><a href="#deux-nouveaux-types" id="deux-nouveaux-types"><small>18&#8202;.&#8202;4</small>Deux Nouveaux Types</a></h2>
<p>Tout notre code clox existant est de retour en état de marche. Finalement, il est temps d&rsquo;ajouter de nouveaux types. Nous avons une calculatrice numérique tournante qui fait maintenant un certain nombre de vérifications de type à l&rsquo;exécution paranoïaques et sans objet. Nous pouvons représenter d&rsquo;autres types en interne, mais il n&rsquo;y a aucun moyen pour un programme utilisateur de jamais créer une Value d&rsquo;un de ces types.</p>
<p>Pas jusqu&rsquo;à maintenant, c&rsquo;est-à-dire. Nous commencerons par ajouter le support du compilateur pour les trois nouveaux littéraux : <code>true</code>, <code>false</code>, et <code>nil</code>. Ils sont tous assez simples, donc nous ferons tous les trois dans un seul lot.</p>
<p>Avec les littéraux nombre, nous avons dû gérer le fait qu&rsquo;il y a des milliards de valeurs numériques possibles. Nous nous sommes occupés de cela en stockant la valeur du littéral dans la table de constantes du morceau et en émettant une instruction bytecode qui chargeait simplement cette constante. Nous pourrions faire la même chose pour les nouveaux types. Nous stockerions, disons, <code>true</code>, dans la table de constantes, et utiliserions un <code>OP_CONSTANT</code> pour le lire.</p>
<p>Mais étant donné qu&rsquo;il y a littéralement (hé) seulement trois valeurs possibles dont nous avons besoin de nous inquiéter avec ces nouveaux types, c&rsquo;est gratuit<span class="em">&mdash;</span>et <span name="small">lent !</span><span class="em">&mdash;</span>de gaspiller une instruction de deux octets et une entrée de table de constantes pour eux. Au lieu de cela, nous définirons trois instructions dédiées pour pousser chacun de ces littéraux sur la pile.</p>
<aside name="small" class="bottom">
<p>Je ne plaisante pas à propos des opérations dédiées pour certaines valeurs constantes qui sont plus rapides. Une VM à bytecode passe beaucoup de son temps d&rsquo;exécution à lire et décoder des instructions. Moins vous avez besoin d&rsquo;instructions, et plus elles sont simples pour un comportement donné, plus ça va vite. Les instructions courtes dédiées aux opérations communes sont une optimisation classique.</p>
<p>Par exemple, le jeu d&rsquo;instructions bytecode Java a des instructions dédiées pour charger 0.0, 1.0, 2.0, et les valeurs entières de -1 à 5. (Cela finit par être une optimisation vestigiale étant donné que la plupart des JVMs matures compilent maintenant à la volée (JIT) le bytecode en code machine avant l&rsquo;exécution de toute façon.)</p>
</aside>
<div class="codehilite"><pre class="insert-before">  OP_CONSTANT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_NIL</span>,
  <span class="a">OP_TRUE</span>,
  <span class="a">OP_FALSE</span>,
</pre><pre class="insert-after">  OP_ADD,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Notre scanner traite déjà <code>true</code>, <code>false</code>, et <code>nil</code> comme des mots-clés, donc nous pouvons sauter directement au parseur. Avec notre parseur Pratt basé sur table, nous avons juste besoin d&rsquo;insérer des fonctions de parseur dans les lignes associées avec ces types de token mot-clé. Nous utiliserons la même fonction dans les trois emplacements. Ici :</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_ELSE]          = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_FALSE</span>]         = {<span class="i">literal</span>,  <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_FOR]           = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Ici :</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_THIS]          = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_TRUE</span>]          = {<span class="i">literal</span>,  <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_VAR]           = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Et ici :</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_IF]            = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_NIL</span>]           = {<span class="i">literal</span>,  <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_OR]            = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Quand le parseur rencontre <code>false</code>, <code>nil</code>, ou <code>true</code>, en position préfixe, il appelle cette nouvelle fonction de parseur :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>binary</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">literal</span>() {
  <span class="k">switch</span> (<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">TOKEN_FALSE</span>: <span class="i">emitByte</span>(<span class="a">OP_FALSE</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_NIL</span>: <span class="i">emitByte</span>(<span class="a">OP_NIL</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_TRUE</span>: <span class="i">emitByte</span>(<span class="a">OP_TRUE</span>); <span class="k">break</span>;
    <span class="k">default</span>: <span class="k">return</span>; <span class="c">// Unreachable.</span>
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>binary</em>()</div>

<p>Puisque <code>parsePrecedence()</code> a déjà consommé le token mot-clé, tout ce que nous avons besoin de faire est de sortir l&rsquo;instruction appropriée. Nous <span name="switch">déterminons</span> celle-ci basé sur le type de token que nous avons parsé. Notre front end peut maintenant compiler les littéraux Booléens et nil en bytecode. En descendant le pipeline d&rsquo;exécution, nous atteignons l&rsquo;interpréteur.</p>
<aside name="switch">
<p>Nous aurions pu utiliser des fonctions de parseur séparées pour chaque littéral et nous épargner un switch mais cela me semblait inutilement verbeux. Je pense que c&rsquo;est surtout une question de goût.</p>
</aside>
<div class="codehilite"><pre class="insert-before">      case OP_CONSTANT: {
        Value constant = READ_CONSTANT();
        push(constant);
        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_NIL</span>: <span class="i">push</span>(<span class="a">NIL_VAL</span>); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_TRUE</span>: <span class="i">push</span>(<span class="a">BOOL_VAL</span>(<span class="k">true</span>)); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_FALSE</span>: <span class="i">push</span>(<span class="a">BOOL_VAL</span>(<span class="k">false</span>)); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_ADD:      BINARY_OP(NUMBER_VAL, +); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>C&rsquo;est assez auto-explicatif. Chaque instruction invoque la valeur appropriée et la pousse sur la pile. Nous ne devrions pas oublier notre désassembleur non plus.</p>
<div class="codehilite"><pre class="insert-before">    case OP_CONSTANT:
      return constantInstruction(&quot;OP_CONSTANT&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_NIL</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_NIL&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_TRUE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_TRUE&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_FALSE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_FALSE&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_ADD:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Avec ceci en place, nous pouvons lancer ce programme bouleversant :</p>
<div class="codehilite"><pre><span class="k">true</span>
</pre></div>
<p>Sauf que quand l&rsquo;interpréteur essaie d&rsquo;imprimer le résultat, il explose. Nous avons besoin d&rsquo;étendre <code>printValue()</code> pour gérer aussi les nouveaux types :</p>
<div class="codehilite"><pre class="insert-before">void printValue(Value value) {
</pre><div class="source-file"><em>value.c</em><br>
in <em>printValue</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">switch</span> (<span class="i">value</span>.<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">VAL_BOOL</span>:
      <span class="i">printf</span>(<span class="a">AS_BOOL</span>(<span class="i">value</span>) ? <span class="s">&quot;true&quot;</span> : <span class="s">&quot;false&quot;</span>);
      <span class="k">break</span>;
    <span class="k">case</span> <span class="a">VAL_NIL</span>: <span class="i">printf</span>(<span class="s">&quot;nil&quot;</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">VAL_NUMBER</span>: <span class="i">printf</span>(<span class="s">&quot;%g&quot;</span>, <span class="a">AS_NUMBER</span>(<span class="i">value</span>)); <span class="k">break</span>;
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, in <em>printValue</em>(), replace 1 line</div>

<p>Et voilà ! Maintenant nous avons de nouveaux types. Ils ne sont juste pas encore très utiles. À part les littéraux, vous ne pouvez pas vraiment <em>faire</em> quoi que ce soit avec eux. Il se passera un moment avant que <code>nil</code> entre en jeu, mais nous pouvons commencer à mettre les Booléens au travail dans les opérateurs logiques.</p>
<h3><a href="#non-logique-et-fausseté" id="non-logique-et-fausseté"><small>18&#8202;.&#8202;4&#8202;.&#8202;1</small>Non logique et fausseté</a></h3>
<p>L&rsquo;opérateur logique le plus simple est notre vieil ami exclamatif non unaire.</p>
<div class="codehilite"><pre><span class="k">print</span> !<span class="k">true</span>; <span class="c">// &quot;false&quot;</span>
</pre></div>
<p>Cette nouvelle opération obtient une nouvelle instruction.</p>
<div class="codehilite"><pre class="insert-before">  OP_DIVIDE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_NOT</span>,
</pre><pre class="insert-after">  OP_NEGATE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Nous pouvons réutiliser la fonction de parseur <code>unary()</code> que nous avons écrite pour la négation unaire pour compiler une expression non. Nous avons juste besoin de l&rsquo;insérer dans la table de parsing.</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_STAR]          = {NULL,     binary, PREC_FACTOR},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_BANG</span>]          = {<span class="i">unary</span>,    <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after">  [TOKEN_BANG_EQUAL]    = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Parce que je savais que nous allions faire ceci, la fonction <code>unary()</code> a déjà un switch sur le type de token pour déterminer quelle instruction bytecode sortir. Nous ajoutons simplement un autre cas.</p>
<div class="codehilite"><pre class="insert-before">  switch (operatorType) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>unary</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">TOKEN_BANG</span>: <span class="i">emitByte</span>(<span class="a">OP_NOT</span>); <span class="k">break</span>;
</pre><pre class="insert-after">    case TOKEN_MINUS: emitByte(OP_NEGATE); break;
    default: return; // Unreachable.
  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>unary</em>()</div>

<p>C&rsquo;est tout pour le front end. Allons vers la VM et conjurons cette instruction à la vie.</p>
<div class="codehilite"><pre class="insert-before">      case OP_DIVIDE:   BINARY_OP(NUMBER_VAL, /); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_NOT</span>:
        <span class="i">push</span>(<span class="a">BOOL_VAL</span>(<span class="i">isFalsey</span>(<span class="i">pop</span>())));
        <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Comme notre opérateur unaire précédent, il dépile l&rsquo;unique opérande, effectue l&rsquo;opération, et pousse le résultat. Et, comme nous l&rsquo;avons fait là, nous devons nous inquiéter du typage dynamique. Prendre le non logique de <code>true</code> est facile, mais il n&rsquo;y a rien empêchant un programmeur indiscipliné d&rsquo;écrire quelque chose comme ceci :</p>
<div class="codehilite"><pre><span class="k">print</span> !<span class="k">nil</span>;
</pre></div>
<p>Pour le moins unaire, nous avons fait une erreur de nier tout ce qui n&rsquo;est pas un <span name="negate">nombre</span>. Mais Lox, comme la plupart des langages de script, est plus permissif quand il s&rsquo;agit de <code>!</code> et d&rsquo;autres contextes où un Booléen est attendu. La règle pour comment les autres types sont gérés est appelée &ldquo;fausseté&rdquo; (falsiness), et nous l&rsquo;implémentons ici :</p>
<aside name="negate">
<p>Maintenant je ne peux m&rsquo;empêcher d&rsquo;essayer de comprendre ce que cela signifierait de nier d&rsquo;autres types de valeurs. <code>nil</code> est probablement sa propre négation, une sorte de pseudo-zéro bizarre. Nier une chaîne pourrait, euh, la renverser ?</p>
</aside>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>peek</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">isFalsey</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="k">return</span> <span class="a">IS_NIL</span>(<span class="i">value</span>) || (<span class="a">IS_BOOL</span>(<span class="i">value</span>) &amp;&amp; !<span class="a">AS_BOOL</span>(<span class="i">value</span>));
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>peek</em>()</div>

<p>Lox suit Ruby en ce que <code>nil</code> et <code>false</code> sont faux (&ldquo;falsey&rdquo;) et toute autre valeur se comporte comme <code>true</code>. Nous avons une nouvelle instruction que nous pouvons générer, donc nous avons aussi besoin d&rsquo;être capable de la <em>dé</em>générer dans le désassembleur.</p>
<div class="codehilite"><pre class="insert-before">    case OP_DIVIDE:
      return simpleInstruction(&quot;OP_DIVIDE&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_NOT</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_NOT&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<h3><a href="#égalité-et-opérateurs-de-comparaison" id="égalité-et-opérateurs-de-comparaison"><small>18&#8202;.&#8202;4&#8202;.&#8202;2</small>Égalité et opérateurs de comparaison</a></h3>
<p>Ce n&rsquo;était pas trop mal. Gardons le momentum et assommons l&rsquo;égalité et les opérateurs de comparaison aussi : <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, et <code>&gt;=</code>. Cela couvre tous les opérateurs qui renvoient des résultats Booléens excepté les opérateurs logiques <code>and</code> et <code>or</code>. Puisque ceux-là ont besoin de court-circuiter (basiquement faire un peu de contrôle de flux) nous ne sommes pas prêts pour eux encore.</p>
<p>Voici les nouvelles instructions pour ce opérateurs :</p>
<div class="codehilite"><pre class="insert-before">  OP_FALSE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_EQUAL</span>,
  <span class="a">OP_GREATER</span>,
  <span class="a">OP_LESS</span>,
</pre><pre class="insert-after">  OP_ADD,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Attendez, seulement trois ? Quoi à propos de <code>!=</code>, <code>&lt;=</code>, et <code>&gt;=</code> ? Nous pourrions créer des instructions pour ceux-là aussi. Honnêtement, la VM s&rsquo;exécuterait plus vite si nous le faisions, donc nous <em>devrions</em> faire ça si le but est la performance.</p>
<p>Mais mon but principal est de vous enseigner à propos des compilateurs bytecode. Je veux que vous commenciez à internaliser l&rsquo;idée que les instructions bytecode n&rsquo;ont pas besoin de suivre de près le code source de l&rsquo;utilisateur. La VM a une liberté totale d&rsquo;utiliser n&rsquo;importe quel jeu d&rsquo;instructions et séquences de code qu&rsquo;elle veut tant qu&rsquo;ils ont le bon comportement visible par l&rsquo;utilisateur.</p>
<p>L&rsquo;expression <code>a != b</code> a la même sémantique que <code>!(a == b)</code>, donc le compilateur est libre de compiler la première comme si c&rsquo;était la seconde. Au lieu d&rsquo;une instruction <code>OP_NOT_EQUAL</code> dédiée, il peut sortir un <code>OP_EQUAL</code> suivi par un <code>OP_NOT</code>. De même, <code>a &lt;= b</code> est la <span name="same">même</span> chose que <code>!(a &gt; b)</code> et <code>a &gt;= b</code> est <code>!(a &lt; b)</code>. Ainsi, nous avons seulement besoin de trois nouvelles instructions.</p>
<aside name="same" class="bottom">
<p><em>Est-ce que</em> <code>a &lt;= b</code> est toujours la même chose que <code>!(a &gt; b)</code> ? Selon <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a>, tous les opérateurs de comparaison renvoient faux quand un opérande est NaN. Cela signifie que <code>NaN &lt;= 1</code> est faux et <code>NaN &gt; 1</code> est aussi faux. Mais notre désucrage suppose que ce dernier est toujours la négation du premier.</p>
<p>Pour le livre, nous ne nous bloquerons pas là-dessus, mais ces genres de détails compteront dans vos implémentations de langage réelles.</p>
</aside>
<p>Là-bas dans le parseur, cependant, nous avons six nouveaux opérateurs à insérer dans la table de parsing. Nous utilisons la même fonction de parseur <code>binary()</code> d&rsquo;avant. Voici la ligne pour <code>!=</code> :</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_BANG]          = {unary,    NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_BANG_EQUAL</span>]    = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_EQUALITY</span>},
</pre><pre class="insert-after">  [TOKEN_EQUAL]         = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Les cinq opérateurs restants sont un peu plus bas dans la table.</p>
<div class="codehilite"><pre class="insert-before">  [TOKEN_EQUAL]         = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 5 lines</div>
<pre class="insert">  [<span class="a">TOKEN_EQUAL_EQUAL</span>]   = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_EQUALITY</span>},
  [<span class="a">TOKEN_GREATER</span>]       = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_COMPARISON</span>},
  [<span class="a">TOKEN_GREATER_EQUAL</span>] = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_COMPARISON</span>},
  [<span class="a">TOKEN_LESS</span>]          = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_COMPARISON</span>},
  [<span class="a">TOKEN_LESS_EQUAL</span>]    = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_COMPARISON</span>},
</pre><pre class="insert-after">  [TOKEN_IDENTIFIER]    = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 5 lines</div>

<p>À l&rsquo;intérieur de <code>binary()</code> nous avons déjà un switch pour générer le bon bytecode pour chaque type de token. Nous ajoutons des cas pour les six nouveaux opérateurs.</p>
<div class="codehilite"><pre class="insert-before">  switch (operatorType) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>binary</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">TOKEN_BANG_EQUAL</span>:    <span class="i">emitBytes</span>(<span class="a">OP_EQUAL</span>, <span class="a">OP_NOT</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_EQUAL_EQUAL</span>:   <span class="i">emitByte</span>(<span class="a">OP_EQUAL</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_GREATER</span>:       <span class="i">emitByte</span>(<span class="a">OP_GREATER</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_GREATER_EQUAL</span>: <span class="i">emitBytes</span>(<span class="a">OP_LESS</span>, <span class="a">OP_NOT</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_LESS</span>:          <span class="i">emitByte</span>(<span class="a">OP_LESS</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_LESS_EQUAL</span>:    <span class="i">emitBytes</span>(<span class="a">OP_GREATER</span>, <span class="a">OP_NOT</span>); <span class="k">break</span>;
</pre><pre class="insert-after">    case TOKEN_PLUS:          emitByte(OP_ADD); break;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>binary</em>()</div>

<p>Les opérateurs <code>==</code>, <code>&lt;</code>, et <code>&gt;</code> sortent une instruction unique. Les autres sortent une paire d&rsquo;instructions, une pour évaluer l&rsquo;opération inverse, et ensuite un <code>OP_NOT</code> pour inverser le résultat. Six opérateurs pour le prix de trois instructions !</p>
<p>Cela signifie que là-bas dans la VM, notre travail est plus simple. L&rsquo;égalité est l&rsquo;opération la plus générale.</p>
<div class="codehilite"><pre class="insert-before">      case OP_FALSE: push(BOOL_VAL(false)); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_EQUAL</span>: {
        <span class="t">Value</span> <span class="i">b</span> = <span class="i">pop</span>();
        <span class="t">Value</span> <span class="i">a</span> = <span class="i">pop</span>();
        <span class="i">push</span>(<span class="a">BOOL_VAL</span>(<span class="i">valuesEqual</span>(<span class="i">a</span>, <span class="i">b</span>)));
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_ADD:      BINARY_OP(NUMBER_VAL, +); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Vous pouvez évaluer <code>==</code> sur n&rsquo;importe quelle paire d&rsquo;objets, même des objets de types différents. Il y a assez de complexité pour que cela ait du sens de déporter cette logique vers une fonction séparée. Cette fonction renvoie toujours un <code>bool</code> C, donc nous pouvons emballer en toute sécurité le résultat dans une <code>BOOL_VAL</code>. La fonction se rapporte aux Values, donc elle vit là-bas dans le module &ldquo;value&rdquo;.</p>
<div class="codehilite"><pre class="insert-before">} ValueArray;

</pre><div class="source-file"><em>value.h</em><br>
add after struct <em>ValueArray</em></div>
<pre class="insert"><span class="t">bool</span> <span class="i">valuesEqual</span>(<span class="t">Value</span> <span class="i">a</span>, <span class="t">Value</span> <span class="i">b</span>);
</pre><pre class="insert-after">void initValueArray(ValueArray* array);
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>ValueArray</em></div>

<p>Et voici l&rsquo;implémentation :</p>
<div class="codehilite"><div class="source-file"><em>value.c</em><br>
add after <em>printValue</em>()</div>
<pre><span class="t">bool</span> <span class="i">valuesEqual</span>(<span class="t">Value</span> <span class="i">a</span>, <span class="t">Value</span> <span class="i">b</span>) {
  <span class="k">if</span> (<span class="i">a</span>.<span class="i">type</span> != <span class="i">b</span>.<span class="i">type</span>) <span class="k">return</span> <span class="k">false</span>;
  <span class="k">switch</span> (<span class="i">a</span>.<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">VAL_BOOL</span>:   <span class="k">return</span> <span class="a">AS_BOOL</span>(<span class="i">a</span>) == <span class="a">AS_BOOL</span>(<span class="i">b</span>);
    <span class="k">case</span> <span class="a">VAL_NIL</span>:    <span class="k">return</span> <span class="k">true</span>;
    <span class="k">case</span> <span class="a">VAL_NUMBER</span>: <span class="k">return</span> <span class="a">AS_NUMBER</span>(<span class="i">a</span>) == <span class="a">AS_NUMBER</span>(<span class="i">b</span>);
    <span class="k">default</span>:         <span class="k">return</span> <span class="k">false</span>; <span class="c">// Unreachable.</span>
  }
}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, add after <em>printValue</em>()</div>

<p>D&rsquo;abord, nous vérifions les types. Si les Values ont des types <span name="equal">différents</span>, elles ne sont définitivement pas égales. Sinon, nous déballons les deux Values et les comparons directement.</p>
<aside name="equal">
<p>Certains langages ont des &ldquo;conversions implicites&rdquo; où des valeurs de types différents peuvent être considérées égales si l&rsquo;une peut être convertie vers le type de l&rsquo;autre. Par exemple, le nombre 0 est équivalent à la chaîne &ldquo;0&rdquo; en JavaScript. Ce relâchement était une source de douleur assez grande pour que JS ajoute un opérateur d&rsquo;&ldquo;égalité stricte&rdquo; séparé, <code>===</code>.</p>
<p>PHP considère les chaînes &ldquo;1&rdquo; et &ldquo;01&rdquo; comme étant équivalentes parce que les deux peuvent être converties en nombres équivalents, bien que la raison ultime soit parce que PHP a été conçu par un dieu ancien lovecraftien pour détruire l&rsquo;esprit.</p>
<p>La plupart des langages typés dynamiquement qui ont des types nombre entier et à virgule flottante séparés considèrent les valeurs de types de nombre différents égales si les valeurs numériques sont les mêmes (donc, disons, 1.0 est égal à 1), bien que même cette commodité apparemment inoffensive puisse mordre les imprudents.</p>
</aside>
<p>Pour chaque type de valeur, nous avons un cas séparé qui gère la comparaison de la valeur elle-même. Étant donné combien les cas sont similaires, vous pourriez vous demander pourquoi nous ne pouvons pas simplement <code>memcmp()</code> les deux structs Value et en avoir fini avec ça. Le problème est qu&rsquo;à cause du remplissage et des champs d&rsquo;union de tailles différentes, une Value contient des bits inutilisés. C ne donne aucune garantie sur ce qui est dans ceux-ci, donc il est possible que deux Values égales diffèrent en fait dans la mémoire qui n&rsquo;est pas utilisée.</p><img src="image/types-of-values/memcmp.png" alt="Les représentations mémoire de deux valeurs égales qui diffèrent dans les octets inutilisés." />
<p>(Vous ne croiriez pas combien de douleur j&rsquo;ai traversée avant d&rsquo;apprendre ce fait.)</p>
<p>Quoi qu&rsquo;il en soit, alors que nous ajoutons plus de types à clox, cette fonction grandira de nouveaux cas. Pour l&rsquo;instant, ces trois sont suffisants. Les autres opérateurs de comparaison sont plus faciles puisqu&rsquo;ils fonctionnent seulement sur les nombres.</p>
<div class="codehilite"><pre class="insert-before">        push(BOOL_VAL(valuesEqual(a, b)));
        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GREATER</span>:  <span class="a">BINARY_OP</span>(<span class="a">BOOL_VAL</span>, &gt;); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_LESS</span>:     <span class="a">BINARY_OP</span>(<span class="a">BOOL_VAL</span>, &lt;); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_ADD:      BINARY_OP(NUMBER_VAL, +); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nous avons déjà étendu la macro <code>BINARY_OP</code> pour gérer les opérateurs qui renvoient des types non-numériques. Maintenant nous pouvons utiliser cela. Nous passons <code>BOOL_VAL</code> puisque le type de valeur résultat est Booléen. Sinon, ce n&rsquo;est pas différent de plus ou moins.</p>
<p>Comme toujours, la coda de l&rsquo;aria d&rsquo;aujourd&rsquo;hui est de désassembler les nouvelles instructions.</p>
<div class="codehilite"><pre class="insert-before">    case OP_FALSE:
      return simpleInstruction(&quot;OP_FALSE&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_EQUAL</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_EQUAL&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_GREATER</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_GREATER&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_LESS</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_LESS&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_ADD:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Avec cela, notre calculatrice numérique est devenue quelque chose de plus proche d&rsquo;un évaluateur d&rsquo;expressions général. Démarrez clox et tapez :</p>
<div class="codehilite"><pre>!(<span class="n">5</span> - <span class="n">4</span> &gt; <span class="n">3</span> * <span class="n">2</span> == !<span class="k">nil</span>)
</pre></div>
<p>OK, j&rsquo;admettrai que ce n&rsquo;est peut-être pas l&rsquo;expression la plus <em>utile</em>, mais nous faisons des progrès. Nous avons un type intégré manquant avec sa propre forme littérale : les chaînes. Celles-ci sont bien plus complexes parce que les chaînes peuvent varier en taille. Cette minuscule différence s&rsquo;avère avoir des implications si grandes que nous donnons aux chaînes <a href="chaînes-de-caractères.html">leur propre chapitre</a>.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>18&#8202;.&#8202;5</small>Défis</a></h2>
<ol>
<li>
<p>Nous pourrions réduire nos opérateurs binaires encore plus loin que nous l&rsquo;avons fait ici. Quelles autres instructions pouvez-vous éliminer, et comment le compilateur se débrouillerait-il avec leur absence ?</p>
</li>
<li>
<p>Inversement, nous pouvons améliorer la vitesse de notre VM bytecode en ajoutant plus d&rsquo;instructions spécifiques qui correspondent à des opérations de plus haut niveau. Quelles instructions définiriez-vous pour accélérer le genre de code utilisateur pour lequel nous avons ajouté le support dans ce chapitre ?</p>
</li>
</ol>
</div>

<footer>
<a href="chaînes-de-caractères.html" class="next">
  Next Chapter: &ldquo;Chaînes de caractères&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
