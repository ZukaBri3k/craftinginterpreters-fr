<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Introduction &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Introduction<small>1</small></a></h3>

<ul>
    <li><a href="#pourquoi-apprendre-tout-ça-"><small>1.1</small> Pourquoi apprendre tout ça ?</a></li>
    <li><a href="#comment-le-livre-est-organisé"><small>1.2</small> Comment le livre est organisé</a></li>
    <li><a href="#le-premier-interpréteur"><small>1.3</small> Le premier interpréteur</a></li>
    <li><a href="#le-deuxième-interpréteur"><small>1.4</small> Le deuxième interpréteur</a></li>
    <li><a href="#défis"><small>1.5</small> Défis</a></li>
    <li><a href="#note-de-conception--que-contient-un-nom-"><small>1.6</small> Note de conception : Que contient un nom ?</a></li>
</ul>


<div class="prev-next">
    <a href="welcome.html" title="Welcome" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="a-map-of-the-territory.html" title="A Map of the Territory" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="welcome.html" title="Welcome" class="prev">←</a>
<a href="a-map-of-the-territory.html" title="A Map of the Territory" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Introduction<small>1</small></a></h3>

<ul>
    <li><a href="#pourquoi-apprendre-tout-ça-"><small>1.1</small> Pourquoi apprendre tout ça ?</a></li>
    <li><a href="#comment-le-livre-est-organisé"><small>1.2</small> Comment le livre est organisé</a></li>
    <li><a href="#le-premier-interpréteur"><small>1.3</small> Le premier interpréteur</a></li>
    <li><a href="#le-deuxième-interpréteur"><small>1.4</small> Le deuxième interpréteur</a></li>
    <li><a href="#défis"><small>1.5</small> Défis</a></li>
    <li><a href="#note-de-conception--que-contient-un-nom-"><small>1.6</small> Note de conception : Que contient un nom ?</a></li>
</ul>


<div class="prev-next">
    <a href="welcome.html" title="Welcome" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="a-map-of-the-territory.html" title="A Map of the Territory" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">1</div>
  <h1>Introduction</h1>

<blockquote>
<p>Les contes de fées sont plus vrais que vrais : non pas parce qu’ils nous disent que les dragons existent,<br />
mais parce qu’ils nous disent que les dragons peuvent être vaincus.  </p>
<p><cite>G.K. Chesterton via Neil Gaiman, <em>Coraline</em></cite></p>
</blockquote>
<p>Je suis vraiment enthousiaste que nous entreprenions ce voyage ensemble. Ceci est un livre sur
l’implémentation d’interpréteurs pour des langages de programmation. C’est aussi un livre sur la manière de
concevoir un langage qui mérite d’être implémenté. C’est le livre que j’aurais aimé avoir quand j’ai commencé
à m’intéresser aux langages, et c’est le livre que j’écris dans ma <span
name="head">tête</span> depuis près d’une décennie.</p>
<aside name="head">
<p>À mes amis et à ma famille, désolé d’avoir été si distrait !</p>
</aside>
<p>Dans ces pages, nous allons parcourir pas à pas deux interpréteurs complets pour
un langage riche en fonctionnalités. Je pars du principe qu’il s’agit de votre première incursion dans les langages, donc
je couvrirai chaque concept et chaque ligne de code dont vous aurez besoin pour construire une implémentation de langage complète, utilisable et rapide.</p>
<p>Afin de caser deux implémentations complètes dans un seul livre sans qu’il ne se transforme
en cale-porte, ce texte est plus léger en théorie que d’autres. À mesure que nous construirons chaque
partie du système, je présenterai l’histoire et les concepts qui la sous-tendent. J’essaierai
de vous familiariser avec le jargon afin que, si jamais vous vous retrouvez à une
<span name="party">soirée cocktail</span> remplie de chercheurs en LP (langages de programmation),
vous soyez à l’aise.</p>
<aside name="party">
<p>Aussi étrange que cela puisse paraître, une situation dans laquelle je me suis retrouvé plusieurs fois.<br />
Vous ne croiriez pas combien certains d’entre eux peuvent boire.</p>
</aside>
<p>Mais nous allons surtout consacrer notre énergie cérébrale à faire en sorte que le langage démarre et fonctionne.<br />
Cela ne veut pas dire que la théorie n’est pas importante. Être capable de raisonner
de manière précise et <span name="formal">formelle</span> à propos de la syntaxe et de la sémantique est
une compétence vitale lorsqu’on travaille sur un langage. Mais, personnellement, j’apprends mieux en
faisant. J’ai du mal à me frayer un chemin à travers des paragraphes remplis de concepts abstraits et
à vraiment les assimiler. Mais si j’ai codé quelque chose, exécuté le code, et corrigé ses erreurs, alors je
<em>comprends</em>.</p>
<aside name="formal">
<p>Les systèmes de types statiques, en particulier, exigent un raisonnement formel rigoureux.<br />
Bidouiller un système de types donne la même impression que de démontrer un théorème en mathématiques.</p>
<p>Il s’avère que ce n’est pas une coïncidence. Dans la première moitié du siècle dernier, Haskell
Curry et William Alvin Howard ont montré qu’il s’agissait des deux faces d’une même pièce :
<a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">le isomorphisme de Curry-Howard</a>.</p>
</aside>
<p>C’est mon objectif pour vous. Je veux que vous repartiez avec une intuition solide de la manière dont un
langage réel vit et respire. J’espère que lorsque vous lirez d’autres livres plus théoriques par la suite,<br />
les concepts qu’ils présentent resteront fermement ancrés dans votre esprit, attachés à ce substrat tangible.</p>
<h2><a href="#pourquoi-apprendre-tout-ça-" id="pourquoi-apprendre-tout-ça-"><small>1&#8202;.&#8202;1</small>Pourquoi apprendre tout ça ?</a></h2>
<p>Chaque introduction de chaque livre sur les compilateurs semble avoir cette section.<br />
Je ne sais pas ce qu’il y a avec les langages de programmation qui provoque un tel doute existentiel.<br />
Je ne pense pas que les livres d’ornithologie s’inquiètent de justifier leur existence.<br />
Ils partent du principe que le lecteur aime les oiseaux et commencent à enseigner.  </p>
<p>Mais les langages de programmation sont un peu différents. J’imagine qu’il est vrai que les chances pour l’un de nous de créer un langage de programmation à usage général et largement populaire sont minces.<br />
Les concepteurs des langages les plus utilisés dans le monde pourraient tenir dans un minibus Volkswagen, même sans relever le toit escamotable.<br />
Si rejoindre ce groupe d’élite était la <em>seule</em> raison d’apprendre les langages, ce serait difficile à justifier. Heureusement, ce n’est pas le cas.  </p>
<h3><a href="#les-petits-langages-sont-partout" id="les-petits-langages-sont-partout"><small>1&#8202;.&#8202;1&#8202;.&#8202;1</small>Les petits langages sont partout</a></h3>
<p>Pour chaque langage généraliste réussi, il existe un millier de langages spécialisés qui réussissent.<br />
Nous avions l’habitude de les appeler « petits langages », mais l’inflation dans l’économie du jargon a conduit au nom de « langages spécifiques à un domaine ».<br />
Ce sont des pidgins conçus sur mesure pour une tâche précise. Pensez aux langages de script d’application, aux moteurs de templates, aux formats de balisage et aux fichiers de configuration.  </p>
<p><span name="little"></span><img src="image/introduction/little-languages.png" alt="Une sélection aléatoire de petits langages." /></p>
<aside name="little">
<p>Une sélection aléatoire de quelques petits langages que vous pourriez rencontrer.  </p>
</aside>
<p>Presque chaque grand projet logiciel a besoin d’une poignée de ceux-ci. Quand c’est possible, il vaut mieux réutiliser un existant plutôt que de créer le vôtre.<br />
Une fois que vous prenez en compte la documentation, les débogueurs, le support dans les éditeurs, la coloration syntaxique et tout le reste, le faire vous-même devient une tâche ardue.  </p>
<p>Mais il y a encore de bonnes chances que vous vous retrouviez à devoir bricoler un parseur ou un autre outil lorsqu’il n’existe pas de bibliothèque adaptée à vos besoins.<br />
Même lorsque vous réutilisez une implémentation existante, vous finirez inévitablement par devoir la déboguer, la maintenir et plonger dans ses entrailles.  </p>
<h3><a href="#les-langages-sont-un-excellent-exercice" id="les-langages-sont-un-excellent-exercice"><small>1&#8202;.&#8202;1&#8202;.&#8202;2</small>Les langages sont un excellent exercice</a></h3>
<p>Les coureurs de fond s’entraînent parfois avec des poids attachés aux chevilles ou en haute altitude, là où l’air est raréfié.<br />
Quand ils s’en débarrassent ensuite, la nouvelle légèreté de leurs membres et l’air riche en oxygène leur permet de courir plus loin et plus vite.  </p>
<p>Implémenter un langage est un véritable test de compétence en programmation. Le code est complexe et critique en termes de performance.<br />
Vous devez maîtriser la récursivité, les tableaux dynamiques, les arbres, les graphes et les tables de hachage.<br />
Vous utilisez probablement des tables de hachage dans votre programmation quotidienne, mais les comprenez-vous <em>vraiment</em> ?<br />
Eh bien, après avoir construit les nôtres à partir de zéro, je vous garantis que oui.  </p>
<p>Même si je souhaite vous montrer qu’un interpréteur n’est pas aussi intimidant que vous pourriez le croire, en implémenter un correctement reste un défi.<br />
Relevez-le, et vous repartirez en meilleur programmeur, plus avisé sur votre utilisation des structures de données et des algorithmes dans votre travail quotidien.  </p>
<h3><a href="#une-raison-de-plus" id="une-raison-de-plus"><small>1&#8202;.&#8202;1&#8202;.&#8202;3</small>Une raison de plus</a></h3>
<p>Cette dernière raison est difficile pour moi à admettre, car elle me tient tellement à cœur.<br />
Depuis que j’ai appris à programmer enfant, j’ai toujours ressenti quelque chose de magique à propos des langages.<br />
Quand j’ai tapoté mes premiers programmes BASIC une touche à la fois, je ne pouvais pas concevoir comment BASIC <em>lui-même</em> était fait.  </p>
<p>Plus tard, le mélange d’admiration et de terreur sur le visage de mes camarades d’université quand ils parlaient de leur cours de compilateurs suffisait à me convaincre que les bidouilleurs de langages étaient d’une autre espèce d’humains — une sorte de sorciers ayant accès à des arts secrets.  </p>
<p>C’est une <span name="image">image</span> séduisante, mais qui a un côté plus sombre. <em>Moi</em>, je ne me sentais pas comme un sorcier, alors j’en venais à penser qu’il me manquait une qualité innée nécessaire pour rejoindre cette cabale.<br />
Bien que j’aie été fasciné par les langages depuis que je griffonnais des mots-clés inventés dans mon cahier d’école, il m’a fallu des décennies pour trouver le courage d’essayer réellement de les apprendre.<br />
Cette qualité « magique », ce sentiment d’exclusivité, m’excluait <em>moi</em>.  </p>
<aside name="image">
<p>Et ceux qui la pratiquent n’hésitent pas à renforcer cette image.<br />
Deux des textes fondateurs sur les langages de programmation affichent un <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">dragon</a> et un <a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">sorcier</a> sur leur couverture.  </p>
</aside>
<p>Lorsque j’ai finalement commencé à assembler mes propres petits interpréteurs, j’ai vite appris que, bien sûr, il n’y a absolument aucune magie.<br />
Ce n’est que du code, et les personnes qui bidouillent les langages ne sont que des gens.  </p>
<p>Il <em>existe</em> quelques techniques que l’on ne rencontre pas souvent en dehors des langages, et certaines parties sont un peu difficiles.<br />
Mais pas plus difficiles que d’autres obstacles que vous avez déjà surmontés.<br />
J’espère que si vous vous êtes senti intimidé par les langages et que ce livre vous aide à surmonter cette peur, peut-être que je vous laisserai un tout petit peu plus courageux qu’auparavant.  </p>
<p>Et, qui sait, peut-être que vous <em>créerez</em> le prochain grand langage. Il faut bien que quelqu’un le fasse.  </p>
<h2><a href="#comment-le-livre-est-organisé" id="comment-le-livre-est-organisé"><small>1&#8202;.&#8202;2</small>Comment le livre est organisé</a></h2>
<p>Ce livre est divisé en trois parties. Vous lisez la première maintenant.<br />
C’est quelques chapitres pour vous orienter, vous apprendre un peu le jargon utilisé par les bidouilleurs de langages, et vous présenter Lox, le langage que nous allons implémenter.  </p>
<p>Chacune des deux autres parties construit un interpréteur Lox complet.<br />
Dans ces parties, chaque chapitre est structuré de la même manière. Le chapitre prend une seule fonctionnalité du langage, vous enseigne les concepts qui la sous-tendent, et vous guide dans son implémentation.  </p>
<p>Il m’a fallu pas mal d’essais et d’erreurs, mais j’ai réussi à découper les deux interpréteurs en sections de taille chapitre qui s’appuient sur les chapitres précédents sans nécessiter ceux qui suivent.<br />
Dès le tout premier chapitre, vous aurez un programme fonctionnel que vous pouvez exécuter et tester.<br />
Au fil des chapitres, il devient de plus en plus complet jusqu’à ce que vous ayez finalement un langage complet.  </p>
<p>En plus d’une prose anglaise abondante et captivante, les chapitres ont quelques autres facettes délicieuses :  </p>
<h3><a href="#le-code" id="le-code"><small>1&#8202;.&#8202;2&#8202;.&#8202;1</small>Le code</a></h3>
<p>Nous sommes là pour <em>fabriquer</em> des interpréteurs, donc ce livre contient du vrai code.<br />
Chaque ligne de code nécessaire est incluse, et chaque extrait vous indique où l’insérer dans votre implémentation toujours croissante.  </p>
<p>Beaucoup d’autres livres sur les langages et implémentations de langages utilisent des outils comme <a href="https://en.wikipedia.org/wiki/Lex_(software)">Lex</a> et <span name="yacc"><a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a></span>, les soi-disant <strong>compiler-compilers</strong>, qui génèrent automatiquement certains fichiers source d’une implémentation à partir d’une description de plus haut niveau.<br />
Il y a des avantages et des inconvénients à ces outils, et des opinions fortes — certains diraient même des convictions religieuses — des deux côtés.  </p>
<aside name="yacc">
<p>Yacc est un outil qui prend un fichier de grammaire et produit un fichier source pour un compilateur, c’est donc un peu comme un « compilateur » qui produit un compilateur, d’où le terme « compiler-compiler ».  </p>
<p>Yacc n’a pas été le premier du genre, ce qui explique son nom — <em>Yet Another</em> Compiler-Compiler.<br />
Un outil similaire ultérieur est [Bison][], nommé en jeu de mots sur la prononciation de Yacc comme « yak ».  </p><img src="image/introduction/yak.png" alt="Un yak." />
<p>Si vous trouvez toutes ces petites auto-références et jeux de mots charmants et amusants, vous vous sentirez à l’aise ici.<br />
Sinon, eh bien, peut-être que le sens de l’humour des nerds de langages est un goût acquis.  </p>
</aside>
<p>Nous nous abstiendrons de les utiliser ici. Je veux m’assurer qu’il n’y ait pas de recoins sombres où magie et confusion pourraient se cacher, donc nous écrirons tout à la main.<br />
Comme vous le verrez, ce n’est pas aussi terrible que cela en a l’air, et cela signifie que vous comprendrez vraiment chaque ligne de code et comment les deux interpréteurs fonctionnent.  </p>
<p>Un livre a des contraintes différentes du « monde réel », et donc le style de codage ici peut ne pas toujours refléter la meilleure manière d’écrire un logiciel de production maintenable.<br />
Si je semble un peu cavalier à propos, par exemple, d’ommettre <code>private</code> ou de déclarer une variable globale, comprenez que je le fais pour rendre le code plus lisible pour vous.<br />
Les pages ici ne sont pas aussi larges que votre IDE et chaque caractère compte.  </p>
<p>De plus, le code ne contient pas beaucoup de commentaires.<br />
C’est parce que chaque poignée de lignes est entourée de plusieurs paragraphes de prose honnête expliquant son fonctionnement.<br />
Lorsque vous écrivez un livre pour accompagner votre programme, vous pouvez également omettre les commentaires.<br />
Sinon, vous devriez probablement utiliser <code>//</code> un peu plus que moi.  </p>
<p>Bien que le livre contienne chaque ligne de code et explique ce que chacune signifie, il ne décrit pas la machinerie nécessaire pour compiler et exécuter l’interpréteur.<br />
Je suppose que vous pouvez créer un makefile ou un projet dans l’IDE de votre choix pour exécuter le code.<br />
Ce genre d’instructions devient vite obsolète, et je veux que ce livre vieillisse comme un XO, pas comme de l’alcool de contrebande maison.  </p>
<h3><a href="#extraits-de-code" id="extraits-de-code"><small>1&#8202;.&#8202;2&#8202;.&#8202;2</small>Extraits de code</a></h3>
<p>Puisque le livre contient littéralement chaque ligne de code nécessaire pour les implémentations, les extraits sont assez précis.<br />
De plus, parce que j’essaie de garder le programme dans un état exécutable même lorsque des fonctionnalités majeures manquent, nous ajoutons parfois du code temporaire qui sera remplacé dans les extraits suivants.  </p>
<p>Un extrait avec toutes les fioritures ressemble à ceci :</p>
<div class="codehilite"><pre class="insert-before">
      default:
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
dans <em>scanToken</em>()<br>
remplacer 1 ligne</div>
<pre class="insert">
        <span class="k">if</span> (<span class="i">isDigit</span>(<span class="i">c</span>)) {
          <span class="i">number</span>();
        } <span class="k">else</span> {
          <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">line</span>, <span class="s">&quot;Unexpected character.&quot;</span>);
        }
</pre><pre class="insert-after">
        break;
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, dans <em>scanToken</em>(), remplacer 1 ligne</div>
<p>Au centre, vous avez le nouveau code à ajouter.<br />
Il peut y avoir quelques lignes estompées au-dessus ou en dessous pour montrer où il s’insère dans le code existant.<br />
Il y a aussi un petit encadré indiquant dans quel fichier et où placer l’extrait.<br />
Si cet encadré dit « remplacer _ ligne », il y a du code existant entre les lignes estompées que vous devez supprimer et remplacer par le nouvel extrait.  </p>
<h3><a href="#asides" id="asides"><small>1&#8202;.&#8202;2&#8202;.&#8202;3</small>Asides</a></h3>
<p><span name="joke">Asides</span> contiennent des profils biographiques, un contexte historique, des références à des sujets connexes et des suggestions d’autres domaines à explorer.<br />
Il n’y a rien que vous ayez <em>besoin</em> de connaître dedans pour comprendre les parties suivantes du livre, donc vous pouvez les ignorer si vous voulez.<br />
Je ne vous jugerai pas, mais je pourrais être un peu triste.  </p>
<aside name="joke">
<p>Eh bien, certains asides en ont besoin, au moins.<br />
La plupart d’entre eux sont juste des blagues stupides et des dessins amateurs.  </p>
</aside>
<h3><a href="#défis" id="défis"><small>1&#8202;.&#8202;2&#8202;.&#8202;4</small>Défis</a></h3>
<p>Chaque chapitre se termine par quelques exercices. Contrairement aux séries de problèmes des manuels, qui tendent à revoir le matériel que vous avez déjà couvert, ceux-ci sont conçus pour vous aider à apprendre <em>plus</em> que ce qui est dans le chapitre.<br />
Ils vous obligent à sortir du chemin guidé et à explorer par vous-même.<br />
Ils vous feront rechercher d’autres langages, comprendre comment implémenter des fonctionnalités, ou simplement vous sortir de votre zone de confort.  </p>
<p><span name="warning">Vainquez</span> les défis et vous repartirez avec une compréhension plus large et peut-être quelques bosses et égratignures.<br />
Ou sautez-les si vous voulez rester dans le confort du bus touristique. C’est votre livre.  </p>
<aside name="warning">
<p>Un mot d’avertissement : les défis vous demandent souvent d’apporter des modifications à l’interpréteur que vous êtes en train de construire.<br />
Vous voudrez implémenter ces modifications dans une copie de votre code.<br />
Les chapitres suivants supposent que votre interpréteur est dans un état impeccable (« non défié » ?).  </p>
</aside>
<h3><a href="#notes-de-conception" id="notes-de-conception"><small>1&#8202;.&#8202;2&#8202;.&#8202;5</small>Notes de conception</a></h3>
<p>La plupart des livres sur les « langages de programmation » sont strictement des livres sur l’<em>implémentation</em> de langages de programmation.<br />
Ils discutent rarement de la manière dont on pourrait <em>concevoir</em> le langage qu’on implémente.<br />
L’implémentation est amusante parce qu’elle est si <span name="benchmark">précisément définie</span>.<br />
Nous, programmeurs, semblons avoir une affinité pour les choses en noir et blanc, des uns et des zéros.  </p>
<aside name="benchmark">
<p>Je connais beaucoup de bidouilleurs de langages dont la carrière est basée sur cela.<br />
Vous glissez une spécification de langage sous leur porte, attendez quelques mois, et le code et les résultats de benchmarks en sortent.  </p>
</aside>
<p>Personnellement, je pense que le monde n’a besoin que d’un nombre limité d’implémentations de <span name="fortran">FORTRAN 77</span>.<br />
À un moment donné, vous vous retrouvez à concevoir un <em>nouveau</em> langage.<br />
Une fois que vous commencez à jouer à <em>ce</em> jeu, alors le côté plus humain et subtil de l’équation devient primordial.<br />
Des choses comme quelles fonctionnalités sont faciles à apprendre, comment équilibrer innovation et familiarité, quelle syntaxe est plus lisible et pour qui.  </p>
<aside name="fortran">
<p>Espérons que votre nouveau langage ne codifie pas des hypothèses sur la largeur d’une carte perforée dans sa grammaire.  </p>
</aside>
<p>Tout cela affecte profondément le succès de votre nouveau langage.<br />
Je veux que votre langage réussisse, donc dans certains chapitres, je termine par une « note de conception », un petit essai sur un aspect humain des langages de programmation.<br />
Je ne suis pas un expert là-dessus — je ne sais pas si quelqu’un l’est vraiment — donc prenez ces notes avec une grande pincée de sel.<br />
Cela devrait en faire une nourriture plus savoureuse pour la réflexion, ce qui est mon objectif principal.</p>
<h2><a href="#le-premier-interpréteur" id="le-premier-interpréteur"><small>1&#8202;.&#8202;3</small>Le premier interpréteur</a></h2>
<p>Nous allons écrire notre premier interpréteur, jlox, en <span name="lang">Java</span>.<br />
L’accent est mis sur les <em>concepts</em>. Nous écrirons le code le plus simple et le plus clair possible pour implémenter correctement la sémantique du langage.<br />
Cela nous permettra de nous familiariser avec les techniques de base et aussi d’affiner notre compréhension de la manière exacte dont le langage est censé se comporter.  </p>
<aside name="lang">
<p>Le livre utilise Java et C, mais des lecteurs ont porté le code vers <a href="https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations">beaucoup d’autres langages</a>.<br />
Si les langages que j’ai choisis ne vous conviennent pas, jetez un œil à ceux-là.  </p>
</aside>
<p>Java est un excellent langage pour cela.<br />
Il est suffisamment haut niveau pour que nous ne soyons pas submergés par des détails d’implémentation fastidieux, mais reste assez explicite.<br />
Contrairement aux langages de script, il y a tendance à avoir moins de machinerie complexe cachée sous le capot, et vous disposez de types statiques pour voir quelles structures de données vous utilisez.  </p>
<p>J’ai également choisi Java spécifiquement parce que c’est un langage orienté objet.<br />
Ce paradigme a envahi le monde de la programmation dans les années 90 et est maintenant la façon dominante de penser pour des millions de programmeurs.<br />
Il y a de bonnes chances que vous soyez déjà habitué à organiser le code en classes et méthodes, donc nous resterons dans cette zone de confort.  </p>
<p>Bien que les universitaires spécialisés en langages regardent parfois de haut les langages orientés objet, la réalité est qu’ils sont largement utilisés même pour le travail sur les langages.<br />
GCC et LLVM sont écrits en C++, tout comme la plupart des machines virtuelles JavaScript.<br />
Les langages orientés objet sont omniprésents, et les outils et compilateurs <em>pour</em> un langage sont souvent écrits <em>dans</em> le <span name="host">même langage</span>.  </p>
<aside name="host">
<p>Un compilateur lit des fichiers dans un langage, les traduit et produit des fichiers dans un autre langage.<br />
Vous pouvez implémenter un compilateur dans n’importe quel langage, y compris le même langage qu’il compile, un processus appelé <strong>self-hosting</strong>.  </p>
<p>Vous ne pouvez pas encore compiler votre compilateur avec lui-même, mais si vous disposez d’un autre compilateur pour votre langage écrit dans un autre langage, vous utilisez <em>celui-là</em> pour compiler votre compilateur une fois.<br />
Maintenant, vous pouvez utiliser la version compilée de votre propre compilateur pour compiler les versions futures de celui-ci, et vous pouvez jeter l’original compilé avec l’autre compilateur.<br />
Cela s’appelle <strong>bootstrapping</strong>, d’après l’image de se tirer soi-même par ses propres bottes.  </p><img src="image/introduction/bootstrap.png" alt="Fait : c’est le principal moyen de transport du cowboy américain." />
</aside>
<p>Enfin, Java est extrêmement populaire.<br />
Cela signifie qu’il y a de bonnes chances que vous le connaissiez déjà, donc moins de choses à apprendre pour commencer le livre.<br />
Si vous n’êtes pas très familier avec Java, ne paniquez pas.<br />
J’essaie de m’en tenir à un sous-ensemble assez minimal.<br />
J’utilise l’opérateur diamant de Java 7 pour rendre certaines choses un peu plus concises, mais c’est à peu près tout pour les fonctionnalités « avancées ».<br />
Si vous connaissez un autre langage orienté objet, comme C# ou C++, vous pouvez vous en sortir.  </p>
<p>À la fin de la partie II, nous aurons une implémentation simple et lisible.<br />
Elle n’est pas très rapide, mais elle est correcte.<br />
Cependant, nous ne pouvons y parvenir qu’en nous appuyant sur les propres facilités d’exécution de la machine virtuelle Java.<br />
Nous voulons apprendre comment Java <em>lui-même</em> implémente ces choses.</p>
<h2><a href="#le-deuxième-interpréteur" id="le-deuxième-interpréteur"><small>1&#8202;.&#8202;4</small>Le deuxième interpréteur</a></h2>
<p>Dans la partie suivante, nous recommençons depuis le début, mais cette fois en C.<br />
C est le langage parfait pour comprendre comment une implémentation <em>fonctionne vraiment</em>, jusqu’aux octets en mémoire et au code circulant dans le CPU.  </p>
<p>Une grande raison pour laquelle nous utilisons C est que je peux vous montrer des choses dans lesquelles C excelle particulièrement, mais cela signifie que vous devez être assez à l’aise avec ce langage.<br />
Vous n’avez pas besoin d’être la réincarnation de Dennis Ritchie, mais vous ne devez pas non plus être effrayé par les pointeurs.  </p>
<p>Si vous n’en êtes pas encore là, prenez un livre d’introduction au C et travaillez-le, puis revenez ici une fois terminé.<br />
En retour, vous sortirez de ce livre un programmeur C encore plus solide.<br />
C’est utile étant donné le nombre d’implémentations de langages écrites en C : Lua, CPython et MRI de Ruby, pour n’en citer que quelques-unes.  </p>
<p>Dans notre interpréteur C, <span name="clox">clox</span>, nous sommes obligés d’implémenter nous-mêmes toutes les fonctionnalités que Java nous fournissait gratuitement.<br />
Nous écrirons notre propre tableau dynamique et table de hachage.<br />
Nous déciderons comment les objets sont représentés en mémoire, et construirons un ramasse-miettes pour les récupérer.  </p>
<aside name="clox">
<p>Je prononce le nom « sea-locks », mais vous pouvez dire « clocks » ou même « cloch », où vous prononcez le « x » à la manière des Grecs si cela vous rend heureux.  </p>
</aside>
<p>Notre implémentation Java se concentrait sur la correction.<br />
Maintenant que nous avons cela, nous allons également viser la <em>performance</em>.<br />
Notre interpréteur C contiendra un <span name="compiler">compilateur</span> qui traduit Lox en une représentation bytecode efficace (ne vous inquiétez pas, je vais expliquer ce que cela signifie bientôt), qu’il exécute ensuite.<br />
C’est la même technique utilisée par les implémentations de Lua, Python, Ruby, PHP et beaucoup d’autres langages à succès.  </p>
<aside name="compiler">
<p>Vous pensiez que ce n’était qu’un livre sur les interpréteurs ? C’est aussi un livre sur les compilateurs.<br />
Deux pour le prix d’un !  </p>
</aside>
<p>Nous essaierons même le benchmarking et l’optimisation.<br />
À la fin, nous aurons un interpréteur robuste, précis et rapide pour notre langage, capable de rivaliser avec d’autres implémentations professionnelles.<br />
Pas mal pour un seul livre et quelques milliers de lignes de code.  </p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>1&#8202;.&#8202;5</small>Défis</a></h2>
<ol>
<li>
<p>Il y a au moins six langages spécifiques à un domaine utilisés dans le <a href="https://github.com/munificent/craftinginterpreters">petit système que j’ai bricolé</a> pour écrire et publier ce livre. Quels sont-ils ?  </p>
</li>
<li>
<p>Écrivez et exécutez un programme « Hello, world! » en Java.<br />
Configurez les makefiles ou projets IDE nécessaires pour le faire fonctionner.<br />
Si vous avez un débogueur, familiarisez-vous avec et suivez votre programme à l’exécution.  </p>
</li>
<li>
<p>Faites la même chose pour C.<br />
Pour vous entraîner aux pointeurs, définissez une [liste doublement chaînée][] de chaînes allouées sur le tas.<br />
Écrivez des fonctions pour insérer, trouver et supprimer des éléments. Testez-les.  </p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--que-contient-un-nom-" id="note-de-conception--que-contient-un-nom-"><small>1&#8202;.&#8202;6</small>Note de conception : Que contient un nom ?</a></h2>
<p>Un des défis les plus difficiles dans l’écriture de ce livre a été de trouver un nom pour le langage qu’il implémente.<br />
J’ai parcouru <em>des pages</em> de candidats avant d’en trouver un qui fonctionnait.<br />
Comme vous le découvrirez le premier jour où vous commencerez à construire votre propre langage, trouver un nom est diaboliquement difficile.<br />
Un bon nom satisfait quelques critères :  </p>
<ol>
<li>
<p><strong>Il n’est pas déjà utilisé.</strong> Vous pouvez rencontrer toutes sortes de problèmes, légaux et sociaux, si vous empiétez involontairement sur le nom de quelqu’un d’autre.  </p>
</li>
<li>
<p><strong>Il est facile à prononcer.</strong> Si tout se passe bien, des hordes de personnes diront et écriront le nom de votre langage. Tout nom de plus de quelques syllabes ou quelques lettres les agacera à outrance.  </p>
</li>
<li>
<p><strong>Il est suffisamment distinct pour être recherché.</strong> Les gens Googleront le nom de votre langage pour en savoir plus, donc vous voulez un mot assez rare pour que la plupart des résultats pointent vers votre documentation.<br />
Bien que, avec le volume actuel des moteurs de recherche IA, ce n’est plus vraiment un problème.<br />
Cependant, vous ne rendrez pas service à vos utilisateurs si vous nommez votre langage « for ».  </p>
</li>
<li>
<p><strong>Il n’a pas de connotations négatives dans plusieurs cultures.</strong> C’est difficile d’être vigilant à ce sujet, mais cela vaut la peine d’y penser.<br />
Le concepteur de Nimrod a fini par renommer son langage « Nim » parce que trop de gens se souvenaient que Bugs Bunny utilisait « Nimrod » comme une insulte. (Bugs l’utilisait ironiquement.)  </p>
</li>
</ol>
<p>Si votre nom potentiel passe ce parcours du combattant, conservez-le.<br />
Ne vous bloquez pas à essayer de trouver un nom qui capture la quintessence de votre langage.<br />
Si les noms des autres langages à succès dans le monde nous enseignent quelque chose, c’est que le nom n’a pas beaucoup d’importance.<br />
Tout ce dont vous avez besoin est un token raisonnablement unique.</p>

<footer>
<a href="a-map-of-the-territory.html" class="next">
  Next Chapter: &ldquo;A Map of the Territory&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
