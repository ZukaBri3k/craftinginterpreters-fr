<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Machine virtuelle &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Machine virtuelle<small>15</small></a></h3>

<ul>
    <li><a href="#une-machine-dexécution-dinstructions"><small>15.1</small> Une Machine d&#x27;Exécution d&#x27;Instructions</a></li>
    <li><a href="#un-manipulateur-de-pile-de-valeurs"><small>15.2</small> Un Manipulateur de Pile de Valeurs</a></li>
    <li><a href="#une-calculatrice-arithmétique"><small>15.3</small> Une Calculatrice Arithmétique</a></li>
    <li><a href="#défis"><small>15.4</small> Défis</a></li>
    <li><a href="#note-de-conception--bytecode-&amp;agrave;-registres"><small>15.5</small> Note de Conception : Bytecode &amp;agrave; Registres</a></li>
</ul>


<div class="prev-next">
    <a href="morceaux-de-bytecode.html" title="Morceaux de bytecode" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="analyse-à-la-demande.html" title="Analyse à la demande" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="morceaux-de-bytecode.html" title="Morceaux de bytecode" class="prev">←</a>
<a href="analyse-à-la-demande.html" title="Analyse à la demande" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Machine virtuelle<small>15</small></a></h3>

<ul>
    <li><a href="#une-machine-dexécution-dinstructions"><small>15.1</small> Une Machine d&#x27;Exécution d&#x27;Instructions</a></li>
    <li><a href="#un-manipulateur-de-pile-de-valeurs"><small>15.2</small> Un Manipulateur de Pile de Valeurs</a></li>
    <li><a href="#une-calculatrice-arithmétique"><small>15.3</small> Une Calculatrice Arithmétique</a></li>
    <li><a href="#défis"><small>15.4</small> Défis</a></li>
    <li><a href="#note-de-conception--bytecode-&amp;agrave;-registres"><small>15.5</small> Note de Conception : Bytecode &amp;agrave; Registres</a></li>
</ul>


<div class="prev-next">
    <a href="morceaux-de-bytecode.html" title="Morceaux de bytecode" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="analyse-à-la-demande.html" title="Analyse à la demande" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">15</div>
  <h1>Machine virtuelle</h1>

<blockquote>
<p>Les magiciens protègent leurs secrets non pas parce que les secrets sont grands et
importants, mais parce qu&rsquo;ils sont si petits et triviaux. Les merveilleux effets
créés sur scène sont souvent le résultat d&rsquo;un secret si absurde que le magicien
serait embarrassé d&rsquo;admettre que c&rsquo;était comme ça que c&rsquo;était fait.</p>
<p><cite>Christopher Priest, <em>Le Prestige</em></cite></p>
</blockquote>
<p>Nous avons passé beaucoup de temps à parler de comment représenter un programme comme une séquence d&rsquo;instructions bytecode, mais cela ressemble à apprendre la biologie en n&rsquo;utilisant que des animaux empaillés et morts. Nous savons ce que sont les instructions en théorie, mais nous ne les avons jamais vues en action, donc il est difficile de vraiment comprendre ce qu&rsquo;elles <em>font</em>. Il serait difficile d&rsquo;écrire un compilateur qui sort du bytecode quand nous n&rsquo;avons pas une bonne compréhension de comment ce bytecode se comporte.</p>
<p>Donc, avant d&rsquo;aller construire le front end de notre nouvel interpréteur, nous commencerons avec le back end<span class="em">&mdash;</span>la machine virtuelle qui exécute les instructions. Elle insuffle la vie dans le bytecode. Regarder les instructions se pavaner nous donne une image plus claire de comment un compilateur pourrait traduire le code source de l&rsquo;utilisateur en une série d&rsquo;entre elles.</p>
<h2><a href="#une-machine-dexécution-dinstructions" id="une-machine-dexécution-dinstructions"><small>15&#8202;.&#8202;1</small>Une Machine d&rsquo;Exécution d&rsquo;Instructions</a></h2>
<p>La machine virtuelle est une partie de l&rsquo;architecture interne de notre interpréteur. Vous lui donnez un morceau de code<span class="em">&mdash;</span>littéralement un Chunk<span class="em">&mdash;</span>et elle l&rsquo;exécute. Le code et les structures de données pour la VM résident dans un nouveau module.</p>
<div class="codehilite"><div class="source-file"><em>vm.h</em><br>
create new file</div>
<pre><span class="a">#ifndef clox_vm_h</span>
<span class="a">#define clox_vm_h</span>

<span class="a">#include &quot;chunk.h&quot;</span>

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Chunk</span>* <span class="i">chunk</span>;
} <span class="a">VM</span>;

<span class="t">void</span> <span class="i">initVM</span>();
<span class="t">void</span> <span class="i">freeVM</span>();

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, create new file</div>

<p>Comme d&rsquo;habitude, nous commençons simple. La VM acquerra graduellement tout un tas d&rsquo;état dont elle a besoin de garder la trace, donc nous définissons une struct maintenant pour bourrer tout ça dedans. Actuellement, tout ce que nous stockons est le morceau qu&rsquo;elle exécute.</p>
<p>Comme nous le faisons avec la plupart des structures de données que nous créons, nous définissons aussi des fonctions pour créer et détruire une VM. Voici l&rsquo;implémentation :</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
create new file</div>
<pre><span class="a">#include &quot;common.h&quot;</span>
<span class="a">#include &quot;vm.h&quot;</span>

<span class="a">VM</span> <span class="i">vm</span>;<span name="one"> </span>

<span class="t">void</span> <span class="i">initVM</span>() {
}

<span class="t">void</span> <span class="i">freeVM</span>() {
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, create new file</div>

<p>OK, appeler ces fonctions des &ldquo;implémentations&rdquo; est un peu fort. Nous n&rsquo;avons aucun état intéressant à initialiser ou libérer encore, donc les fonctions sont vides. Croyez-moi, nous y arriverons.</p>
<p>La ligne légèrement plus intéressante ici est cette déclaration de <code>vm</code>. Ce module va éventuellement avoir une flopée de fonctions et ce serait une corvée de passer un pointeur vers la VM à toutes celles-ci. Au lieu de ça, nous déclarons un unique objet VM global. Nous en avons besoin d&rsquo;un seul de toute façon, et cela garde le code dans le livre un peu plus léger sur la page.</p>
<aside name="one">
<p>Le choix d&rsquo;avoir une instance statique de VM est une concession pour le livre, mais pas nécessairement un choix d&rsquo;ingénierie sain pour une implémentation de langage réelle. Si vous construisez une VM qui est conçue pour être embarquée dans d&rsquo;autres applications hôtes, cela donne à l&rsquo;hôte plus de flexibilité si vous prenez explicitement un pointeur de VM et le passez autour.</p>
<p>De cette façon, l&rsquo;app hôte peut contrôler quand et où la mémoire pour la VM est allouée, lancer de multiples VMs en parallèle, etc.</p>
<p>Ce que je fais ici est une variable globale, et <a href="http://gameprogrammingpatterns.com/singleton.html">tout ce que vous avez entendu de mauvais à propos des variables globales</a> est encore vrai quand on programme en grand. Mais quand on garde les choses petites pour un livre<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
</aside>
<p>Avant que nous commencions à pomper du code amusant dans notre VM, allons-y et câblons-la au point d&rsquo;entrée principal de l&rsquo;interpréteur.</p>
<div class="codehilite"><pre class="insert-before">int main(int argc, const char* argv[]) {
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="i">initVM</span>();

</pre><pre class="insert-after">  Chunk chunk;
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>Nous démarrons la VM quand l&rsquo;interpréteur commence. Puis quand nous sommes sur le point de sortir, nous l&rsquo;arrêtons.</p>
<div class="codehilite"><pre class="insert-before">  disassembleChunk(&amp;chunk, &quot;test chunk&quot;);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="i">freeVM</span>();
</pre><pre class="insert-after">  freeChunk(&amp;chunk);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>Une dernière obligation cérémonielle :</p>
<div class="codehilite"><pre class="insert-before">#include &quot;debug.h&quot;
</pre><div class="source-file"><em>main.c</em></div>
<pre class="insert"><span class="a">#include &quot;vm.h&quot;</span>
</pre><pre class="insert-after">

int main(int argc, const char* argv[]) {
</pre></div>
<div class="source-file-narrow"><em>main.c</em></div>

<p>Maintenant quand vous lancez clox, il démarre la VM avant qu&rsquo;il ne crée ce morceau écrit à la main du <a href="morceaux-de-bytecode.html#désassembler-des-morceaux">dernier chapitre</a>. La VM est prête et attend, donc apprenons-lui à faire quelque chose.</p>
<h3><a href="#exécuter-des-instructions" id="exécuter-des-instructions"><small>15&#8202;.&#8202;1&#8202;.&#8202;1</small>Exécuter des instructions</a></h3>
<p>La VM saute en action quand nous lui commandons d&rsquo;interpréter un morceau de bytecode.</p>
<div class="codehilite"><pre class="insert-before">  disassembleChunk(&amp;chunk, &quot;test chunk&quot;);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="i">interpret</span>(&amp;<span class="i">chunk</span>);
</pre><pre class="insert-after">  freeVM();
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>Cette fonction est le point d&rsquo;entrée principal dans la VM. Elle est déclarée comme ceci :</p>
<div class="codehilite"><pre class="insert-before">void freeVM();
</pre><div class="source-file"><em>vm.h</em><br>
add after <em>freeVM</em>()</div>
<pre class="insert"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after <em>freeVM</em>()</div>

<p>La VM exécute le morceau et ensuite répond avec une valeur de cet enum :</p>
<div class="codehilite"><pre class="insert-before">} VM;

</pre><div class="source-file"><em>vm.h</em><br>
add after struct <em>VM</em></div>
<pre class="insert"><span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">INTERPRET_OK</span>,
  <span class="a">INTERPRET_COMPILE_ERROR</span>,
  <span class="a">INTERPRET_RUNTIME_ERROR</span>
} <span class="t">InterpretResult</span>;

</pre><pre class="insert-after">void initVM();
void freeVM();
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after struct <em>VM</em></div>

<p>Nous n&rsquo;utilisons pas le résultat encore, mais quand nous aurons un compilateur qui rapporte des erreurs statiques et une VM qui détecte des erreurs d&rsquo;exécution, l&rsquo;interpréteur utilisera cela pour savoir comment définir le code de sortie du processus.</p>
<p>Nous avançons pouce par pouce vers une implémentation réelle.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>freeVM</em>()</div>
<pre><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>) {
  <span class="i">vm</span>.<span class="i">chunk</span> = <span class="i">chunk</span>;
  <span class="i">vm</span>.<span class="i">ip</span> = <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>;
  <span class="k">return</span> <span class="i">run</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>

<p>D&rsquo;abord, nous stockons le morceau étant exécuté dans la VM. Ensuite nous appelons <code>run()</code>, une fonction utilitaire interne qui exécute réellement les instructions bytecode. Entre ces deux parties est une ligne intrigante. C&rsquo;est quoi cette affaire de <code>ip</code> ?</p>
<p>Alors que la VM travaille son chemin à travers le bytecode, elle garde la trace de où elle est<span class="em">&mdash;</span>l&rsquo;emplacement de l&rsquo;instruction actuellement exécutée. Nous n&rsquo;utilisons pas une variable <span name="local">locale</span> à l&rsquo;intérieur de <code>run()</code> pour cela parce qu&rsquo;éventuellement d&rsquo;autres fonctions auront besoin d&rsquo;y accéder. Au lieu de cela, nous la stockons comme un champ dans VM.</p>
<aside name="local">
<p>Si nous essayions de presser chaque once de vitesse hors de notre interpréteur bytecode, nous stockerions <code>ip</code> dans une variable locale. Il est modifié si souvent durant l&rsquo;exécution que nous voulons que le compilateur C le garde dans un registre.</p>
</aside>
<div class="codehilite"><pre class="insert-before">typedef struct {
  Chunk* chunk;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">uint8_t</span>* <span class="i">ip</span>;
</pre><pre class="insert-after">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>Son type est un pointeur d&rsquo;octet. Nous utilisons un pointeur C réel pointant droit au milieu du tableau de bytecode au lieu de quelque chose comme un index entier parce qu&rsquo;il est plus rapide de déréférencer un pointeur que de chercher un élément dans un tableau par index.</p>
<p>Le nom &ldquo;IP&rdquo; est traditionnel, et<span class="em">&mdash;</span>contrairement à beaucoup de noms traditionnels en informatique<span class="em">&mdash;</span>a réellement du sens : c&rsquo;est un <strong><a href="https://en.wikipedia.org/wiki/Program_counter">pointeur d&rsquo;instruction</a></strong>. Presque chaque jeu d&rsquo;instructions dans le <span name="ip">monde</span>, réel ou virtuel, a un registre ou une variable comme celle-ci.</p>
<aside name="ip">
<p>x86, x64, et le CLR l&rsquo;appellent &ldquo;IP&rdquo;. 68k, PowerPC, ARM, p-code, et la JVM l&rsquo;appellent &ldquo;PC&rdquo;, pour <strong>compteur de programme</strong> (Program Counter).</p>
</aside>
<p>Nous initialisons <code>ip</code> en le pointant au premier octet de code dans le morceau. Nous n&rsquo;avons pas exécuté cette instruction encore, donc <code>ip</code> pointe vers l&rsquo;instruction <em>sur le point d&rsquo;être exécutée</em>. Ce sera vrai durant tout le temps où la VM tourne : l&rsquo;IP pointe toujours vers la prochaine instruction, pas celle actuellement gérée.</p>
<p>Le vrai fun se passe dans <code>run()</code>.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>freeVM</em>()</div>
<pre><span class="k">static</span> <span class="t">InterpretResult</span> <span class="i">run</span>() {
<span class="a">#define READ_BYTE() (*vm.ip++)</span>

  <span class="k">for</span> (;;) {
    <span class="t">uint8_t</span> <span class="i">instruction</span>;
    <span class="k">switch</span> (<span class="i">instruction</span> = <span class="a">READ_BYTE</span>()) {
      <span class="k">case</span> <span class="a">OP_RETURN</span>: {
        <span class="k">return</span> <span class="a">INTERPRET_OK</span>;
      }
    }
  }

<span class="a">#undef READ_BYTE</span>
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>

<p>C&rsquo;est l&rsquo;unique fonction la plus <span name="important">importante</span> dans tout clox, de loin. Quand l&rsquo;interpréteur exécute un programme utilisateur, il passera quelque chose comme 90% de son temps à l&rsquo;intérieur de <code>run()</code>. C&rsquo;est le cœur battant de la VM.</p>
<aside name="important">
<p>Ou, au moins, il le <em>sera</em> dans quelques chapitres quand il aura assez de contenu pour être utile. Pour l&rsquo;instant, ce n&rsquo;est pas exactement une merveille de sorcellerie logicielle.</p>
</aside>
<p>Malgré cette intro dramatique, c&rsquo;est conceptuellement assez simple. Nous avons une boucle extérieure qui va et va. Chaque tour à travers cette boucle, nous lisons et exécutons une seule instruction bytecode.</p>
<p>Pour traiter une instruction, nous trouvons d&rsquo;abord à quel genre d&rsquo;instruction nous avons affaire. La macro <code>READ_BYTE</code> lit l&rsquo;octet actuellement pointé par <code>ip</code> et ensuite <span name="next">avance</span> le pointeur d&rsquo;instruction. Le premier octet de n&rsquo;importe quelle instruction est l&rsquo;opcode. Étant donné un opcode numérique, nous devons aller au bon code C qui implémente la sémantique de cette instruction. Ce processus est appelé <strong>décoder</strong> ou <strong>dispatcher</strong> l&rsquo;instruction.</p>
<aside name="next">
<p>Notez que <code>ip</code> avance dès que nous lisons l&rsquo;opcode, avant que nous ayons réellement commencé à exécuter l&rsquo;instruction. Donc, encore une fois, <code>ip</code> pointe vers le <em>prochain</em> octet de code à être utilisé.</p>
</aside>
<p>Nous faisons ce processus pour chaque instruction unique, chaque fois qu&rsquo;une est exécutée, donc c&rsquo;est la partie la plus critique en performance de la machine virtuelle entière. Le folklore des langages de programmation est rempli de techniques <span name="dispatch">intelligentes</span> pour faire le dispatch de bytecode efficacement, remontant tout le chemin jusqu&rsquo;aux premiers jours des ordinateurs.</p>
<aside name="dispatch">
<p>Si vous voulez apprendre certaines de ces techniques, cherchez &ldquo;direct threaded code&rdquo;, &ldquo;jump table&rdquo;, et &ldquo;computed goto&rdquo;.</p>
</aside>
<p>Hélas, les solutions les plus rapides exigent soit des extensions non-standard à C, ou du code assembleur écrit à la main. Pour clox, nous garderons ça simple. Juste comme notre désassembleur, nous avons une unique instruction <code>switch</code> géante avec un case pour chaque opcode. Le corps de chaque case implémente le comportement de cet opcode.</p>
<p>Jusqu&rsquo;à présent, nous gérons seulement une unique instruction, <code>OP_RETURN</code>, et la seule chose qu&rsquo;elle fait est de sortir de la boucle entièrement. Éventuellement, cette instruction sera utilisée pour revenir de la fonction Lox courante, mais nous n&rsquo;avons pas de fonctions encore, donc nous la réutiliserons temporairement pour finir l&rsquo;exécution.</p>
<p>Allons-y et supportons notre seule autre instruction.</p>
<div class="codehilite"><pre class="insert-before">    switch (instruction = READ_BYTE()) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_CONSTANT</span>: {
        <span class="t">Value</span> <span class="i">constant</span> = <span class="a">READ_CONSTANT</span>();
        <span class="i">printValue</span>(<span class="i">constant</span>);
        <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nous n&rsquo;avons pas assez de machinerie en place pour faire quoi que ce soit d&rsquo;utile avec une constante. Pour l&rsquo;instant, nous l&rsquo;imprimerons juste pour que nous les hackers d&rsquo;interpréteur puissions voir ce qui se passe à l&rsquo;intérieur de notre VM. Cet appel à <code>printf()</code> nécessite un include.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add to top of file</div>
<pre class="insert"><span class="a">#include &lt;stdio.h&gt;</span>

</pre><pre class="insert-after">#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add to top of file</div>

<p>Nous avons aussi une nouvelle macro à définir.</p>
<div class="codehilite"><pre class="insert-before">#define READ_BYTE() (*vm.ip++)
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])</span>
</pre><pre class="insert-after">

  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p><code>READ_CONSTANT()</code> lit le prochain octet depuis le bytecode, traite le nombre résultant comme un index, et cherche la Value correspondante dans la table de constantes du morceau. Dans les chapitres ultérieurs, nous ajouterons quelques instructions de plus avec des opérandes qui font référence à des constantes, donc nous mettons en place cette macro utilitaire maintenant.</p>
<p>Comme la macro <code>READ_BYTE</code> précédente, <code>READ_CONSTANT</code> est seulement utilisée à l&rsquo;intérieur de <code>run()</code>. Pour rendre cette portée plus explicite, les définitions de macro elles-mêmes sont confinées à cette fonction. Nous les <span name="macro">définissons</span> au début et<span class="em">&mdash;</span>parce que nous nous soucions<span class="em">&mdash;</span>les indéfinissons à la fin.</p>
<div class="codehilite"><pre class="insert-before">#undef READ_BYTE
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#undef READ_CONSTANT</span>
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<aside name="macro">
<p>Indéfinir ces macros explicitement peut sembler inutilement méticuleux, mais C tend à punir les utilisateurs négligents, et le préprocesseur C doublement.</p>
</aside>
<h3><a href="#traçage-dexécution" id="traçage-dexécution"><small>15&#8202;.&#8202;1&#8202;.&#8202;2</small>Traçage d&rsquo;exécution</a></h3>
<p>Si vous lancez clox maintenant, il exécute le morceau que nous avons écrit à la main dans le dernier chapitre et crache <code>1.2</code> sur votre terminal. Nous pouvons voir que ça marche, mais c&rsquo;est seulement parce que notre implémentation de <code>OP_CONSTANT</code> a du code temporaire pour loguer la valeur. Une fois que cette instruction fera ce qu&rsquo;elle est supposée faire et tuyautera cette constante vers d&rsquo;autres opérations qui veulent la consommer, la VM deviendra une boîte noire. Cela rend nos vies en tant qu&rsquo;implémenteurs de VM plus dures.</p>
<p>Pour nous aider, maintenant est un bon moment pour ajouter un peu de journalisation de diagnostic à la VM comme nous l&rsquo;avons fait avec les morceaux eux-mêmes. En fait, nous réutiliserons même le même code. Nous ne voulons pas cette journalisation activée tout le temps<span class="em">&mdash;</span>c&rsquo;est juste pour nous les hackers de VM, pas les utilisateurs Lox<span class="em">&mdash;</span>donc d&rsquo;abord nous créons un drapeau derrière lequel la cacher.</p>
<div class="codehilite"><pre class="insert-before">#include &lt;stdint.h&gt;
</pre><div class="source-file"><em>common.h</em></div>
<pre class="insert">

<span class="a">#define DEBUG_TRACE_EXECUTION</span>
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>

<p>Quand ce drapeau est défini, la VM désassemble et imprime chaque instruction juste avant de l&rsquo;exécuter. Là où notre précédent désassembleur parcourait un morceau entier une fois, statiquement, ceci désassemble les instructions dynamiquement, à la volée.</p>
<div class="codehilite"><pre class="insert-before">  for (;;) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#ifdef DEBUG_TRACE_EXECUTION</span>
    <span class="i">disassembleInstruction</span>(<span class="i">vm</span>.<span class="i">chunk</span>,
                           (<span class="t">int</span>)(<span class="i">vm</span>.<span class="i">ip</span> - <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>));
<span class="a">#endif</span>

</pre><pre class="insert-after">    uint8_t instruction;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Puisque <code>disassembleInstruction()</code> prend un <em>offset</em> d&rsquo;octet entier et que nous stockons la référence d&rsquo;instruction courante comme un pointeur direct, nous faisons d&rsquo;abord un peu de maths de pointeur pour convertir <code>ip</code> en retour vers un offset relatif depuis le début du bytecode. Ensuite nous désassemblons l&rsquo;instruction qui commence à cet octet.</p>
<p>Comme toujours, nous avons besoin d&rsquo;amener la déclaration de la fonction avant que nous puissions l&rsquo;appeler.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert"><span class="a">#include &quot;debug.h&quot;</span>
</pre><pre class="insert-after">#include &quot;vm.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>

<p>Je sais que ce code n&rsquo;est pas super impressionnant pour l&rsquo;instant<span class="em">&mdash;</span>c&rsquo;est littéralement une instruction switch enveloppée dans une boucle <code>for</code> mais, croyez-le ou non, c&rsquo;est l&rsquo;un des deux composants majeurs de notre VM. Avec cela, nous pouvons exécuter impérativement des instructions. Sa simplicité est une vertu<span class="em">&mdash;</span>moins elle fait de travail, plus vite elle peut le faire. Contrastez cela avec toute la complexité et la surcharge que nous avions dans jlox avec le pattern Visiteur pour parcourir l&rsquo;AST.</p>
<h2><a href="#un-manipulateur-de-pile-de-valeurs" id="un-manipulateur-de-pile-de-valeurs"><small>15&#8202;.&#8202;2</small>Un Manipulateur de Pile de Valeurs</a></h2>
<p>En plus des effets de bord impératifs, Lox a des expressions qui produisent, modifient, et consomment des valeurs. Ainsi, notre bytecode compilé a besoin d&rsquo;un moyen de navetter des valeurs entre les différentes instructions qui en ont besoin. Par exemple :</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="n">3</span> - <span class="n">2</span>;
</pre></div>
<p>Nous avons évidemment besoin d&rsquo;instructions pour les constantes 3 et 2, l&rsquo;instruction <code>print</code>, et la soustraction. Mais comment l&rsquo;instruction de soustraction sait-elle que 3 est le <span name="word">diminuende</span> et 2 est le diminuteur ? Comment l&rsquo;instruction print sait-elle d&rsquo;imprimer le résultat de cela ?</p>
<aside name="word">
<p>Oui, j&rsquo;ai dû chercher &ldquo;diminuteur&rdquo; et &ldquo;diminuende&rdquo; dans un dictionnaire. Mais ne sont-ils pas des mots délicieux ? &ldquo;Diminuende&rdquo; sonne comme une sorte de danse élisabéthaine et &ldquo;diminuteur&rdquo; pourrait être une sorte de monument Paléolithique souterrain.</p>
</aside>
<p>Pour mettre un point plus fin là-dessus, regardez cette chose juste ici :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">echo</span>(<span class="i">n</span>) {
  <span class="k">print</span> <span class="i">n</span>;
  <span class="k">return</span> <span class="i">n</span>;
}

<span class="k">print</span> <span class="i">echo</span>(<span class="i">echo</span>(<span class="n">1</span>) + <span class="i">echo</span>(<span class="n">2</span>)) + <span class="i">echo</span>(<span class="i">echo</span>(<span class="n">4</span>) + <span class="i">echo</span>(<span class="n">5</span>));
</pre></div>
<p>J&rsquo;ai enveloppé chaque sous-expression dans un appel à <code>echo()</code> qui imprime et renvoie son argument. Cet effet de bord signifie que nous pouvons voir l&rsquo;ordre exact des opérations.</p>
<p>Ne vous inquiétez pas de la VM pour une minute. Pensez juste à la sémantique de Lox lui-même. Les opérandes pour un opérateur arithmétique ont évidemment besoin d&rsquo;être évalués avant que nous puissions effectuer l&rsquo;opération elle-même. (C&rsquo;est assez dur d&rsquo;ajouter <code>a + b</code> si vous ne savez pas ce que sont <code>a</code> et <code>b</code>.) Aussi, quand nous avons implémenté les expressions dans jlox, nous avons <span name="undefined">décidé</span> que l&rsquo;opérande gauche doit être évalué avant le droit.</p>
<aside name="undefined">
<p>Nous aurions pu laisser l&rsquo;ordre d&rsquo;évaluation non spécifié et laisser chaque implémentation décider. Cela laisse la porte ouverte pour des compilateurs optimisants pour réordonner les expressions arithmétiques pour l&rsquo;efficacité, même dans des cas où les opérandes ont des effets de bord visibles. C et Scheme laissent l&rsquo;ordre d&rsquo;évaluation non spécifié. Java spécifie l&rsquo;évaluation de gauche à droite comme nous le faisons pour Lox.</p>
<p>Je pense que clouer des trucs comme ça est généralement mieux pour les utilisateurs. Quand les expressions ne sont pas évaluées dans l&rsquo;ordre que les utilisateurs intuitent<span class="em">&mdash;</span>possiblement dans des ordres différents à travers différentes implémentations !<span class="em">&mdash;</span>cela peut être un paysage infernal de douleur brûlante de comprendre ce qui se passe.</p>
</aside>
<p>Voici l&rsquo;arbre syntaxique pour le statement <code>print</code> :</p><img src="image/a-virtual-machine/ast.png" alt="L'AST pour le statement exemple, avec des nombres marquant l'ordre dans lequel les nœuds sont évalués." />
<p>Étant donné l&rsquo;évaluation de gauche à droite, et la façon dont les expressions sont imbriquées, toute implémentation Lox correcte <em>doit</em> imprimer ces nombres dans cet ordre :</p>
<div class="codehilite"><pre>1  // de echo(1)
2  // de echo(2)
3  // de echo(1 + 2)
4  // de echo(4)
5  // de echo(5)
9  // de echo(4 + 5)
12 // de print 3 + 9
</pre></div>
<p>Notre vieil interpréteur jlox accomplit cela en traversant récursivement l&rsquo;AST. Il fait un parcours post-ordre. D&rsquo;abord il récurse en bas de la branche de l&rsquo;opérande gauche, puis l&rsquo;opérande droit, puis finalement il évalue le nœud lui-même.</p>
<p>Après avoir évalué l&rsquo;opérande gauche, jlox a besoin de stocker ce résultat quelque part temporairement pendant qu&rsquo;il est occupé à traverser vers le bas à travers l&rsquo;arbre d&rsquo;opérande droit. Nous utilisons une variable locale en Java pour cela. Notre interpréteur à parcours d&rsquo;arbre récursif crée un cadre d&rsquo;appel Java unique pour chaque nœud étant évalué, donc nous pouvions avoir autant de ces variables locales que nous avions besoin.</p>
<p>Dans clox, notre fonction <code>run()</code> n&rsquo;est pas récursive<span class="em">&mdash;</span>l&rsquo;arbre d&rsquo;expression imbriqué est aplati en une série linéaire d&rsquo;instructions. Nous n&rsquo;avons pas le luxe d&rsquo;utiliser des variables locales C, donc comment et où devrions-nous stocker ces valeurs temporaires ? Vous pouvez probablement déjà <span name="guess">deviner</span>, mais je veux vraiment creuser là-dedans parce que c&rsquo;est un aspect de la programmation que nous prenons pour acquis, mais nous apprenons rarement <em>pourquoi</em> les ordinateurs sont architecturés de cette façon.</p>
<aside name="guess">
<p>Indice : c&rsquo;est dans le nom de cette section, et c&rsquo;est comment Java et C gèrent les appels récursifs aux fonctions.</p>
</aside>
<p>Faisons un exercice bizarre. Nous allons marcher à travers l&rsquo;exécution du programme ci-dessus une étape à la fois :</p><img src="image/a-virtual-machine/bars.png" alt="La série d'instructions avec des barres montrant quels nombres ont besoin d'être préservés à travers quelles instructions." />
<p>À gauche sont les étapes de code. À droite sont les valeurs que nous suivons. Chaque barre représente un nombre. Elle commence quand la valeur est d&rsquo;abord produite<span class="em">&mdash;</span>soit une constante ou le résultat d&rsquo;une addition. La longueur de la barre suit quand une valeur précédemment produite a besoin d&rsquo;être gardée dans le coin, et elle finit quand cette valeur est finalement consommée par une opération.</p>
<p>Alors que vous avancez, vous voyez des valeurs apparaître et ensuite plus tard être mangées. Celles qui vivent le plus longtemps sont les valeurs produites depuis le côté gauche d&rsquo;une addition. Celles-ci restent dans le coin pendant que nous travaillons à travers l&rsquo;expression opérande de droite.</p>
<p>Dans le diagramme ci-dessus, j&rsquo;ai donné à chaque nombre unique sa propre colonne visuelle. Soyons un peu plus parcimonieux. Une fois qu&rsquo;un nombre est consommé, nous permettons à sa colonne d&rsquo;être réutilisée pour une autre valeur plus tard. En d&rsquo;autres termes, nous prenons tous ces trous là-haut et les remplissons, poussant les nombres depuis la droite :</p><img src="image/a-virtual-machine/bars-stacked.png" alt="Comme le diagramme précédent, mais avec les barres de nombres poussées vers la gauche, formant une pile." />
<p>Il y a des trucs intéressants qui se passent ici. Quand nous décalons tout, chaque nombre réussit encore à rester dans une colonne unique pour sa vie entière. Aussi, il n&rsquo;y a pas de trous laissés. En d&rsquo;autres termes, chaque fois qu&rsquo;un nombre apparaît plus tôt qu&rsquo;un autre, alors il vivra au moins aussi longtemps que ce second. Le premier nombre à apparaître est le dernier à être consommé. Hmm<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>dernier-entré, premier-sorti (LIFO)<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>Tiens, c&rsquo;est une <span name="pancakes">pile</span> !</p>
<aside name="pancakes">
<p>Ceci est aussi une pile :</p><img src="image/a-virtual-machine/pancakes.png" alt="Une pile... de pancakes." />
</aside>
<p>Dans le second diagramme, chaque fois que nous introduisons un nombre, nous le poussons sur la pile depuis la droite. Quand des nombres sont consommés, ils sont toujours dépilés depuis le plus à droite vers la gauche.</p>
<p>Puisque les valeurs temporaires que nous avons besoin de suivre ont naturellement un comportement de type pile, notre VM utilisera une pile pour les gérer. Quand une instruction &ldquo;produit&rdquo; une valeur, elle la pousse sur la pile. Quand elle a besoin de consommer une ou plusieurs valeurs, elle les obtient en les dépilant de la pile.</p>
<h3><a href="#la-pile-de-la-vm" id="la-pile-de-la-vm"><small>15&#8202;.&#8202;2&#8202;.&#8202;1</small>La Pile de la VM</a></h3>
<p>Peut-être que cela ne semble pas comme une révélation, mais j&rsquo;<em>adore</em> les VMs à base de pile. Quand vous voyez pour la première fois un tour de magie, cela ressemble à quelque chose de réellement magique. Mais ensuite vous apprenez comment ça marche<span class="em">&mdash;</span>habituellement quelque truc mécanique ou de la mauvaise direction<span class="em">&mdash;</span>et le sens du merveilleux s&rsquo;évapore. Il y a une <span name="wonder">paire</span> d&rsquo;idées en informatique où même après que je les ai démontées et appris tous les tenants et aboutissants, un peu de l&rsquo;étincelle initiale est restée. Les VMs à base de pile sont l&rsquo;une de celles-là.</p>
<aside name="wonder">
<p>Les tas (heaps)<span class="em">&mdash;</span><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">la structure de données</a>, pas <a href="https://en.wikipedia.org/wiki/Memory_management#HEAP">le truc de gestion de la mémoire</a><span class="em">&mdash;</span>en sont une autre. Et le schéma d&rsquo;analyse à précédence d&rsquo;opérateur descendante de Vaughan Pratt, duquel nous apprendrons <a href="compilation-des-expressions.html">en temps voulu</a>.</p>
</aside>
<p>Comme vous le verrez dans ce chapitre, exécuter des instructions dans une VM à base de pile est mortellement <span name="cheat">simple</span>. Dans les chapitres ultérieurs, vous découvrirez aussi que compiler un langage source vers un jeu d&rsquo;instructions à base de pile est du gâteau. Et pourtant, cette architecture est assez rapide pour être utilisée par des implémentations de langage en production. Cela ressemble presque à tricher au jeu du langage de programmation.</p>
<aside name="cheat">
<p>Pour enlever un peu du lustre : les interpréteurs à base de pile ne sont pas une solution miracle. Ils sont souvent <em>adéquats</em>, mais les implémentations modernes de la JVM, du CLR, et de JavaScript utilisent toutes des pipelines sophistiqués de <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">compilation à la volée</a> (JIT) pour générer du code natif <em>beaucoup</em> plus rapide à la volée.</p>
</aside>
<p>D&rsquo;accord, c&rsquo;est l&rsquo;heure de coder ! Voici la pile :</p>
<div class="codehilite"><pre class="insert-before">typedef struct {
  Chunk* chunk;
  uint8_t* ip;
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em></div>
<pre class="insert">  <span class="t">Value</span> <span class="i">stack</span>[<span class="a">STACK_MAX</span>];
  <span class="t">Value</span>* <span class="i">stackTop</span>;
</pre><pre class="insert-after">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>

<p>Nous implémentons la sémantique de pile nous-mêmes au-dessus d&rsquo;un tableau C brut. Le bas de la pile<span class="em">&mdash;</span>la première valeur poussée et la dernière à être dépilée<span class="em">&mdash;</span>est à l&rsquo;élément zéro dans le tableau, et les valeurs poussées plus tard la suivent. Si nous poussons les lettres de &ldquo;crepe&rdquo;<span class="em">&mdash;</span>mon élément de petit-déjeuner empilable favori<span class="em">&mdash;</span>sur la pile, dans l&rsquo;ordre, le tableau C résultant ressemble à ceci :</p><img src="image/a-virtual-machine/array.png" alt="Un tableau contenant les lettres dans 'crepe' dans l'ordre commençant à l'élément 0." />
<p>Puisque la pile grandit et rétrécit alors que les valeurs sont poussées et dépilées, nous avons besoin de suivre où est le sommet de la pile dans le tableau. Comme avec <code>ip</code>, nous utilisons un pointeur direct au lieu d&rsquo;un index entier puisque c&rsquo;est plus rapide de déréférencer le pointeur que de calculer l&rsquo;offset depuis l&rsquo;index chaque fois que nous en avons besoin.</p>
<p>Le pointeur pointe à l&rsquo;élément du tableau juste <em>après</em> l&rsquo;élément contenant la valeur du sommet de la pile. Cela semble un peu bizarre, mais presque chaque implémentation fait cela. Cela signifie que nous pouvons indiquer que la pile est vide en pointant à l&rsquo;élément zéro dans le tableau.</p><img src="image/a-virtual-machine/stack-empty.png" alt="Un tableau vide avec stackTop pointant au premier élément." />
<p>Si nous pointions vers l&rsquo;élément du sommet, alors pour une pile vide nous aurions besoin de pointer à l&rsquo;élément -1. C&rsquo;est <span name="defined">indéfini</span> en C. Alors que nous poussons des valeurs sur la pile<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<aside name="defined">
<p>Quoi à propos de quand la pile est <em>pleine</em>, vous demandez, Lecteur Malin ? Le standard C est une étape en avance sur vous. Il <em>est</em> permis et bien spécifié d&rsquo;avoir un pointeur de tableau qui pointe juste après la fin d&rsquo;un tableau.</p>
</aside><img src="image/a-virtual-machine/stack-c.png" alt="Un tableau avec 'c' à l'élément zéro." />
<p><span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span><code>stackTop</code> pointe toujours juste après le dernier élément.</p><img src="image/a-virtual-machine/stack-crepe.png" alt="Un tableau avec 'c', 'r', 'e', 'p', et 'e' dans les cinq premiers éléments." />
<p>Je me souviens de ça comme ceci : <code>stackTop</code> pointe vers où la prochaine valeur à être poussée ira. Le nombre maximum de valeurs que nous pouvons stocker sur la pile (pour l&rsquo;instant, au moins) est :</p>
<div class="codehilite"><pre class="insert-before">#include &quot;chunk.h&quot;
</pre><div class="source-file"><em>vm.h</em></div>
<pre class="insert">

<span class="a">#define STACK_MAX 256</span>
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>

<p>Donner à notre VM une taille de pile fixe signifie qu&rsquo;il est possible pour une certaine séquence d&rsquo;instructions de pousser trop de valeurs et de tomber à court d&rsquo;espace de pile<span class="em">&mdash;</span>le classique &ldquo;débordement de pile&rdquo; (stack overflow). Nous pourrions faire grandir la pile dynamiquement comme nécessaire, mais pour l&rsquo;instant nous garderons ça simple. Puisque VM utilise Value, nous avons besoin d&rsquo;inclure sa déclaration.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;chunk.h&quot;
</pre><div class="source-file"><em>vm.h</em></div>
<pre class="insert"><span class="a">#include &quot;value.h&quot;</span>
</pre><pre class="insert-after">

#define STACK_MAX 256
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>

<p>Maintenant que VM a un état intéressant, nous pouvons l&rsquo;initialiser.</p>
<div class="codehilite"><pre class="insert-before">void initVM() {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">  <span class="i">resetStack</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>Cela utilise cette fonction utilitaire :</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after variable <em>vm</em></div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">resetStack</span>() {
  <span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">vm</span>.<span class="i">stack</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after variable <em>vm</em></div>

<p>Puisque le tableau de pile est déclaré directement inline dans la struct VM, nous n&rsquo;avons pas besoin de l&rsquo;allouer. Nous n&rsquo;avons même pas besoin de nettoyer les cellules inutilisées dans le tableau<span class="em">&mdash;</span>nous ne les accèderons simplement pas jusqu&rsquo;à ce que des valeurs aient été stockées dedans. La seule initialisation dont nous avons besoin est de définir <code>stackTop</code> pour pointer au début du tableau pour indiquer que la pile est vide.</p>
<p>Le protocole de pile supporte deux opérations :</p>
<div class="codehilite"><pre class="insert-before">InterpretResult interpret(Chunk* chunk);
</pre><div class="source-file"><em>vm.h</em><br>
add after <em>interpret</em>()</div>
<pre class="insert"><span class="t">void</span> <span class="i">push</span>(<span class="t">Value</span> <span class="i">value</span>);
<span class="t">Value</span> <span class="i">pop</span>();
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after <em>interpret</em>()</div>

<p>Vous pouvez pousser une nouvelle valeur sur le sommet de la pile, et vous pouvez dépiler la valeur poussée le plus récemment en retour. Voici la première fonction :</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>freeVM</em>()</div>
<pre><span class="t">void</span> <span class="i">push</span>(<span class="t">Value</span> <span class="i">value</span>) {
  *<span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">value</span>;
  <span class="i">vm</span>.<span class="i">stackTop</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>

<p>Si vous êtes rouillé sur votre syntaxe de pointeur C et opérations, c&rsquo;est un bon échauffement. La première ligne stocke <code>value</code> dans l&rsquo;élément du tableau au sommet de la pile. Rappelez-vous, <code>stackTop</code> pointe juste <em>après</em> le dernier élément utilisé, au prochain disponible. Cela stocke la valeur dans cet emplacement. Ensuite nous incrémentons le pointeur lui-même pour pointer vers le prochain emplacement inutilisé dans le tableau maintenant que l&rsquo;emplacement précédent est occupé.</p>
<p>Dépiler est l&rsquo;image miroir.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>push</em>()</div>
<pre><span class="t">Value</span> <span class="i">pop</span>() {
  <span class="i">vm</span>.<span class="i">stackTop</span>--;
  <span class="k">return</span> *<span class="i">vm</span>.<span class="i">stackTop</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>push</em>()</div>

<p>D&rsquo;abord, nous déplaçons le pointeur de pile en <em>arrière</em> pour arriver à l&rsquo;emplacement utilisé le plus récent dans le tableau. Ensuite nous cherchons la valeur à cet index et la renvoyons. Nous n&rsquo;avons pas besoin de l&rsquo;&ldquo;enlever&rdquo; explicitement du tableau<span class="em">&mdash;</span>déplacer <code>stackTop</code> vers le bas est assez pour marquer cet emplacement comme n&rsquo;étant plus utilisé.</p>
<h3><a href="#traçage-de-pile" id="traçage-de-pile"><small>15&#8202;.&#8202;2&#8202;.&#8202;2</small>Traçage de pile</a></h3>
<p>Nous avons une pile qui fonctionne, mais c&rsquo;est dur de <em>voir</em> qu&rsquo;elle fonctionne. Quand nous commencerons à implémenter des instructions plus complexes et compiler et exécuter de plus gros morceaux de code, nous finirons avec beaucoup de valeurs entassées dans ce tableau. Cela rendrait nos vies en tant que hackers de VM plus faciles si nous avions une certaine visibilité dans la pile.</p>
<p>À cette fin, chaque fois que nous traçons l&rsquo;exécution, nous montrerons aussi le contenu courant de la pile avant que nous interprétions chaque instruction.</p>
<div class="codehilite"><pre class="insert-before">#ifdef DEBUG_TRACE_EXECUTION
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">    <span class="i">printf</span>(<span class="s">&quot;          &quot;</span>);
    <span class="k">for</span> (<span class="t">Value</span>* <span class="i">slot</span> = <span class="i">vm</span>.<span class="i">stack</span>; <span class="i">slot</span> &lt; <span class="i">vm</span>.<span class="i">stackTop</span>; <span class="i">slot</span>++) {
      <span class="i">printf</span>(<span class="s">&quot;[ &quot;</span>);
      <span class="i">printValue</span>(*<span class="i">slot</span>);
      <span class="i">printf</span>(<span class="s">&quot; ]&quot;</span>);
    }
    <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
</pre><pre class="insert-after">    disassembleInstruction(vm.chunk,
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nous bouclons, imprimant chaque valeur dans le tableau, commençant à la première (bas de la pile) et finissant quand nous atteignons le sommet. Cela nous laisse observer l&rsquo;effet de chaque instruction sur la pile. La sortie est assez verbeuse, mais c&rsquo;est utile quand nous extrayons chirurgicalement un vilain bug des entrailles de l&rsquo;interpréteur.</p>
<p>Pile en main, revisitons nos deux instructions. D&rsquo;abord :</p>
<div class="codehilite"><pre class="insert-before">      case OP_CONSTANT: {
        Value constant = READ_CONSTANT();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 2 lines</div>
<pre class="insert">        <span class="i">push</span>(<span class="i">constant</span>);
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>

<p>Dans le dernier chapitre, j&rsquo;agitais les mains à propos de comment l&rsquo;instruction <code>OP_CONSTANT</code> &ldquo;charge&rdquo; une constante. Maintenant que nous avons une pile vous savez ce que cela signifie de réellement produire une valeur : elle est poussée sur la pile.</p>
<div class="codehilite"><pre class="insert-before">      case OP_RETURN: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="i">printValue</span>(<span class="i">pop</span>());
        <span class="i">printf</span>(<span class="s">&quot;</span><span class="e">\n</span><span class="s">&quot;</span>);
</pre><pre class="insert-after">        return INTERPRET_OK;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Ensuite nous faisons en sorte que <code>OP_RETURN</code> dépile la pile et imprime la valeur du sommet avant de sortir. Quand nous ajouterons le support pour les fonctions réelles à clox, nous changerons ce code. Mais, pour l&rsquo;instant, cela nous donne un moyen d&rsquo;avoir la VM exécutant des séquences d&rsquo;instruction simples et affichant le résultat.</p>
<h2><a href="#une-calculatrice-arithmétique" id="une-calculatrice-arithmétique"><small>15&#8202;.&#8202;3</small>Une Calculatrice Arithmétique</a></h2>
<p>Le cœur et l&rsquo;âme de notre VM sont en place maintenant. La boucle de bytecode dispatche et exécute les instructions. La pile grandit et rétrécit alors que les valeurs coulent à travers elles. Les deux moitiés fonctionnent, mais c&rsquo;est dur d&rsquo;avoir un sentiment pour comment intelligemment elles interagissent avec seulement les deux instructions rudimentaires que nous avons jusqu&rsquo;ici. Donc apprenons à notre interpréteur à faire de l&rsquo;arithmétique.</p>
<p>Nous commencerons avec l&rsquo;opération arithmétique la plus simple, la négation unaire.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">1.2</span>;
<span class="k">print</span> -<span class="i">a</span>; <span class="c">// -1.2.</span>
</pre></div>
<p>L&rsquo;opérateur préfixe <code>-</code> prend un opérande, la valeur à nier. Il produit un seul résultat. Nous ne nous en faisons pas avec un parseur encore, mais nous pouvons ajouter l&rsquo;instruction bytecode vers laquelle la syntaxe ci-dessus compilera.</p>
<div class="codehilite"><pre class="insert-before">  OP_CONSTANT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_NEGATE</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Nous l&rsquo;exécutons comme ceci :</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_NEGATE</span>:   <span class="i">push</span>(-<span class="i">pop</span>()); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>L&rsquo;instruction a besoin d&rsquo;une valeur sur laquelle opérer, qu&rsquo;elle obtient en dépilant de la pile. Elle nie cela, puis pousse le résultat en retour pour que les instructions ultérieures l&rsquo;utilisent. Ça ne devient pas beaucoup plus facile que ça. Nous pouvons la désassembler aussi.</p>
<div class="codehilite"><pre class="insert-before">    case OP_CONSTANT:
      return constantInstruction(&quot;OP_CONSTANT&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_NEGATE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_NEGATE&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Et nous pouvons l&rsquo;essayer dans notre morceau de test.</p>
<div class="codehilite"><pre class="insert-before">  writeChunk(&amp;chunk, constant, 123);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_NEGATE</span>, <span class="n">123</span>);
</pre><pre class="insert-after">

  writeChunk(&amp;chunk, OP_RETURN, 123);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>Après avoir chargé la constante, mais avant de retourner, nous exécutons l&rsquo;instruction de négation. Cela remplace la constante sur la pile avec sa négation. Ensuite l&rsquo;instruction de retour imprime cela :</p>
<div class="codehilite"><pre>-1.2
</pre></div>
<p>Magique !</p>
<h3><a href="#opérateurs-binaires" id="opérateurs-binaires"><small>15&#8202;.&#8202;3&#8202;.&#8202;1</small>Opérateurs binaires</a></h3>
<p>OK, les opérateurs unaires ne sont pas <em>si</em> impressionnants. Nous avons encore seulement jamais une valeur unique sur la pile. Pour voir vraiment de la profondeur, nous avons besoin d&rsquo;opérateurs binaires. Lox a quatre opérateurs <span name="ops">arithmétiques</span> binaires : addition, soustraction, multiplication, et division. Nous allons aller de l&rsquo;avant et les implémenter tous en même temps.</p>
<aside name="ops">
<p>Lox a quelques autres opérateurs binaires<span class="em">&mdash;</span>comparaison et égalité<span class="em">&mdash;</span>mais ceux-là ne produisent pas de nombres comme résultat, donc nous ne sommes pas prêts pour eux encore.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  OP_CONSTANT,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_ADD</span>,
  <span class="a">OP_SUBTRACT</span>,
  <span class="a">OP_MULTIPLY</span>,
  <span class="a">OP_DIVIDE</span>,
</pre><pre class="insert-after">  OP_NEGATE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>De retour dans la boucle bytecode, ils sont exécutés comme ceci :</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_ADD</span>:      <span class="a">BINARY_OP</span>(+); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_SUBTRACT</span>: <span class="a">BINARY_OP</span>(-); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_MULTIPLY</span>: <span class="a">BINARY_OP</span>(*); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_DIVIDE</span>:   <span class="a">BINARY_OP</span>(/); <span class="k">break</span>;
</pre><pre class="insert-after">      case OP_NEGATE:   push(-pop()); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>La seule différence entre ces quatre instructions est quel opérateur C sous-jacent elles utilisent ultimement pour combiner les deux opérandes. Autour de cette expression arithmétique centrale est un peu de code boilerplate pour tirer les valeurs de la pile et pousser le résultat. Quand nous ajouterons plus tard le typage dynamique, ce boilerplate grandira. Pour éviter de répéter ce code quatre fois, je l&rsquo;ai enveloppé dans une macro.</p>
<div class="codehilite"><pre class="insert-before">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#define BINARY_OP(op) \</span>
<span class="a">    do { \</span>
<span class="a">      double b = pop(); \</span>
<span class="a">      double a = pop(); \</span>
<span class="a">      push(a op b); \</span>
<span class="a">    } while (false)</span>
</pre><pre class="insert-after">

  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>J&rsquo;admets que c&rsquo;est un usage assez <span name="operator">aventureux</span> du préprocesseur C. J&rsquo;ai hésité à faire cela, mais vous serez content dans les chapitres ultérieurs quand nous aurons besoin d&rsquo;ajouter la vérification de type pour chaque opérande et tout ça. Ce serait une corvée de vous faire marcher à travers le même code quatre fois.</p>
<aside name="operator">
<p>Saviez-vous même que vous pouvez passer un <em>opérateur</em> comme argument à une macro ? Maintenant vous savez. Le préprocesseur ne se soucie pas que les opérateurs ne soient pas de première classe en C. Pour autant qu&rsquo;il soit concerné, c&rsquo;est tout juste des tokens de texte.</p>
<p>Je sais, vous pouvez juste <em>sentir</em> la tentation d&rsquo;abuser de ça, n&rsquo;est-ce pas ?</p>
</aside>
<p>Si vous n&rsquo;êtes pas familier avec le truc déjà, cette boucle <code>do while</code> extérieure semble probablement vraiment bizarre. Cette macro a besoin de s&rsquo;étendre en une série d&rsquo;instructions. Pour être des auteurs de macro prudents, nous voulons nous assurer que ces instructions finissent toutes dans la même portée quand la macro est étendue. Imaginez si vous définissiez :</p>
<div class="codehilite"><pre><span class="a">#define WAKE_UP() makeCoffee(); drinkCoffee();</span>
</pre></div>
<p>Et ensuite l&rsquo;utilisiez comme :</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">morning</span>) <span class="a">WAKE_UP</span>();
</pre></div>
<p>L&rsquo;intention est d&rsquo;exécuter les deux instructions du corps de la macro seulement si <code>morning</code> est vrai. Mais ça s&rsquo;étend à :</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">morning</span>) <span class="i">makeCoffee</span>(); <span class="i">drinkCoffee</span>();;
</pre></div>
<p>Oups. Le <code>if</code> s&rsquo;attache seulement à la <em>première</em> instruction. Vous pourriez penser que vous pourriez corriger cela en utilisant un bloc.</p>
<div class="codehilite"><pre><span class="a">#define WAKE_UP() { makeCoffee(); drinkCoffee(); }</span>
</pre></div>
<p>C&rsquo;est mieux, mais vous risquez encore :</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">morning</span>)
  <span class="a">WAKE_UP</span>();
<span class="k">else</span>
  <span class="i">sleepIn</span>();
</pre></div>
<p>Maintenant vous obtenez une erreur de compilation sur le <code>else</code> à cause de ce <code>;</code> traînant après le bloc de la macro. Utiliser une boucle <code>do while</code> dans la macro semble drôle, mais cela vous donne un moyen de contenir de multiples instructions à l&rsquo;intérieur d&rsquo;un bloc qui permet <em>aussi</em> un point-virgule à la fin.</p>
<p>Où étions-nous ? Juste, donc ce que le corps de cette macro fait est direct. Un opérateur binaire prend deux opérandes, donc il dépile deux fois. Il effectue l&rsquo;opération sur ces deux valeurs et ensuite pousse le résultat.</p>
<p>Payez une attention proche à l&rsquo;<em>ordre</em> des deux dépilements. Notez que nous assignons le premier opérande dépilé à <code>b</code>, pas <code>a</code>. Ça semble à l&rsquo;envers. Quand les opérandes eux-mêmes sont calculés, le gauche est évalué d&rsquo;abord, puis le droit. Cela signifie que l&rsquo;opérande gauche est poussé avant l&rsquo;opérande droit. Donc l&rsquo;opérande droit sera au sommet de la pile. Ainsi, la première valeur que nous dépilons est <code>b</code>.</p>
<p>Par exemple, si nous compilons <code>3 - 1</code>, le flux de données entre les instructions ressemble à ceci :</p><img src="image/a-virtual-machine/reverse.png" alt="Une séquence d'instructions avec la pile pour chacune montrant comment pousser et ensuite dépiler les valeurs inverse leur ordre." />
<p>Comme nous l&rsquo;avons fait avec les autres macros à l&rsquo;intérieur de <code>run()</code>, nous nettoyons après nous-mêmes à la fin de la fonction.</p>
<div class="codehilite"><pre class="insert-before">#undef READ_CONSTANT
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span class="a">#undef BINARY_OP</span>
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Le dernier est le support du désassembleur.</p>
<div class="codehilite"><pre class="insert-before">    case OP_CONSTANT:
      return constantInstruction(&quot;OP_CONSTANT&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_ADD</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_ADD&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SUBTRACT</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_SUBTRACT&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_MULTIPLY</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_MULTIPLY&quot;</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_DIVIDE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">&quot;OP_DIVIDE&quot;</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Les formats d&rsquo;instruction arithmétique sont simples, comme <code>OP_RETURN</code>. Même si les <em>opérateurs</em> arithmétiques prennent des opérandes<span class="em">&mdash;</span>qui sont trouvés sur la pile<span class="em">&mdash;</span>les <em>instructions bytecode</em> arithmétiques ne le font pas.</p>
<p>Mettons certaines de nos nouvelles instructions à l&rsquo;épreuve en évaluant une plus grosse expression :</p><img src="image/a-virtual-machine/chunk.png" alt="L'expression étant évaluée : -((1.2 + 3.4) / 5.6)" />
<p>Construisant sur notre exemple de morceau existant, voici les instructions additionnelles que nous avons besoin de compiler à la main de cet AST vers le bytecode.</p>
<div class="codehilite"><pre class="insert-before">  int constant = addConstant(&amp;chunk, 1.2);
  writeChunk(&amp;chunk, OP_CONSTANT, 123);
  writeChunk(&amp;chunk, constant, 123);
</pre><div class="source-file"><em>main.c</em><br>
in <em>main</em>()</div>
<pre class="insert">

  <span class="i">constant</span> = <span class="i">addConstant</span>(&amp;<span class="i">chunk</span>, <span class="n">3.4</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>, <span class="n">123</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>, <span class="n">123</span>);

  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_ADD</span>, <span class="n">123</span>);

  <span class="i">constant</span> = <span class="i">addConstant</span>(&amp;<span class="i">chunk</span>, <span class="n">5.6</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>, <span class="n">123</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>, <span class="n">123</span>);

  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_DIVIDE</span>, <span class="n">123</span>);
</pre><pre class="insert-after">  writeChunk(&amp;chunk, OP_NEGATE, 123);

  writeChunk(&amp;chunk, OP_RETURN, 123);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>

<p>L&rsquo;addition va en premier. L&rsquo;instruction pour la constante de gauche, 1.2, est déjà là, donc nous en ajoutons une autre pour 3.4. Ensuite nous ajoutons ces deux en utilisant <code>OP_ADD</code>, laissant cela sur la pile. Cela couvre le côté gauche de la division. Ensuite nous poussons le 5.6, et divisons le résultat de l&rsquo;addition par lui. Finalement, nous nions le résultat de cela.</p>
<p>Notez comment la sortie de <code>OP_ADD</code> coule implicitement en étant un opérande de <code>OP_DIVIDE</code> sans qu&rsquo;aucune instruction ne soit directement couplée l&rsquo;une à l&rsquo;autre. C&rsquo;est la magie de la pile. Elle nous laisse composer librement des instructions sans qu&rsquo;elles aient besoin d&rsquo;aucune complexité ou conscience du flux de données. La pile agit comme un espace de travail partagé dans lequel elles lisent et écrivent toutes.</p>
<p>Dans ce minuscule morceau exemple, la pile devient seulement haute de deux valeurs, mais quand nous commencerons à compiler du code source Lox vers du bytecode, nous aurons des morceaux qui utilisent beaucoup plus de la pile. En attendant, essayez de jouer avec ce morceau écrit à la main pour calculer différentes expressions arithmétiques imbriquées et voyez comment les valeurs coulent à travers les instructions et la pile.</p>
<p>Vous pourriez aussi bien sortir ça de votre système maintenant. C&rsquo;est le dernier morceau que nous construirons à la main. La prochaine fois que nous revisiterons le bytecode, nous écrirons un compilateur pour le générer pour nous.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>15&#8202;.&#8202;4</small>Défis</a></h2>
<ol>
<li>
<p>Quelles séquences d&rsquo;instructions bytecode généreriez-vous pour les expressions suivantes :</p>
<div class="codehilite"><pre><span class="n">1</span> * <span class="n">2</span> + <span class="n">3</span>
<span class="n">1</span> + <span class="n">2</span> * <span class="n">3</span>
<span class="n">3</span> - <span class="n">2</span> - <span class="n">1</span>
<span class="n">1</span> + <span class="n">2</span> * <span class="n">3</span> - <span class="n">4</span> / -<span class="n">5</span>
</pre></div>
<p>(Rappelez-vous que Lox n&rsquo;a pas de syntaxe pour les littéraux de nombres négatifs, donc le <code>-5</code> nie le nombre 5.)</p>
</li>
<li>
<p>Si nous voulions vraiment un jeu d&rsquo;instructions minimal, nous pourrions éliminer soit <code>OP_NEGATE</code> ou <code>OP_SUBTRACT</code>. Montrez la séquence d&rsquo;instructions bytecode que vous généreriez pour :</p>
<div class="codehilite"><pre><span class="n">4</span> - <span class="n">3</span> * -<span class="n">2</span>
</pre></div>
<p>D&rsquo;abord, sans utiliser <code>OP_NEGATE</code>. Ensuite, sans utiliser <code>OP_SUBTRACT</code>.</p>
<p>Étant donné le ci-dessus, pensez-vous que cela a du sens d&rsquo;avoir les deux instructions ? Pourquoi ou pourquoi pas ? Y a-t-il d&rsquo;autres instructions redondantes que vous considéreriez inclure ?</p>
</li>
<li>
<p>La pile de notre VM a une taille fixe, et nous ne vérifions pas si pousser une valeur la fait déborder. Cela signifie que la mauvaise série d&rsquo;instructions pourrait causer le crash de notre interpréteur ou aller en comportement indéfini. Évitez cela en faisant grandir la pile dynamiquement comme nécessaire.</p>
<p>Quels sont les coûts et bénéfices de faire ainsi ?</p>
</li>
<li>
<p>Pour interpréter <code>OP_NEGATE</code>, nous dépilons l&rsquo;opérande, nions la valeur, et ensuite poussons le résultat. C&rsquo;est une implémentation simple, mais elle incrémente et décrémente <code>stackTop</code> inutilement, puisque la pile finit à la même hauteur à la fin. Il pourrait être plus rapide de simplement nier la valeur en place sur la pile et laisser <code>stackTop</code> tranquille. Essayez cela et voyez si vous pouvez mesurer une différence de performance.</p>
<p>Y a-t-il d&rsquo;autres instructions où vous pouvez faire une optimisation similaire ?</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--bytecode-&agrave;-registres" id="note-de-conception--bytecode-&agrave;-registres"><small>15&#8202;.&#8202;5</small>Note de Conception : Bytecode &agrave; Registres</a></h2>
<p>Pour le reste de ce livre, nous implémenterons méticuleusement un interpréteur autour d&rsquo;un jeu d&rsquo;instructions bytecode basé sur une pile. Il y a une autre famille d&rsquo;architectures bytecode là-dehors<span class="em">&mdash;</span><em>basées sur des registres</em>. Malgré le nom, ces instructions bytecode ne sont pas tout à fait aussi difficiles à travailler qu&rsquo;avec les registres dans une puce réelle comme <span name="x64">x64</span>. Avec des registres matériels réels, vous en avez habituellement seulement une poignée pour le programme entier, donc vous passez beaucoup d&rsquo;effort <a href="https://en.wikipedia.org/wiki/Register_allocation">à essayer de les utiliser efficacement et à navetter des trucs dedans et dehors</a>.</p>
<aside name="x64">
<p>Le bytecode à registres est un peu plus proche des <a href="https://en.wikipedia.org/wiki/Register_window"><em>fenêtres de registres</em></a> supportées par les puces SPARC.</p>
</aside>
<p>Dans une VM à registres, vous avez encore une pile. Les valeurs temporaires sont encore poussées dessus et dépilées quand elles ne sont plus nécessaires. La différence principale est que les instructions peuvent lire leurs entrées de n&rsquo;importe où dans la pile et peuvent stocker leurs sorties dans des emplacements de pile spécifiques.</p>
<p>Prenez ce petit script Lox :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
<span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
<span class="k">var</span> <span class="i">c</span> = <span class="i">a</span> + <span class="i">b</span>;
</pre></div>
<p>Dans notre VM à pile, le dernier statement sera compilé vers quelque chose comme :</p>
<div class="codehilite"><pre><span class="i">load</span> &lt;<span class="i">a</span>&gt;  <span class="c">// Lire la variable locale a et pousser sur la pile.</span>
<span class="i">load</span> &lt;<span class="i">b</span>&gt;  <span class="c">// Lire la variable locale b et pousser sur la pile.</span>
<span class="i">add</span>       <span class="c">// Dépiler deux valeurs, ajouter, pousser le résultat.</span>
<span class="i">store</span> &lt;<span class="i">c</span>&gt; <span class="c">// Dépiler la valeur et stocker dans la variable locale c.</span>
</pre></div>
<p>(Ne vous inquiétez pas si vous ne comprenez pas pleinement les instructions load et store encore. Nous les passerons en revue en bien plus grand détail <a href="variables-globales.html">quand nous implémenterons les variables</a>.) Nous avons quatre instructions séparées. Cela signifie quatre fois à travers la boucle d&rsquo;interprétation de bytecode, quatre instructions à décoder et dispatcher. C&rsquo;est au moins sept octets de code<span class="em">&mdash;</span>quatre pour les opcodes et trois autres pour les opérandes identifiant quels locaux charger et stocker. Trois empilements et trois dépilements. Beaucoup de travail !</p>
<p>Dans un jeu d&rsquo;instructions à registres, les instructions peuvent lire depuis et stocker directement dans les variables locales. Le bytecode pour le dernier statement ci-dessus ressemble à :</p>
<div class="codehilite"><pre><span class="i">add</span> &lt;<span class="i">a</span>&gt; &lt;<span class="i">b</span>&gt; &lt;<span class="i">c</span>&gt; <span class="c">// Lire les valeurs de a et b, ajouter, stocker dans c.</span>
</pre></div>
<p>L&rsquo;instruction d&rsquo;ajout est plus grosse<span class="em">&mdash;</span>elle a trois opérandes d&rsquo;instruction qui définissent où dans la pile elle lit ses entrées et écrit le résultat. Mais puisque les variables locales vivent sur la pile, elle peut lire directement de <code>a</code> et <code>b</code> et ensuite stocker le résultat droit dans <code>c</code>.</p>
<p>Il y a seulement une unique instruction à décoder et dispatcher, et le truc entier tient dans quatre octets. Le décodage est plus complexe à cause des opérandes additionnels, mais c&rsquo;est toujours un gain net. Il n&rsquo;y a pas d&rsquo;empilement et dépilement ou autre manipulation de pile.</p>
<p>L&rsquo;implémentation principale de Lua avait l&rsquo;habitude d&rsquo;être basée sur une pile. Pour <span name="lua">Lua 5.0</span>, les implémenteurs ont changé pour un jeu d&rsquo;instructions à registres et noté une amélioration de vitesse. Le montant de l&rsquo;amélioration, naturellement, dépend lourdement des détails de la sémantique du langage, du jeu d&rsquo;instructions spécifique, et de la sophistication du compilateur, mais cela devrait attirer votre attention.</p>
<aside name="lua">
<p>L&rsquo;équipe de dev Lua<span class="em">&mdash;</span>Roberto Ierusalimschy, Waldemar Celes, et Luiz Henrique de Figueiredo<span class="em">&mdash;</span>a écrit un papier <em>fantastique</em> là-dessus, un de mes papiers d&rsquo;informatique favoris de tous les temps, &ldquo;<a href="https://www.lua.org/doc/jucs05.pdf">The Implementation of Lua 5.0</a>&rdquo; (PDF).</p>
</aside>
<p>Cela soulève la question évidente de pourquoi je vais passer le reste du livre à faire un bytecode basé sur une pile. Les VMs à registres sont chouettes, mais elles sont un peu plus dures pour lesquelles écrire un compilateur. Pour ce qui est probablement votre tout premier compilateur, je voulais rester avec un jeu d&rsquo;instructions qui est facile à générer et facile à exécuter. Le bytecode à pile est merveilleusement simple.</p>
<p>Il est aussi <em>bien</em> mieux connu dans la littérature et la communauté. Même si vous pouvez éventuellement bouger vers quelque chose de plus avancé, c&rsquo;est un bon terrain commun à partager avec le reste de vos pairs hackers de langages.</p>
</div>

<footer>
<a href="analyse-à-la-demande.html" class="next">
  Next Chapter: &ldquo;Analyse à la demande&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
