<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Analyse lexicale &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Analyse lexicale<small>4</small></a></h3>

<ul>
    <li><a href="#le-cadre-de-linterpréteur"><small>4.1</small> Le cadre de l&#x27;interpréteur</a></li>
    <li><a href="#lexèmes-et-tokens"><small>4.2</small> Lexèmes et Tokens</a></li>
    <li><a href="#langages-réguliers-et-expressions"><small>4.3</small> Langages Réguliers et Expressions</a></li>
    <li><a href="#la-classe-scanner"><small>4.4</small> La Classe Scanner</a></li>
    <li><a href="#reconnaître-les-lexèmes"><small>4.5</small> Reconnaître les Lexèmes</a></li>
    <li><a href="#lexèmes-plus-longs"><small>4.6</small> Lexèmes plus longs</a></li>
    <li><a href="#mots-réservés-et-identifiants"><small>4.7</small> Mots Réservés et Identifiants</a></li>
    <li><a href="#défis"><small>4.8</small> Défis</a></li>
    <li><a href="#note-de-conception--points-virgules-implicites"><small>4.9</small> Note de Conception : Points-virgules Implicites</a></li>
</ul>


<div class="prev-next">
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="représentation-du-code.html" title="Représentation du code" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre" class="prev">←</a>
<a href="représentation-du-code.html" title="Représentation du code" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Analyse lexicale<small>4</small></a></h3>

<ul>
    <li><a href="#le-cadre-de-linterpréteur"><small>4.1</small> Le cadre de l&#x27;interpréteur</a></li>
    <li><a href="#lexèmes-et-tokens"><small>4.2</small> Lexèmes et Tokens</a></li>
    <li><a href="#langages-réguliers-et-expressions"><small>4.3</small> Langages Réguliers et Expressions</a></li>
    <li><a href="#la-classe-scanner"><small>4.4</small> La Classe Scanner</a></li>
    <li><a href="#reconnaître-les-lexèmes"><small>4.5</small> Reconnaître les Lexèmes</a></li>
    <li><a href="#lexèmes-plus-longs"><small>4.6</small> Lexèmes plus longs</a></li>
    <li><a href="#mots-réservés-et-identifiants"><small>4.7</small> Mots Réservés et Identifiants</a></li>
    <li><a href="#défis"><small>4.8</small> Défis</a></li>
    <li><a href="#note-de-conception--points-virgules-implicites"><small>4.9</small> Note de Conception : Points-virgules Implicites</a></li>
</ul>


<div class="prev-next">
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="représentation-du-code.html" title="Représentation du code" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">4</div>
  <h1>Analyse lexicale</h1>

<blockquote>
<p>Voyez grand. Tout ce qui mérite d&rsquo;être fait mérite d&rsquo;être fait avec excès.</p>
<p><cite>Robert A. Heinlein, <em>Time Enough for Love</em></cite></p>
</blockquote>
<p>La première étape de tout compilateur ou interpréteur est l&rsquo;<span
name="lexing">analyse lexicale</span> (scanning). Le scanner prend le code source brut sous forme d&rsquo;une série de caractères et le regroupe en une série de blocs que nous appelons <strong>tokens</strong>. Ce sont les &ldquo;mots&rdquo; et la &ldquo;ponctuation&rdquo; significatifs qui constituent la grammaire du langage.</p>
<aside name="lexing">
<p>Cette tâche a été appelée diversement &ldquo;scanning&rdquo; et &ldquo;lexing&rdquo; (abréviation de &ldquo;analyse lexicale&rdquo;) au fil des ans. À l&rsquo;époque où les ordinateurs étaient aussi gros que des camping-cars mais avaient moins de mémoire que votre montre, certains utilisaient &ldquo;scanner&rdquo; uniquement pour désigner le morceau de code qui s&rsquo;occupait de lire les caractères du code source brut depuis le disque et de les mettre en mémoire tampon. Ensuite, le &ldquo;lexing&rdquo; était la phase suivante qui faisait des choses utiles avec les caractères.</p>
<p>De nos jours, lire un fichier source en mémoire est trivial, c&rsquo;est donc rarement une phase distincte dans le compilateur. De ce fait, les deux termes sont fondamentalement interchangeables.</p>
</aside>
<p>L&rsquo;analyse lexicale est aussi un bon point de départ pour nous car le code n&rsquo;est pas très difficile<span class="em">&mdash;</span>c&rsquo;est à peu près une instruction <code>switch</code> avec la folie des grandeurs. Cela nous aidera à nous échauffer avant d&rsquo;aborder des sujets plus intéressants plus tard. À la fin de ce chapitre, nous aurons un scanner complet et rapide qui pourra prendre n&rsquo;importe quelle chaîne de code source Lox et produire les tokens que nous fournirons au parseur dans le chapitre suivant.</p>
<h2><a href="#le-cadre-de-linterpréteur" id="le-cadre-de-linterpréteur"><small>4&#8202;.&#8202;1</small>Le cadre de l&rsquo;interpréteur</a></h2>
<p>Puisque c&rsquo;est notre premier vrai chapitre, avant de commencer à scanner du code, nous devons esquisser la forme de base de notre interpréteur, jlox. Tout commence par une classe en Java.</p>
<div class="codehilite"><div class="source-file"><em>lox/Lox.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.io.BufferedReader</span>;
<span class="k">import</span> <span class="i">java.io.IOException</span>;
<span class="k">import</span> <span class="i">java.io.InputStreamReader</span>;
<span class="k">import</span> <span class="i">java.nio.charset.Charset</span>;
<span class="k">import</span> <span class="i">java.nio.file.Files</span>;
<span class="k">import</span> <span class="i">java.nio.file.Paths</span>;
<span class="k">import</span> <span class="i">java.util.List</span>;

<span class="k">public</span> <span class="k">class</span> <span class="t">Lox</span> {
  <span class="k">public</span> <span class="k">static</span> <span class="t">void</span> <span class="i">main</span>(<span class="t">String</span>[] <span class="i">args</span>) <span class="k">throws</span> <span class="t">IOException</span> {
    <span class="k">if</span> (<span class="i">args</span>.<span class="i">length</span> &gt; <span class="n">1</span>) {
      <span class="t">System</span>.<span class="i">out</span>.<span class="i">println</span>(<span class="s">&quot;Usage: jlox [script]&quot;</span>);
      <span class="t">System</span>.<span class="i">exit</span>(<span class="n">64</span>);<span name="64"> </span>
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">args</span>.<span class="i">length</span> == <span class="n">1</span>) {
      <span class="i">runFile</span>(<span class="i">args</span>[<span class="n">0</span>]);
    } <span class="k">else</span> {
      <span class="i">runPrompt</span>();
    }
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, create new file</div>

<aside name="64">
<p>Pour les codes de sortie, j&rsquo;utilise les conventions définies dans l&rsquo;en-tête UNIX <a href="https://www.freebsd.org/cgi/man.cgi?query=sysexits&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html">&ldquo;sysexits.h&rdquo;</a>. C&rsquo;est la chose la plus proche d&rsquo;un standard que j&rsquo;ai pu trouver.</p>
</aside>
<p>Mettez cela dans un fichier texte, et préparez votre IDE ou Makefile ou quoi que ce soit. Je serai juste là quand vous serez prêt. C&rsquo;est bon ? OK !</p>
<p>Lox est un langage de script, ce qui signifie qu&rsquo;il s&rsquo;exécute directement à partir du code source. Notre interpréteur supporte deux façons d&rsquo;exécuter du code. Si vous lancez jlox depuis la ligne de commande et lui donnez un chemin vers un fichier, il lit le fichier et l&rsquo;exécute.</p>
<div class="codehilite"><div class="source-file"><em>lox/Lox.java</em><br>
add after <em>main</em>()</div>
<pre>  <span class="k">private</span> <span class="k">static</span> <span class="t">void</span> <span class="i">runFile</span>(<span class="t">String</span> <span class="i">path</span>) <span class="k">throws</span> <span class="t">IOException</span> {
    <span class="t">byte</span>[] <span class="i">bytes</span> = <span class="t">Files</span>.<span class="i">readAllBytes</span>(<span class="t">Paths</span>.<span class="i">get</span>(<span class="i">path</span>));
    <span class="i">run</span>(<span class="k">new</span> <span class="t">String</span>(<span class="i">bytes</span>, <span class="t">Charset</span>.<span class="i">defaultCharset</span>()));
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, add after <em>main</em>()</div>

<p>Si vous voulez une conversation plus intime avec votre interpréteur, vous pouvez aussi l&rsquo;exécuter de manière interactive. Lancez jlox sans aucun argument, et il vous dépose dans une invite où vous pouvez entrer et exécuter du code une ligne à la fois.</p>
<aside name="repl">
<p>Une invite interactive est aussi appelée un &ldquo;REPL&rdquo; (prononcé comme &ldquo;rebel&rdquo; mais avec un &ldquo;p&rdquo;). Le nom vient de Lisp où en implémenter un est aussi simple que d&rsquo;envelopper une boucle autour de quelques fonctions intégrées :</p>
<div class="codehilite"><pre>(<span class="i">print</span> (<span class="i">eval</span> (<span class="i">read</span>)))
</pre></div>
<p>En partant de l&rsquo;appel le plus imbriqué vers l&rsquo;extérieur, vous lisez (<strong>R</strong>ead) une ligne d&rsquo;entrée, l&rsquo;évaluez (<strong>E</strong>valuate), affichez (<strong>P</strong>rint) le résultat, puis bouclez (<strong>L</strong>oop) pour recommencer.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>lox/Lox.java</em><br>
add after <em>runFile</em>()</div>
<pre>  <span class="k">private</span> <span class="k">static</span> <span class="t">void</span> <span class="i">runPrompt</span>() <span class="k">throws</span> <span class="t">IOException</span> {
    <span class="t">InputStreamReader</span> <span class="i">input</span> = <span class="k">new</span> <span class="t">InputStreamReader</span>(<span class="t">System</span>.<span class="i">in</span>);
    <span class="t">BufferedReader</span> <span class="i">reader</span> = <span class="k">new</span> <span class="t">BufferedReader</span>(<span class="i">input</span>);

    <span class="k">for</span> (;;) {<span name="repl"> </span>
      <span class="t">System</span>.<span class="i">out</span>.<span class="i">print</span>(<span class="s">&quot;&gt; &quot;</span>);
      <span class="t">String</span> <span class="i">line</span> = <span class="i">reader</span>.<span class="i">readLine</span>();
      <span class="k">if</span> (<span class="i">line</span> == <span class="k">null</span>) <span class="k">break</span>;
      <span class="i">run</span>(<span class="i">line</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, add after <em>runFile</em>()</div>

<p>La fonction <code>readLine()</code>, comme son nom l&rsquo;indique si utilement, lit une ligne d&rsquo;entrée de l&rsquo;utilisateur sur la ligne de commande et renvoie le résultat. Pour tuer une application interactive en ligne de commande, vous tapez généralement Contrôle-D. Cela signale une condition &ldquo;fin de fichier&rdquo; au programme. Lorsque cela se produit, <code>readLine()</code> renvoie <code>null</code>, donc nous vérifions cela pour quitter la boucle.</p>
<p>L&rsquo;invite et le lanceur de fichier sont tous deux de minces enveloppes autour de cette fonction centrale :</p>
<div class="codehilite"><div class="source-file"><em>lox/Lox.java</em><br>
add after <em>runPrompt</em>()</div>
<pre>  <span class="k">private</span> <span class="k">static</span> <span class="t">void</span> <span class="i">run</span>(<span class="t">String</span> <span class="i">source</span>) {
    <span class="t">Scanner</span> <span class="i">scanner</span> = <span class="k">new</span> <span class="t">Scanner</span>(<span class="i">source</span>);
    <span class="t">List</span>&lt;<span class="t">Token</span>&gt; <span class="i">tokens</span> = <span class="i">scanner</span>.<span class="i">scanTokens</span>();

    <span class="c">// For now, just print the tokens.</span>
    <span class="k">for</span> (<span class="t">Token</span> <span class="i">token</span> : <span class="i">tokens</span>) {
      <span class="t">System</span>.<span class="i">out</span>.<span class="i">println</span>(<span class="i">token</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, add after <em>runPrompt</em>()</div>

<p>Ce n&rsquo;est pas encore très utile puisque nous n&rsquo;avons pas écrit l&rsquo;interpréteur, mais piano piano, n&rsquo;est-ce pas ? Pour l&rsquo;instant, cela affiche les tokens que notre futur scanner émettra afin que nous puissions voir si nous progressons.</p>
<h3><a href="#gestion-des-erreurs" id="gestion-des-erreurs"><small>4&#8202;.&#8202;1&#8202;.&#8202;1</small>Gestion des erreurs</a></h3>
<p>Pendant que nous mettons les choses en place, une autre pièce clé de l&rsquo;infrastructure est la <em>gestion des erreurs</em>. Les manuels scolaires passent parfois cela sous silence car c&rsquo;est plus une question pratique qu&rsquo;un problème formel d&rsquo;informatique. Mais si vous vous souciez de faire un langage réellement <em>utilisable</em>, alors gérer les erreurs avec grâce est vital.</p>
<p>Les outils que notre langage fournit pour gérer les erreurs constituent une grande partie de son interface utilisateur. Lorsque le code de l&rsquo;utilisateur fonctionne, il ne pense pas du tout à notre langage<span class="em">&mdash;</span>son esprit est tout entier à <em>son programme</em>. C&rsquo;est généralement seulement quand les choses tournent mal qu&rsquo;ils remarquent notre implémentation.</p>
<p><span name="errors">Lorsque</span> cela arrive, c&rsquo;est à nous de donner à l&rsquo;utilisateur toutes les informations dont il a besoin pour comprendre ce qui a mal tourné et le guider doucement vers là où il essaie d&rsquo;aller. Bien faire cela signifie penser à la gestion des erreurs tout au long de l&rsquo;implémentation de notre interpréteur, en commençant maintenant.</p>
<aside name="errors">
<p>Ceci étant dit, pour <em>cet</em> interpréteur, ce que nous allons construire est assez minimaliste. J&rsquo;adorerais parler de débogueurs interactifs, d&rsquo;analyseurs statiques et d&rsquo;autres choses amusantes, mais il n&rsquo;y a pas tant d&rsquo;encre que ça dans le stylo.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>lox/Lox.java</em><br>
add after <em>run</em>()</div>
<pre>  <span class="k">static</span> <span class="t">void</span> <span class="i">error</span>(<span class="t">int</span> <span class="i">line</span>, <span class="t">String</span> <span class="i">message</span>) {
    <span class="i">report</span>(<span class="i">line</span>, <span class="s">&quot;&quot;</span>, <span class="i">message</span>);
  }

  <span class="k">private</span> <span class="k">static</span> <span class="t">void</span> <span class="i">report</span>(<span class="t">int</span> <span class="i">line</span>, <span class="t">String</span> <span class="i">where</span>,
                             <span class="t">String</span> <span class="i">message</span>) {
    <span class="t">System</span>.<span class="i">err</span>.<span class="i">println</span>(
        <span class="s">&quot;[line &quot;</span> + <span class="i">line</span> + <span class="s">&quot;] Error&quot;</span> + <span class="i">where</span> + <span class="s">&quot;: &quot;</span> + <span class="i">message</span>);
    <span class="i">hadError</span> = <span class="k">true</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, add after <em>run</em>()</div>

<p>Cette fonction <code>error()</code> et son aide <code>report()</code> indiquent à l&rsquo;utilisateur qu&rsquo;une erreur de syntaxe s&rsquo;est produite sur une ligne donnée. C&rsquo;est vraiment le strict minimum pour pouvoir prétendre que vous <em>avez</em> même un rapport d&rsquo;erreurs. Imaginez si vous laissiez accidentellement une virgule pendante dans un appel de fonction et que l&rsquo;interpréteur affichait :</p>
<div class="codehilite"><pre>Error: Unexpected &quot;,&quot; somewhere in your code. Good luck finding it!
</pre></div>
<p>Ce n&rsquo;est pas très utile. Nous devons au moins les diriger vers la bonne ligne. Encore mieux serait la colonne de début et de fin pour qu&rsquo;ils sachent <em>où</em> dans la ligne. Encore mieux que <em>ça</em> serait de <em>montrer</em> à l&rsquo;utilisateur la ligne incriminée, comme :</p>
<div class="codehilite"><pre>Error: Unexpected &quot;,&quot; in argument list.

    15 | function(first, second,);
                               ^-- Here.
</pre></div>
<p>J&rsquo;adorerais implémenter quelque chose comme ça dans ce livre, mais la vérité honnête est que c&rsquo;est beaucoup de code de manipulation de chaînes fastidieux. Très utile pour les utilisateurs, mais pas super amusant à lire dans un livre et pas très intéressant techniquement. Donc nous nous en tiendrons juste à un numéro de ligne. Dans vos propres interpréteurs, faites ce que je dis et non ce que je fais.</p>
<p>La raison principale pour laquelle nous mettons cette fonction de rapport d&rsquo;erreur dans la classe principale Lox est à cause de ce champ <code>hadError</code>. Il est défini ici :</p>
<div class="codehilite"><pre class="insert-before">public class Lox {
</pre><div class="source-file"><em>lox/Lox.java</em><br>
in class <em>Lox</em></div>
<pre class="insert">  <span class="k">static</span> <span class="t">boolean</span> <span class="i">hadError</span> = <span class="k">false</span>;
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in class <em>Lox</em></div>

<p>Nous utiliserons cela pour nous assurer que nous n&rsquo;essayons pas d&rsquo;exécuter du code qui a une erreur connue. Aussi, cela nous permet de quitter avec un code de sortie non nul comme un bon citoyen de la ligne de commande devrait le faire.</p>
<div class="codehilite"><pre class="insert-before">    run(new String(bytes, Charset.defaultCharset()));
</pre><div class="source-file"><em>lox/Lox.java</em><br>
in <em>runFile</em>()</div>
<pre class="insert">

    <span class="c">// Indicate an error in the exit code.</span>
    <span class="k">if</span> (<span class="i">hadError</span>) <span class="t">System</span>.<span class="i">exit</span>(<span class="n">65</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>runFile</em>()</div>

<p>Nous devons réinitialiser ce drapeau dans la boucle interactive. Si l&rsquo;utilisateur fait une erreur, cela ne devrait pas tuer toute sa session.</p>
<div class="codehilite"><pre class="insert-before">      run(line);
</pre><div class="source-file"><em>lox/Lox.java</em><br>
in <em>runPrompt</em>()</div>
<pre class="insert">      <span class="i">hadError</span> = <span class="k">false</span>;
</pre><pre class="insert-after">    }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>runPrompt</em>()</div>

<p>L&rsquo;autre raison pour laquelle j&rsquo;ai sorti le rapport d&rsquo;erreur ici au lieu de le fourrer dans le scanner et d&rsquo;autres phases où l&rsquo;erreur pourrait se produire est pour vous rappeler que c&rsquo;est une bonne pratique d&rsquo;ingénierie de séparer le code qui <em>génère</em> les erreurs du code qui les <em>rapporte</em>.</p>
<p>Diverses phases du front-end détecteront des erreurs, mais ce n&rsquo;est pas vraiment leur travail de savoir comment présenter cela à un utilisateur. Dans une implémentation de langage complète, vous aurez probablement plusieurs façons d&rsquo;afficher les erreurs : sur stderr, dans la fenêtre d&rsquo;erreur d&rsquo;un IDE, consigné dans un fichier, etc. Vous ne voulez pas que ce code soit étalé partout dans votre scanner et votre parseur.</p>
<p>Idéalement, nous aurions une véritable abstraction, une sorte d&rsquo;interface <span name="reporter">&ldquo;ErrorReporter&rdquo;</span> qui serait passée au scanner et au parseur afin que nous puissions échanger différentes stratégies de rapport. Pour notre interpréteur simple ici, je n&rsquo;ai pas fait cela, mais j&rsquo;ai au moins déplacé le code de rapport d&rsquo;erreur dans une classe différente.</p>
<aside name="reporter">
<p>J&rsquo;avais exactement cela quand j&rsquo;ai implémenté jlox pour la première fois. J&rsquo;ai fini par l&rsquo;enlever parce que cela semblait sur-ingénierie pour l&rsquo;interpréteur minimal de ce livre.</p>
</aside>
<p>Avec une gestion rudimentaire des erreurs en place, notre coquille d&rsquo;application est prête. Une fois que nous aurons une classe Scanner avec une méthode <code>scanTokens()</code>, nous pourrons commencer à l&rsquo;exécuter. Avant d&rsquo;en arriver là, soyons plus précis sur ce que sont les tokens.</p>
<h2><a href="#lexèmes-et-tokens" id="lexèmes-et-tokens"><small>4&#8202;.&#8202;2</small>Lexèmes et Tokens</a></h2>
<p>Voici une ligne de code Lox :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">language</span> = <span class="s">&quot;lox&quot;</span>;
</pre></div>
<p>Ici, <code>var</code> est le mot-clé pour déclarer une variable. Cette séquence de trois caractères &ldquo;v-a-r&rdquo; signifie quelque chose. Mais si nous arrachons trois lettres au milieu de <code>language</code>, comme &ldquo;g-u-a&rdquo;, celles-ci ne signifient rien par elles-mêmes.</p>
<p>C&rsquo;est de cela qu&rsquo;il s&rsquo;agit dans l&rsquo;analyse lexicale. Notre travail est de parcourir la liste des caractères et de les regrouper dans les plus petites séquences qui représentent encore quelque chose. Chacun de ces blocs de caractères est appelé un <strong>lexème</strong>. Dans cet exemple de ligne de code, les lexèmes sont :</p><img src="image/scanning/lexemes.png" alt="'var', 'language', '=', 'lox', ';'" />
<p>Les lexèmes ne sont que les sous-chaînes brutes du code source. Cependant, dans le processus de regroupement des séquences de caractères en lexèmes, nous tombons également sur d&rsquo;autres informations utiles. Lorsque nous prenons le lexème et le regroupons avec ces autres données, le résultat est un token. Il comprend des choses utiles comme :</p>
<h3><a href="#type-de-token" id="type-de-token"><small>4&#8202;.&#8202;2&#8202;.&#8202;1</small>Type de token</a></h3>
<p>Les mots-clés font partie de la forme de la grammaire du langage, donc le parseur a souvent du code comme, &ldquo;Si le prochain token est <code>while</code> alors faire<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>&rdquo;. Cela signifie que le parseur veut savoir non seulement qu&rsquo;il a un lexème pour un identifiant, mais qu&rsquo;il a un mot <em>réservé</em>, et <em>quel</em> mot-clé c&rsquo;est.</p>
<p>Le <span name="ugly">parseur</span> pourrait catégoriser les tokens à partir du lexème brut en comparant les chaînes, mais c&rsquo;est lent et un peu laid. Au lieu de cela, au moment où nous reconnaissons un lexème, nous nous souvenons aussi de quel <em>genre</em> de lexème il représente. Nous avons un type différent pour chaque mot-clé, opérateur, morceau de ponctuation et type littéral.</p>
<aside name="ugly">
<p>Après tout, la comparaison de chaînes finit par regarder les caractères individuels, et n&rsquo;est-ce pas le travail du scanner ?</p>
</aside>
<div class="codehilite"><div class="source-file"><em>lox/TokenType.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">enum</span> <span class="t">TokenType</span> {
  <span class="c">// Single-character tokens.</span>
  <span class="i">LEFT_PAREN</span>, <span class="i">RIGHT_PAREN</span>, <span class="i">LEFT_BRACE</span>, <span class="i">RIGHT_BRACE</span>,
  <span class="i">COMMA</span>, <span class="i">DOT</span>, <span class="i">MINUS</span>, <span class="i">PLUS</span>, <span class="i">SEMICOLON</span>, <span class="i">SLASH</span>, <span class="i">STAR</span>,

  <span class="c">// One or two character tokens.</span>
  <span class="i">BANG</span>, <span class="i">BANG_EQUAL</span>,
  <span class="i">EQUAL</span>, <span class="i">EQUAL_EQUAL</span>,
  <span class="i">GREATER</span>, <span class="i">GREATER_EQUAL</span>,
  <span class="i">LESS</span>, <span class="i">LESS_EQUAL</span>,

  <span class="c">// Literals.</span>
  <span class="i">IDENTIFIER</span>, <span class="i">STRING</span>, <span class="i">NUMBER</span>,

  <span class="c">// Keywords.</span>
  <span class="i">AND</span>, <span class="i">CLASS</span>, <span class="i">ELSE</span>, <span class="i">FALSE</span>, <span class="i">FUN</span>, <span class="i">FOR</span>, <span class="i">IF</span>, <span class="i">NIL</span>, <span class="i">OR</span>,
  <span class="i">PRINT</span>, <span class="i">RETURN</span>, <span class="i">SUPER</span>, <span class="i">THIS</span>, <span class="i">TRUE</span>, <span class="i">VAR</span>, <span class="i">WHILE</span>,

  <span class="i">EOF</span>
}
</pre></div>
<div class="source-file-narrow"><em>lox/TokenType.java</em>, create new file</div>

<h3><a href="#valeur-littérale" id="valeur-littérale"><small>4&#8202;.&#8202;2&#8202;.&#8202;2</small>Valeur littérale</a></h3>
<p>Il y a des lexèmes pour les valeurs littérales<span class="em">&mdash;</span>nombres et chaînes et autres. Puisque le scanner doit parcourir chaque caractère du littéral pour l&rsquo;identifier correctement, il peut aussi convertir cette représentation textuelle d&rsquo;une valeur en l&rsquo;objet vivant à l&rsquo;exécution qui sera utilisé par l&rsquo;interpréteur plus tard.</p>
<h3><a href="#informations-de-localisation" id="informations-de-localisation"><small>4&#8202;.&#8202;2&#8202;.&#8202;3</small>Informations de localisation</a></h3>
<p>Quand je prêchais l&rsquo;évangile sur la gestion des erreurs, nous avons vu que nous devons dire aux utilisateurs <em>où</em> les erreurs se sont produites. Le suivi de cela commence ici. Dans notre interpréteur simple, nous notons seulement sur quelle ligne le token apparaît, mais des implémentations plus sophistiquées incluent aussi la colonne et la longueur.</p>
<aside name="location">
<p>Certaines implémentations de tokens stockent la localisation sous forme de deux nombres : le décalage depuis le début du fichier source jusqu&rsquo;au début du lexème, et la longueur du lexème. Le scanner a besoin de les connaître de toute façon, donc il n&rsquo;y a pas de surcharge à les calculer.</p>
<p>Un décalage peut être converti en positions de ligne et de colonne plus tard en regardant en arrière dans le fichier source et en comptant les retours à la ligne précédents. Cela semble lent, et ça l&rsquo;est. Cependant, vous n&rsquo;avez besoin de le faire <em>que lorsque vous devez réellement afficher une ligne et une colonne à l&rsquo;utilisateur</em>. La plupart des tokens n&rsquo;apparaissent jamais dans un message d&rsquo;erreur. Pour ceux-là, moins vous passez de temps à calculer les informations de position à l&rsquo;avance, mieux c&rsquo;est.</p>
</aside>
<p>Nous prenons toutes ces données et les enveloppons dans une classe.</p>
<div class="codehilite"><div class="source-file"><em>lox/Token.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">class</span> <span class="t">Token</span> {
  <span class="k">final</span> <span class="t">TokenType</span> <span class="i">type</span>;
  <span class="k">final</span> <span class="t">String</span> <span class="i">lexeme</span>;
  <span class="k">final</span> <span class="t">Object</span> <span class="i">literal</span>;
  <span class="k">final</span> <span class="t">int</span> <span class="i">line</span>;<span name="location"> </span>

  <span class="t">Token</span>(<span class="t">TokenType</span> <span class="i">type</span>, <span class="t">String</span> <span class="i">lexeme</span>, <span class="t">Object</span> <span class="i">literal</span>, <span class="t">int</span> <span class="i">line</span>) {
    <span class="k">this</span>.<span class="i">type</span> = <span class="i">type</span>;
    <span class="k">this</span>.<span class="i">lexeme</span> = <span class="i">lexeme</span>;
    <span class="k">this</span>.<span class="i">literal</span> = <span class="i">literal</span>;
    <span class="k">this</span>.<span class="i">line</span> = <span class="i">line</span>;
  }

  <span class="k">public</span> <span class="t">String</span> <span class="i">toString</span>() {
    <span class="k">return</span> <span class="i">type</span> + <span class="s">&quot; &quot;</span> + <span class="i">lexeme</span> + <span class="s">&quot; &quot;</span> + <span class="i">literal</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/Token.java</em>, create new file</div>

<p>Maintenant nous avons un objet avec assez de structure pour être utile pour toutes les phases ultérieures de l&rsquo;interpréteur.</p>
<h2><a href="#langages-réguliers-et-expressions" id="langages-réguliers-et-expressions"><small>4&#8202;.&#8202;3</small>Langages Réguliers et Expressions</a></h2>
<p>Maintenant que nous savons ce que nous essayons de produire, eh bien, produisons-le. Le cœur du scanner est une boucle. En commençant au premier caractère du code source, le scanner détermine à quel lexème le caractère appartient, et le consomme ainsi que tous les caractères suivants qui font partie de ce lexème. Lorsqu&rsquo;il atteint la fin de ce lexème, il émet un token.</p>
<p>Puis il boucle en arrière et recommence, en commençant par le caractère tout juste suivant dans le code source. Il continue à faire cela, mangeant des caractères et occasionnellement, euh, excrétant des tokens, jusqu&rsquo;à ce qu&rsquo;il atteigne la fin de l&rsquo;entrée.</p>
<p><span name="alligator"></span></p><img src="image/scanning/lexigator.png" alt="Un alligator mangeant des caractères et, eh bien, vous ne voulez pas savoir." />
<aside name="alligator">
<p>Lexical analygator. (Jeu de mots intraduisible sur Analysis/Alligator)</p>
</aside>
<p>La partie de la boucle où nous regardons une poignée de caractères pour comprendre quel genre de lexème cela &ldquo;matche&rdquo; peut sembler familière. Si vous connaissez les expressions régulières, vous pourriez envisager de définir une regex pour chaque genre de lexème et de les utiliser pour matcher les caractères. Par exemple, Lox a les mêmes règles que C pour les identifiants (noms de variables et autres). Cette regex en matche une :</p>
<div class="codehilite"><pre>[a-zA-Z_][a-zA-Z_0-9]*
</pre></div>
<p>Si vous avez pensé aux expressions régulières, votre intuition est profonde. Les règles qui déterminent comment un langage particulier regroupe les caractères en lexèmes sont appelées sa <span name="theory"><strong>grammaire lexicale</strong></span>. Dans Lox, comme dans la plupart des langages de programmation, les règles de cette grammaire sont assez simples pour que le langage soit classé comme un <strong>[langage régulier][]</strong>. C&rsquo;est le même &ldquo;régulier&rdquo; que dans les expressions régulières.</p>
<aside name="theory">
<p>Cela me peine de passer autant sous silence la théorie, surtout quand elle est aussi intéressante que je pense que le sont la [hiérarchie de Chomsky][] et les [machines à états finis][]. Mais la vérité honnête est que d&rsquo;autres livres couvrent cela mieux que je ne le pourrais. <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools"><em>Compilers: Principles, Techniques, and Tools</em></a> (universellement connu comme &ldquo;le dragon book&rdquo;) est la référence canonique.</p>
</aside>
<p>Vous pouvez très précisément reconnaître tous les différents lexèmes pour Lox en utilisant des regexes si vous le voulez, et il y a une pile de théorie intéressante sous-jacente sur pourquoi c&rsquo;est ainsi et ce que cela signifie. Des outils comme <a href="http://dinosaur.compilertools.net/lex/">Lex</a> ou <a href="https://github.com/westes/flex">Flex</a> sont conçus expressément pour vous permettre de faire cela<span class="em">&mdash;</span>jetez-leur une poignée de regexes, et ils vous donnent un scanner complet en <span name="lex">retour</span>.</p>
<aside name="lex">
<p>Lex a été créé par Mike Lesk et Eric Schmidt. Oui, le même Eric Schmidt qui fut président exécutif de Google. Je ne dis pas que les langages de programmation sont un chemin infaillible vers la richesse et la gloire, mais nous <em>pouvons</em> compter au moins un mégamilliardaire parmi nous.</p>
</aside>
<p>Puisque notre but est de comprendre comment un scanner fait ce qu&rsquo;il fait, nous ne déléguerons pas cette tâche. Nous sommes pour les produits faits main.</p>
<h2><a href="#la-classe-scanner" id="la-classe-scanner"><small>4&#8202;.&#8202;4</small>La Classe Scanner</a></h2>
<p>Sans plus tarder, faisons-nous un scanner.</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.ArrayList</span>;
<span class="k">import</span> <span class="i">java.util.HashMap</span>;
<span class="k">import</span> <span class="i">java.util.List</span>;
<span class="k">import</span> <span class="i">java.util.Map</span>;

<span class="k">import static</span> <span class="i">com.craftinginterpreters.lox.TokenType.*</span>;<span name="static-import"> </span>

<span class="k">class</span> <span class="t">Scanner</span> {
  <span class="k">private</span> <span class="k">final</span> <span class="t">String</span> <span class="i">source</span>;
  <span class="k">private</span> <span class="k">final</span> <span class="t">List</span>&lt;<span class="t">Token</span>&gt; <span class="i">tokens</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();

  <span class="t">Scanner</span>(<span class="t">String</span> <span class="i">source</span>) {
    <span class="k">this</span>.<span class="i">source</span> = <span class="i">source</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, create new file</div>

<aside name="static-import">
<p>Je sais que les imports statiques sont considérés comme du mauvais style par certains, mais ils m&rsquo;évitent d&rsquo;avoir à saupoudrer <code>TokenType.</code> partout dans le scanner et le parseur. Pardonnez-moi, mais chaque caractère compte dans un livre.</p>
</aside>
<p>Nous stockons le code source brut comme une simple chaîne, et nous avons une liste prête à être remplie avec les tokens que nous allons générer. La boucle susmentionnée qui fait cela ressemble à ceci :</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
add after <em>Scanner</em>()</div>
<pre>  <span class="t">List</span>&lt;<span class="t">Token</span>&gt; <span class="i">scanTokens</span>() {
    <span class="k">while</span> (!<span class="i">isAtEnd</span>()) {
      <span class="c">// We are at the beginning of the next lexeme.</span>
      <span class="i">start</span> = <span class="i">current</span>;
      <span class="i">scanToken</span>();
    }

    <span class="i">tokens</span>.<span class="i">add</span>(<span class="k">new</span> <span class="t">Token</span>(<span class="i">EOF</span>, <span class="s">&quot;&quot;</span>, <span class="k">null</span>, <span class="i">line</span>));
    <span class="k">return</span> <span class="i">tokens</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, add after <em>Scanner</em>()</div>

<p>Le scanner avance à travers le code source, ajoutant des tokens jusqu&rsquo;à ce qu&rsquo;il n&rsquo;y ait plus de caractères. Ensuite, il ajoute un token final &ldquo;fin de fichier&rdquo;. Ce n&rsquo;est pas strictement nécessaire, mais cela rend notre parseur un peu plus propre.</p>
<p>Cette boucle dépend de quelques champs pour garder une trace d&rsquo;où se trouve le scanner dans le code source.</p>
<div class="codehilite"><pre class="insert-before">  private final List&lt;Token&gt; tokens = new ArrayList&lt;&gt;();
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in class <em>Scanner</em></div>
<pre class="insert">  <span class="k">private</span> <span class="t">int</span> <span class="i">start</span> = <span class="n">0</span>;
  <span class="k">private</span> <span class="t">int</span> <span class="i">current</span> = <span class="n">0</span>;
  <span class="k">private</span> <span class="t">int</span> <span class="i">line</span> = <span class="n">1</span>;
</pre><pre class="insert-after">

  Scanner(String source) {
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in class <em>Scanner</em></div>

<p>Les champs <code>start</code> et <code>current</code> sont des décalages qui indexent dans la chaîne. Le champ <code>start</code> pointe vers le premier caractère du lexème en cours de scan, et <code>current</code> pointe vers le caractère actuellement considéré. Le champ <code>line</code> suit sur quelle ligne source se trouve <code>current</code> afin que nous puissions produire des tokens qui connaissent leur emplacement.</p>
<p>Ensuite, nous avons une petite fonction d&rsquo;aide qui nous dit si nous avons consommé tous les caractères.</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
add after <em>scanTokens</em>()</div>
<pre>  <span class="k">private</span> <span class="t">boolean</span> <span class="i">isAtEnd</span>() {
    <span class="k">return</span> <span class="i">current</span> &gt;= <span class="i">source</span>.<span class="i">length</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, add after <em>scanTokens</em>()</div>

<h2><a href="#reconnaître-les-lexèmes" id="reconnaître-les-lexèmes"><small>4&#8202;.&#8202;5</small>Reconnaître les Lexèmes</a></h2>
<p>À chaque tour de boucle, nous scannons un seul token. C&rsquo;est le vrai cœur du scanner. Nous commencerons simplement. Imaginez si chaque lexème ne faisait qu&rsquo;un seul caractère de long. Tout ce que vous auriez à faire serait de consommer le caractère suivant et de choisir un type de token pour lui. Plusieurs lexèmes <em>sont</em> de fait d&rsquo;un seul caractère en Lox, donc commençons par ceux-là.</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
add after <em>scanTokens</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">scanToken</span>() {
    <span class="t">char</span> <span class="i">c</span> = <span class="i">advance</span>();
    <span class="k">switch</span> (<span class="i">c</span>) {
      <span class="k">case</span> <span class="s">&#39;(&#39;</span>: <span class="i">addToken</span>(<span class="i">LEFT_PAREN</span>); <span class="k">break</span>;
      <span class="k">case</span> <span class="s">&#39;)&#39;</span>: <span class="i">addToken</span>(<span class="i">RIGHT_PAREN</span>); <span class="k">break</span>;
      <span class="k">case</span> <span class="s">&#39;{&#39;</span>: <span class="i">addToken</span>(<span class="i">LEFT_BRACE</span>); <span class="k">break</span>;
      <span class="k">case</span> <span class="s">&#39;}&#39;</span>: <span class="i">addToken</span>(<span class="i">RIGHT_BRACE</span>); <span class="k">break</span>;
      <span class="k">case</span> <span class="s">&#39;,&#39;</span>: <span class="i">addToken</span>(<span class="i">COMMA</span>); <span class="k">break</span>;
      <span class="k">case</span> <span class="s">&#39;.&#39;</span>: <span class="i">addToken</span>(<span class="i">DOT</span>); <span class="k">break</span>;
      <span class="k">case</span> <span class="s">&#39;-&#39;</span>: <span class="i">addToken</span>(<span class="i">MINUS</span>); <span class="k">break</span>;
      <span class="k">case</span> <span class="s">&#39;+&#39;</span>: <span class="i">addToken</span>(<span class="i">PLUS</span>); <span class="k">break</span>;
      <span class="k">case</span> <span class="s">&#39;;&#39;</span>: <span class="i">addToken</span>(<span class="i">SEMICOLON</span>); <span class="k">break</span>;
      <span class="k">case</span> <span class="s">&#39;*&#39;</span>: <span class="i">addToken</span>(<span class="i">STAR</span>); <span class="k">break</span>;<span name="slash"> </span>
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, add after <em>scanTokens</em>()</div>

<aside name="slash">
<p>Vous vous demandez pourquoi <code>/</code> n&rsquo;est pas là-dedans ? Ne vous inquiétez pas, nous y viendrons.</p>
</aside>
<p>Encore une fois, nous avons besoin de quelques méthodes d&rsquo;aide.</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
add after <em>isAtEnd</em>()</div>
<pre>  <span class="k">private</span> <span class="t">char</span> <span class="i">advance</span>() {
    <span class="k">return</span> <span class="i">source</span>.<span class="i">charAt</span>(<span class="i">current</span>++);
  }

  <span class="k">private</span> <span class="t">void</span> <span class="i">addToken</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
    <span class="i">addToken</span>(<span class="i">type</span>, <span class="k">null</span>);
  }

  <span class="k">private</span> <span class="t">void</span> <span class="i">addToken</span>(<span class="t">TokenType</span> <span class="i">type</span>, <span class="t">Object</span> <span class="i">literal</span>) {
    <span class="t">String</span> <span class="i">text</span> = <span class="i">source</span>.<span class="i">substring</span>(<span class="i">start</span>, <span class="i">current</span>);
    <span class="i">tokens</span>.<span class="i">add</span>(<span class="k">new</span> <span class="t">Token</span>(<span class="i">type</span>, <span class="i">text</span>, <span class="i">literal</span>, <span class="i">line</span>));
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, add after <em>isAtEnd</em>()</div>

<p>La méthode <code>advance()</code> consomme le caractère suivant dans le fichier source et le renvoie. Là où <code>advance()</code> est pour l&rsquo;entrée, <code>addToken()</code> est pour la sortie. Elle saisit le texte du lexème courant et crée un nouveau token pour lui. Nous utiliserons l&rsquo;autre surcharge pour gérer les tokens avec des valeurs littérales bientôt.</p>
<h3><a href="#erreurs-lexicales" id="erreurs-lexicales"><small>4&#8202;.&#8202;5&#8202;.&#8202;1</small>Erreurs lexicales</a></h3>
<p>Avant d&rsquo;aller trop loin, prenons un moment pour penser aux erreurs au niveau lexical. Que se passe-t-il si un utilisateur jette un fichier source contenant des caractères que Lox n&rsquo;utilise pas, comme <code>@#^</code>, à notre interpréteur ? Pour l&rsquo;instant, ces caractères sont silencieusement ignorés. Ils ne sont pas utilisés par le langage Lox, mais cela ne signifie pas que l&rsquo;interpréteur peut prétendre qu&rsquo;ils ne sont pas là. Au lieu de cela, nous rapportons une erreur.</p>
<div class="codehilite"><pre class="insert-before">      case '*': addToken(STAR); break;<span name="slash"> </span>
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>scanToken</em>()</div>
<pre class="insert">

      <span class="k">default</span>:
        <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">line</span>, <span class="s">&quot;Unexpected character.&quot;</span>);
        <span class="k">break</span>;
</pre><pre class="insert-after">    }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in <em>scanToken</em>()</div>

<p>Notez que le caractère erroné est quand même <em>consommé</em> par l&rsquo;appel précédent à <code>advance()</code>. C&rsquo;est important pour que nous ne restions pas coincés dans une boucle infinie.</p>
<p>Notez aussi que nous <span name="shotgun"><em>continuons à scanner</em></span>. Il peut y avoir d&rsquo;autres erreurs plus loin dans le programme. Cela donne à nos utilisateurs une meilleure expérience si nous en détectons autant que possible en une seule fois. Sinon, ils voient une petite erreur et la corrigent, seulement pour voir l&rsquo;erreur suivante apparaître, et ainsi de suite. Le jeu de la taupe des erreurs de syntaxe n&rsquo;est pas amusant.</p>
<p>(Ne vous inquiétez pas. Puisque <code>hadError</code> est défini, nous n&rsquo;essaierons jamais d&rsquo;<em>exécuter</em> le moindre code, même si nous continuons et scannons le reste.)</p>
<aside name="shotgun">
<p>Le code rapporte chaque caractère invalide séparément, donc cela bombarde l&rsquo;utilisateur d&rsquo;une rafale d&rsquo;erreurs s&rsquo;ils collent accidentellement un gros pâté de texte bizarre. Regrouper une suite de caractères invalides en une seule erreur donnerait une expérience utilisateur plus agréable.</p>
</aside>
<h3><a href="#opérateurs" id="opérateurs"><small>4&#8202;.&#8202;5&#8202;.&#8202;2</small>Opérateurs</a></h3>
<p>Nous avons les lexèmes à caractère unique qui fonctionnent, mais cela ne couvre pas tous les opérateurs de Lox. Quid de <code>!</code> ? C&rsquo;est un seul caractère, non ? Parfois, oui, mais si le caractère juste après est un signe égal, alors nous devrions à la place créer un lexème <code>!=</code>. Notez que le <code>!</code> et le <code>=</code> ne sont <em>pas</em> deux opérateurs indépendants. Vous ne pouvez pas écrire <code>!   =</code> en Lox et avoir le comportement d&rsquo;un opérateur d&rsquo;inégalité. C&rsquo;est pourquoi nous devons scanner <code>!=</code> comme un seul lexème. De même, <code>&lt;</code>, <code>&gt;</code>, et <code>=</code> peuvent tous être suivis par <code>=</code> pour créer les autres opérateurs d&rsquo;égalité et de comparaison.</p>
<p>Pour tous ceux-ci, nous devons regarder le second caractère.</p>
<div class="codehilite"><pre class="insert-before">      case '*': addToken(STAR); break;<span name="slash"> </span>
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>scanToken</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="s">&#39;!&#39;</span>:
        <span class="i">addToken</span>(<span class="i">match</span>(<span class="s">&#39;=&#39;</span>) ? <span class="i">BANG_EQUAL</span> : <span class="i">BANG</span>);
        <span class="k">break</span>;
      <span class="k">case</span> <span class="s">&#39;=&#39;</span>:
        <span class="i">addToken</span>(<span class="i">match</span>(<span class="s">&#39;=&#39;</span>) ? <span class="i">EQUAL_EQUAL</span> : <span class="i">EQUAL</span>);
        <span class="k">break</span>;
      <span class="k">case</span> <span class="s">&#39;&lt;&#39;</span>:
        <span class="i">addToken</span>(<span class="i">match</span>(<span class="s">&#39;=&#39;</span>) ? <span class="i">LESS_EQUAL</span> : <span class="i">LESS</span>);
        <span class="k">break</span>;
      <span class="k">case</span> <span class="s">&#39;&gt;&#39;</span>:
        <span class="i">addToken</span>(<span class="i">match</span>(<span class="s">&#39;=&#39;</span>) ? <span class="i">GREATER_EQUAL</span> : <span class="i">GREATER</span>);
        <span class="k">break</span>;
</pre><pre class="insert-after">

      default:
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in <em>scanToken</em>()</div>

<p>Ces cas utilisent cette nouvelle méthode :</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
add after <em>scanToken</em>()</div>
<pre>  <span class="k">private</span> <span class="t">boolean</span> <span class="i">match</span>(<span class="t">char</span> <span class="i">expected</span>) {
    <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="k">false</span>;
    <span class="k">if</span> (<span class="i">source</span>.<span class="i">charAt</span>(<span class="i">current</span>) != <span class="i">expected</span>) <span class="k">return</span> <span class="k">false</span>;

    <span class="i">current</span>++;
    <span class="k">return</span> <span class="k">true</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, add after <em>scanToken</em>()</div>

<p>C&rsquo;est comme un <code>advance()</code> conditionnel. Nous ne consommons le caractère actuel que s&rsquo;il correspond à ce que nous cherchons.</p>
<p>En utilisant <code>match()</code>, nous reconnaissons ces lexèmes en deux étapes. Lorsque nous atteignons, par exemple, <code>!</code>, nous sautons à son cas dans le switch. Cela signifie que nous savons que le lexème <em>commence</em> par <code>!</code>. Ensuite, nous regardons le caractère suivant pour déterminer si nous sommes sur un <code>!=</code> ou simplement un <code>!</code>.</p>
<h2><a href="#lexèmes-plus-longs" id="lexèmes-plus-longs"><small>4&#8202;.&#8202;6</small>Lexèmes plus longs</a></h2>
<p>Il nous manque encore un opérateur : <code>/</code> pour la division. Ce caractère nécessite un traitement un peu spécial car les commentaires commencent aussi par une barre oblique.</p>
<div class="codehilite"><pre class="insert-before">        break;
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>scanToken</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="s">&#39;/&#39;</span>:
        <span class="k">if</span> (<span class="i">match</span>(<span class="s">&#39;/&#39;</span>)) {
          <span class="c">// A comment goes until the end of the line.</span>
          <span class="k">while</span> (<span class="i">peek</span>() != <span class="s">&#39;\n&#39;</span> &amp;&amp; !<span class="i">isAtEnd</span>()) <span class="i">advance</span>();
        } <span class="k">else</span> {
          <span class="i">addToken</span>(<span class="i">SLASH</span>);
        }
        <span class="k">break</span>;
</pre><pre class="insert-after">

      default:
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in <em>scanToken</em>()</div>

<p>C&rsquo;est similaire aux autres opérateurs à deux caractères, sauf que lorsque nous trouvons un second <code>/</code>, nous ne terminons pas encore le token. Au lieu de cela, nous continuons à consommer des caractères jusqu&rsquo;à ce nous atteignions la fin de la ligne.</p>
<p>C&rsquo;est notre stratégie générale pour gérer les lexèmes plus longs. Après avoir détecté le début de l&rsquo;un d&rsquo;eux, nous basculons vers un code spécifique au lexème qui continue à manger des caractères jusqu&rsquo;à ce qu&rsquo;il voie la fin.</p>
<p>Nous avons un autre assistant :</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
add after <em>match</em>()</div>
<pre>  <span class="k">private</span> <span class="t">char</span> <span class="i">peek</span>() {
    <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="s">&#39;\0&#39;</span>;
    <span class="k">return</span> <span class="i">source</span>.<span class="i">charAt</span>(<span class="i">current</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, add after <em>match</em>()</div>

<p>C&rsquo;est un peu comme <code>advance()</code>, mais ne consomme pas le caractère. Cela s&rsquo;appelle <span name="match"><strong>lookahead</strong></span> (lecture anticipée). Puisqu&rsquo;il ne regarde que le caractère actuel non consommé, nous avons <em>un caractère d&rsquo;anticipation</em>. Plus ce nombre est petit, généralement, plus le scanner s&rsquo;exécute vite. Les règles de la grammaire lexicale dictent combien d&rsquo;anticipation nous avons besoin. Heureusement, la plupart des langages largement utilisés ne regardent qu&rsquo;un ou deux caractères en avance.</p>
<aside name="match">
<p>Techniquement, <code>match()</code> fait aussi de l&rsquo;anticipation. <code>advance()</code> et <code>peek()</code> sont les opérateurs fondamentaux et <code>match()</code> les combine.</p>
</aside>
<p>Les commentaires sont des lexèmes, mais ils ne sont pas significatifs, et le parseur ne veut pas avoir à faire avec eux. Donc, lorsque nous atteignons la fin du commentaire, nous <em>n&rsquo;appelons pas</em> <code>addToken()</code>. Lorsque nous bouclons pour commencer le prochain lexème, <code>start</code> est réinitialisé et le lexème du commentaire disparaît dans un nuage de fumée.</p>
<p>Pendant que nous y sommes, c&rsquo;est le bon moment pour sauter ces autres caractères sans signification : les retours à la ligne et les espaces.</p>
<div class="codehilite"><pre class="insert-before">        break;
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>scanToken</em>()</div>
<pre class="insert">

      <span class="k">case</span> <span class="s">&#39; &#39;</span>:
      <span class="k">case</span> <span class="s">&#39;\r&#39;</span>:
      <span class="k">case</span> <span class="s">&#39;\t&#39;</span>:
        <span class="c">// Ignore whitespace.</span>
        <span class="k">break</span>;

      <span class="k">case</span> <span class="s">&#39;\n&#39;</span>:
        <span class="i">line</span>++;
        <span class="k">break</span>;
</pre><pre class="insert-after">

      default:
        Lox.error(line, &quot;Unexpected character.&quot;);
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in <em>scanToken</em>()</div>

<p>Lorsque nous rencontrons un espace, nous retournons simplement au début de la boucle de scan. Cela commence un nouveau lexème <em>après</em> le caractère d&rsquo;espace. Pour les retours à la ligne, nous faisons la même chose, mais nous incrémentons aussi le compteur de ligne. (C&rsquo;est pourquoi nous avons utilisé <code>peek()</code> pour trouver le retour à la ligne terminant un commentaire au lieu de <code>match()</code>. Nous voulons que ce retour à la ligne nous amène ici pour pouvoir mettre à jour <code>line</code>.)</p>
<p>Notre scanner devient plus intelligent. Il peut gérer du code assez libre comme :</p>
<div class="codehilite"><pre><span class="c">// ceci est un commentaire</span>
(( )){} <span class="c">// des trucs de groupement</span>
!*+-/=&lt;&gt; &lt;= == <span class="c">// opérateurs</span>
</pre></div>
<h3><a href="#littéraux-de-chaîne" id="littéraux-de-chaîne"><small>4&#8202;.&#8202;6&#8202;.&#8202;1</small>Littéraux de chaîne</a></h3>
<p>Maintenant que nous sommes à l&rsquo;aise avec les lexèmes plus longs, nous sommes prêts à nous attaquer aux littéraux. Nous ferons les chaînes en premier, puisqu&rsquo;elles commencent toujours par un caractère spécifique, <code>"</code>.</p>
<div class="codehilite"><pre class="insert-before">        break;
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>scanToken</em>()</div>
<pre class="insert">

      <span class="k">case</span> <span class="s">&#39;&quot;&#39;</span>: <span class="i">string</span>(); <span class="k">break</span>;
</pre><pre class="insert-after">

      default:
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in <em>scanToken</em>()</div>

<p>Cela appelle :</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
add after <em>scanToken</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">string</span>() {
    <span class="k">while</span> (<span class="i">peek</span>() != <span class="s">&#39;&quot;&#39;</span> &amp;&amp; !<span class="i">isAtEnd</span>()) {
      <span class="k">if</span> (<span class="i">peek</span>() == <span class="s">&#39;\n&#39;</span>) <span class="i">line</span>++;
      <span class="i">advance</span>();
    }

    <span class="k">if</span> (<span class="i">isAtEnd</span>()) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">line</span>, <span class="s">&quot;Unterminated string.&quot;</span>);
      <span class="k">return</span>;
    }

    <span class="c">// The closing &quot;.</span>
    <span class="i">advance</span>();

    <span class="c">// Trim the surrounding quotes.</span>
    <span class="t">String</span> <span class="i">value</span> = <span class="i">source</span>.<span class="i">substring</span>(<span class="i">start</span> + <span class="n">1</span>, <span class="i">current</span> - <span class="n">1</span>);
    <span class="i">addToken</span>(<span class="i">STRING</span>, <span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, add after <em>scanToken</em>()</div>

<p>Comme avec les commentaires, nous consommons des caractères jusqu&rsquo;à ce que nous touchions le <code>"</code> qui termine la chaîne. Nous gérons aussi gracieusement le cas où nous manquons d&rsquo;entrée avant que la chaîne ne soit fermée et rapportons une erreur pour cela.</p>
<p>Sans raison particulière, Lox supporte les chaînes multi-lignes. Il y a des pour et des contre à cela, mais les interdire était un peu plus complexe que de les permettre, donc je les ai laissées. Cela signifie que nous devons aussi mettre à jour <code>line</code> quand nous rencontrons un retour à la ligne à l&rsquo;intérieur d&rsquo;une chaîne.</p>
<p>Enfin, le dernier morceau intéressant est que lorsque nous créons le token, nous produisons aussi la <em>valeur</em> réelle de la chaîne qui sera utilisée plus tard par l&rsquo;interpréteur. Ici, cette conversion nécessite seulement un <code>substring()</code> pour enlever les guillemets environnants. Si Lox supportait les séquences d&rsquo;échappement comme <code>\n</code>, nous les déséchapperions ici.</p>
<h3><a href="#littéraux-numériques" id="littéraux-numériques"><small>4&#8202;.&#8202;6&#8202;.&#8202;2</small>Littéraux numériques</a></h3>
<p>Tous les nombres dans Lox sont à virgule flottante à l&rsquo;exécution, mais les littéraux entiers et décimaux sont tous deux supportés. Un littéral numérique est une série de <span name="minus">chiffres</span> optionnellement suivie par un <code>.</code> et un ou plusieurs chiffres suivants.</p>
<aside name="minus">
<p>Puisque nous ne cherchons qu&rsquo;un chiffre pour commencer un nombre, cela signifie que <code>-123</code> n&rsquo;est pas un <em>littéral</em> numérique. Au lieu de cela, <code>-123</code> est une <em>expression</em> qui applique <code>-</code> au littéral numérique <code>123</code>. En pratique, le résultat est le même, bien qu&rsquo;il y ait un cas limite intéressant si nous devions ajouter des appels de méthode sur les nombres. Considérez :</p>
<div class="codehilite"><pre><span class="k">print</span> -<span class="n">123</span>.<span class="i">abs</span>();
</pre></div>
<p>Ceci affiche <code>-123</code> parce que la négation a une précédence plus basse que les appels de méthode. Nous pourrions corriger cela en faisant de <code>-</code> une partie du littéral numérique. Mais considérez alors :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">n</span> = <span class="n">123</span>;
<span class="k">print</span> -<span class="i">n</span>.<span class="i">abs</span>();
</pre></div>
<p>Cela produit toujours <code>-123</code>, donc maintenant le langage semble incohérent. Quoi que vous fassiez, certains cas finissent par être bizarres.</p>
</aside>
<div class="codehilite"><pre><span class="n">1234</span>
<span class="n">12.34</span>
</pre></div>
<p>Nous n&rsquo;autorisons pas de point décimal initial ou final, donc ceux-ci sont tous deux invalides :</p>
<div class="codehilite"><pre>.<span class="n">1234</span>
<span class="n">1234</span>.
</pre></div>
<p>Nous pourrions facilement supporter le premier, mais je l&rsquo;ai laissé de côté pour garder les choses simples. Le second devient bizarre si jamais nous voulons permettre des méthodes sur les nombres comme <code>123.sqrt()</code>.</p>
<p>Pour reconnaître le début d&rsquo;un lexème numérique, nous cherchons n&rsquo;importe quel chiffre. C&rsquo;est un peu fastidieux d&rsquo;ajouter des cas pour chaque chiffre décimal, donc nous le fourrons dans le cas par défaut à la place.</p>
<div class="codehilite"><pre class="insert-before">      default:
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>scanToken</em>()<br>
replace 1 line</div>
<pre class="insert">        <span class="k">if</span> (<span class="i">isDigit</span>(<span class="i">c</span>)) {
          <span class="i">number</span>();
        } <span class="k">else</span> {
          <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">line</span>, <span class="s">&quot;Unexpected character.&quot;</span>);
        }
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in <em>scanToken</em>(), replace 1 line</div>

<p>Cela repose sur ce petit utilitaire :</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
add after <em>peek</em>()</div>
<pre>  <span class="k">private</span> <span class="t">boolean</span> <span class="i">isDigit</span>(<span class="t">char</span> <span class="i">c</span>) {
    <span class="k">return</span> <span class="i">c</span> &gt;= <span class="s">&#39;0&#39;</span> &amp;&amp; <span class="i">c</span> &lt;= <span class="s">&#39;9&#39;</span>;
  }<span name="is-digit"> </span>
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, add after <em>peek</em>()</div>

<aside name="is-digit">
<p>La bibliothèque standard Java fournit <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html#isDigit(char)"><code>Character.isDigit()</code></a>, qui semble être un bon choix. Hélas, cette méthode autorise des choses comme les chiffres Devanagari, les nombres pleine chasse, et d&rsquo;autres trucs drôles dont nous ne voulons pas.</p>
</aside>
<p>Une fois que nous savons que nous sommes dans un nombre, nous bifurquons vers une méthode séparée pour consommer le reste du littéral, comme nous le faisons avec les chaînes.</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
add after <em>scanToken</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">number</span>() {
    <span class="k">while</span> (<span class="i">isDigit</span>(<span class="i">peek</span>())) <span class="i">advance</span>();

    <span class="c">// Look for a fractional part.</span>
    <span class="k">if</span> (<span class="i">peek</span>() == <span class="s">&#39;.&#39;</span> &amp;&amp; <span class="i">isDigit</span>(<span class="i">peekNext</span>())) {
      <span class="c">// Consume the &quot;.&quot;</span>
      <span class="i">advance</span>();

      <span class="k">while</span> (<span class="i">isDigit</span>(<span class="i">peek</span>())) <span class="i">advance</span>();
    }

    <span class="i">addToken</span>(<span class="i">NUMBER</span>,
        <span class="t">Double</span>.<span class="i">parseDouble</span>(<span class="i">source</span>.<span class="i">substring</span>(<span class="i">start</span>, <span class="i">current</span>)));
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, add after <em>scanToken</em>()</div>

<p>Nous consommons autant de chiffres que nous trouvons pour la partie entière du littéral. Ensuite nous cherchons une partie fractionnaire, qui est un point décimal (<code>.</code>) suivi d&rsquo;au moins un chiffre. Si nous avons une partie fractionnaire, encore une fois, nous consommons autant de chiffres que nous pouvons trouver.</p>
<p>Regarder au-delà du point décimal nécessite un deuxième caractère d&rsquo;anticipation puisque nous ne voulons pas consommer le <code>.</code> tant que nous ne sommes pas sûrs qu&rsquo;il y a un chiffre <em>après</em> lui. Donc nous ajoutons :</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
add after <em>peek</em>()</div>
<pre>  <span class="k">private</span> <span class="t">char</span> <span class="i">peekNext</span>() {
    <span class="k">if</span> (<span class="i">current</span> + <span class="n">1</span> &gt;= <span class="i">source</span>.<span class="i">length</span>()) <span class="k">return</span> <span class="s">&#39;\0&#39;</span>;
    <span class="k">return</span> <span class="i">source</span>.<span class="i">charAt</span>(<span class="i">current</span> + <span class="n">1</span>);
  }<span name="peek-next"> </span>
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, add after <em>peek</em>()</div>

<aside name="peek-next">
<p>J&rsquo;aurais pu faire en sorte que <code>peek()</code> prenne un paramètre pour le nombre de caractères à regarder en avant au lieu de définir deux fonctions, mais cela permettrait une anticipation <em>arbitrairement</em> lointaine. Fournir ces deux fonctions rend plus clair pour un lecteur du code que notre scanner regarde en avant au plus deux caractères.</p>
</aside>
<p>Enfin, nous convertissons le lexème en sa valeur numérique. Notre interpréteur utilise le type Java <code>Double</code> pour représenter les nombres, donc nous produisons une valeur de ce type. Nous utilisons la propre méthode de parsing de Java pour convertir le lexème en un vrai double Java. Nous pourrions implémenter cela nous-mêmes, mais, honnêtement, à moins que vous n&rsquo;essayiez de réviser pour un entretien de programmation imminent, cela ne vaut pas votre temps.</p>
<p>Les littéraux restants sont les Booléens et <code>nil</code>, mais nous les gérons comme des mots-clés, ce qui nous amène à<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h2><a href="#mots-réservés-et-identifiants" id="mots-réservés-et-identifiants"><small>4&#8202;.&#8202;7</small>Mots Réservés et Identifiants</a></h2>
<p>Notre scanner est presque terminé. Les seules pièces restantes de la grammaire lexicale à implémenter sont les identifiants et leurs proches cousins, les mots réservés. Vous pourriez penser que nous pourrions matcher les mots-clés comme <code>or</code> de la même manière que nous gérons les opérateurs à plusieurs caractères comme <code>&lt;=</code>.</p>
<div class="codehilite"><pre><span class="k">case</span> <span class="s">&#39;o&#39;</span>:
  <span class="k">if</span> (<span class="i">match</span>(<span class="s">&#39;r&#39;</span>)) {
    <span class="i">addToken</span>(<span class="i">OR</span>);
  }
  <span class="k">break</span>;
</pre></div>
<p>Considérez ce qui se passerait si un utilisateur nommait une variable <code>orchid</code>. Le scanner verrait les deux premières lettres, <code>or</code>, et émettrait immédiatement un token mot-clé <code>or</code>. Cela nous amène à un principe important appelé <span name="maximal"><strong>maximal munch</strong></span> (bouchée maximale). Lorsque deux règles de grammaire lexicale peuvent toutes deux matcher un morceau de code que le scanner regarde, <em>celle qui matche le plus de caractères gagne</em>.</p>
<p>Cette règle stipule que si nous pouvons matcher <code>orchid</code> comme un identifiant et <code>or</code> comme un mot-clé, alors le premier gagne. C&rsquo;est aussi pourquoi nous avons tacitement supposé, précédemment, que <code>&lt;=</code> devrait être scanné comme un seul token <code>&lt;=</code> et non <code>&lt;</code> suivi de <code>=</code>.</p>
<aside name="maximal">
<p>Considérez ce méchant morceau de code C :</p>
<div class="codehilite"><pre>---<span class="i">a</span>;
</pre></div>
<p>Est-ce valide ? Cela dépend de comment le scanner sépare les lexèmes. Et si le scanner le voit comme ça :</p>
<div class="codehilite"><pre>- --<span class="i">a</span>;
</pre></div>
<p>Alors cela pourrait être parsé. Mais cela nécessiterait que le scanner connaisse la structure grammaticale du code environnant, ce qui emmêle les choses plus que nous ne le voulons. Au lieu de cela, la règle du maximal munch dit que c&rsquo;est <em>toujours</em> scanné comme :</p>
<div class="codehilite"><pre>-- -<span class="i">a</span>;
</pre></div>
<p>Il le scanne de cette façon même si le faire conduit à une erreur de syntaxe plus tard dans le parseur.</p>
</aside>
<p>Maximal munch signifie que nous ne pouvons pas facilement détecter un mot réservé avant d&rsquo;avoir atteint la fin de ce qui pourrait être à la place un identifiant. Après tout, un mot réservé <em>est</em> un identifiant, c&rsquo;est juste un qui a été réclamé par le langage pour son propre usage. C&rsquo;est de là que vient le terme <strong>mot réservé</strong>.</p>
<p>Donc nous commençons par supposer que tout lexème commençant par une lettre ou un tiret bas est un identifiant.</p>
<div class="codehilite"><pre class="insert-before">      default:
        if (isDigit(c)) {
          number();
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>scanToken</em>()</div>
<pre class="insert">        } <span class="k">else</span> <span class="k">if</span> (<span class="i">isAlpha</span>(<span class="i">c</span>)) {
          <span class="i">identifier</span>();
</pre><pre class="insert-after">        } else {
          Lox.error(line, &quot;Unexpected character.&quot;);
        }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in <em>scanToken</em>()</div>

<p>Le reste du code vit par ici :</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
add after <em>scanToken</em>()</div>
<pre>  <span class="k">private</span> <span class="t">void</span> <span class="i">identifier</span>() {
    <span class="k">while</span> (<span class="i">isAlphaNumeric</span>(<span class="i">peek</span>())) <span class="i">advance</span>();

    <span class="i">addToken</span>(<span class="i">IDENTIFIER</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, add after <em>scanToken</em>()</div>

<p>Nous définissons cela en termes de ces assistants :</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
add after <em>peekNext</em>()</div>
<pre>  <span class="k">private</span> <span class="t">boolean</span> <span class="i">isAlpha</span>(<span class="t">char</span> <span class="i">c</span>) {
    <span class="k">return</span> (<span class="i">c</span> &gt;= <span class="s">&#39;a&#39;</span> &amp;&amp; <span class="i">c</span> &lt;= <span class="s">&#39;z&#39;</span>) ||
           (<span class="i">c</span> &gt;= <span class="s">&#39;A&#39;</span> &amp;&amp; <span class="i">c</span> &lt;= <span class="s">&#39;Z&#39;</span>) ||
            <span class="i">c</span> == <span class="s">&#39;_&#39;</span>;
  }

  <span class="k">private</span> <span class="t">boolean</span> <span class="i">isAlphaNumeric</span>(<span class="t">char</span> <span class="i">c</span>) {
    <span class="k">return</span> <span class="i">isAlpha</span>(<span class="i">c</span>) || <span class="i">isDigit</span>(<span class="i">c</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, add after <em>peekNext</em>()</div>

<p>Cela fait fonctionner les identifiants. Pour gérer les mots-clés, nous regardons si le lexème de l&rsquo;identifiant est l&rsquo;un des mots réservés. Si c&rsquo;est le cas, nous utilisons un type de token spécifique à ce mot-clé. Nous définissons l&rsquo;ensemble des mots réservés dans une map.</p>
<div class="codehilite"><div class="source-file"><em>lox/Scanner.java</em><br>
in class <em>Scanner</em></div>
<pre>  <span class="k">private</span> <span class="k">static</span> <span class="k">final</span> <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">TokenType</span>&gt; <span class="i">keywords</span>;

  <span class="k">static</span> {
    <span class="i">keywords</span> = <span class="k">new</span> <span class="t">HashMap</span>&lt;&gt;();
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;and&quot;</span>,    <span class="i">AND</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;class&quot;</span>,  <span class="i">CLASS</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;else&quot;</span>,   <span class="i">ELSE</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;false&quot;</span>,  <span class="i">FALSE</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;for&quot;</span>,    <span class="i">FOR</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;fun&quot;</span>,    <span class="i">FUN</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;if&quot;</span>,     <span class="i">IF</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;nil&quot;</span>,    <span class="i">NIL</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;or&quot;</span>,     <span class="i">OR</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;print&quot;</span>,  <span class="i">PRINT</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;return&quot;</span>, <span class="i">RETURN</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;super&quot;</span>,  <span class="i">SUPER</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;this&quot;</span>,   <span class="i">THIS</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;true&quot;</span>,   <span class="i">TRUE</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;var&quot;</span>,    <span class="i">VAR</span>);
    <span class="i">keywords</span>.<span class="i">put</span>(<span class="s">&quot;while&quot;</span>,  <span class="i">WHILE</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in class <em>Scanner</em></div>

<p>Puis, après avoir scanné un identifiant, nous vérifions s&rsquo;il correspond à quelque chose dans la map.</p>
<div class="codehilite"><pre class="insert-before">    while (isAlphaNumeric(peek())) advance();

</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>identifier</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">String</span> <span class="i">text</span> = <span class="i">source</span>.<span class="i">substring</span>(<span class="i">start</span>, <span class="i">current</span>);
    <span class="t">TokenType</span> <span class="i">type</span> = <span class="i">keywords</span>.<span class="i">get</span>(<span class="i">text</span>);
    <span class="k">if</span> (<span class="i">type</span> == <span class="k">null</span>) <span class="i">type</span> = <span class="i">IDENTIFIER</span>;
    <span class="i">addToken</span>(<span class="i">type</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in <em>identifier</em>(), replace 1 line</div>

<p>Si oui, nous utilisons le type de token de ce mot-clé. Sinon, c&rsquo;est un identifiant défini par l&rsquo;utilisateur ordinaire.</p>
<p>Et avec cela, nous avons maintenant un scanner complet pour toute la grammaire lexicale de Lox. Lancez le REPL et tapez un peu de code valide et invalide. Est-ce qu&rsquo;il produit les tokens que vous attendez ? Essayez de trouver quelques cas limites intéressants et voyez s&rsquo;il les gère comme il devrait.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>4&#8202;.&#8202;8</small>Défis</a></h2>
<ol>
<li>
<p>Les grammaires lexicales de Python et Haskell ne sont pas <em>régulières</em>. Qu&rsquo;est-ce que cela signifie, et pourquoi ne le sont-elles pas ?</p>
</li>
<li>
<p>À part pour séparer les tokens<span class="em">&mdash;</span>distinguer <code>print foo</code> de <code>printfoo</code><span class="em">&mdash;</span>les espaces ne sont pas beaucoup utilisés dans la plupart des langages. Cependant, dans quelques coins sombres, un espace <em>affecte</em> comment le code est parsé en CoffeeScript, Ruby, et le préprocesseur C. Où et quel effet cela a-t-il dans chacun de ces langages ?</p>
</li>
<li>
<p>Notre scanner ici, comme la plupart, rejette les commentaires et les espaces puisque ceux-ci ne sont pas nécessaires au parseur. Pourquoi voudriez-vous écrire un scanner qui ne les rejette <em>pas</em> ? Pour quoi cela serait-il utile ?</p>
</li>
<li>
<p>Ajoutez le support au scanner de Lox pour les commentaires par bloc de style C <code>/* ... */</code>. Assurez-vous de gérer les retours à la ligne dedans. Considérez de leur permettre de s&rsquo;imbriquer. Est-ce qu&rsquo;ajouter le support pour l&rsquo;imbrication est plus de travail que vous ne l&rsquo;attendiez ? Pourquoi ?</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--points-virgules-implicites" id="note-de-conception--points-virgules-implicites"><small>4&#8202;.&#8202;9</small>Note de Conception : Points-virgules Implicites</a></h2>
<p>Les programmeurs d&rsquo;aujourd&rsquo;hui ont l&rsquo;embarras du choix en matière de langages et sont devenus difficiles sur la syntaxe. Ils veulent que leur langage paraisse propre et moderne. Un bout de lichen syntaxique que presque chaque nouveau langage gratte (et que certains anciens comme BASIC n&rsquo;ont jamais eu) est le <code>;</code> comme terminateur d&rsquo;instruction explicite.</p>
<p>Au lieu de cela, ils traitent un retour à la ligne comme un terminateur d&rsquo;instruction là où cela a du sens. La partie &ldquo;là où cela a du sens&rdquo; est le morceau difficile. Alors que la <em>plupart</em> des instructions sont sur leur propre ligne, parfois vous avez besoin d&rsquo;étaler une seule instruction sur quelques lignes. Ces retours à la ligne entremêlés ne devraient pas être traités comme des terminateurs.</p>
<p>La plupart des cas évidents où le retour à la ligne devrait être ignoré sont faciles à détecter, mais il y en a une poignée de méchants :</p>
<ul>
<li>
<p>Une valeur de retour sur la ligne suivante :</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">condition</span>) <span class="k">return</span>;
(<span class="s">&quot;value&quot;</span>);
</pre></div>
<p>Est-ce que &ldquo;value&rdquo; est la valeur retournée, ou avons-nous une instruction <code>return</code> sans valeur suivie d&rsquo;une instruction expression contenant un littéral de chaîne ?</p>
</li>
<li>
<p>Une expression entre parenthèses sur la ligne suivante :</p>
<div class="codehilite"><pre><span class="i">func</span>(<span class="i">parenthesized</span>);
</pre></div>
<p>Est-ce un appel à <code>func(parenthesized)</code>, ou deux instructions expression, une pour <code>func</code> et une pour une expression entre parenthèses ?</p>
</li>
<li>
<p>Un <code>-</code> sur la ligne suivante :</p>
<div class="codehilite"><pre><span class="i">first</span> - <span class="i">second</span>;
</pre></div>
<p>Est-ce <code>first - second</code><span class="em">&mdash;</span>une soustraction infixe<span class="em">&mdash;</span>ou deux instructions expression, une pour <code>first</code> et une pour nier <code>second</code> ?</p>
</li>
</ul>
<p>Dans tous ces cas, soit traiter le retour à la ligne comme un séparateur ou non produirait du code valide, mais possiblement pas le code que l&rsquo;utilisateur veut. À travers les langages, il y a une variété inquiétante de règles utilisées pour décider quels retours à la ligne sont des séparateurs. En voici quelques-unes :</p>
<ul>
<li>
<p><a href="https://www.lua.org/pil/1.1.html">Lua</a> ignore complètement les retours à la ligne, mais contrôle soigneusement sa grammaire de telle sorte qu&rsquo;aucun séparateur entre les instructions n&rsquo;est nécessaire du tout dans la plupart des cas. C&rsquo;est parfaitement légitime :</p>
<div class="codehilite"><pre><span class="i">a</span> = <span class="n">1</span> <span class="i">b</span> = <span class="n">2</span>
</pre></div>
<p>Lua évite le problème du <code>return</code> en exigeant qu&rsquo;une instruction <code>return</code> soit la toute dernière instruction d&rsquo;un bloc. S&rsquo;il y a une valeur après <code>return</code> avant le mot-clé <code>end</code>, elle <em>doit</em> être pour le <code>return</code>. Pour les deux autres cas, ils autorisent un <code>;</code> explicite et attendent des utilisateurs qu&rsquo;ils l&rsquo;utilisent. En pratique, cela n&rsquo;arrive presque jamais car il n&rsquo;y a pas d&rsquo;intérêt à une instruction expression parenthésée ou de négation unaire.</p>
</li>
<li>
<p><a href="https://golang.org/ref/spec#Semicolons">Go</a> gère les retours à la ligne dans le scanner. Si un retour à la ligne apparaît à la suite de l&rsquo;un d&rsquo;une poignée de types de tokens qui sont connus pour pouvoir potentiellement terminer une instruction, le retour à la ligne est traité comme un point-virgule. Sinon il est ignoré. L&rsquo;équipe Go fournit un formateur de code canonique, <a href="https://golang.org/cmd/gofmt/">gofmt</a>, et l&rsquo;écosystème est fervent sur son utilisation, ce qui assure que le code stylé de manière idiomatique fonctionne bien avec cette règle simple.</p>
</li>
<li>
<p><a href="https://docs.python.org/3.5/reference/lexical_analysis.html#implicit-line-joining">Python</a> traite tous les retours à la ligne comme significatifs à moins qu&rsquo;un antislash explicite soit utilisé à la fin d&rsquo;une ligne pour la continuer sur la ligne suivante. Cependant, les retours à la ligne n&rsquo;importe où à l&rsquo;intérieur d&rsquo;une paire de crochets (<code>()</code>, <code>[]</code>, ou <code>{}</code>) sont ignorés. Le style idiomatique préfère fortement ces derniers.</p>
<p>Cette règle fonctionne bien pour Python car c&rsquo;est un langage hautement orienté instructions. En particulier, la grammaire de Python assure qu&rsquo;une instruction n&rsquo;apparaît jamais à l&rsquo;intérieur d&rsquo;une expression. C fait la même chose, mais beaucoup d&rsquo;autres langages qui ont une syntaxe de &ldquo;lambda&rdquo; ou de littéral de fonction ne le font pas.</p>
<p>Un exemple en JavaScript :</p>
<div class="codehilite"><pre><span class="i">console</span>.<span class="i">log</span>(<span class="k">function</span> () {
    <span class="i">statement</span>();
});
</pre></div>
<p>Ici, l&rsquo;<em>expression</em> <code>console.log()</code> contient un littéral de fonction qui à son tour contient l&rsquo;<em>instruction</em> <code>statement();</code>.</p>
<p>Python aurait besoin d&rsquo;un ensemble de règles différent pour joindre implicitement les lignes si vous pouviez revenir <em>dans</em> une <span name="lambda">instruction</span> où les retours à la ligne devraient devenir significatifs tout en étant encore imbriqués dans des crochets.</p>
</li>
</ul>
<aside name="lambda">
<p>Et maintenant vous savez pourquoi le <code>lambda</code> de Python autorise seulement un corps d&rsquo;expression unique.</p>
</aside>
<ul>
<li>
<p>La règle d&rsquo;&ldquo;<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-7.9">insertion automatique de point-virgule</a>&rdquo; de JavaScript est la vraie bizarre. Là où d&rsquo;autres langages supposent que la plupart des retours à la ligne <em>sont</em> significatifs et que seuls quelques-uns devraient être ignorés dans les instructions multi-lignes, JS suppose le contraire. Il traite tous vos retours à la ligne comme des espaces sans signification <em>à moins qu&rsquo;il</em> ne rencontre une erreur de parsing. Si c&rsquo;est le cas, il revient en arrière et essaie de transformer le retour à la ligne précédent en un point-virgule pour obtenir quelque chose de grammaticalement valide.</p>
<p>Cette note de conception tournerait en une diatribe de conception si j&rsquo;entrais dans les détails complets de comment cela <em>fonctionne</em> même, et encore moins toutes les diverses façons dont la &ldquo;solution&rdquo; de JavaScript est une mauvaise idée. C&rsquo;est un gâchis. JavaScript est le seul langage que je connaisse où de nombreux guides de style exigent des points-virgules explicites après chaque instruction même si le langage vous laisse théoriquement les élider.</p>
</li>
</ul>
<p>Si vous concevez un nouveau langage, vous devriez presque sûrement <em>éviter</em> un terminateur d&rsquo;instruction explicite. Les programmeurs sont des créatures de mode comme les autres humains, et les points-virgules sont aussi passés que les MOTS-CLÉS EN MAJUSCULES. Assurez-vous juste de choisir un ensemble de règles qui ont du sens pour la grammaire et les idiomes particuliers de votre langage. Et ne faites pas ce que JavaScript a fait.</p>
</div>

<footer>
<a href="représentation-du-code.html" class="next">
  Next Chapter: &ldquo;Représentation du code&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
