<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Classes &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Classes<small>12</small></a></h3>

<ul>
    <li><a href="#poo-et-classes"><small>12.1</small> POO et Classes</a></li>
    <li><a href="#déclarations-de-classe"><small>12.2</small> Déclarations de Classe</a></li>
    <li><a href="#créer-des-instances"><small>12.3</small> Créer des Instances</a></li>
    <li><a href="#propriétés-sur-les-instances"><small>12.4</small> Propriétés sur les Instances</a></li>
    <li><a href="#méthodes-sur-les-classes"><small>12.5</small> Méthodes sur les Classes</a></li>
    <li><a href="#this"><small>12.6</small> This</a></li>
    <li><a href="#constructeurs-et-initialiseurs"><small>12.7</small> Constructeurs et Initialiseurs</a></li>
    <li><a href="#défis"><small>12.8</small> Défis</a></li>
    <li><a href="#note-de-conception--prototypes-et-puissance"><small>12.9</small> Note de Conception : Prototypes et Puissance</a></li>
</ul>


<div class="prev-next">
    <a href="résolution-et-liaison.html" title="Résolution et liaison" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="héritage.html" title="Héritage" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="résolution-et-liaison.html" title="Résolution et liaison" class="prev">←</a>
<a href="héritage.html" title="Héritage" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Classes<small>12</small></a></h3>

<ul>
    <li><a href="#poo-et-classes"><small>12.1</small> POO et Classes</a></li>
    <li><a href="#déclarations-de-classe"><small>12.2</small> Déclarations de Classe</a></li>
    <li><a href="#créer-des-instances"><small>12.3</small> Créer des Instances</a></li>
    <li><a href="#propriétés-sur-les-instances"><small>12.4</small> Propriétés sur les Instances</a></li>
    <li><a href="#méthodes-sur-les-classes"><small>12.5</small> Méthodes sur les Classes</a></li>
    <li><a href="#this"><small>12.6</small> This</a></li>
    <li><a href="#constructeurs-et-initialiseurs"><small>12.7</small> Constructeurs et Initialiseurs</a></li>
    <li><a href="#défis"><small>12.8</small> Défis</a></li>
    <li><a href="#note-de-conception--prototypes-et-puissance"><small>12.9</small> Note de Conception : Prototypes et Puissance</a></li>
</ul>


<div class="prev-next">
    <a href="résolution-et-liaison.html" title="Résolution et liaison" class="left">&larr;&nbsp;Previous</a>
    <a href="un-interpréteur-à-parcours-darbre.html" title="Un interpréteur à parcours d&#x27;arbre">&uarr;&nbsp;Up</a>
    <a href="héritage.html" title="Héritage" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">12</div>
  <h1>Classes</h1>

<blockquote>
<p>On n&rsquo;a le droit ni d&rsquo;aimer ni de haïr quoi que ce soit si l&rsquo;on n&rsquo;a pas acquis une connaissance
approfondie de sa nature. Le grand amour naît de la grande connaissance de l&rsquo;objet
aimé, et si vous ne le connaissez que peu vous serez capable de l&rsquo;aimer seulement
un peu ou pas du tout.</p>
<p><cite>Léonard de Vinci</cite></p>
</blockquote>
<p>Nous sommes à onze chapitres, et l&rsquo;interpréteur assis sur votre machine est presque un langage de script complet. Il pourrait utiliser quelques structures de données intégrées comme des listes et des maps, et il a certainement besoin d&rsquo;une bibliothèque centrale pour les E/S de fichier, l&rsquo;entrée utilisateur, etc. Mais le langage lui-même est suffisant. Nous avons un petit langage procédural dans la même veine que BASIC, Tcl, Scheme (moins les macros), et les premières versions de Python et Lua.</p>
<p>Si nous étions dans les années 80, nous nous arrêterions là. Mais aujourd&rsquo;hui, beaucoup de langages populaires supportent la &ldquo;programmation orientée objet&rdquo;. Ajouter cela à Lox donnera aux utilisateurs un ensemble familier d&rsquo;outils pour écrire des programmes plus grands. Même si vous personnellement n&rsquo;aimez <span name="hate">pas</span> la POO, ce chapitre et <a href="inheritance.html">le suivant</a> vous aideront à comprendre comment d&rsquo;autres conçoivent et construisent des systèmes d&rsquo;objets.</p>
<aside name="hate">
<p>Si vous détestez <em>vraiment</em> les classes, cependant, vous pouvez sauter ces deux chapitres. Ils sont assez isolés du reste du livre. Personnellement, je trouve qu&rsquo;il est bon d&rsquo;en apprendre plus sur les choses que je n&rsquo;aime pas. Les choses semblent simples à distance, mais à mesure que je me rapproche, les détails émergent et je gagne une perspective plus nuancée.</p>
</aside>
<h2><a href="#poo-et-classes" id="poo-et-classes"><small>12&#8202;.&#8202;1</small>POO et Classes</a></h2>
<p>Il y a trois grandes voies vers la programmation orientée objet : les classes, les <a href="http://gameprogrammingpatterns.com/prototype.html">prototypes</a>, et les <span name="multimethods"><a href="https://en.wikipedia.org/wiki/Multiple_dispatch">multiméthodes</a></span>. Les classes sont venues en premier et sont le style le plus populaire. Avec la montée de JavaScript (et dans une moindre mesure <a href="https://www.lua.org/pil/13.4.1.html">Lua</a>), les prototypes sont plus largement connus qu&rsquo;ils ne l&rsquo;étaient. Je parlerai plus de ceux-ci <a href="#design-note">plus tard</a>. Pour Lox, nous prenons l&rsquo;approche, ahem, classique.</p>
<aside name="multimethods">
<p>Les multiméthodes sont l&rsquo;approche avec laquelle vous êtes le moins susceptible d&rsquo;être familier. J&rsquo;adorerais parler plus d&rsquo;elles<span class="em">&mdash;</span>j&rsquo;ai conçu <a href="http://magpie-lang.org/">un langage hobby</a> autour d&rsquo;elles une fois et elles sont <em>super cool</em><span class="em">&mdash;</span>mais il n&rsquo;y a qu&rsquo;un nombre limité de pages que je peux caser. Si vous aimeriez en apprendre plus, jetez un œil à <a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System">CLOS</a> (le système d&rsquo;objet en Common Lisp), <a href="https://opendylan.org/">Dylan</a>, <a href="https://julialang.org/">Julia</a>, ou <a href="https://docs.raku.org/language/functions#Multi-dispatch">Raku</a>.</p>
</aside>
<p>Puisque vous avez écrit environ mille lignes de code Java avec moi déjà, je suppose que vous n&rsquo;avez pas besoin d&rsquo;une introduction détaillée à l&rsquo;orientation objet. Le but principal est d&rsquo;empaqueter des données avec le code qui agit dessus. Les utilisateurs font cela en déclarant une <em>classe</em> qui :</p>
<p><span name="circle"></span></p>
<ol>
<li>
<p>Expose un <em>constructeur</em> pour créer et initialiser de nouvelles <em>instances</em> de la classe</p>
</li>
<li>
<p>Fournit un moyen de stocker et d&rsquo;accéder à des <em>champs</em> sur les instances</p>
</li>
<li>
<p>Définit un ensemble de <em>méthodes</em> partagées par toutes les instances de la classe qui opèrent sur l&rsquo;état de chaque instance.</p>
</li>
</ol>
<p>C&rsquo;est à peu près aussi minimal que possible. La plupart des langages orientés objet, tout le chemin en arrière jusqu&rsquo;à Simula, font aussi de l&rsquo;héritage pour réutiliser le comportement à travers les classes. Nous ajouterons cela dans le <a href="inheritance.html">prochain chapitre</a>. Même en virant cela, nous avons encore beaucoup à traverser. C&rsquo;est un gros chapitre et tout ne s&rsquo;assemble pas tout à fait jusqu&rsquo;à ce que nous ayons toutes les pièces ci-dessus, donc rassemblez votre endurance.</p>
<aside name="circle"><img src="image/classes/circle.png" alt="Les relations entre classes, méthodes, instances, constructeurs, et champs." />
<p>C&rsquo;est comme le cycle de la vie, <em>sans</em> Sir Elton John.</p>
</aside>
<h2><a href="#déclarations-de-classe" id="déclarations-de-classe"><small>12&#8202;.&#8202;2</small>Déclarations de Classe</a></h2>
<p>Comme nous faisons, nous allons commencer avec la syntaxe. Une instruction <code>class</code> introduit un nouveau nom, donc elle vit dans la règle de grammaire <code>declaration</code>.</p>
<div class="codehilite"><pre><span class="i">declaration</span>    → <span class="i">classDecl</span>
               | <span class="i">funDecl</span>
               | <span class="i">varDecl</span>
               | <span class="i">statement</span> ;

<span class="i">classDecl</span>      → <span class="s">&quot;class&quot;</span> <span class="t">IDENTIFIER</span> <span class="s">&quot;{&quot;</span> <span class="i">function</span>* <span class="s">&quot;}&quot;</span> ;
</pre></div>
<p>La nouvelle règle <code>classDecl</code> repose sur la règle <code>function</code> que nous avons définie <a href="functions.html#function-declarations">plus tôt</a>. Pour rafraîchir votre mémoire :</p>
<div class="codehilite"><pre><span class="i">function</span>       → <span class="t">IDENTIFIER</span> <span class="s">&quot;(&quot;</span> <span class="i">parameters</span>? <span class="s">&quot;)&quot;</span> <span class="i">block</span> ;
<span class="i">parameters</span>     → <span class="t">IDENTIFIER</span> ( <span class="s">&quot;,&quot;</span> <span class="t">IDENTIFIER</span> )* ;
</pre></div>
<p>En français clair, une déclaration de classe est le mot-clé <code>class</code>, suivi par le nom de la classe, puis un corps entre accolades. À l&rsquo;intérieur de ce corps est une liste de déclarations de méthode. Contrairement aux déclarations de fonction, les méthodes n&rsquo;ont pas de mot-clé <span name="fun"><code>fun</code></span> en tête. Chaque méthode est un nom, une liste de paramètres, et un corps. Voici un exemple :</p>
<aside name="fun">
<p>Pas que j&rsquo;essaie de dire que les méthodes ne sont pas fun ou quoi que ce soit.</p>
</aside>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Breakfast</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">&quot;Eggs a-fryin&#39;!&quot;</span>;
  }

  <span class="i">serve</span>(<span class="i">who</span>) {
    <span class="k">print</span> <span class="s">&quot;Enjoy your breakfast, &quot;</span> + <span class="i">who</span> + <span class="s">&quot;.&quot;</span>;
  }
}
</pre></div>
<p>Comme la plupart des langages typés dynamiquement, les champs ne sont pas explicitement listés dans la déclaration de classe. Les instances sont des sacs lâches de données et vous pouvez librement leur ajouter des champs comme bon vous semble en utilisant du code impératif normal.</p>
<p>Là-bas dans notre générateur AST, la règle de grammaire <code>classDecl</code> obtient son propre <span name="class-ast">nœud</span> d&rsquo;instruction.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Block      : List&lt;Stmt&gt; statements&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Class      : Token name, List&lt;Stmt.Function&gt; methods&quot;</span>,
</pre><pre class="insert-after">      &quot;Expression : Expr expression&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="class-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#class-statement">Annexe II</a>.</p>
</aside>
<p>Il stocke le nom de la classe et les méthodes à l&rsquo;intérieur de son corps. Les méthodes sont représentées par la classe Stmt.Function existante que nous utilisons pour les nœuds AST de déclaration de fonction. Cela nous donne tous les bouts d&rsquo;état dont nous avons besoin pour une méthode : nom, liste de paramètres, et corps.</p>
<p>Une classe peut apparaître n&rsquo;importe où une déclaration nommée est autorisée, déclenchée par le mot-clé <code>class</code> en tête.</p>
<div class="codehilite"><pre class="insert-before">    try {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>declaration</em>()</div>
<pre class="insert">      <span class="k">if</span> (<span class="i">match</span>(<span class="i">CLASS</span>)) <span class="k">return</span> <span class="i">classDeclaration</span>();
</pre><pre class="insert-after">      if (match(FUN)) return function(&quot;function&quot;);
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>declaration</em>()</div>

<p>Cela appelle vers :</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>declaration</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">classDeclaration</span>() {
    <span class="t">Token</span> <span class="i">name</span> = <span class="i">consume</span>(<span class="i">IDENTIFIER</span>, <span class="s">&quot;Expect class name.&quot;</span>);
    <span class="i">consume</span>(<span class="i">LEFT_BRACE</span>, <span class="s">&quot;Expect &#39;{&#39; before class body.&quot;</span>);

    <span class="t">List</span>&lt;<span class="t">Stmt</span>.<span class="t">Function</span>&gt; <span class="i">methods</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();
    <span class="k">while</span> (!<span class="i">check</span>(<span class="i">RIGHT_BRACE</span>) &amp;&amp; !<span class="i">isAtEnd</span>()) {
      <span class="i">methods</span>.<span class="i">add</span>(<span class="i">function</span>(<span class="s">&quot;method&quot;</span>));
    }

    <span class="i">consume</span>(<span class="i">RIGHT_BRACE</span>, <span class="s">&quot;Expect &#39;}&#39; after class body.&quot;</span>);

    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Class</span>(<span class="i">name</span>, <span class="i">methods</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>declaration</em>()</div>

<p>Il y a plus de viande ici que dans la plupart des autres méthodes de parsing, mais cela suit grossièrement la grammaire. Nous avons déjà consommé le mot-clé <code>class</code>, donc nous cherchons le nom de classe attendu ensuite, suivi par l&rsquo;accolade ouvrante. Une fois à l&rsquo;intérieur du corps, nous continuons à parser des déclarations de méthode jusqu&rsquo;à ce que nous frappions l&rsquo;accolade fermante. Chaque déclaration de méthode est parsée par un appel à <code>function()</code>, que nous avons défini là-bas dans le <a href="functions.html">chapitre où les fonctions ont été introduites</a>.</p>
<p>Comme nous le faisons dans toute boucle ouverte dans le parseur, nous vérifions aussi si nous frappons la fin du fichier. Cela n&rsquo;arrivera pas dans le code correct puisqu&rsquo;une classe devrait avoir une accolade fermante à la fin, mais cela assure que le parseur ne reste pas coincé dans une boucle infinie si l&rsquo;utilisateur a une erreur de syntaxe et oublie de finir correctement le corps de la classe.</p>
<p>Nous enveloppons le nom et la liste de méthodes dans un nœud Stmt.Class et nous avons fini. Précédemment, nous aurions sauté directement dans l&rsquo;interpréteur, mais maintenant nous devons d&rsquo;abord passer le nœud à travers le résolveur.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitBlockStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitClassStmt</span>(<span class="t">Stmt</span>.<span class="t">Class</span> <span class="i">stmt</span>) {
    <span class="i">declare</span>(<span class="i">stmt</span>.<span class="i">name</span>);
    <span class="i">define</span>(<span class="i">stmt</span>.<span class="i">name</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitBlockStmt</em>()</div>

<p>Nous n&rsquo;allons pas nous inquiéter de résoudre les méthodes elles-mêmes encore, donc pour l&rsquo;instant tout ce que nous avons besoin de faire est de déclarer la classe en utilisant son nom. Ce n&rsquo;est pas courant de déclarer une classe comme une variable locale, mais Lox le permet, donc nous devons le gérer correctement.</p>
<p>Maintenant nous interprétons la déclaration de classe.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitBlockStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitClassStmt</span>(<span class="t">Stmt</span>.<span class="t">Class</span> <span class="i">stmt</span>) {
    <span class="i">environment</span>.<span class="i">define</span>(<span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>, <span class="k">null</span>);
    <span class="t">LoxClass</span> <span class="i">klass</span> = <span class="k">new</span> <span class="t">LoxClass</span>(<span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>);
    <span class="i">environment</span>.<span class="i">assign</span>(<span class="i">stmt</span>.<span class="i">name</span>, <span class="i">klass</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitBlockStmt</em>()</div>

<p>Cela ressemble à comment nous exécutons les déclarations de fonction. Nous déclarons le nom de la classe dans l&rsquo;environnement courant. Ensuite nous transformons le <em>nœud de syntaxe</em> de classe en une LoxClass, la représentation à l&rsquo;<em>exécution</em> d&rsquo;une classe. Nous revenons en arrière et stockons l&rsquo;objet classe dans la variable que nous avons précédemment déclarée. Ce processus de liaison de variable en deux étapes permet des références à la classe à l&rsquo;intérieur de ses propres méthodes.</p>
<p>Nous allons la raffiner tout au long du chapitre, mais le premier brouillon de LoxClass ressemble à ceci :</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxClass.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.List</span>;
<span class="k">import</span> <span class="i">java.util.Map</span>;

<span class="k">class</span> <span class="t">LoxClass</span> {
  <span class="k">final</span> <span class="t">String</span> <span class="i">name</span>;

  <span class="t">LoxClass</span>(<span class="t">String</span> <span class="i">name</span>) {
    <span class="k">this</span>.<span class="i">name</span> = <span class="i">name</span>;
  }

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">toString</span>() {
    <span class="k">return</span> <span class="i">name</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, create new file</div>

<p>Littéralement une enveloppe autour d&rsquo;un nom. Nous ne stockons même pas les méthodes encore. Pas super utile, mais elle a une méthode <code>toString()</code> pour que nous puissions écrire un script trivial et tester que les objets classe sont réellement parsés et exécutés.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">DevonshireCream</span> {
  <span class="i">serveOn</span>() {
    <span class="k">return</span> <span class="s">&quot;Scones&quot;</span>;
  }
}

<span class="k">print</span> <span class="t">DevonshireCream</span>; <span class="c">// Imprime &quot;DevonshireCream&quot;.</span>
</pre></div>
<h2><a href="#créer-des-instances" id="créer-des-instances"><small>12&#8202;.&#8202;3</small>Créer des Instances</a></h2>
<p>Nous avons des classes, mais elles ne font rien encore. Lox n&rsquo;a pas de méthodes &ldquo;statiques&rdquo; que vous pouvez appeler directement sur la classe elle-même, donc sans instances réelles, les classes sont inutiles. Ainsi les instances sont la prochaine étape.</p>
<p>Bien que certaines syntaxes et sémantiques soient assez standard à travers les langages POO, la façon dont vous créez de nouvelles instances ne l&rsquo;est pas. Ruby, suivant Smalltalk, crée des instances en appelant une méthode sur l&rsquo;objet classe lui-même, une approche <span name="turtles">récursivement</span> gracieuse. Certains, comme C++ et Java, ont un mot-clé <code>new</code> dédié à donner naissance à un nouvel objet. Python vous fait &ldquo;appeler&rdquo; la classe elle-même comme une fonction. (JavaScript, toujours bizarre, fait en quelque sorte les deux.)</p>
<aside name="turtles">
<p>En Smalltalk, même les <em>classes</em> sont créées en appelant des méthodes sur un objet existant, habituellement la superclasse désirée. C&rsquo;est en quelque sorte une chose où il y a des tortues tout le long vers le bas. Cela touche finalement le fond sur quelques classes magiques comme Object et Metaclass que le runtime conjure dans l&rsquo;être <em>ex nihilo</em>.</p>
</aside>
<p>J&rsquo;ai pris une approche minimale avec Lox. Nous avons déjà des objets classe, et nous avons déjà des appels de fonction, donc nous utiliserons des expressions d&rsquo;appel sur des objets classe pour créer de nouvelles instances. C&rsquo;est comme si une classe était une fonction usine qui génère des instances d&rsquo;elle-même. Cela semble élégant pour moi, et nous épargne aussi le besoin d&rsquo;introduire une syntaxe comme <code>new</code>. Par conséquent, nous pouvons passer outre le front end directement dans le runtime.</p>
<p>Tout de suite, si vous essayez ceci :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Bagel</span> {}
<span class="t">Bagel</span>();
</pre></div>
<p>Vous obtenez une erreur d&rsquo;exécution. <code>visitCallExpr()</code> vérifie pour voir si l&rsquo;objet appelé implémente <code>LoxCallable</code> et rapporte une erreur puisque LoxClass ne le fait pas. Pas <em>encore</em>, c&rsquo;est-à-dire.</p>
<div class="codehilite"><pre class="insert-before">import java.util.Map;

</pre><div class="source-file"><em>lox/LoxClass.java</em><br>
replace 1 line</div>
<pre class="insert"><span class="k">class</span> <span class="t">LoxClass</span> <span class="k">implements</span> <span class="t">LoxCallable</span> {
</pre><pre class="insert-after">  final String name;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, replace 1 line</div>

<p>Implémenter cette interface exige deux méthodes.</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxClass.java</em><br>
add after <em>toString</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">call</span>(<span class="t">Interpreter</span> <span class="i">interpreter</span>,
                     <span class="t">List</span>&lt;<span class="t">Object</span>&gt; <span class="i">arguments</span>) {
    <span class="t">LoxInstance</span> <span class="i">instance</span> = <span class="k">new</span> <span class="t">LoxInstance</span>(<span class="k">this</span>);
    <span class="k">return</span> <span class="i">instance</span>;
  }

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">int</span> <span class="i">arity</span>() {
    <span class="k">return</span> <span class="n">0</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, add after <em>toString</em>()</div>

<p>Celle intéressante est <code>call()</code>. Quand vous &ldquo;appelez&rdquo; une classe, elle instancie une nouvelle LoxInstance pour la classe appelée et la renvoie. La méthode <code>arity()</code> est comment l&rsquo;interpréteur valide que vous avez passé le bon nombre d&rsquo;arguments à un appelable. Pour l&rsquo;instant, nous dirons que vous ne pouvez en passer aucun. Quand nous arriverons aux constructeurs définis par l&rsquo;utilisateur, nous revisiterons cela.</p>
<p>Cela nous mène à LoxInstance, la représentation exécution d&rsquo;une instance d&rsquo;une classe Lox. Encore une fois, notre première implémentation commence petit.</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxInstance.java</em><br>
create new file</div>
<pre><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.HashMap</span>;
<span class="k">import</span> <span class="i">java.util.Map</span>;

<span class="k">class</span> <span class="t">LoxInstance</span> {
  <span class="k">private</span> <span class="t">LoxClass</span> <span class="i">klass</span>;

  <span class="t">LoxInstance</span>(<span class="t">LoxClass</span> <span class="i">klass</span>) {
    <span class="k">this</span>.<span class="i">klass</span> = <span class="i">klass</span>;
  }

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">toString</span>() {
    <span class="k">return</span> <span class="i">klass</span>.<span class="i">name</span> + <span class="s">&quot; instance&quot;</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/LoxInstance.java</em>, create new file</div>

<p>Comme LoxClass, c&rsquo;est assez squelettique, mais nous ne faisons que commencer. Si vous voulez lui donner un essai, voici un script à lancer :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Bagel</span> {}
<span class="k">var</span> <span class="i">bagel</span> = <span class="t">Bagel</span>();
<span class="k">print</span> <span class="i">bagel</span>; <span class="c">// Imprime &quot;Bagel instance&quot;.</span>
</pre></div>
<p>Ce programme ne fait pas grand-chose, mais il commence à faire <em>quelque chose</em>.</p>
<h2><a href="#propriétés-sur-les-instances" id="propriétés-sur-les-instances"><small>12&#8202;.&#8202;4</small>Propriétés sur les Instances</a></h2>
<p>Nous avons des instances, donc nous devrions les rendre utiles. Nous sommes à un embranchement sur la route. Nous pourrions ajouter du comportement d&rsquo;abord<span class="em">&mdash;</span>des méthodes<span class="em">&mdash;</span>ou nous pourrions commencer avec l&rsquo;état<span class="em">&mdash;</span>des propriétés. Nous allons prendre ce dernier car, comme nous le verrons, les deux deviennent intriqués d&rsquo;une façon intéressante et il sera plus facile de leur donner du sens si nous faisons fonctionner les propriétés d&rsquo;abord.</p>
<p>Lox suit JavaScript et Python dans comment il gère l&rsquo;état. Chaque instance est une collection ouverte de valeurs nommées. Les méthodes sur la classe de l&rsquo;instance peuvent accéder et modifier les propriétés, mais le code <span name="outside">externe</span> le peut aussi. Les propriétés sont accédées en utilisant une syntaxe <code>.</code>.</p>
<aside name="outside">
<p>Permettre au code en dehors de la classe de modifier directement les champs d&rsquo;un objet va à l&rsquo;encontre du credo orienté objet qu&rsquo;une classe <em>encapsule</em> l&rsquo;état. Certains langages prennent une position plus fondée sur des principes. En Smalltalk, les champs sont accédés en utilisant des identifieurs simples<span class="em">&mdash;</span>essentiellement, des variables qui sont seulement dans la portée à l&rsquo;intérieur des méthodes d&rsquo;une classe. Ruby utilise <code>@</code> suivi par un nom pour accéder à un champ dans un objet. Cette syntaxe est seulement significative à l&rsquo;intérieur d&rsquo;une méthode et accède toujours à l&rsquo;état sur l&rsquo;objet courant.</p>
<p>Lox, pour le meilleur ou pour le pire, n&rsquo;est pas tout à fait si pieux à propos de sa foi POO.</p>
</aside>
<div class="codehilite"><pre><span class="i">objet</span>.<span class="i">propriete</span>
</pre></div>
<p>Une expression suivie par <code>.</code> et un identifieur lit la propriété avec ce nom depuis l&rsquo;objet en lequel l&rsquo;expression s&rsquo;évalue. Ce point a la même précédence que les parenthèses dans une expression d&rsquo;appel de fonction, donc nous le glissons dans la grammaire en remplaçant la règle <code>call</code> existante par :</p>
<div class="codehilite"><pre><span class="i">call</span>           → <span class="i">primary</span> ( <span class="s">&quot;(&quot;</span> <span class="i">arguments</span>? <span class="s">&quot;)&quot;</span> | <span class="s">&quot;.&quot;</span> <span class="t">IDENTIFIER</span> )* ;
</pre></div>
<p>Après une expression primaire, nous permettons une série de n&rsquo;importe quel mélange d&rsquo;appels parenthésés et d&rsquo;accès aux propriétés avec point. &ldquo;Accès aux propriétés&rdquo; est une bouchée, donc d&rsquo;ici là, nous appellerons ceux-ci des &ldquo;expressions d&rsquo;accès&rdquo; (get expressions).</p>
<h3><a href="#expressions-daccès" id="expressions-daccès"><small>12&#8202;.&#8202;4&#8202;.&#8202;1</small>Expressions d&rsquo;accès</a></h3>
<p>Le <span name="get-ast">nœud d&rsquo;arbre syntaxique</span> est :</p>
<div class="codehilite"><pre class="insert-before">      &quot;Call     : Expr callee, Token paren, List&lt;Expr&gt; arguments&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Get      : Expr object, Token name&quot;</span>,
</pre><pre class="insert-after">      &quot;Grouping : Expr expression&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="get-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#get-expression">Annexe II</a>.</p>
</aside>
<p>Suivant la grammaire, le nouveau code de parsing va dans notre méthode <code>call()</code> existante.</p>
<div class="codehilite"><pre class="insert-before">    while (true) {<span name="while-true"> </span>
      if (match(LEFT_PAREN)) {
        expr = finishCall(expr);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>call</em>()</div>
<pre class="insert">      } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="i">DOT</span>)) {
        <span class="t">Token</span> <span class="i">name</span> = <span class="i">consume</span>(<span class="i">IDENTIFIER</span>,
            <span class="s">&quot;Expect property name after &#39;.&#39;.&quot;</span>);
        <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Get</span>(<span class="i">expr</span>, <span class="i">name</span>);
</pre><pre class="insert-after">      } else {
        break;
      }
    }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>call</em>()</div>

<p>La boucle <code>while</code> externe là correspond au <code>*</code> dans la règle de grammaire. Nous zippons le long des tokens construisant une chaîne d&rsquo;appels et d&rsquo;accès alors que nous trouvons des parenthèses et des points, comme ceci :</p><img src="image/classes/zip.png" alt="Parser une série d'expressions '.' et '()' en un AST." />
<p>Les instances du nouveau nœud Expr.Get alimentent le résolveur.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitCallExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitGetExpr</span>(<span class="t">Expr</span>.<span class="t">Get</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">object</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitCallExpr</em>()</div>

<p>OK, pas grand chose à cela. Puisque les propriétés sont cherchées <span name="dispatch">dynamiquement</span>, elles ne sont pas résolues. Pendant la résolution, nous récursons seulement dans l&rsquo;expression à la gauche du point. L&rsquo;accès réel à la propriété se produit dans l&rsquo;interpréteur.</p>
<aside name="dispatch">
<p>Vous pouvez littéralement voir que le dispatch de propriété dans Lox est dynamique puisque nous ne traitons pas le nom de propriété pendant la passe de résolution statique.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitCallExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitGetExpr</span>(<span class="t">Expr</span>.<span class="t">Get</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">object</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">object</span>);
    <span class="k">if</span> (<span class="i">object</span> <span class="k">instanceof</span> <span class="t">LoxInstance</span>) {
      <span class="k">return</span> ((<span class="t">LoxInstance</span>) <span class="i">object</span>).<span class="i">get</span>(<span class="i">expr</span>.<span class="i">name</span>);
    }

    <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">expr</span>.<span class="i">name</span>,
        <span class="s">&quot;Only instances have properties.&quot;</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitCallExpr</em>()</div>

<p>D&rsquo;abord, nous évaluons l&rsquo;expression dont la propriété est accédée. Dans Lox, seules les instances de classes ont des propriétés. Si l&rsquo;objet est un autre type comme un nombre, invoquer un getter dessus est une erreur d&rsquo;exécution.</p>
<p>Si l&rsquo;objet est une LoxInstance, alors nous lui demandons de chercher la propriété. Il doit être temps de donner à LoxInstance un état réel. Une map fera l&rsquo;affaire.</p>
<div class="codehilite"><pre class="insert-before">  private LoxClass klass;
</pre><div class="source-file"><em>lox/LoxInstance.java</em><br>
in class <em>LoxInstance</em></div>
<pre class="insert">  <span class="k">private</span> <span class="k">final</span> <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">Object</span>&gt; <span class="i">fields</span> = <span class="k">new</span> <span class="t">HashMap</span>&lt;&gt;();
</pre><pre class="insert-after">

  LoxInstance(LoxClass klass) {
</pre></div>
<div class="source-file-narrow"><em>lox/LoxInstance.java</em>, in class <em>LoxInstance</em></div>

<p>Chaque clé dans la map est un nom de propriété et la valeur correspondante est la valeur de la propriété. Pour chercher une propriété sur une instance :</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxInstance.java</em><br>
add after <em>LoxInstance</em>()</div>
<pre>  <span class="t">Object</span> <span class="i">get</span>(<span class="t">Token</span> <span class="i">name</span>) {
    <span class="k">if</span> (<span class="i">fields</span>.<span class="i">containsKey</span>(<span class="i">name</span>.<span class="i">lexeme</span>)) {
      <span class="k">return</span> <span class="i">fields</span>.<span class="i">get</span>(<span class="i">name</span>.<span class="i">lexeme</span>);
    }

    <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">name</span>,<span name="hidden"> </span>
        <span class="s">&quot;Undefined property &#39;&quot;</span> + <span class="i">name</span>.<span class="i">lexeme</span> + <span class="s">&quot;&#39;.&quot;</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxInstance.java</em>, add after <em>LoxInstance</em>()</div>

<aside name="hidden">
<p>Faire une recherche dans une table de hachage pour chaque accès de champ est assez rapide pour beaucoup d&rsquo;implémentations de langage, mais pas idéal. Les VMs haute performance pour des langages comme JavaScript utilisent des optimisations sophistiquées comme les &ldquo;<a href="http://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html">classes cachées</a>&rdquo; pour éviter cette surcharge.</p>
<p>Paradoxalement, beaucoup des optimisations inventées pour rendre les langages dynamiques rapides reposent sur l&rsquo;observation que<span class="em">&mdash;</span>même dans ces langages<span class="em">&mdash;</span>la plupart du code est assez statique en termes des types d&rsquo;objets avec lesquels il travaille et de leurs champs.</p>
</aside>
<p>Un cas limite intéressant que nous devons gérer est ce qui arrive si l&rsquo;instance n&rsquo;a <em>pas</em> une propriété avec le nom donné. Nous pourrions silencieusement renvoyer une certaine valeur factice comme <code>nil</code>, mais mon expérience avec des langages comme JavaScript est que ce comportement masque des bugs plus souvent qu&rsquo;il ne fait quoi que ce soit d&rsquo;utile. Au lieu de cela, nous en ferons une erreur d&rsquo;exécution.</p>
<p>Donc la première chose que nous faisons est de voir si l&rsquo;instance a réellement un champ avec le nom donné. Seulement alors nous le renvoyons. Sinon, nous levons une erreur.</p>
<p>Notez comment j&rsquo;ai changé de parler de &ldquo;propriétés&rdquo; à &ldquo;champs&rdquo;. Il y a une différence subtile entre les deux. Les champs sont des bits d&rsquo;état nommés stockés directement dans une instance. Les propriétés sont les <em>choses</em> nommées, uh, qu&rsquo;une expression d&rsquo;accès peut renvoyer. Chaque champ est une propriété, mais comme nous le verrons <span name="foreshadowing">plus tard</span>, pas chaque propriété est un champ.</p>
<aside name="foreshadowing">
<p>Ooh, préfiguration. Effrayant !</p>
</aside>
<p>En théorie, nous pouvons maintenant lire des propriétés sur des objets. Mais puisqu&rsquo;il n&rsquo;y a aucun moyen de bourrer réellement un état dans une instance, il n&rsquo;y a pas de champs auxquels accéder. Avant que nous puissions tester la lecture, nous devons supporter l&rsquo;écriture.</p>
<h3><a href="#expressions-daffectation" id="expressions-daffectation"><small>12&#8202;.&#8202;4&#8202;.&#8202;2</small>Expressions d&rsquo;affectation</a></h3>
<p>Les setters utilisent la même syntaxe que les getters, sauf qu&rsquo;ils apparaissent du côté gauche d&rsquo;une assignation.</p>
<div class="codehilite"><pre><span class="i">objet</span>.<span class="i">propriete</span> = <span class="i">valeur</span>;
</pre></div>
<p>Au pays de la grammaire, nous étendons la règle pour l&rsquo;assignation pour permettre des identifieurs pointés sur le côté gauche.</p>
<div class="codehilite"><pre><span class="i">assignment</span>     → ( <span class="i">call</span> <span class="s">&quot;.&quot;</span> )? <span class="t">IDENTIFIER</span> <span class="s">&quot;=&quot;</span> <span class="i">assignment</span>
               | <span class="i">logic_or</span> ;
</pre></div>
<p>Contrairement aux getters, les setters ne s&rsquo;enchaînent pas. Cependant, la référence à <code>call</code> permet n&rsquo;importe quelle expression à haute précédence avant le dernier point, incluant n&rsquo;importe quel nombre de <em>getters</em>, comme dans :</p><img src="image/classes/setter.png" alt="breakfast.omelette.filling.meat = ham" />
<p>Notez ici que seulement la <em>dernière</em> partie, le <code>.meat</code> est le <em>setter</em>. Les parties <code>.omelette</code> et <code>.filling</code> sont tous les deux des expressions <em>get</em>.</p>
<p>Tout comme nous avons deux nœuds AST séparés pour l&rsquo;accès de variable et l&rsquo;assignation de variable, nous avons besoin d&rsquo;un <span name="set-ast">second nœud setter</span> pour compléter notre nœud getter.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Logical  : Expr left, Token operator, Expr right&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Set      : Expr object, Token name, Expr value&quot;</span>,
</pre><pre class="insert-after">      &quot;Unary    : Token operator, Expr right&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="set-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#set-expression">Annexe II</a>.</p>
</aside>
<p>Au cas où vous ne vous souvenez pas, la façon dont nous gérons l&rsquo;assignation dans le parseur est un peu drôle. Nous ne pouvons pas facilement dire qu&rsquo;une série de tokens est le côté gauche d&rsquo;une assignation jusqu&rsquo;à ce que nous atteignions le <code>=</code>. Maintenant que notre règle de grammaire d&rsquo;assignation a <code>call</code> sur le côté gauche, qui peut s&rsquo;étendre en expressions arbitrairement grandes, ce <code>=</code> final peut être à beaucoup de tokens de distance du point où nous avons besoin de savoir que nous parsons une assignation.</p>
<p>Au lieu de cela, l&rsquo;astuce que nous faisons est de parser le côté gauche comme une expression normale. Ensuite, quand nous trébuchons sur le signe égal après, nous prenons l&rsquo;expression que nous avons déjà parsée et la transformons en le nœud d&rsquo;arbre syntaxique correct pour l&rsquo;assignation.</p>
<p>Nous ajoutons une autre clause à cette transformation pour gérer la transformation d&rsquo;une expression Expr.Get sur la gauche en l&rsquo;Expr.Set correspondante.</p>
<div class="codehilite"><pre class="insert-before">        return new Expr.Assign(name, value);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>assignment</em>()</div>
<pre class="insert">      } <span class="k">else</span> <span class="k">if</span> (<span class="i">expr</span> <span class="k">instanceof</span> <span class="t">Expr</span>.<span class="t">Get</span>) {
        <span class="t">Expr</span>.<span class="t">Get</span> <span class="i">get</span> = (<span class="t">Expr</span>.<span class="t">Get</span>)<span class="i">expr</span>;
        <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Set</span>(<span class="i">get</span>.<span class="i">object</span>, <span class="i">get</span>.<span class="i">name</span>, <span class="i">value</span>);
</pre><pre class="insert-after">      }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>assignment</em>()</div>

<p>C&rsquo;est le parsing de notre syntaxe. Nous poussons ce nœud à travers le résolveur.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitLogicalExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitSetExpr</span>(<span class="t">Expr</span>.<span class="t">Set</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">value</span>);
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">object</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitLogicalExpr</em>()</div>

<p>Encore une fois, comme Expr.Get, la propriété elle-même est évaluée dynamiquement, donc il n&rsquo;y a rien à résoudre là. Tout ce que nous avons besoin de faire est de récurser dans les deux sous-expressions d&rsquo;Expr.Set, l&rsquo;objet dont la propriété est définie, et la valeur à laquelle elle est définie.</p>
<p>Cela nous mène à l&rsquo;interpréteur.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitLogicalExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitSetExpr</span>(<span class="t">Expr</span>.<span class="t">Set</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">object</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">object</span>);

    <span class="k">if</span> (!(<span class="i">object</span> <span class="k">instanceof</span> <span class="t">LoxInstance</span>)) {<span name="order"> </span>
      <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">expr</span>.<span class="i">name</span>,
                             <span class="s">&quot;Only instances have fields.&quot;</span>);
    }

    <span class="t">Object</span> <span class="i">value</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">value</span>);
    ((<span class="t">LoxInstance</span>)<span class="i">object</span>).<span class="i">set</span>(<span class="i">expr</span>.<span class="i">name</span>, <span class="i">value</span>);
    <span class="k">return</span> <span class="i">value</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitLogicalExpr</em>()</div>

<p>Nous évaluons l&rsquo;objet dont la propriété est définie et vérifions pour voir s&rsquo;il est une LoxInstance. Sinon, c&rsquo;est une erreur d&rsquo;exécution. Autrement, nous évaluons la valeur étant définie et la stockons sur l&rsquo;instance. Cela repose sur une nouvelle méthode dans LoxInstance.</p>
<aside name="order">
<p>Ceci est un autre cas limite sémantique. Il y a trois opérations distinctes :</p>
<ol>
<li>
<p>Évaluer l&rsquo;objet.</p>
</li>
<li>
<p>Lever une erreur d&rsquo;exécution s&rsquo;il n&rsquo;est pas une instance d&rsquo;une classe.</p>
</li>
<li>
<p>Évaluer la valeur.</p>
</li>
</ol>
<p>L&rsquo;ordre dans lequel celles-ci sont effectuées pourrait être visible par l&rsquo;utilisateur, ce qui signifie que nous avons besoin de le spécifier soigneusement et de nous assurer que nos implémentations font celles-ci dans le même ordre.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>lox/LoxInstance.java</em><br>
add after <em>get</em>()</div>
<pre>  <span class="t">void</span> <span class="i">set</span>(<span class="t">Token</span> <span class="i">name</span>, <span class="t">Object</span> <span class="i">value</span>) {
    <span class="i">fields</span>.<span class="i">put</span>(<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxInstance.java</em>, add after <em>get</em>()</div>

<p>Pas de vraie magie ici. Nous bourrons les valeurs directement dans la map Java où les champs vivent. Puisque Lox permet de créer librement de nouveaux champs sur les instances, il n&rsquo;y a pas besoin de voir si la clé est déjà présente.</p>
<h2><a href="#méthodes-sur-les-classes" id="méthodes-sur-les-classes"><small>12&#8202;.&#8202;5</small>Méthodes sur les Classes</a></h2>
<p>Vous pouvez créer des instances de classes et bourrer des données dedans, mais la classe elle-même ne <em>fait</em> pas vraiment quelque chose. Les instances sont juste des maps et toutes les instances sont plus ou moins les mêmes. Pour les faire se sentir comme des instances <em>de classes</em>, nous avons besoin de comportement<span class="em">&mdash;</span>des méthodes.</p>
<p>Notre parseur serviable parse déjà les déclarations de méthode, donc nous sommes bons là. Nous n&rsquo;avons aussi pas besoin d&rsquo;ajouter de support parseur pour les <em>appels</em> de méthode. Nous avons déjà <code>.</code> (getters) et <code>()</code> (appels de fonction). Un &ldquo;appel de méthode&rdquo; enchaîne simplement ceux-ci ensemble.</p><img src="image/classes/method.png" alt="L'arbre syntaxique pour 'objet.methode(argument)" />
<p>Cela soulève une question intéressante. Qu&rsquo;arrive-t-il quand ces deux expressions sont séparées ? En supposant que <code>methode</code> dans cet exemple est une méthode sur la classe de <code>objet</code> et pas un champ sur l&rsquo;instance, que devrait faire le morceau de code suivant ?</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">m</span> = <span class="i">objet</span>.<span class="i">methode</span>;
<span class="i">m</span>(<span class="i">argument</span>);
</pre></div>
<p>Ce programme &ldquo;cherche&rdquo; la méthode et stocke le résultat<span class="em">&mdash;</span>quel qu&rsquo;il soit<span class="em">&mdash;</span>dans une variable et ensuite appelle cet objet plus tard. Est-ce autorisé ? Pouvez-vous traiter une méthode comme si c&rsquo;était une fonction sur l&rsquo;instance ?</p>
<p>Qu&rsquo;en est-il de l&rsquo;autre direction ?</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Box</span> {}

<span class="k">fun</span> <span class="i">notMethod</span>(<span class="i">argument</span>) {
  <span class="k">print</span> <span class="s">&quot;called function with &quot;</span> + <span class="i">argument</span>;
}

<span class="k">var</span> <span class="i">box</span> = <span class="t">Box</span>();
<span class="i">box</span>.<span class="i">function</span> = <span class="i">notMethod</span>;
<span class="i">box</span>.<span class="i">function</span>(<span class="s">&quot;argument&quot;</span>);
</pre></div>
<p>Ce programme crée une instance et ensuite stocke une fonction dans un champ dessus. Ensuite il appelle cette fonction en utilisant la même syntaxe qu&rsquo;un appel de méthode. Est-ce que ça marche ?</p>
<p>Différents langages ont différentes réponses à ces questions. On pourrit écrire un traité là-dessus. Pour Lox, nous dirons que la réponse à ces deux-là est oui, ça marche. Nous avons quelques raisons pour justifier cela. Pour le second exemple<span class="em">&mdash;</span>appeler une fonction stockée dans un champ<span class="em">&mdash;</span>nous voulons supporter cela parce que les fonctions de première classe sont utiles et les stocker dans des champs est une chose parfaitement normale à faire.</p>
<p>Le premier exemple est plus obscur. Une motivation est que les utilisateurs s&rsquo;attendent généralement à être capables de hisser une sous-expression hors dans une variable locale sans changer le sens du programme. Vous pouvez prendre ceci :</p>
<div class="codehilite"><pre><span class="i">breakfast</span>(<span class="i">omelette</span>.<span class="i">filledWith</span>(<span class="i">cheese</span>), <span class="i">sausage</span>);
</pre></div>
<p>Et le transformer en ceci :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">eggs</span> = <span class="i">omelette</span>.<span class="i">filledWith</span>(<span class="i">cheese</span>);
<span class="i">breakfast</span>(<span class="i">eggs</span>, <span class="i">sausage</span>);
</pre></div>
<p>Et cela fait la même chose. De même, puisque le <code>.</code> et les <code>()</code> dans un appel de méthode <em>sont</em> deux expressions séparées, il semble que vous devriez être capable de hisser la partie <em>recherche</em> dans une variable et ensuite l&rsquo;appeler <span name="callback">plus tard</span>. Nous devons penser soigneusement à ce qu&rsquo;est la <em>chose</em> que vous obtenez quand vous cherchez une méthode, et comment elle se comporte, même dans des cas bizarres comme :</p>
<aside name="callback">
<p>Un usage motivant pour cela est les callbacks. Souvent, vous voulez passer un callback dont le corps invoque simplement une méthode sur un certain objet. Être capable de chercher la méthode et de la passer directement vous épargne la corvée de déclarer manuellement une fonction pour l&rsquo;envelopper. Comparez ceci :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">callback</span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>) {
  <span class="i">objet</span>.<span class="i">methode</span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>);
}

<span class="i">takeCallback</span>(<span class="i">callback</span>);
</pre></div>
<p>Avec ceci :</p>
<div class="codehilite"><pre><span class="i">takeCallback</span>(<span class="i">objet</span>.<span class="i">methode</span>);
</pre></div>
</aside>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Person</span> {
  <span class="i">sayName</span>() {
    <span class="k">print</span> <span class="k">this</span>.<span class="i">name</span>;
  }
}

<span class="k">var</span> <span class="i">jane</span> = <span class="t">Person</span>();
<span class="i">jane</span>.<span class="i">name</span> = <span class="s">&quot;Jane&quot;</span>;

<span class="k">var</span> <span class="i">method</span> = <span class="i">jane</span>.<span class="i">sayName</span>;
<span class="i">method</span>(); <span class="c">// ?</span>
</pre></div>
<p>Si vous attrapez une poignée vers une méthode sur une certaine instance et l&rsquo;appelez plus tard, est-ce qu&rsquo;elle &ldquo;se souvient&rdquo; de l&rsquo;instance d&rsquo;où elle a été tirée ? Est-ce que <code>this</code> à l&rsquo;intérieur de la méthode fait toujours référence à cet objet original ?</p>
<p>Voici un exemple plus pathologique pour tordre votre cerveau :</p>
<div class="codehilite"><pre> <span class="k">class</span> <span class="t">Person</span> {
  <span class="i">sayName</span>() {
    <span class="k">print</span> <span class="k">this</span>.<span class="i">name</span>;
  }
}

<span class="k">var</span> <span class="i">jane</span> = <span class="t">Person</span>();
<span class="i">jane</span>.<span class="i">name</span> = <span class="s">&quot;Jane&quot;</span>;

<span class="k">var</span> <span class="i">bill</span> = <span class="t">Person</span>();
<span class="i">bill</span>.<span class="i">name</span> = <span class="s">&quot;Bill&quot;</span>;

<span class="i">bill</span>.<span class="i">sayName</span> = <span class="i">jane</span>.<span class="i">sayName</span>;
<span class="i">bill</span>.<span class="i">sayName</span>(); <span class="c">// ?</span>
</pre></div>
<p>Est-ce que cette dernière ligne imprime &ldquo;Bill&rdquo; parce que c&rsquo;est l&rsquo;instance à travers laquelle nous avons <em>appelé</em> la méthode, ou &ldquo;Jane&rdquo; parce que c&rsquo;est l&rsquo;instance où nous avons d&rsquo;abord attrapé la méthode ?</p>
<p>Du code équivalent en Lua et JavaScript imprimerait &ldquo;Bill&rdquo;. Ces langages n&rsquo;ont pas vraiment une notion de &ldquo;méthodes&rdquo;. Tout est en quelque sorte fonctions-dans-champs, donc il n&rsquo;est pas clair que <code>jane</code> &ldquo;possède&rdquo; <code>sayName</code> plus que <code>bill</code> ne le fait.</p>
<p>Lox, cependant, a une vraie syntaxe de classe donc nous savons quelles choses appelables sont des méthodes et lesquelles sont des fonctions. Ainsi, comme Python, C#, et autres, nous ferons en sorte que les méthodes &ldquo;lient&rdquo; <code>this</code> à l&rsquo;instance originale quand la méthode est d&rsquo;abord attrapée. Python appelle <span name="bound">ceux-ci</span> des <strong>méthodes liées</strong>.</p>
<aside name="bound">
<p>Je sais, nom imaginatif, pas vrai ?</p>
</aside>
<p>En pratique, c&rsquo;est habituellement ce que vous voulez. Si vous prenez une référence vers une méthode sur un certain objet pour pouvoir l&rsquo;utiliser comme un callback plus tard, vous voulez vous souvenir de l&rsquo;instance à laquelle elle appartenait, même si ce callback se trouve être stocké dans un champ sur un autre objet.</p>
<p>OK, c&rsquo;est beaucoup de sémantique à charger dans votre tête. Oubliez les cas limites pour un peu. Nous y reviendrons. Pour l&rsquo;instant, faisons fonctionner les appels de méthode basiques. Nous parsons déjà les déclarations de méthode à l&rsquo;intérieur du corps de la classe, donc la prochaine étape est de les résoudre.</p>
<div class="codehilite"><pre class="insert-before">    define(stmt.name);
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">

    <span class="k">for</span> (<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">method</span> : <span class="i">stmt</span>.<span class="i">methods</span>) {
      <span class="t">FunctionType</span> <span class="i">declaration</span> = <span class="t">FunctionType</span>.<span class="i">METHOD</span>;
      <span class="i">resolveFunction</span>(<span class="i">method</span>, <span class="i">declaration</span>);<span name="local"> </span>
    }

</pre><pre class="insert-after">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>

<aside name="local">
<p>Stocker le type de fonction dans une variable locale est inutile pour l&rsquo;instant, mais nous étendrons ce code d&rsquo;ici peu et cela aura plus de sens.</p>
</aside>
<p>Nous itérons à travers les méthodes dans le corps de la classe et appelons la méthode <code>resolveFunction()</code> que nous avons écrite pour gérer les déclarations de fonction précédemment. La seule différence est que nous passons une nouvelle valeur d&rsquo;enum FunctionType.</p>
<div class="codehilite"><pre class="insert-before">    NONE,
</pre><pre class="insert-before">    <span class="i">FUNCTION</span><span class="insert-comma">,</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in enum <em>FunctionType</em><br>
add <em>&ldquo;,&rdquo;</em> to previous line</div>
<pre class="insert">    <span class="i">METHOD</span>
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in enum <em>FunctionType</em>, add <em>&ldquo;,&rdquo;</em> to previous line</div>

<p>Cela va être important quand nous résoudrons les expressions <code>this</code>. Pour l&rsquo;instant, ne vous inquiétez pas pour ça. Le truc intéressant est dans l&rsquo;interpréteur.</p>
<div class="codehilite"><pre class="insert-before">    environment.define(stmt.name.lexeme, null);
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitClassStmt</em>()<br>
replace 1 line</div>
<pre class="insert">

    <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">LoxFunction</span>&gt; <span class="i">methods</span> = <span class="k">new</span> <span class="t">HashMap</span>&lt;&gt;();
    <span class="k">for</span> (<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">method</span> : <span class="i">stmt</span>.<span class="i">methods</span>) {
      <span class="t">LoxFunction</span> <span class="i">function</span> = <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">method</span>, <span class="i">environment</span>);
      <span class="i">methods</span>.<span class="i">put</span>(<span class="i">method</span>.<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">function</span>);
    }

    <span class="t">LoxClass</span> <span class="i">klass</span> = <span class="k">new</span> <span class="t">LoxClass</span>(<span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">methods</span>);
</pre><pre class="insert-after">    environment.assign(stmt.name, klass);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitClassStmt</em>(), replace 1 line</div>

<p>Quand nous interprétons une instruction de déclaration de classe, nous transformons la représentation syntaxique de la classe<span class="em">&mdash;</span>son nœud AST<span class="em">&mdash;</span>en sa représentation à l&rsquo;exécution. Maintenant, nous devons faire cela pour les méthodes contenues dans la classe aussi. Chaque déclaration de méthode éclot en un objet LoxFunction.</p>
<p>Nous prenons tous ceux-là et les enveloppons dans une map, indexée par les noms de méthode. Cela est stocké dans LoxClass.</p>
<div class="codehilite"><pre class="insert-before">  final String name;
</pre><div class="source-file"><em>lox/LoxClass.java</em><br>
in class <em>LoxClass</em><br>
replace 4 lines</div>
<pre class="insert">  <span class="k">private</span> <span class="k">final</span> <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">LoxFunction</span>&gt; <span class="i">methods</span>;

  <span class="t">LoxClass</span>(<span class="t">String</span> <span class="i">name</span>, <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">LoxFunction</span>&gt; <span class="i">methods</span>) {
    <span class="k">this</span>.<span class="i">name</span> = <span class="i">name</span>;
    <span class="k">this</span>.<span class="i">methods</span> = <span class="i">methods</span>;
  }
</pre><pre class="insert-after">

  @Override
  public String toString() {
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, in class <em>LoxClass</em>, replace 4 lines</div>

<p>Là où une instance stocke l&rsquo;état, la classe stocke le comportement. LoxInstance a sa map de champs, et LoxClass obtient une map de méthodes. Même si les méthodes sont possédées par la classe, elles sont toujours accédées à travers des instances de cette classe.</p>
<div class="codehilite"><pre class="insert-before">  Object get(Token name) {
    if (fields.containsKey(name.lexeme)) {
      return fields.get(name.lexeme);
    }

</pre><div class="source-file"><em>lox/LoxInstance.java</em><br>
in <em>get</em>()</div>
<pre class="insert">    <span class="t">LoxFunction</span> <span class="i">method</span> = <span class="i">klass</span>.<span class="i">findMethod</span>(<span class="i">name</span>.<span class="i">lexeme</span>);
    <span class="k">if</span> (<span class="i">method</span> != <span class="k">null</span>) <span class="k">return</span> <span class="i">method</span>;

</pre><pre class="insert-after">    throw new RuntimeError(name,<span name="hidden"> </span>
        &quot;Undefined property '&quot; + name.lexeme + &quot;'.&quot;);
</pre></div>
<div class="source-file-narrow"><em>lox/LoxInstance.java</em>, in <em>get</em>()</div>

<p>Quand nous cherchons une propriété sur une instance, si nous ne <span name="shadow">trouvons</span> pas un champ correspondant, nous cherchons une méthode avec ce nom sur la classe de l&rsquo;instance. Si trouvée, nous renvoyons cela. C&rsquo;est là que la distinction entre &ldquo;champ&rdquo; et &ldquo;propriété&rdquo; devient significative. Quand vous accédez à une propriété, vous pourriez obtenir un champ<span class="em">&mdash;</span>un peu d&rsquo;état stocké sur l&rsquo;instance<span class="em">&mdash;</span>ou vous pourriez frapper une méthode définie sur la classe de l&rsquo;instance.</p>
<p>La méthode est cherchée en utilisant ceci :</p>
<aside name="shadow">
<p>Chercher un champ d&rsquo;abord implique que les champs masquent les méthodes, un point sémantique subtil mais important.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>lox/LoxClass.java</em><br>
add after <em>LoxClass</em>()</div>
<pre>  <span class="t">LoxFunction</span> <span class="i">findMethod</span>(<span class="t">String</span> <span class="i">name</span>) {
    <span class="k">if</span> (<span class="i">methods</span>.<span class="i">containsKey</span>(<span class="i">name</span>)) {
      <span class="k">return</span> <span class="i">methods</span>.<span class="i">get</span>(<span class="i">name</span>);
    }

    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, add after <em>LoxClass</em>()</div>

<p>Vous pouvez probablement deviner que cette méthode va devenir plus intéressante plus tard. Pour l&rsquo;instant, une simple recherche de map sur la table de méthodes de la classe est suffisante pour nous démarrer. Donnez-lui un essai :</p>
<p><span name="crunch"></span></p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Bacon</span> {
  <span class="i">eat</span>() {
    <span class="k">print</span> <span class="s">&quot;Crunch crunch crunch!&quot;</span>;
  }
}

<span class="t">Bacon</span>().<span class="i">eat</span>(); <span class="c">// Imprime &quot;Crunch crunch crunch!&quot;.</span>
</pre></div>
<aside name="crunch">
<p>Excuses si vous préférez le bacon caoutchouteux plutôt que croustillant. Sentez-vous libre d&rsquo;ajuster le script à votre goût.</p>
</aside>
<h2><a href="#this" id="this"><small>12&#8202;.&#8202;6</small>This</a></h2>
<p>Nous pouvons définir à la fois le comportement et l&rsquo;état sur les objets, mais ils ne sont pas encore liés ensemble. À l&rsquo;intérieur d&rsquo;une méthode, nous n&rsquo;avons aucun moyen d&rsquo;accéder aux champs de l&rsquo;objet &ldquo;courant&rdquo;<span class="em">&mdash;</span>l&rsquo;instance sur laquelle la méthode a été appelée<span class="em">&mdash;</span>ni ne pouvons appeler d&rsquo;autres méthodes sur ce même objet.</p>
<p>Pour atteindre cette instance, elle a besoin d&rsquo;un <span name="i">nom</span>. Smalltalk, Ruby, et Swift utilisent &ldquo;self&rdquo;. Simula, C++, Java, et d&rsquo;autres utilisent &ldquo;this&rdquo;. Python utilise &ldquo;self&rdquo; par convention, mais vous pouvez techniquement l&rsquo;appeler comme vous voulez.</p>
<aside name="i">
<p>&ldquo;I&rdquo; (Je) aurait été un super choix, mais utiliser &ldquo;i&rdquo; pour les variables de boucle précède la POO et remonte tout le chemin jusqu&rsquo;à Fortran. Nous sommes victimes des choix accidentels de nos ancêtres.</p>
</aside>
<p>Pour Lox, puisque nous nous tenons généralement au style Java-esque, nous irons avec &ldquo;this&rdquo;. À l&rsquo;intérieur d&rsquo;un corps de méthode, une expression <code>this</code> s&rsquo;évalue à l&rsquo;instance sur laquelle la méthode a été appelée. Ou, plus spécifiquement, puisque les méthodes sont accédées et ensuite invoquées comme deux étapes, elle fera référence à l&rsquo;objet depuis lequel la méthode a été <em>accédée</em>.</p>
<p>Cela rend notre travail plus difficile. Regardez :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Egotist</span> {
  <span class="i">speak</span>() {
    <span class="k">print</span> <span class="k">this</span>;
  }
}

<span class="k">var</span> <span class="i">method</span> = <span class="t">Egotist</span>().<span class="i">speak</span>;
<span class="i">method</span>();
</pre></div>
<p>Sur l&rsquo;avant-dernière ligne, nous attrapons une référence à la méthode <code>speak()</code> depuis une instance de la classe. Cela renvoie une fonction, et cette fonction a besoin de se souvenir de l&rsquo;instance d&rsquo;où elle a été tirée pour que <em>plus tard</em>, sur la dernière ligne, elle puisse encore la trouver quand la fonction est appelée.</p>
<p>Nous avons besoin de prendre <code>this</code> au point où la méthode est accédée et de l&rsquo;attacher à la fonction d&rsquo;une manière ou d&rsquo;une autre pour qu&rsquo;il reste dans les parages aussi longtemps que nous en avons besoin. Hmm<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>un moyen de stocker quelques données supplémentaires qui traînent autour d&rsquo;une fonction, hein ? Cela sonne terriblement comme une <em>fermeture</em>, n&rsquo;est-ce pas ?</p>
<p>Si nous définissions <code>this</code> comme une sorte de variable cachée dans un environnement qui entoure la fonction renvoyée lors de la recherche d&rsquo;une méthode, alors les utilisations de <code>this</code> dans le corps seraient capables de la trouver plus tard. LoxFunction a déjà la capacité de s&rsquo;accrocher à un environnement environnant, donc nous avons la machinerie dont nous avons besoin.</p>
<p>Parcourons un exemple pour voir comment ça marche :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Cake</span> {
  <span class="i">taste</span>() {
    <span class="k">var</span> <span class="i">adjective</span> = <span class="s">&quot;delicious&quot;</span>;
    <span class="k">print</span> <span class="s">&quot;The &quot;</span> + <span class="k">this</span>.<span class="i">flavor</span> + <span class="s">&quot; cake is &quot;</span> + <span class="i">adjective</span> + <span class="s">&quot;!&quot;</span>;
  }
}

<span class="k">var</span> <span class="i">cake</span> = <span class="t">Cake</span>();
<span class="i">cake</span>.<span class="i">flavor</span> = <span class="s">&quot;German chocolate&quot;</span>;
<span class="i">cake</span>.<span class="i">taste</span>(); <span class="c">// Imprime &quot;The German chocolate cake is delicious!&quot;.</span>
</pre></div>
<p>Quand nous évaluons d&rsquo;abord la définition de classe, nous créons une LoxFunction pour <code>taste()</code>. Sa fermeture est l&rsquo;environnement entourant la classe, dans ce cas le global. Donc la LoxFunction que nous stockons dans la map de méthodes de la classe ressemble à ceci :</p><img src="image/classes/closure.png" alt="La fermeture initiale pour la méthode." />
<p>Quand nous évaluons l&rsquo;expression d&rsquo;accès <code>cake.taste</code>, nous créons un nouvel environnement qui lie <code>this</code> à l&rsquo;objet depuis lequel la méthode est accédée (ici, <code>cake</code>). Ensuite nous faisons une <em>nouvelle</em> LoxFunction avec le même code que l&rsquo;originale mais utilisant ce nouvel environnement comme sa fermeture.</p><img src="image/classes/bound-method.png" alt="La nouvelle fermeture qui lie 'this'." />
<p>C&rsquo;est la LoxFunction qui est renvoyée lors de l&rsquo;évaluation de l&rsquo;expression d&rsquo;accès pour le nom de méthode. Quand cette fonction est plus tard appelée par une expression <code>()</code>, nous créons un environnement pour le corps de méthode comme d&rsquo;habitude.</p><img src="image/classes/call.png" alt="Appeler la méthode liée et créer un nouvel environnement pour le corps de la méthode." />
<p>Le parent de l&rsquo;environnement du corps est l&rsquo;environnement que nous avons créé plus tôt pour lier <code>this</code> à l&rsquo;objet courant. Ainsi tout usage de <code>this</code> à l&rsquo;intérieur du corps se résout avec succès à cette instance.</p>
<p>Réutiliser notre code d&rsquo;environnement pour implémenter <code>this</code> s&rsquo;occupe aussi des cas intéressants où méthodes et fonctions interagissent, comme :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Thing</span> {
  <span class="i">getCallback</span>() {
    <span class="k">fun</span> <span class="i">localFunction</span>() {
      <span class="k">print</span> <span class="k">this</span>;
    }

    <span class="k">return</span> <span class="i">localFunction</span>;
  }
}

<span class="k">var</span> <span class="i">callback</span> = <span class="t">Thing</span>().<span class="i">getCallback</span>();
<span class="i">callback</span>();
</pre></div>
<p>En, disons, JavaScript, il est courant de renvoyer un callback depuis l&rsquo;intérieur d&rsquo;une méthode. Ce callback peut vouloir s&rsquo;accrocher et retenir l&rsquo;accès à l&rsquo;objet original<span class="em">&mdash;</span>la valeur <code>this</code><span class="em">&mdash;</span>auquel la méthode était associée. Notre support existant pour les fermetures et les chaînes d&rsquo;environnement devrait faire tout cela correctement.</p>
<p>Codons-le. La première étape est d&rsquo;ajouter une <span name="this-ast">nouvelle syntaxe</span> pour <code>this</code>.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Set      : Expr object, Token name, Expr value&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;This     : Token keyword&quot;</span>,
</pre><pre class="insert-after">      &quot;Unary    : Token operator, Expr right&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="this-ast">
<p>Le code généré pour le nouveau nœud est dans l&rsquo;<a href="appendix-ii.html#this-expression">Annexe II</a>.</p>
</aside>
<p>Le parsing est simple puisque c&rsquo;est un seul token que notre lexer reconnaît déjà comme un mot réservé.</p>
<div class="codehilite"><pre class="insert-before">      return new Expr.Literal(previous().literal);
    }
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>primary</em>()</div>
<pre class="insert">

    <span class="k">if</span> (<span class="i">match</span>(<span class="i">THIS</span>)) <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">This</span>(<span class="i">previous</span>());
</pre><pre class="insert-after">

    if (match(IDENTIFIER)) {
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>primary</em>()</div>

<p>Vous pouvez commencer à voir comment <code>this</code> fonctionne comme une variable quand nous arrivons au résolveur.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitSetExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitThisExpr</span>(<span class="t">Expr</span>.<span class="t">This</span> <span class="i">expr</span>) {
    <span class="i">resolveLocal</span>(<span class="i">expr</span>, <span class="i">expr</span>.<span class="i">keyword</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }

</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitSetExpr</em>()</div>

<p>Nous le résolvons exactement comme n&rsquo;importe quelle autre variable locale en utilisant &ldquo;this&rdquo; comme le nom pour la &ldquo;variable&rdquo;. Bien sûr, ça ne va pas marcher maintenant, parce que &ldquo;this&rdquo; n&rsquo;<em>est pas</em> déclaré dans une quelconque portée. Fixons cela là-bas dans <code>visitClassStmt()</code>.</p>
<div class="codehilite"><pre class="insert-before">    define(stmt.name);

</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">    <span class="i">beginScope</span>();
    <span class="i">scopes</span>.<span class="i">peek</span>().<span class="i">put</span>(<span class="s">&quot;this&quot;</span>, <span class="k">true</span>);

</pre><pre class="insert-after">    for (Stmt.Function method : stmt.methods) {
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>

<p>Avant que nous entrions et commencions à résoudre les corps des méthodes, nous poussons une nouvelle portée et définissons &ldquo;this&rdquo; dedans comme si c&rsquo;était une variable. Ensuite, quand nous avons fini, nous jetons cette portée environnante.</p>
<div class="codehilite"><pre class="insert-before">    }

</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">    <span class="i">endScope</span>();

</pre><pre class="insert-after">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>

<p>Maintenant, chaque fois qu&rsquo;une expression <code>this</code> est rencontrée (au moins à l&rsquo;intérieur d&rsquo;une méthode) elle se résoudra à une &ldquo;variable locale&rdquo; définie dans une portée implicite juste en dehors du bloc pour le corps de la méthode.</p>
<p>Le résolveur a une nouvelle <em>portée</em> pour <code>this</code>, donc l&rsquo;interpréteur a besoin de créer un <em>environnement</em> correspondant pour lui. Rappelez-vous, nous devons toujours garder les chaînes de portée du résolveur et les environnements chaînés de l&rsquo;interpréteur synchronisés l&rsquo;un avec l&rsquo;autre. À l&rsquo;exécution, nous créons l&rsquo;environnement après que nous ayons trouvé la méthode sur l&rsquo;instance. Nous remplaçons la ligne de code précédente qui renvoyait simplement la LoxFunction de la méthode par ceci :</p>
<div class="codehilite"><pre class="insert-before">    LoxFunction method = klass.findMethod(name.lexeme);
</pre><div class="source-file"><em>lox/LoxInstance.java</em><br>
in <em>get</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">method</span> != <span class="k">null</span>) <span class="k">return</span> <span class="i">method</span>.<span class="i">bind</span>(<span class="k">this</span>);
</pre><pre class="insert-after">

    throw new RuntimeError(name,<span name="hidden"> </span>
        &quot;Undefined property '&quot; + name.lexeme + &quot;'.&quot;);
</pre></div>
<div class="source-file-narrow"><em>lox/LoxInstance.java</em>, in <em>get</em>(), replace 1 line</div>

<p>Notez le nouvel appel à <code>bind()</code>. Cela ressemble à ceci :</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxFunction.java</em><br>
add after <em>LoxFunction</em>()</div>
<pre>  <span class="t">LoxFunction</span> <span class="i">bind</span>(<span class="t">LoxInstance</span> <span class="i">instance</span>) {
    <span class="t">Environment</span> <span class="i">environment</span> = <span class="k">new</span> <span class="t">Environment</span>(<span class="i">closure</span>);
    <span class="i">environment</span>.<span class="i">define</span>(<span class="s">&quot;this&quot;</span>, <span class="i">instance</span>);
    <span class="k">return</span> <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">declaration</span>, <span class="i">environment</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, add after <em>LoxFunction</em>()</div>

<p>Il n&rsquo;y a pas grand chose à cela. Nous créons un nouvel environnement niché à l&rsquo;intérieur de la fermeture originale de la méthode. Sorte d&rsquo;une fermeture-dans-une-fermeture. Quand la méthode est appelée, cela deviendra le parent de l&rsquo;environnement du corps de la méthode.</p>
<p>Nous déclarons &ldquo;this&rdquo; comme une variable dans cet environnement et la lions à l&rsquo;instance donnée, l&rsquo;instance depuis laquelle la méthode est accédée. <em>Et voilà</em>, la LoxFunction renvoyée transporte maintenant son propre petit monde persistant où &ldquo;this&rdquo; est lié à l&rsquo;objet.</p>
<p>La tâche restante est d&rsquo;interpréter ces expressions <code>this</code>. Similaire au résolveur, c&rsquo;est la même chose qu&rsquo;interpréter une expression de variable.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitSetExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitThisExpr</span>(<span class="t">Expr</span>.<span class="t">This</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">lookUpVariable</span>(<span class="i">expr</span>.<span class="i">keyword</span>, <span class="i">expr</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitSetExpr</em>()</div>

<p>Allez-y et donnez-lui un essai en utilisant cet exemple de gâteau de tout à l&rsquo;heure. Avec moins de vingt lignes de code, notre interpréteur gère <code>this</code> à l&rsquo;intérieur des méthodes même dans toutes les façons bizarres dont il peut interagir avec les classes imbriquées, les fonctions à l&rsquo;intérieur de méthodes, les poignées vers des méthodes, etc.</p>
<h3><a href="#usages-invalides-de-this" id="usages-invalides-de-this"><small>12&#8202;.&#8202;6&#8202;.&#8202;1</small>Usages invalides de this</a></h3>
<p>Attendez une minute. Qu&rsquo;arrive-t-il si vous essayez d&rsquo;utiliser <code>this</code> <em>en dehors</em> d&rsquo;une méthode ? Qu&rsquo;en est-il de :</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="k">this</span>;
</pre></div>
<p>Ou :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">notAMethod</span>() {
  <span class="k">print</span> <span class="k">this</span>;
}
</pre></div>
<p>Il n&rsquo;y a pas d&rsquo;instance vers laquelle <code>this</code> peut pointer si vous n&rsquo;êtes pas dans une méthode. Nous pourrions lui donner une certaine valeur par défaut comme <code>nil</code> ou en faire une erreur d&rsquo;exécution, mais l&rsquo;utilisateur a clairement fait une erreur. Le plus tôt ils trouvent et corrigent cette erreur, le plus heureux ils seront.</p>
<p>Notre passe de résolution est un bon endroit pour détecter cette erreur statiquement. Elle détecte déjà les instructions <code>return</code> en dehors des fonctions. Nous ferons quelque chose de similaire pour <code>this</code>. Dans la veine de notre enum FunctionType existant, nous définissons un nouveau ClassType.</p>
<div class="codehilite"><pre class="insert-before">  }
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
add after enum <em>FunctionType</em></div>
<pre class="insert">

  <span class="k">private</span> <span class="k">enum</span> <span class="t">ClassType</span> {
    <span class="i">NONE</span>,
    <span class="i">CLASS</span>
  }

  <span class="k">private</span> <span class="t">ClassType</span> <span class="i">currentClass</span> = <span class="t">ClassType</span>.<span class="i">NONE</span>;

</pre><pre class="insert-after">  void resolve(List&lt;Stmt&gt; statements) {
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after enum <em>FunctionType</em></div>

<p>Oui, cela pourrait être un Booléen. Quand nous arriverons à l&rsquo;héritage, cela obtiendra une troisième valeur, d&rsquo;où l&rsquo;enum maintenant. Nous ajoutons aussi un champ correspondant, <code>currentClass</code>. Sa valeur nous dit si nous sommes actuellement à l&rsquo;intérieur d&rsquo;une déclaration de classe pendant que nous traversons l&rsquo;arbre syntaxique. Il commence à <code>NONE</code> ce qui signifie que nous ne sommes pas dans une.</p>
<p>Quand nous commençons à résoudre une déclaration de classe, nous changeons cela.</p>
<div class="codehilite"><pre class="insert-before">  public Void visitClassStmt(Stmt.Class stmt) {
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">    <span class="t">ClassType</span> <span class="i">enclosingClass</span> = <span class="i">currentClass</span>;
    <span class="i">currentClass</span> = <span class="t">ClassType</span>.<span class="i">CLASS</span>;

</pre><pre class="insert-after">    declare(stmt.name);
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>

<p>Comme avec <code>currentFunction</code>, nous stockons la valeur précédente du champ dans une variable locale. Cela nous permet de faire du ferroutage sur la JVM pour garder une pile de valeurs <code>currentClass</code>. De cette façon nous ne perdons pas la trace de la valeur précédente si une classe s&rsquo;imbrique à l&rsquo;intérieur d&rsquo;une autre.</p>
<p>Une fois que les méthodes ont été résolues, nous &ldquo;dépilons&rdquo; cette pile en restaurant l&rsquo;ancienne valeur.</p>
<div class="codehilite"><pre class="insert-before">    endScope();

</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">    <span class="i">currentClass</span> = <span class="i">enclosingClass</span>;
</pre><pre class="insert-after">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>

<p>Quand nous résolvons une expression <code>this</code>, le champ <code>currentClass</code> nous donne le bout de donnée dont nous avons besoin pour rapporter une erreur si l&rsquo;expression ne se produit pas nichée à l&rsquo;intérieur d&rsquo;un corps de méthode.</p>
<div class="codehilite"><pre class="insert-before">  public Void visitThisExpr(Expr.This expr) {
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitThisExpr</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">currentClass</span> == <span class="t">ClassType</span>.<span class="i">NONE</span>) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">expr</span>.<span class="i">keyword</span>,
          <span class="s">&quot;Can&#39;t use &#39;this&#39; outside of a class.&quot;</span>);
      <span class="k">return</span> <span class="k">null</span>;
    }

</pre><pre class="insert-after">    resolveLocal(expr, expr.keyword);
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitThisExpr</em>()</div>

<p>Cela devrait aider les utilisateurs à utiliser <code>this</code> correctement, et cela nous épargne d&rsquo;avoir à gérer la mauvaise utilisation à l&rsquo;exécution dans l&rsquo;interpréteur.</p>
<h2><a href="#constructeurs-et-initialiseurs" id="constructeurs-et-initialiseurs"><small>12&#8202;.&#8202;7</small>Constructeurs et Initialiseurs</a></h2>
<p>Nous pouvons faire presque tout avec les classes maintenant, et alors que nous approchons de la fin du chapitre nous nous trouvons étrangement concentrés sur un début. Les méthodes et les champs nous permettent d&rsquo;encapsuler l&rsquo;état et le comportement ensemble pour qu&rsquo;un objet <em>reste</em> toujours dans une configuration valide. Mais comment nous assurons-nous qu&rsquo;un tout nouvel objet <em>commence</em> dans un bon état ?</p>
<p>Pour cela, nous avons besoin de constructeurs. Je trouve qu&rsquo;ils sont l&rsquo;une des parties les plus délicates d&rsquo;un langage à concevoir, et si vous regardez de près la plupart des autres langages, vous verrez des <span name="cracks">fissures</span> autour de la construction d&rsquo;objet où les coutures du design ne s&rsquo;ajustent pas tout à fait parfaitement ensemble. Peut-être qu&rsquo;il y a quelque chose d&rsquo;intrinsèquement désordonné à propos du moment de la naissance.</p>
<aside name="cracks">
<p>Quelques exemples : En Java, même si les champs finaux doivent être initialisés, il est toujours possible d&rsquo;en lire un <em>avant</em> qu&rsquo;il ne l&rsquo;ait été. Les exceptions<span class="em">&mdash;</span>une fonctionnalité énorme, complexe<span class="em">&mdash;</span>ont été ajoutées à C++ principalement comme un moyen d&rsquo;émettre des erreurs depuis des constructeurs.</p>
</aside>
<p>&ldquo;Construire&rdquo; un objet est en fait une paire d&rsquo;opérations :</p>
<ol>
<li>
<p>Le runtime <span name="allocate"><em>alloue</em></span> la mémoire requise pour une instance fraîche. Dans la plupart des langages, cette opération est à un niveau fondamental en dessous de ce à quoi le code utilisateur est capable d&rsquo;accéder.</p>
<aside name="allocate">
<p>Le &ldquo;<a href="https://en.wikipedia.org/wiki/Placement_syntax">placement new</a>&rdquo; de C++ est un exemple rare où les entrailles de l&rsquo;allocation sont mises à nu pour que le programmeur puisse les piquer.</p>
</aside></li>
<li>
<p>Ensuite, un morceau de code fourni par l&rsquo;utilisateur est appelé qui <em>initialise</em> l&rsquo;objet non formé.</p>
</li>
</ol>
<p>Ce dernier est ce à quoi nous avons tendance à penser quand nous entendons &ldquo;constructeur&rdquo;, mais le langage lui-même a habituellement fait un peu de travail préparatoire pour nous avant que nous arrivions à ce point. En fait, notre interpréteur Lox a déjà cela couvert quand il crée un nouvel objet LoxInstance.</p>
<p>Nous ferons la partie restante<span class="em">&mdash;</span>l&rsquo;initialisation définie par l&rsquo;utilisateur<span class="em">&mdash;</span>maintenant. Les langages ont une variété de notations pour le morceau de code qui met en place un nouvel objet pour une classe. C++, Java, et C# utilisent une méthode dont le nom correspond au nom de la classe. Ruby et Python l&rsquo;appellent <code>init()</code>. Ce dernier est sympa et court, donc nous ferons ça.</p>
<p>Dans l&rsquo;implémentation de LoxClass de LoxCallable, nous ajoutons quelques lignes de plus.</p>
<div class="codehilite"><pre class="insert-before">                     List&lt;Object&gt; arguments) {
    LoxInstance instance = new LoxInstance(this);
</pre><div class="source-file"><em>lox/LoxClass.java</em><br>
in <em>call</em>()</div>
<pre class="insert">    <span class="t">LoxFunction</span> <span class="i">initializer</span> = <span class="i">findMethod</span>(<span class="s">&quot;init&quot;</span>);
    <span class="k">if</span> (<span class="i">initializer</span> != <span class="k">null</span>) {
      <span class="i">initializer</span>.<span class="i">bind</span>(<span class="i">instance</span>).<span class="i">call</span>(<span class="i">interpreter</span>, <span class="i">arguments</span>);
    }

</pre><pre class="insert-after">    return instance;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, in <em>call</em>()</div>

<p>Quand une classe est appelée, après que la LoxInstance soit créée, nous cherchons une méthode &ldquo;init&rdquo;. Si nous en trouvons une, nous la lions immédiatement et l&rsquo;invoquons juste comme un appel de méthode normal. La liste d&rsquo;arguments est transférée au passage.</p>
<p>Cette liste d&rsquo;arguments signifie que nous avons aussi besoin d&rsquo;ajuster comment une classe déclare son arité.</p>
<div class="codehilite"><pre class="insert-before">  public int arity() {
</pre><div class="source-file"><em>lox/LoxClass.java</em><br>
in <em>arity</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">LoxFunction</span> <span class="i">initializer</span> = <span class="i">findMethod</span>(<span class="s">&quot;init&quot;</span>);
    <span class="k">if</span> (<span class="i">initializer</span> == <span class="k">null</span>) <span class="k">return</span> <span class="n">0</span>;
    <span class="k">return</span> <span class="i">initializer</span>.<span class="i">arity</span>();
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, in <em>arity</em>(), replace 1 line</div>

<p>S&rsquo;il y a un initialiseur, l&rsquo;arité de cette méthode détermine combien d&rsquo;arguments vous devez passer quand vous appelez la classe elle-même. Nous n&rsquo;<em>exigeons</em> pas d&rsquo;une classe de définir un initialiseur, cependant, comme commodité. Si vous n&rsquo;avez pas d&rsquo;initialiseur, l&rsquo;arité est toujours zéro.</p>
<p>C&rsquo;est fondamentalement ça. Puisque nous lions la méthode <code>init()</code> avant de l&rsquo;appeler, elle a accès à <code>this</code> à l&rsquo;intérieur de son corps. Cela, avec les arguments passés à la classe, est tout ce dont vous avez besoin pour être capable de mettre en place la nouvelle instance comme vous le désirez.</p>
<h3><a href="#invoquer-init-directement" id="invoquer-init-directement"><small>12&#8202;.&#8202;7&#8202;.&#8202;1</small>Invoquer init() directement</a></h3>
<p>Comme d&rsquo;habitude, explorer ce nouveau territoire sémantique fait bruisser quelques créatures bizarres. Considérez :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Foo</span> {
  <span class="i">init</span>() {
    <span class="k">print</span> <span class="k">this</span>;
  }
}

<span class="k">var</span> <span class="i">foo</span> = <span class="t">Foo</span>();
<span class="k">print</span> <span class="i">foo</span>.<span class="i">init</span>();
</pre></div>
<p>Pouvez-vous &ldquo;ré-initialiser&rdquo; un objet en appelant directement sa méthode <code>init()</code> ? Si vous le faites, que renvoie-t-elle ? Une réponse <span name="compromise">raisonnable</span> serait <code>nil</code> puisque c&rsquo;est ce que le corps semble renvoyer.</p>
<p>Cependant<span class="em">&mdash;</span>et je déteste généralement faire des compromis pour satisfaire l&rsquo;implémentation<span class="em">&mdash;</span>cela rendra l&rsquo;implémentation des constructeurs de clox beaucoup plus facile si nous disons que les méthodes <code>init()</code> renvoient toujours <code>this</code>, même quand appelées directement. Afin de garder jlox compatible avec cela, nous ajoutons un petit code de cas spécial dans LoxFunction.</p>
<aside name="compromise">
<p>Peut-être que &ldquo;déteste&rdquo; est une affirmation trop forte. Il est raisonnable d&rsquo;avoir les contraintes et ressources de votre implémentation affecter le design du langage. Il n&rsquo;y a qu&rsquo;un nombre limité d&rsquo;heures dans la journée, et si un coin coupé ici ou là vous permet d&rsquo;obtenir plus de fonctionnalités pour les utilisateurs en moins de temps, cela peut très bien être une victoire nette pour leur bonheur et productivité. L&rsquo;astuce est de deviner <em>quels</em> coins couper qui ne causeront pas à vos utilisateurs et votre futur moi de maudire votre myopie.</p>
</aside>
<div class="codehilite"><pre class="insert-before">      return returnValue.value;
    }
</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in <em>call</em>()</div>
<pre class="insert">

    <span class="k">if</span> (<span class="i">isInitializer</span>) <span class="k">return</span> <span class="i">closure</span>.<span class="i">getAt</span>(<span class="n">0</span>, <span class="s">&quot;this&quot;</span>);
</pre><pre class="insert-after">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in <em>call</em>()</div>

<p>Si la fonction est un initialiseur, nous surchargeons la valeur de retour réelle et renvoyons de force <code>this</code>. Cela repose sur un nouveau champ <code>isInitializer</code>.</p>
<div class="codehilite"><pre class="insert-before">  private final Environment closure;

</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in class <em>LoxFunction</em><br>
replace 1 line</div>
<pre class="insert">  <span class="k">private</span> <span class="k">final</span> <span class="t">boolean</span> <span class="i">isInitializer</span>;

  <span class="t">LoxFunction</span>(<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">declaration</span>, <span class="t">Environment</span> <span class="i">closure</span>,
              <span class="t">boolean</span> <span class="i">isInitializer</span>) {
    <span class="k">this</span>.<span class="i">isInitializer</span> = <span class="i">isInitializer</span>;
</pre><pre class="insert-after">    this.closure = closure;
    this.declaration = declaration;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in class <em>LoxFunction</em>, replace 1 line</div>

<p>Nous ne pouvons pas simplement voir si le nom de le LoxFunction est &ldquo;init&rdquo; parce que l&rsquo;utilisateur pourrait avoir défini une <em>fonction</em> avec ce nom. Dans ce cas, il n&rsquo;y a <em>pas</em> de <code>this</code> à renvoyer. Pour éviter <em>ce</em> cas limite bizarre, nous stockerons directement si la LoxFunction représente une méthode initialiseur. Cela signifie que nous avons besoin de revenir en arrière et corriger les quelques endroits où nous créons des LoxFunctions.</p>
<div class="codehilite"><pre class="insert-before">  public Void visitFunctionStmt(Stmt.Function stmt) {
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitFunctionStmt</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">LoxFunction</span> <span class="i">function</span> = <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">stmt</span>, <span class="i">environment</span>,
                                           <span class="k">false</span>);
</pre><pre class="insert-after">    environment.define(stmt.name.lexeme, function);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitFunctionStmt</em>(), replace 1 line</div>

<p>Pour les déclarations de fonction réelles, <code>isInitializer</code> est toujours faux. Pour les méthodes, nous vérifions le nom.</p>
<div class="codehilite"><pre class="insert-before">    for (Stmt.Function method : stmt.methods) {
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitClassStmt</em>()<br>
replace 1 line</div>
<pre class="insert">      <span class="t">LoxFunction</span> <span class="i">function</span> = <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">method</span>, <span class="i">environment</span>,
          <span class="i">method</span>.<span class="i">name</span>.<span class="i">lexeme</span>.<span class="i">equals</span>(<span class="s">&quot;init&quot;</span>));
</pre><pre class="insert-after">      methods.put(method.name.lexeme, function);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitClassStmt</em>(), replace 1 line</div>

<p>Et ensuite dans <code>bind()</code> où nous créons la fermeture qui lie <code>this</code> à une méthode, nous passons la valeur de la méthode originale.</p>
<div class="codehilite"><pre class="insert-before">    environment.define(&quot;this&quot;, instance);
</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in <em>bind</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="k">return</span> <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">declaration</span>, <span class="i">environment</span>,
                           <span class="i">isInitializer</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in <em>bind</em>(), replace 1 line</div>

<h3><a href="#revenir-depuis-init" id="revenir-depuis-init"><small>12&#8202;.&#8202;7&#8202;.&#8202;2</small>Revenir depuis init()</a></h3>
<p>Nous ne sommes pas encore sortis du bois. Nous avons supposé qu&rsquo;un initialiseur écrit par l&rsquo;utilisateur ne renvoie pas explicitement une valeur parce que la plupart des constructeurs ne le font pas. Que devrait-il arriver si un utilisateur essaie :</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Foo</span> {
  <span class="i">init</span>() {
    <span class="k">return</span> <span class="s">&quot;something else&quot;</span>;
  }
}
</pre></div>
<p>Cela ne va définitivement pas faire ce qu&rsquo;ils veulent, donc autant en faire une erreur statique. De retour dans le résolveur, nous ajoutons un autre cas à FunctionType.</p>
<div class="codehilite"><pre class="insert-before">    FUNCTION,
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in enum <em>FunctionType</em></div>
<pre class="insert">    <span class="i">INITIALIZER</span>,
</pre><pre class="insert-after">    METHOD
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in enum <em>FunctionType</em></div>

<p>Nous utilisons le nom de la méthode visitée pour déterminer si nous résolvons un initialiseur ou pas.</p>
<div class="codehilite"><pre class="insert-before">      FunctionType declaration = FunctionType.METHOD;
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert">      <span class="k">if</span> (<span class="i">method</span>.<span class="i">name</span>.<span class="i">lexeme</span>.<span class="i">equals</span>(<span class="s">&quot;init&quot;</span>)) {
        <span class="i">declaration</span> = <span class="t">FunctionType</span>.<span class="i">INITIALIZER</span>;
      }

</pre><pre class="insert-after">      resolveFunction(method, declaration);<span name="local"> </span>
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>

<p>Quand nous traversons plus tard dans une instruction <code>return</code>, nous vérifions ce champ et en faisons une erreur de renvoyer une valeur depuis l&rsquo;intérieur d&rsquo;une méthode <code>init()</code>.</p>
<div class="codehilite"><pre class="insert-before">    if (stmt.value != null) {
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitReturnStmt</em>()</div>
<pre class="insert">      <span class="k">if</span> (<span class="i">currentFunction</span> == <span class="t">FunctionType</span>.<span class="i">INITIALIZER</span>) {
        <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">stmt</span>.<span class="i">keyword</span>,
            <span class="s">&quot;Can&#39;t return a value from an initializer.&quot;</span>);
      }

</pre><pre class="insert-after">      resolve(stmt.value);
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitReturnStmt</em>()</div>

<p>Nous n&rsquo;avons <em>toujours</em> pas fini. Nous interdisons statiquement de renvoyer une <em>valeur</em> depuis un initialiseur, mais vous pouvez toujours utiliser un <code>return</code> vide anticipé.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Foo</span> {
  <span class="i">init</span>() {
    <span class="k">return</span>;
  }
}
</pre></div>
<p>C&rsquo;est en fait assez utile parfois, donc nous ne voulons pas l&rsquo;interdire entièrement. Au lieu de cela, cela devrait renvoyer <code>this</code> au lieu de <code>nil</code>. C&rsquo;est une correction facile là-bas dans LoxFunction.</p>
<div class="codehilite"><pre class="insert-before">    } catch (Return returnValue) {
</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in <em>call</em>()</div>
<pre class="insert">      <span class="k">if</span> (<span class="i">isInitializer</span>) <span class="k">return</span> <span class="i">closure</span>.<span class="i">getAt</span>(<span class="n">0</span>, <span class="s">&quot;this&quot;</span>);

</pre><pre class="insert-after">      return returnValue.value;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in <em>call</em>()</div>

<p>Si nous sommes dans un initialiseur et exécutons une instruction <code>return</code>, au lieu de renvoyer la valeur (qui sera toujours <code>nil</code>), nous renvoyons encore <code>this</code>.</p>
<p>Ouf ! C&rsquo;était toute une liste de tâches mais notre récompense est que notre petit interpréteur a gagné un paradigme de programmation entier. Classes, méthodes, champs, <code>this</code>, et constructeurs. Notre langage bébé a l&rsquo;air terriblement adulte.</p>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>12&#8202;.&#8202;8</small>Défis</a></h2>
<ol>
<li>
<p>Nous avons des méthodes sur les instances, mais il n&rsquo;y a pas de moyen de définir des méthodes &ldquo;statiques&rdquo; qui peuvent être appelées directement sur l&rsquo;objet classe lui-même. Ajoutez le support pour elles. Utilisez un mot-clé <code>class</code> précédant la méthode pour indiquer une méthode statique qui s&rsquo;accroche à l&rsquo;objet classe.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Math</span> {
  <span class="k">class</span> <span class="i">square</span>(<span class="i">n</span>) {
    <span class="k">return</span> <span class="i">n</span> * <span class="i">n</span>;
  }
}

<span class="k">print</span> <span class="t">Math</span>.<span class="i">square</span>(<span class="n">3</span>); <span class="c">// Imprime &quot;9&quot;.</span>
</pre></div>
<p>Vous pouvez résoudre ceci comme vous voulez, mais les &ldquo;<a href="https://en.wikipedia.org/wiki/Metaclass">métaclasses</a>&rdquo; utilisées par Smalltalk et Ruby sont une approche particulièrement élégante. <em>Indice : Faites en sorte que LoxClass étende LoxInstance et partez de là.</em></p>
</li>
<li>
<p>La plupart des langages modernes supportent des &ldquo;getters&rdquo; et &ldquo;setters&rdquo;<span class="em">&mdash;</span>des membres sur une classe qui ressemblent à des lectures et écritures de champ mais qui exécutent en fait du code défini par l&rsquo;utilisateur. Étendez Lox pour supporter les méthodes getter. Celles-ci sont déclarées sans liste de paramètres. Le corps du getter est exécuté quand une propriété avec ce nom est accédée.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Circle</span> {
  <span class="i">init</span>(<span class="i">radius</span>) {
    <span class="k">this</span>.<span class="i">radius</span> = <span class="i">radius</span>;
  }

  <span class="i">area</span> {
    <span class="k">return</span> <span class="n">3.141592653</span> * <span class="k">this</span>.<span class="i">radius</span> * <span class="k">this</span>.<span class="i">radius</span>;
  }
}

<span class="k">var</span> <span class="i">circle</span> = <span class="t">Circle</span>(<span class="n">4</span>);
<span class="k">print</span> <span class="i">circle</span>.<span class="i">area</span>; <span class="c">// Imprime grossièrement &quot;50.2655&quot;.</span>
</pre></div>
</li>
<li>
<p>Python et JavaScript vous permettent d&rsquo;accéder librement aux champs d&rsquo;un objet depuis l&rsquo;extérieur de ses propres méthodes. Ruby et Smalltalk encapsulent l&rsquo;état de l&rsquo;instance. Seules les méthodes sur la classe peuvent accéder aux champs bruts, et c&rsquo;est à la classe de décider quel état est exposé. La plupart des langages typés statiquement offrent des modificateurs comme <code>private</code> et <code>public</code> pour contrôler quelles parties d&rsquo;une classe sont accessibles de l&rsquo;extérieur sur une base par-membre.</p>
<p>Quels sont les compromis entre ces approches et pourquoi un langage pourrait-il préférer l&rsquo;une ou l&rsquo;autre ?</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#note-de-conception--prototypes-et-puissance" id="note-de-conception--prototypes-et-puissance"><small>12&#8202;.&#8202;9</small>Note de Conception : Prototypes et Puissance</a></h2>
<p>Dans ce chapitre, nous avons introduit deux nouvelles entités d&rsquo;exécution, LoxClass et LoxInstance. La première est où le comportement pour les objets vit, et la dernière est pour l&rsquo;état. Et si vous pouviez définir des méthodes juste sur un seul objet, à l&rsquo;intérieur de LoxInstance ? Dans ce cas, nous n&rsquo;aurions pas besoin de LoxClass du tout. LoxInstance serait un paquet complet pour définir le comportement et l&rsquo;état d&rsquo;un objet.</p>
<p>Nous voudrions toujours un moyen, sans classes, de réutiliser le comportement à travers plusieurs instances. Nous pourrions laisser une LoxInstance <a href="https://en.wikipedia.org/wiki/Prototype-based_programming#Delegation"><em>déléguer</em></a> directement à une autre LoxInstance pour réutiliser ses champs et méthodes, en quelque sorte comme l&rsquo;héritage.</p>
<p>Les utilisateurs modéliseraient leur programme comme une constellation d&rsquo;objets, dont certains délèguent les uns aux autres pour refléter la communalité. Les objets utilisés comme délégués représentent des objets &ldquo;canoniques&rdquo; ou &ldquo;prototypiques&rdquo; que d&rsquo;autres raffinent. Le résultat est un runtime plus simple avec seulement une seule construction interne, LoxInstance.</p>
<p>C&rsquo;est de là que le nom <strong><a href="https://en.wikipedia.org/wiki/Prototype-based_programming">prototypes</a></strong> vient pour ce paradigme. Il a été inventé par David Ungar et Randall Smith dans un langage appelé <a href="http://www.selflanguage.org/">Self</a>. Ils sont arrivés avec en commençant avec Smalltalk et en suivant l&rsquo;exercice mental ci-dessus pour voir combien ils pouvaient le réduire.</p>
<p>Les prototypes ont été une curiosité académique pendant longtemps, une fascinante qui a généré de la recherche intéressante mais n&rsquo;a pas fait une bosse dans le monde plus large de la programmation. C&rsquo;est-à-dire, jusqu&rsquo;à ce que Brendan Eich bourre les prototypes dans JavaScript, qui a alors promptement pris le contrôle du monde. Beaucoup (beaucoup) de <span name="words">mots</span> ont été écrits à propos des prototypes dans JavaScript. Si cela montre que les prototypes sont brillants ou confus<span class="em">&mdash;</span>ou les deux !<span class="em">&mdash;</span>est une question ouverte.</p>
<aside name="words">
<p>Incluant <a href="http://gameprogrammingpatterns.com/prototype.html">plus qu&rsquo;une poignée</a> par votre serviteur.</p>
</aside>
<p>Je n&rsquo;entrerai pas dans si je pense ou non que les prototypes sont une bonne idée pour un langage. J&rsquo;ai fait des langages qui sont <a href="http://finch.stuffwithstuff.com/">prototypaux</a> et <a href="http://wren.io/">basés sur des classes</a>, et mes opinions des deux sont complexes. Ce que je veux discuter est le rôle de la <em>simplicité</em> dans un langage.</p>
<p>Les prototypes sont plus simples que les classes<span class="em">&mdash;</span>moins de code pour l&rsquo;implémenteur du langage à écrire, et moins de concepts pour l&rsquo;utilisateur à apprendre et comprendre. Est-ce que ça les rend meilleurs ? Nous les nerds des langages avons une tendance à fétichiser le minimalisme. Personnellement, je pense que la simplicité est seulement une partie de l&rsquo;équation. Ce que nous voulons vraiment donner à l&rsquo;utilisateur est de la <em>puissance</em>, que je définis comme :</p>
<div class="codehilite"><pre>puissance = étendue × facilité ÷ complexité
</pre></div>
<p>Aucune de celles-ci ne sont des mesures numériques précises. J&rsquo;utilise les maths comme analogie ici, pas une quantification réelle.</p>
<ul>
<li>
<p><strong>L&rsquo;étendue</strong> est la gamme de choses différentes que le langage vous laisse exprimer. C a beaucoup d&rsquo;étendue<span class="em">&mdash;</span>il a été utilisé pour tout, des systèmes d&rsquo;exploitation aux applications utilisateur aux jeux. Les langages spécifiques au domaine comme AppleScript et Matlab ont moins d&rsquo;étendue.</p>
</li>
<li>
<p><strong>La facilité</strong> est le peu d&rsquo;effort que cela prend pour faire faire au langage ce que vous voulez. &ldquo;Utilisabilité&rdquo; pourrait être un autre terme, bien qu&rsquo;il porte plus de bagages que je ne veux en apporter. Les langages de &ldquo;plus haut niveau&rdquo; ont tendance à avoir plus de facilité que ceux de &ldquo;plus bas niveau&rdquo;. La plupart des langages ont un &ldquo;grain&rdquo; à eux où certaines choses semblent plus faciles à exprimer que d&rsquo;autres.</p>
</li>
<li>
<p><strong>La complexité</strong> est combien le langage (incluant son runtime, bibliothèques centrales, outils, écosystème, etc.) est gros. Les gens parlent de combien de pages sont dans la spec d&rsquo;un langage, ou combien de mots-clés il a. C&rsquo;est combien l&rsquo;utilisateur doit charger dans son cerveau (wetware) avant qu&rsquo;il puisse être productif dans le système. C&rsquo;est l&rsquo;antonyme de la simplicité.</p>
</li>
</ul>
<p>Réduire la complexité augmente <em>bien</em> la puissance. Plus le dénominateur est petit, plus la valeur résultante est grande, donc notre intuition que la simplicité est bonne est valide. Cependant, quand nous réduisons la complexité, nous devons faire attention de ne pas sacrifier l&rsquo;étendue ou la facilité dans le processus, ou la puissance totale peut baisser. Java serait un langage strictement <em>plus simple</em> s&rsquo;il supprimait les chaînes de caractères, mais il ne gérerait probablement pas bien les tâches de manipulation de texte, ni ne serait-il aussi facile de faire avancer les choses.</p>
<p>L&rsquo;art, alors, est de trouver la complexité <em>accidentelle</em> qui peut être omise<span class="em">&mdash;</span>les fonctionnalités de langage et interactions qui ne portent pas leur poids en augmentant l&rsquo;étendue ou la facilité d&rsquo;utilisation du langage.</p>
<p>Si les utilisateurs veulent exprimer leur programme en termes de catégories d&rsquo;objets, alors cuire les classes dans le langage augmente la facilité de faire cela, avec un peu de chance par une marge assez grande pour payer pour la complexité ajoutée. Mais si ce n&rsquo;est pas comment les utilisateurs utilisent votre langage, alors par tous les moyens laissez les classes de côté.</p>
</div>

<footer>
<a href="héritage.html" class="next">
  Next Chapter: &ldquo;Héritage&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
