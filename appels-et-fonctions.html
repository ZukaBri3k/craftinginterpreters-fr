<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Appels et fonctions &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Appels et fonctions<small>24</small></a></h3>

<ul>
    <li><a href="#objets-fonction"><small>24.1</small> Objets Fonction</a></li>
    <li><a href="#compiler-vers-des-objets-fonction"><small>24.2</small> Compiler vers des Objets Fonction</a></li>
    <li><a href="#cadres-dappel-call-frames"><small>24.3</small> Cadres d&#x27;Appel (Call Frames)</a></li>
    <li><a href="#déclarations-de-fonction"><small>24.4</small> Déclarations de Fonction</a></li>
    <li><a href="#appels-de-fonction"><small>24.5</small> Appels de Fonction</a></li>
    <li><a href="#instructions-return"><small>24.6</small> Instructions Return</a></li>
    <li><a href="#fonctions-natives"><small>24.7</small> Fonctions Natives</a></li>
    <li><a href="#défis"><small>24.8</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="sauts-avant-et-arrière.html" title="Sauts avant et arrière" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="fermetures.html" title="Fermetures" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="sauts-avant-et-arrière.html" title="Sauts avant et arrière" class="prev">←</a>
<a href="fermetures.html" title="Fermetures" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Appels et fonctions<small>24</small></a></h3>

<ul>
    <li><a href="#objets-fonction"><small>24.1</small> Objets Fonction</a></li>
    <li><a href="#compiler-vers-des-objets-fonction"><small>24.2</small> Compiler vers des Objets Fonction</a></li>
    <li><a href="#cadres-dappel-call-frames"><small>24.3</small> Cadres d&#x27;Appel (Call Frames)</a></li>
    <li><a href="#déclarations-de-fonction"><small>24.4</small> Déclarations de Fonction</a></li>
    <li><a href="#appels-de-fonction"><small>24.5</small> Appels de Fonction</a></li>
    <li><a href="#instructions-return"><small>24.6</small> Instructions Return</a></li>
    <li><a href="#fonctions-natives"><small>24.7</small> Fonctions Natives</a></li>
    <li><a href="#défis"><small>24.8</small> Défis</a></li>
</ul>


<div class="prev-next">
    <a href="sauts-avant-et-arrière.html" title="Sauts avant et arrière" class="left">&larr;&nbsp;Previous</a>
    <a href="une-machine-virtuelle-à-bytecode.html" title="Une machine virtuelle à bytecode">&uarr;&nbsp;Up</a>
    <a href="fermetures.html" title="Fermetures" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">24</div>
  <h1>Appels et fonctions</h1>

<blockquote>
<p>Tout problème en informatique peut être résolu avec un autre niveau d&rsquo;indirection. Sauf pour le problème de trop de couches d&rsquo;indirection.</p>
<p><cite>David Wheeler</cite></p>
</blockquote>
<p>Ce chapitre est un monstre. J&rsquo;essaie de briser les fonctionnalités en morceaux de la taille d&rsquo;une bouchée, mais parfois vous devez avaler le <span name="eat">repas</span> entier. Notre tâche suivante est les fonctions. Nous pourrions commencer avec seulement les déclarations de fonction, mais ce n&rsquo;est pas très utile quand vous ne pouvez pas les appeler. Nous pourrions faire les appels, mais il n&rsquo;y a rien à appeler. Et tout le support runtime nécessaire dans la VM pour supporter ces deux est peu gratifiant s&rsquo;il n&rsquo;est pas accroché à quelque chose que vous pouvez voir. Donc nous allons tout faire. C&rsquo;est beaucoup, mais nous nous sentirons bien quand nous aurons fini.</p>
<aside name="eat">
<p>Manger<span class="em">&mdash;</span>la consommation<span class="em">&mdash;</span>est une métaphore bizarre pour un acte créatif. Mais la plupart des processus biologiques qui produisent de la &ldquo;sortie&rdquo; sont un peu moins, ahem, bienséants.</p>
</aside>
<h2><a href="#objets-fonction" id="objets-fonction"><small>24&#8202;.&#8202;1</small>Objets Fonction</a></h2>
<p>Le changement structurel le plus intéressant dans la VM est autour de la pile. Nous avons déjà <em>une</em> pile pour les variables locales et les temporaires, donc nous y sommes en partie. Mais nous n&rsquo;avons aucune notion d&rsquo;une pile d&rsquo;<em>appels</em>. Avant que nous puissions faire beaucoup de progrès, nous devrons réparer cela. Mais d&rsquo;abord, écrivons un peu de code. Je me sens toujours mieux une fois que je commence à bouger. Nous ne pouvons pas faire grand-chose sans avoir quelque sorte de représentation pour les fonctions, donc nous commencerons là. De la perspective de la VM, qu&rsquo;est-ce qu&rsquo;une fonction ?</p>
<p>Une fonction a un corps qui peut être exécuté, donc cela signifie du bytecode. Nous pourrions compiler le programme entier et toutes ses déclarations de fonction en un gros Chunk monolithique. Chaque fonction aurait un pointeur vers la première instruction de son code à l&rsquo;intérieur du Chunk.</p>
<p>C&rsquo;est grosso modo comment la compilation vers du code natif fonctionne où vous finissez avec un blob solide de code machine. Mais pour notre VM à bytecode, nous pouvons faire quelque chose d&rsquo;un peu plus haut niveau. Je pense qu&rsquo;un modèle plus propre est de donner à chaque fonction son propre Chunk. Nous voudrons quelques autres métadonnées aussi, donc allons de l&rsquo;avant et fourrons tout cela dans une structure maintenant.</p>
<div class="codehilite"><pre class="insert-before">  struct Obj* next;
};
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>Obj</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">int</span> <span class="i">arity</span>;
  <span class="t">Chunk</span> <span class="i">chunk</span>;
  <span class="t">ObjString</span>* <span class="i">name</span>;
} <span class="t">ObjFunction</span>;
</pre><pre class="insert-after">

struct ObjString {
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>Obj</em></div>

<p>Les fonctions sont de première classe dans Lox, donc elles ont besoin d&rsquo;être de vrais objets Lox. Ainsi ObjFunction a le même en-tête Obj que tous les types objets partagent. Le champ <code>arity</code> stocke le nombre de paramètres que la fonction attend. Ensuite, en plus du fragment (chunk), nous stockons le <span name="name">nom</span> de la fonction. Cela sera pratique pour rapporter des erreurs d&rsquo;exécution lisibles.</p>
<aside name="name">
<p>Les humains ne semblent pas trouver les décalages de bytecode numériques particulièrement éclairants dans les vidages sur plantage.</p>
</aside>
<p>C&rsquo;est la première fois que le module &ldquo;object&rdquo; a eu besoin de référencer Chunk, donc nous obtenons une inclusion.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;common.h&quot;
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#include &quot;chunk.h&quot;</span>
</pre><pre class="insert-after">#include &quot;value.h&quot;
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Comme nous l&rsquo;avons fait avec les chaînes, nous définissons quelques accessoires pour rendre les fonctions Lox plus faciles à travailler en C. Sorte d&rsquo;orientation objet du pauvre. D&rsquo;abord, nous déclarerons une fonction C pour créer une nouvelle fonction Lox.</p>
<div class="codehilite"><pre class="insert-before">  uint32_t hash;
};

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjString</em></div>
<pre class="insert"><span class="t">ObjFunction</span>* <span class="i">newFunction</span>();
</pre><pre class="insert-after">ObjString* takeString(char* chars, int length);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>

<p>L&rsquo;implémentation est par ici :</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>allocateObject</em>()</div>
<pre><span class="t">ObjFunction</span>* <span class="i">newFunction</span>() {
  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjFunction</span>, <span class="a">OBJ_FUNCTION</span>);
  <span class="i">function</span>-&gt;<span class="i">arity</span> = <span class="n">0</span>;
  <span class="i">function</span>-&gt;<span class="i">name</span> = <span class="a">NULL</span>;
  <span class="i">initChunk</span>(&amp;<span class="i">function</span>-&gt;<span class="i">chunk</span>);
  <span class="k">return</span> <span class="i">function</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateObject</em>()</div>

<p>Nous utilisons notre ami <code>ALLOCATE_OBJ()</code> pour allouer la mémoire et initialiser l&rsquo;en-tête de l&rsquo;objet pour que la VM sache quel type d&rsquo;objet c&rsquo;est. Au lieu de passer des arguments pour initialiser la fonction comme nous l&rsquo;avons fait avec ObjString, nous configurons la fonction dans une sorte d&rsquo;état vide<span class="em">&mdash;</span>arité zéro, pas de nom, et pas de code. Cela sera rempli plus tard après que la fonction est créée.</p>
<p>Puisque nous avons un nouveau genre d&rsquo;objet, nous avons besoin d&rsquo;un nouveau type d&rsquo;objet dans l&rsquo;énumération.</p>
<div class="codehilite"><pre class="insert-before">typedef enum {
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_FUNCTION</span>,
</pre><pre class="insert-after">  OBJ_STRING,
} ObjType;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>Quand nous avons fini avec un objet fonction, nous devons rendre les bits qu&rsquo;il a empruntés au système d&rsquo;exploitation.</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_FUNCTION</span>: {
      <span class="t">ObjFunction</span>* <span class="i">function</span> = (<span class="t">ObjFunction</span>*)<span class="i">object</span>;
      <span class="i">freeChunk</span>(&amp;<span class="i">function</span>-&gt;<span class="i">chunk</span>);
      <span class="a">FREE</span>(<span class="t">ObjFunction</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_STRING: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>Ce <code>switch case</code> est <span name="free-name">responsable</span> de libérer l&rsquo;ObjFunction elle-même aussi bien que toute autre mémoire qu&rsquo;elle possède. Les fonctions possèdent leur fragment, donc nous appelons la fonction de type destructeur de Chunk.</p>
<aside name="free-name">
<p>Nous n&rsquo;avons pas besoin de libérer explicitement le nom de la fonction parce que c&rsquo;est une ObjString. Cela signifie que nous pouvons laisser le ramasse-miettes gérer sa durée de vie pour nous. Ou, au moins, nous pourrons une fois que nous <a href="garbage-collection.html">implémenterons un ramasse-miettes</a>.</p>
</aside>
<p>Lox vous laisse afficher n&rsquo;importe quel objet, et les fonctions sont des objets de première classe, donc nous devons les gérer aussi.</p>
<div class="codehilite"><pre class="insert-before">  switch (OBJ_TYPE(value)) {
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_FUNCTION</span>:
      <span class="i">printFunction</span>(<span class="a">AS_FUNCTION</span>(<span class="i">value</span>));
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_STRING:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p>Cela appelle vers :</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>copyString</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">printFunction</span>(<span class="t">ObjFunction</span>* <span class="i">function</span>) {
  <span class="i">printf</span>(<span class="s">&quot;&lt;fn %s&gt;&quot;</span>, <span class="i">function</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>copyString</em>()</div>

<p>Puisqu&rsquo;une fonction connaît son nom, elle peut aussi bien le dire.</p>
<p>Finalement, nous avons une couple de macros pour convertir des valeurs en fonctions. D&rsquo;abord, assurez-vous que votre valeur <em>est</em> réellement une fonction.</p>
<div class="codehilite"><pre class="insert-before">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)</span>
</pre><pre class="insert-after">#define IS_STRING(value)       isObjType(value, OBJ_STRING)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Supposant que cela évalue à vrai, vous pouvez alors sûrement caster la Value vers un pointeur ObjFunction en utilisant ceci :</p>
<div class="codehilite"><pre class="insert-before">#define IS_STRING(value)       isObjType(value, OBJ_STRING)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))</span>
</pre><pre class="insert-after">#define AS_STRING(value)       ((ObjString*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Avec ça, notre modèle objet sait comment représenter les fonctions. Je me sens chauffé maintenant. Vous êtes prêt pour quelque chose d&rsquo;un peu plus dur ?</p>
<h2><a href="#compiler-vers-des-objets-fonction" id="compiler-vers-des-objets-fonction"><small>24&#8202;.&#8202;2</small>Compiler vers des Objets Fonction</a></h2>
<p>En ce moment, notre compilateur suppose qu&rsquo;il compile toujours vers un seul fragment unique. Avec le code de chaque fonction vivant dans des fragments séparés, cela devient plus complexe. Quand le compilateur atteint une déclaration de fonction, il a besoin d&rsquo;émettre du code dans le fragment de la fonction lors de la compilation de son corps. À la fin du corps de fonction, le compilateur a besoin de retourner au fragment précédent avec lequel il travaillait.</p>
<p>C&rsquo;est bien pour le code à l&rsquo;intérieur des corps de fonction, mais qu&rsquo;en est-il du code qui ne l&rsquo;est pas ? Le &ldquo;niveau supérieur&rdquo; (top level) d&rsquo;un programme Lox est aussi du code impératif et nous avons besoin d&rsquo;un fragment dans lequel compiler cela. Nous pouvons simplifier le compilateur et la VM en plaçant ce code de niveau supérieur à l&rsquo;intérieur d&rsquo;une fonction définie automatiquement aussi. De cette façon, le compilateur est toujours à l&rsquo;intérieur de quelque sorte de corps de fonction, et la VM court toujours du code en invoquant une fonction. C&rsquo;est comme si le programme entier était <span name="wrap">enveloppé</span> à l&rsquo;intérieur d&rsquo;une fonction implicite <code>main()</code>.</p>
<aside name="wrap">
<p>Un coin sémantique où cette analogie s&rsquo;effondre est les variables globales. Elles ont des règles de portée spéciales différentes des variables locales, donc de cette façon, le niveau supérieur d&rsquo;un script n&rsquo;est pas comme un corps de fonction.</p>
</aside>
<p>Avant que nous arrivions aux fonctions définies par l&rsquo;utilisateur, alors, faisons la réorganisation pour supporter cette fonction implicite de niveau supérieur. Cela commence avec la structure Compiler. Au lieu de pointer directement vers un Chunk auquel le compilateur écrit, il a au lieu de cela une référence vers l&rsquo;objet fonction étant construit.</p>
<div class="codehilite"><pre class="insert-before">typedef struct {
</pre><div class="source-file"><em>compiler.c</em><br>
in struct <em>Compiler</em></div>
<pre class="insert">  <span class="t">ObjFunction</span>* <span class="i">function</span>;
  <span class="t">FunctionType</span> <span class="i">type</span>;

</pre><pre class="insert-after">  Local locals[UINT8_COUNT];
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Compiler</em></div>

<p>Nous avons aussi une petite énumération FunctionType. Cela laisse le compilateur dire quand il compile du code de niveau supérieur versus le corps d&rsquo;une fonction. La plupart du compilateur ne se soucie pas de cela<span class="em">&mdash;</span>c&rsquo;est pourquoi c&rsquo;est une abstraction utile<span class="em">&mdash;</span>mais dans un ou deux endroits la distinction est significative. Nous en arriverons à un plus tard.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after struct <em>Local</em></div>
<pre><span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">TYPE_FUNCTION</span>,
  <span class="a">TYPE_SCRIPT</span>
} <span class="t">FunctionType</span>;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>Local</em></div>

<p>Chaque endroit dans le compilateur qui écrivait au Chunk a maintenant besoin de passer par ce pointeur <code>function</code>. Heureusement, il y a de nombreux <span name="current">chapitres</span>, nous avons encapsulé l&rsquo;accès au fragment dans la fonction <code>currentChunk()</code>. Nous avons seulement besoin de réparer ça et le reste du compilateur est heureux.</p>
<aside name="current">
<p>C&rsquo;est presque comme si j&rsquo;avais une boule de cristal qui pouvait voir dans le futur et savait que nous aurions besoin de changer le code plus tard. Mais, vraiment, c&rsquo;est parce que j&rsquo;ai écrit tout le code pour le livre avant n&rsquo;importe lequel des textes.</p>
</aside>
<div class="codehilite"><pre class="insert-before">Compiler* current = NULL;
</pre><div class="source-file"><em>compiler.c</em><br>
add after variable <em>current</em><br>
replace 5 lines</div>
<pre class="insert">

<span class="k">static</span> <span class="t">Chunk</span>* <span class="i">currentChunk</span>() {
  <span class="k">return</span> &amp;<span class="i">current</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>;
}
</pre><pre class="insert-after">

static void errorAt(Token* token, const char* message) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>current</em>, replace 5 lines</div>

<p>Le fragment courant est toujours le fragment possédé par la fonction que nous sommes au milieu de compiler. Ensuite, nous avons besoin de créer réellement cette fonction. Précédemment, la VM passait un Chunk au compilateur qui le remplissait avec du code. Au lieu de cela, le compilateur créera et renverra une fonction qui contient le code de niveau supérieur compilé<span class="em">&mdash;</span>ce qui est tout ce que nous supportons pour l&rsquo;instant<span class="em">&mdash;</span>du programme de l&rsquo;utilisateur.</p>
<h3><a href="#créer-des-fonctions-au-moment-de-la-compilation" id="créer-des-fonctions-au-moment-de-la-compilation"><small>24&#8202;.&#8202;2&#8202;.&#8202;1</small>Créer des fonctions au moment de la compilation</a></h3>
<p>Nous commençons à enfiler cela à travers <code>compile()</code>, qui est le point d&rsquo;entrée principal dans le compilateur.</p>
<div class="codehilite"><pre class="insert-before">  Compiler compiler;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()<br>
replace 2 lines</div>
<pre class="insert">  <span class="i">initCompiler</span>(&amp;<span class="i">compiler</span>, <span class="a">TYPE_SCRIPT</span>);
</pre><pre class="insert-after">

  parser.hadError = false;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>(), replace 2 lines</div>

<p>Il y a un tas de changements dans comment le compilateur est initialisé. D&rsquo;abord, nous initialisons les nouveaux champs de Compiler.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>initCompiler</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">void</span> <span class="i">initCompiler</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>, <span class="t">FunctionType</span> <span class="i">type</span>) {
  <span class="i">compiler</span>-&gt;<span class="i">function</span> = <span class="a">NULL</span>;
  <span class="i">compiler</span>-&gt;<span class="i">type</span> = <span class="i">type</span>;
</pre><pre class="insert-after">  compiler-&gt;localCount = 0;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>initCompiler</em>(), replace 1 line</div>

<p>Ensuite nous allouons un nouvel objet fonction dans lequel compiler.</p>
<div class="codehilite"><pre class="insert-before">  compiler-&gt;scopeDepth = 0;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>initCompiler</em>()</div>
<pre class="insert">  <span class="i">compiler</span>-&gt;<span class="i">function</span> = <span class="i">newFunction</span>();
</pre><pre class="insert-after">  current = compiler;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>

<p><span name="null"></span></p>
<aside name="null">
<p>Je sais, cela semble bête de mettre à null le champ <code>function</code> seulement pour lui assigner immédiatement une valeur quelques lignes plus tard. Plus de paranoïa liée au ramasse-miettes.</p>
</aside>
<p>Créer une ObjFunction dans le compilateur pourrait sembler un peu étrange. Un objet fonction est la représentation <em>runtime</em> d&rsquo;une fonction, mais ici nous le créons au moment de la compilation. La façon de penser à cela est qu&rsquo;une fonction est similaire à un littéral chaîne ou nombre. Elle forme un pont entre les mondes de la compilation et de l&rsquo;exécution. Quand nous arrivons aux <em>déclarations</em> de fonction, celles-ci <em>sont</em> réellement des littéraux<span class="em">&mdash;</span>c&rsquo;est une notation qui produit des valeurs d&rsquo;un type intégré. Donc le <span name="closure">compilateur</span> crée des objets fonction durant la compilation. Ensuite, à l&rsquo;exécution, ils sont simplement invoqués.</p>
<aside name="closure">
<p>Nous pouvons créer des fonctions au moment de la compilation parce qu&rsquo;elles contiennent seulement des données disponibles à la compilation. Le code, le nom, et l&rsquo;arité de la fonction sont tous fixes. Quand nous ajouterons les fermetures dans le <a href="closures.html">chapitre suivant</a>, qui capturent des variables à l&rsquo;exécution, l&rsquo;histoire devient plus complexe.</p>
</aside>
<p>Voici un autre morceau de code étrange :</p>
<div class="codehilite"><pre class="insert-before">  current = compiler;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>initCompiler</em>()</div>
<pre class="insert">

  <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span>++];
  <span class="i">local</span>-&gt;<span class="i">depth</span> = <span class="n">0</span>;
  <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">start</span> = <span class="s">&quot;&quot;</span>;
  <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">length</span> = <span class="n">0</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>

<p>Rappelez-vous que le tableau <code>locals</code> du compilateur garde la trace de quels emplacements de pile sont associés avec quelles variables locales ou temporaires. À partir de maintenant, le compilateur réclame implicitement l&rsquo;emplacement de pile zéro pour le propre usage interne de la VM. Nous lui donnons un nom vide pour que l&rsquo;utilisateur ne puisse pas écrire un identifiant qui s&rsquo;y réfère. J&rsquo;expliquerai de quoi il s&rsquo;agit quand cela deviendra utile.</p>
<p>C&rsquo;est le côté initialisation. Nous avons aussi besoin d&rsquo;une couple de changements à l&rsquo;autre bout quand nous avons fini de compiler du code.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>endCompiler</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="k">static</span> <span class="t">ObjFunction</span>* <span class="i">endCompiler</span>() {
</pre><pre class="insert-after">  emitReturn();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>endCompiler</em>(), replace 1 line</div>

<p>Précédemment, quand <code>interpret()</code> appelait vers le compilateur, il passait un Chunk pour y écrire. Maintenant que le compilateur crée l&rsquo;objet fonction lui-même, nous renvoyons cette fonction. Nous l&rsquo;attrapons depuis le compilateur courant ici :</p>
<div class="codehilite"><pre class="insert-before">  emitReturn();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endCompiler</em>()</div>
<pre class="insert">  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">current</span>-&gt;<span class="i">function</span>;

</pre><pre class="insert-after">#ifdef DEBUG_PRINT_CODE
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>()</div>

<p>Et ensuite la renvoyons à <code>compile()</code> comme ceci :</p>
<div class="codehilite"><pre class="insert-before">#endif
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endCompiler</em>()</div>
<pre class="insert">

  <span class="k">return</span> <span class="i">function</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>()</div>

<p>Maintenant est un bon moment pour faire un autre ajustement dans cette fonction. Plus tôt, nous avions ajouté du code de diagnostic pour faire vider par la VM le bytecode désassemblé pour que nous puissions déboguer le compilateur. Nous devrions réparer cela pour qu&rsquo;il continue de fonctionner maintenant que le fragment généré est enveloppé dans une fonction.</p>
<div class="codehilite"><pre class="insert-before">#ifdef DEBUG_PRINT_CODE
  if (!parser.hadError) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endCompiler</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">disassembleChunk</span>(<span class="i">currentChunk</span>(), <span class="i">function</span>-&gt;<span class="i">name</span> != <span class="a">NULL</span>
        ? <span class="i">function</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span> : <span class="s">&quot;&lt;script&gt;&quot;</span>);
</pre><pre class="insert-after">  }
#endif
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>(), replace 1 line</div>

<p>Remarquez la vérification là-dedans pour voir si le nom de la fonction est <code>NULL</code> ? Les fonctions définies par l&rsquo;utilisateur ont des noms, mais la fonction implicite que nous créons pour le code de niveau supérieur n&rsquo;en a pas, et nous avons besoin de gérer cela gracieusement même dans notre propre code de diagnostic. En parlant de quoi :</p>
<div class="codehilite"><pre class="insert-before">static void printFunction(ObjFunction* function) {
</pre><div class="source-file"><em>object.c</em><br>
in <em>printFunction</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">function</span>-&gt;<span class="i">name</span> == <span class="a">NULL</span>) {
    <span class="i">printf</span>(<span class="s">&quot;&lt;script&gt;&quot;</span>);
    <span class="k">return</span>;
  }
</pre><pre class="insert-after">  printf(&quot;&lt;fn %s&gt;&quot;, function-&gt;name-&gt;chars);
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printFunction</em>()</div>

<p>Il n&rsquo;y a aucun moyen pour un <em>utilisateur</em> d&rsquo;obtenir une référence à la fonction de niveau supérieur et essayer de l&rsquo;afficher, mais notre code de <span name="debug">diagnostic</span> <code>DEBUG_TRACE_EXECUTION</code> qui affiche la pile entière peut et le fait.</p>
<aside name="debug">
<p>Ce n&rsquo;est pas drôle si le code de diagnostic que nous utilisons pour trouver des bugs cause lui-même la VM de segfault !</p>
</aside>
<p>Montant d&rsquo;un niveau à <code>compile()</code>, nous ajustons sa signature.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;vm.h&quot;

</pre><div class="source-file"><em>compiler.h</em><br>
function <em>compile</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="t">ObjFunction</span>* <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>);
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em>, function <em>compile</em>(), replace 1 line</div>

<p>Au lieu de prendre un fragment, maintenant elle renvoie une fonction. Par ici dans l&rsquo;implémentation :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
function <em>compile</em>()<br>
replace 1 line</div>
<pre class="insert"><span class="t">ObjFunction</span>* <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>) {
</pre><pre class="insert-after">  initScanner(source);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>compile</em>(), replace 1 line</div>

<p>Finalement nous arrivons à du code réel. Nous changeons la toute fin de la fonction pour ceci :</p>
<div class="codehilite"><pre class="insert-before">  while (!match(TOKEN_EOF)) {
    declaration();
  }

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()<br>
replace 2 lines</div>
<pre class="insert">  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">endCompiler</span>();
  <span class="k">return</span> <span class="i">parser</span>.<span class="i">hadError</span> ? <span class="a">NULL</span> : <span class="i">function</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>(), replace 2 lines</div>

<p>Nous obtenons l&rsquo;objet fonction depuis le compilateur. S&rsquo;il n&rsquo;y avait pas d&rsquo;erreurs de compilation, nous le renvoyons. Sinon, nous signalons une erreur en renvoyant <code>NULL</code>. De cette façon, la VM n&rsquo;essaie pas d&rsquo;exécuter une fonction qui peut contenir du bytecode invalide.</p>
<p>Éventuellement, nous mettrons à jour <code>interpret()</code> pour gérer la nouvelle déclaration de <code>compile()</code>, mais d&rsquo;abord nous avons quelques autres changements à faire.</p>
<h2><a href="#cadres-dappel-call-frames" id="cadres-dappel-call-frames"><small>24&#8202;.&#8202;3</small>Cadres d&rsquo;Appel (Call Frames)</a></h2>
<p>Il est temps pour un grand bond conceptuel. Avant que nous puissions implémenter les déclarations et les appels de fonction, nous devons préparer la VM à les gérer. Il y a deux problèmes principaux dont nous devons nous soucier :</p>
<h3><a href="#allouer-les-variables-locales" id="allouer-les-variables-locales"><small>24&#8202;.&#8202;3&#8202;.&#8202;1</small>Allouer les variables locales</a></h3>
<p>Le compilateur alloue des emplacements de pile pour les variables locales. Comment cela devrait-il marcher quand l&rsquo;ensemble des variables locales dans un programme est distribué à travers de multiples fonctions ?</p>
<p>Une option serait de les garder totalement séparées. Chaque fonction obtiendrait son propre ensemble dédié d&rsquo;emplacements dans la pile de la VM qu&rsquo;elle posséderait pour <span name="static">toujours</span>, même quand la fonction n&rsquo;est pas en train d&rsquo;être appelée. Chaque variable locale dans le programme entier aurait un bout de mémoire dans la VM qu&rsquo;elle garde pour elle-même.</p>
<aside name="static">
<p>C&rsquo;est fondamentalement ce que vous obtiendriez si vous déclariez chaque variable locale dans un programme C en utilisant <code>static</code>.</p>
</aside>
<p>Croyez-le ou non, les premières implémentations de langages de programmation fonctionnaient de cette façon. Les premiers compilateurs Fortran allouaient statiquement la mémoire pour chaque variable. Le problème évident est que c&rsquo;est vraiment inefficace. La plupart des fonctions ne sont pas au milieu d&rsquo;être appelées à n&rsquo;importe quel point dans le temps, donc s&rsquo;asseoir sur de la mémoire inutilisée pour elles est du gaspillage.</p>
<p>Le problème plus fondamental, cependant, est la récursivité. Avec la récursivité, vous pouvez être &ldquo;dans&rdquo; de multiples appels à la même fonction en même temps. Chacun a besoin de sa <span name="fortran">propre</span> mémoire pour ses variables locales. Dans jlox, nous avons résolu cela en allouant dynamiquement de la mémoire pour un environnement chaque fois qu&rsquo;une fonction était appelée ou un bloc entré. Dans clox, nous ne voulons pas ce genre de coût de performance à chaque appel de fonction.</p>
<aside name="fortran">
<p>Fortran évitait ce problème en interdisant la récursivité entièrement. La récursivité était considérée comme une fonctionnalité avancée, ésotérique à l&rsquo;époque.</p>
</aside>
<p>Au lieu de cela, notre solution repose quelque part entre l&rsquo;allocation statique de Fortran et l&rsquo;approche dynamique de jlox. La pile de valeurs dans la VM fonctionne sur l&rsquo;observation que les variables locales et les temporaires se comportent d&rsquo;une façon dernier-récent premier-sorti (LIFO). Heureusement pour nous, c&rsquo;est toujours vrai même quand vous ajoutez les appels de fonction dans le mélange. Voici un exemple :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">first</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
  <span class="i">second</span>();
  <span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
}

<span class="k">fun</span> <span class="i">second</span>() {
  <span class="k">var</span> <span class="i">c</span> = <span class="n">3</span>;
  <span class="k">var</span> <span class="i">d</span> = <span class="n">4</span>;
}

<span class="i">first</span>();
</pre></div>
<p>Parcourez le programme et regardez quelles variables sont en mémoire à chaque point dans le temps :</p><img src="image/calls-and-functions/calls.png" alt="Traçage à travers l'exécution du programme précédent, montrant la pile de variables à chaque étape." />
<p>Comme l&rsquo;exécution coule à travers les deux appels, chaque variable locale obéit au principe que toute variable déclarée après elle sera jetée avant que la première variable ait besoin de l&rsquo;être. C&rsquo;est vrai même à travers les appels. Nous savons que nous aurons fini avec <code>c</code> et <code>d</code> avant que nous ayons fini avec <code>a</code>. Il semble que nous devrions être capables d&rsquo;allouer les variables locales sur la pile de valeurs de la VM.</p>
<p>Idéalement, nous déterminons toujours <em>où</em> sur la pile chaque variable ira au moment de la compilation. Cela garde les instructions bytecode pour travailler avec les variables simples et rapides. Dans l&rsquo;exemple ci-dessus, nous pourrions <span name="imagine">imaginer</span> faire ainsi d&rsquo;une manière directe, mais cela ne s&rsquo;arrange pas toujours. Considérez :</p>
<aside name="imagine">
<p>Je dis &ldquo;imaginer&rdquo; parce que le compilateur ne peut pas réellement déterminer cela. Parce que les fonctions sont de première classe dans Lox, nous ne pouvons pas déterminer quelles fonctions appellent lesquelles autres à la compilation.</p>
</aside>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">first</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
  <span class="i">second</span>();
  <span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
  <span class="i">second</span>();
}

<span class="k">fun</span> <span class="i">second</span>() {
  <span class="k">var</span> <span class="i">c</span> = <span class="n">3</span>;
  <span class="k">var</span> <span class="i">d</span> = <span class="n">4</span>;
}

<span class="i">first</span>();
</pre></div>
<p>Dans le premier appel à <code>second()</code>, <code>c</code> et <code>d</code> iraient dans les emplacements 1 et 2. Mais dans le second appel, nous avons besoin d&rsquo;avoir fait de la place pour <code>b</code>, donc <code>c</code> et <code>d</code> ont besoin d&rsquo;être dans les emplacements 2 et 3. Ainsi le compilateur ne peut pas épingler un emplacement exact pour chaque variable locale à travers les appels de fonction. Mais <em>au sein</em> d&rsquo;une fonction donnée, les emplacements <em>relatifs</em> de chaque variable locale sont fixes. La variable <code>d</code> est toujours dans l&rsquo;emplacement juste après <code>c</code>. C&rsquo;est l&rsquo;intuition clé.</p>
<p>Quand une fonction est appelée, nous ne savons pas où le sommet de la pile sera parce qu&rsquo;elle peut être appelée depuis différents contextes. Mais, peu importe où ce sommet se trouve être, nous savons où toutes les variables locales de la fonction seront relativement à ce point de départ. Donc, comme beaucoup de problèmes, nous résolvons notre problème d&rsquo;allocation avec un niveau d&rsquo;indirection.</p>
<p>Au début de chaque appel de fonction, la VM enregistre l&rsquo;emplacement du premier emplacement où les propres locales de cette fonction commencent. Les instructions pour travailler avec les variables locales y accèdent par un index d&rsquo;emplacement relatif à cela, au lieu de relatif au bas de la pile comme elles le font aujourd&rsquo;hui. À la compilation, nous calculons ces emplacements relatifs. À l&rsquo;exécution, nous convertissons cet emplacement relatif en un index de pile absolu en ajoutant l&rsquo;emplacement de départ de l&rsquo;appel de fonction.</p>
<p>C&rsquo;est comme si la fonction obtenait une &ldquo;fenêtre&rdquo; ou un &ldquo;cadre&rdquo; au sein de la plus grande pile où elle peut stocker ses locales. La position du <strong>cadre d&rsquo;appel</strong> (call frame) est déterminée à l&rsquo;exécution, mais au sein et relativement à cette région, nous savons où trouver les choses.</p><img src="image/calls-and-functions/window.png" alt="La pile aux deux points quand second() est appelée, avec une fenêtre planant au-dessus de chacun montrant la paire d'emplacements de pile utilisée par la fonction." />
<p>Le nom historique pour cet emplacement enregistré où les locales de la fonction commencent est un <strong>pointeur de cadre</strong> parce qu&rsquo;il pointe vers le début du cadre d&rsquo;appel de la fonction. Parfois vous entendez <strong>pointeur de base</strong>, parce qu&rsquo;il pointe vers l&rsquo;emplacement de pile de base au-dessus duquel toutes les variables de la fonction vivent.</p>
<p>C&rsquo;est le premier morceau de données que nous avons besoin de suivre. Chaque fois que nous appelons une fonction, la VM détermine le premier emplacement de pile où les variables de cette fonction commencent.</p>
<h3><a href="#adresses-de-retour" id="adresses-de-retour"><small>24&#8202;.&#8202;3&#8202;.&#8202;2</small>Adresses de retour</a></h3>
<p>En ce moment, la VM travaille son chemin à travers le flux d&rsquo;instruction en incrémentant le champ <code>ip</code>. Le seul comportement intéressant est autour des instructions de contrôle de flux qui décalent l&rsquo;<code>ip</code> de montants plus grands. <em>Appeler</em> une fonction est assez direct<span class="em">&mdash;</span>réglez simplement <code>ip</code> pour pointer vers la première instruction dans le fragment de cette fonction. Mais qu&rsquo;en est-il quand la fonction est finie ?</p>
<p>La VM a besoin de <span name="return">retourner</span> au fragment où la fonction a été appelée et reprendre l&rsquo;exécution à l&rsquo;instruction immédiatement après l&rsquo;appel. Ainsi, pour chaque appel de fonction, nous avons besoin de suivre où nous sautons en retour quand l&rsquo;appel se complète. Ceci est appelé une <strong>adresse de retour</strong> parce que c&rsquo;est l&rsquo;adresse de l&rsquo;instruction à laquelle la VM retourne après l&rsquo;appel.</p>
<p>Encore, grâce à la récursivité, il peut y avoir de multiples adresses de retour pour une seule fonction, donc ceci est une propriété de chaque <em>invocation</em> et non de la fonction elle-même.</p>
<aside name="return">
<p>Les auteurs des premiers compilateurs Fortran avaient un truc malin pour implémenter les adresses de retour. Puisqu&rsquo;ils ne supportaient <em>pas</em> la récursivité, toute fonction donnée avait besoin seulement d&rsquo;une seule adresse de retour à n&rsquo;importe quel point dans le temps. Donc quand une fonction était appelée à l&rsquo;exécution, le programme <em>modifiait son propre code</em> pour changer une instruction de saut à la fin de la fonction pour sauter en retour vers son appelant. Parfois la ligne entre génie et folie est fine comme un cheveu.</p>
</aside>
<h3><a href="#la-pile-dappels" id="la-pile-dappels"><small>24&#8202;.&#8202;3&#8202;.&#8202;3</small>La pile d&rsquo;appels</a></h3>
<p>Donc pour chaque invocation de fonction vivante<span class="em">&mdash;</span>chaque appel qui n&rsquo;a pas retourné encore<span class="em">&mdash;</span>nous avons besoin de suivre où sur la pile les locales de cette fonction commencent, et où l&rsquo;appelant devrait reprendre. Nous mettrons cela, avec quelques autres trucs, dans une nouvelle structure.</p>
<div class="codehilite"><pre class="insert-before">#define STACK_MAX 256
</pre><div class="source-file"><em>vm.h</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">ObjFunction</span>* <span class="i">function</span>;
  <span class="t">uint8_t</span>* <span class="i">ip</span>;
  <span class="t">Value</span>* <span class="i">slots</span>;
} <span class="t">CallFrame</span>;
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>

<p>Une CallFrame représente un seul appel de fonction en cours. Le champ <code>slots</code> pointe dans la pile de valeurs de la VM au premier emplacement que cette fonction peut utiliser. Je lui ai donné un nom pluriel parce que<span class="em">&mdash;</span>grâce au truc bizarre de C &ldquo;les pointeurs sont en quelque sorte des tableaux&rdquo;<span class="em">&mdash;</span>nous le traiterons comme un tableau.</p>
<p>L&rsquo;implémentation des adresses de retour est un peu différente de ce que j&rsquo;ai décrit ci-dessus. Au lieu de stocker l&rsquo;adresse de retour dans le cadre de l&rsquo;appelé, l&rsquo;appelant stocke son propre <code>ip</code>. Quand nous retournons d&rsquo;une fonction, la VM sautera à l&rsquo;<code>ip</code> de la CallFrame de l&rsquo;appelant et reprendra de là.</p>
<p>J&rsquo;ai aussi fourré un pointeur vers la fonction étant appelée ici. Nous utiliserons cela pour rechercher des constantes et pour quelques autres choses.</p>
<p>Chaque fois qu&rsquo;une fonction est appelée, nous créons une de ces structures. Nous pourrions les allouer <span name="heap">dynamiquement</span> sur le tas, mais c&rsquo;est lent. Les appels de fonction sont une opération centrale, donc ils ont besoin d&rsquo;être aussi rapides que possible. Heureusement, nous pouvons faire la même observation que nous avons faite pour les variables : les appels de fonction ont une sémantique de pile. Si <code>first()</code> appelle <code>second()</code>, l&rsquo;appel à <code>second()</code> se complétera avant que <code>first()</code> ne le fasse.</p>
<aside name="heap">
<p>Beaucoup d&rsquo;implémentations Lisp allouent dynamiquement les cadres de pile parce que cela simplifie l&rsquo;implémentation des <a href="https://fr.wikipedia.org/wiki/Continuation">continuations</a>. Si votre langage supporte les continuations, alors les appels de fonction n&rsquo;ont <em>pas</em> toujours une sémantique de pile.</p>
</aside>
<p>Donc là-bas dans la VM, nous créons un tableau de ces structures CallFrame à l&rsquo;avance et le traitons comme une pile, comme nous le faisons avec le tableau de valeurs.</p>
<div class="codehilite"><pre class="insert-before">typedef struct {
</pre><div class="source-file"><em>vm.h</em><br>
in struct <em>VM</em><br>
replace 2 lines</div>
<pre class="insert">  <span class="t">CallFrame</span> <span class="i">frames</span>[<span class="a">FRAMES_MAX</span>];
  <span class="t">int</span> <span class="i">frameCount</span>;

</pre><pre class="insert-after">  Value stack[STACK_MAX];
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em>, replace 2 lines</div>

<p>Ce tableau remplace les champs <code>chunk</code> et <code>ip</code> que nous avions l&rsquo;habitude d&rsquo;avoir directement dans la VM. Maintenant chaque CallFrame a son propre <code>ip</code> et son propre pointeur vers l&rsquo;ObjFunction qu&rsquo;elle exécute. De là, nous pouvons aller au fragment de la fonction.</p>
<p>Le nouveau champ <code>frameCount</code> dans la VM stocke la hauteur courante de la pile CallFrame<span class="em">&mdash;</span>le nombre d&rsquo;appels de fonction en cours. Pour garder clox simple, la capacité du tableau est fixe. Cela signifie, comme dans beaucoup d&rsquo;implémentations de langage, qu&rsquo;il existe une profondeur d&rsquo;appel maximale que nous pouvons gérer. Pour clox, c&rsquo;est défini ici :</p>
<div class="codehilite"><pre class="insert-before">#include &quot;value.h&quot;

</pre><div class="source-file"><em>vm.h</em><br>
replace 1 line</div>
<pre class="insert"><span class="a">#define FRAMES_MAX 64</span>
<span class="a">#define STACK_MAX (FRAMES_MAX * UINT8_COUNT)</span>
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, replace 1 line</div>

<p>Nous redéfinissons aussi la <span name="plenty">taille</span> de la pile de valeurs en termes de cela pour nous assurer que nous avons plein d&rsquo;emplacements de pile même dans des arbres d&rsquo;appel très profonds. Quand la VM démarre, la pile CallFrame est vide.</p>
<aside name="plenty">
<p>Il est toujours possible de déborder la pile si assez d&rsquo;appels de fonction utilisent assez de temporaires en plus des locales. Une implémentation robuste se garderait contre cela, mais j&rsquo;essaie de garder les choses simples.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  vm.stackTop = vm.stack;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>resetStack</em>()</div>
<pre class="insert">  <span class="i">vm</span>.<span class="i">frameCount</span> = <span class="n">0</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>resetStack</em>()</div>

<p>L&rsquo;en-tête &ldquo;vm.h&rdquo; a besoin d&rsquo;accéder à ObjFunction, donc nous ajoutons une inclusion.</p>
<div class="codehilite"><pre class="insert-before">#define clox_vm_h

</pre><div class="source-file"><em>vm.h</em><br>
replace 1 line</div>
<pre class="insert"><span class="a">#include &quot;object.h&quot;</span>
</pre><pre class="insert-after">#include &quot;table.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, replace 1 line</div>

<p>Maintenant nous sommes prêts à bouger vers le fichier d&rsquo;implémentation de la VM. Nous avons du sale boulot devant nous. Nous avons déplacé le <code>ip</code> hors de la structure VM et dans CallFrame. Nous avons besoin de réparer chaque ligne de code dans la VM qui touche à <code>ip</code> pour gérer cela. Aussi, les instructions qui accèdent aux variables locales par emplacement de pile ont besoin d&rsquo;être mises à jour pour le faire relativement au champ <code>slots</code> de la CallFrame courante.</p>
<p>Nous commencerons au sommet et labourerons à travers.</p>
<div class="codehilite"><pre class="insert-before">static InterpretResult run() {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 4 lines</div>
<pre class="insert">  <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];

<span class="a">#define READ_BYTE() (*frame-&gt;ip++)</span>

<span class="a">#define READ_SHORT() \</span>
<span class="a">    (frame-&gt;ip += 2, \</span>
<span class="a">    (uint16_t)((frame-&gt;ip[-2] &lt;&lt; 8) | frame-&gt;ip[-1]))</span>

<span class="a">#define READ_CONSTANT() \</span>
<span class="a">    (frame-&gt;function-&gt;chunk.constants.values[READ_BYTE()])</span>

</pre><pre class="insert-after">#define READ_STRING() AS_STRING(READ_CONSTANT())
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 4 lines</div>

<p>D&rsquo;abord, nous stockons la CallFrame la plus haute courante dans une variable <span name="local">locale</span> à l&rsquo;intérieur de la fonction principale d&rsquo;exécution bytecode. Ensuite nous remplaçons les macros d&rsquo;accès au bytecode par des versions qui accèdent à <code>ip</code> à travers cette variable.</p>
<aside name="local">
<p>Nous pourrions accéder au cadre courant en passant par le tableau CallFrame chaque fois, mais c&rsquo;est verbeux. Plus important, stocker le cadre dans une variable locale encourage le compilateur C à garder ce pointeur dans un registre. Cela accélère l&rsquo;accès à l&rsquo;<code>ip</code> du cadre. Il n&rsquo;y a pas de <em>garantie</em> que le compilateur fera cela, mais il y a une bonne chance qu&rsquo;il le fasse.</p>
</aside>
<p>Maintenant sur chaque instruction qui a besoin d&rsquo;un peu d&rsquo;amour et de soin.</p>
<div class="codehilite"><pre class="insert-before">      case OP_GET_LOCAL: {
        uint8_t slot = READ_BYTE();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">        <span class="i">push</span>(<span class="i">frame</span>-&gt;<span class="i">slots</span>[<span class="i">slot</span>]);
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>Précédemment, <code>OP_GET_LOCAL</code> lisait l&rsquo;emplacement local donné directement depuis le tableau de pile de la VM, ce qui signifiait qu&rsquo;il indexait l&rsquo;emplacement commençant depuis le bas de la pile. Maintenant, il accède au tableau <code>slots</code> du cadre courant, ce qui signifie qu&rsquo;il accède à l&rsquo;emplacement numéroté donné relativement au début de ce cadre.</p>
<p>Régler une variable locale fonctionne de la même façon.</p>
<div class="codehilite"><pre class="insert-before">      case OP_SET_LOCAL: {
        uint8_t slot = READ_BYTE();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">        <span class="i">frame</span>-&gt;<span class="i">slots</span>[<span class="i">slot</span>] = <span class="i">peek</span>(<span class="n">0</span>);
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>Les instructions de saut avaient l&rsquo;habitude de modifier le champ <code>ip</code> de la VM. Maintenant, elles font la même chose pour l&rsquo;<code>ip</code> du cadre courant.</p>
<div class="codehilite"><pre class="insert-before">      case OP_JUMP: {
        uint16_t offset = READ_SHORT();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">        <span class="i">frame</span>-&gt;<span class="i">ip</span> += <span class="i">offset</span>;
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>Même chose avec le saut conditionnel :</p>
<div class="codehilite"><pre class="insert-before">      case OP_JUMP_IF_FALSE: {
        uint16_t offset = READ_SHORT();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">        <span class="k">if</span> (<span class="i">isFalsey</span>(<span class="i">peek</span>(<span class="n">0</span>))) <span class="i">frame</span>-&gt;<span class="i">ip</span> += <span class="i">offset</span>;
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>Et notre instruction de boucle sautant en arrière :</p>
<div class="codehilite"><pre class="insert-before">      case OP_LOOP: {
        uint16_t offset = READ_SHORT();
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert">        <span class="i">frame</span>-&gt;<span class="i">ip</span> -= <span class="i">offset</span>;
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>

<p>Nous avons du code de diagnostic qui imprime chaque instruction comme elle s&rsquo;exécute pour nous aider à déboguer notre VM. Cela a besoin de fonctionner avec la nouvelle structure aussi.</p>
<div class="codehilite"><pre class="insert-before">    printf(&quot;\n&quot;);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 2 lines</div>
<pre class="insert">    <span class="i">disassembleInstruction</span>(&amp;<span class="i">frame</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>,
        (<span class="t">int</span>)(<span class="i">frame</span>-&gt;<span class="i">ip</span> - <span class="i">frame</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>));
</pre><pre class="insert-after">#endif
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>

<p>Au lieu de passer les champs <code>chunk</code> et <code>ip</code> de la VM, maintenant nous lisons depuis la CallFrame courante.</p>
<p>Vous savez, ce n&rsquo;était pas trop mal, en fait. La plupart des instructions utilisent juste les macros donc n&rsquo;ont pas eu besoin d&rsquo;être touchées. Ensuite, nous sautons d&rsquo;un niveau au code qui appelle <code>run()</code>.</p>
<div class="codehilite"><pre class="insert-before">InterpretResult interpret(const char* source) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>interpret</em>()<br>
replace 10 lines</div>
<pre class="insert">  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">compile</span>(<span class="i">source</span>);
  <span class="k">if</span> (<span class="i">function</span> == <span class="a">NULL</span>) <span class="k">return</span> <span class="a">INTERPRET_COMPILE_ERROR</span>;

  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">function</span>));
  <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span>++];
  <span class="i">frame</span>-&gt;<span class="i">function</span> = <span class="i">function</span>;
  <span class="i">frame</span>-&gt;<span class="i">ip</span> = <span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>;
  <span class="i">frame</span>-&gt;<span class="i">slots</span> = <span class="i">vm</span>.<span class="i">stack</span>;
</pre><pre class="insert-after">

  InterpretResult result = run();
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 10 lines</div>

<p>Nous arrivons finalement à brancher nos changements de compilateur précédents aux changements back-end que nous venons de faire. D&rsquo;abord, nous passons le code source au compilateur. Il nous renvoie une nouvelle ObjFunction contenant le code de niveau supérieur compilé. Si nous obtenons <code>NULL</code> en retour, cela signifie qu&rsquo;il y a eu quelque erreur au moment de la compilation que le compilateur a déjà rapportée. Dans ce cas, nous abandonnons puisque nous ne pouvons rien exécuter.</p>
<p>Sinon, nous stockons la fonction sur la pile et préparons une CallFrame initiale pour exécuter son code. Maintenant vous pouvez voir pourquoi le compilateur met de côté l&rsquo;emplacement de pile zéro<span class="em">&mdash;</span>cela stocke la fonction étant appelée. Dans la nouvelle CallFrame, nous pointons vers la fonction, initialisons son <code>ip</code> pour pointer vers le début du bytecode de la fonction, et configurons sa fenêtre de pile pour commencer tout au bas de la pile de valeurs de la VM.</p>
<p>Cela prépare l&rsquo;interpréteur à commencer à exécuter du code. Après avoir fini, la VM avait l&rsquo;habitude de libérer le fragment codé en dur. Maintenant que l&rsquo;ObjFunction possède ce code, nous n&rsquo;avons plus besoin de faire cela, donc la fin de <code>interpret()</code> est simplement ceci :</p>
<div class="codehilite"><pre class="insert-before">  frame-&gt;slots = vm.stack;

</pre><div class="source-file"><em>vm.c</em><br>
in <em>interpret</em>()<br>
replace 4 lines</div>
<pre class="insert">  <span class="k">return</span> <span class="i">run</span>();
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 4 lines</div>

<p>Le dernier morceau de code se référant aux vieux champs de la VM est <code>runtimeError()</code>. Nous revisiterons cela plus tard dans le chapitre, mais pour l&rsquo;instant changeons-le pour ceci :</p>
<div class="codehilite"><pre class="insert-before">  fputs(&quot;\n&quot;, stderr);

</pre><div class="source-file"><em>vm.c</em><br>
in <em>runtimeError</em>()<br>
replace 2 lines</div>
<pre class="insert">  <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];
  <span class="t">size_t</span> <span class="i">instruction</span> = <span class="i">frame</span>-&gt;<span class="i">ip</span> - <span class="i">frame</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span> - <span class="n">1</span>;
  <span class="t">int</span> <span class="i">line</span> = <span class="i">frame</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">lines</span>[<span class="i">instruction</span>];
</pre><pre class="insert-after">  fprintf(stderr, &quot;[line %d] in script\n&quot;, line);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>runtimeError</em>(), replace 2 lines</div>

<p>Au lieu de lire le fragment et l&rsquo;<code>ip</code> directement depuis la VM, il tire ceux-ci depuis la CallFrame la plus haute sur la pile. Cela devrait faire fonctionner la fonction à nouveau et se comporter comme elle le faisait avant.</p>
<p>Supposant que nous avons fait tout cela correctement, nous avons ramené clox à un état exécutable. Démarrez-le et il fait<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>exactement ce qu&rsquo;il faisait avant. Nous n&rsquo;avons ajouté aucune nouvelle fonctionnalité encore, donc c&rsquo;est un peu une déception. Mais toute l&rsquo;infrastructure est là et prête pour nous maintenant. Tirons-en avantage.</p>
<h2><a href="#déclarations-de-fonction" id="déclarations-de-fonction"><small>24&#8202;.&#8202;4</small>Déclarations de Fonction</a></h2>
<p>Avant que nous puissions faire des expressions d&rsquo;appel, nous avons besoin de quelque chose à appeler, donc nous ferons les déclarations de fonction d&rsquo;abord. Le <span name="fun">fun</span> commence avec un mot-clé.</p>
<aside name="fun">
<p>Oui, je vais faire une blague bête sur le mot-clé <code>fun</code> à chaque fois qu&rsquo;il apparaît.</p>
</aside>
<div class="codehilite"><pre class="insert-before">static void declaration() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declaration</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_FUN</span>)) {
    <span class="i">funDeclaration</span>();
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_VAR</span>)) {
</pre><pre class="insert-after">    varDeclaration();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>(), replace 1 line</div>

<p>Cela passe le contrôle ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>block</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">funDeclaration</span>() {
  <span class="t">uint8_t</span> <span class="i">global</span> = <span class="i">parseVariable</span>(<span class="s">&quot;Expect function name.&quot;</span>);
  <span class="i">markInitialized</span>();
  <span class="i">function</span>(<span class="a">TYPE_FUNCTION</span>);
  <span class="i">defineVariable</span>(<span class="i">global</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>block</em>()</div>

<p>Les fonctions sont des valeurs de première classe, et une déclaration de fonction crée et stocke simplement une dans une variable nouvellement déclarée. Donc nous analysons le nom juste comme n&rsquo;importe quelle autre déclaration de variable. Une déclaration de fonction au niveau supérieur liera la fonction à une variable globale. À l&rsquo;intérieur d&rsquo;un bloc ou autre fonction, une déclaration de fonction crée une variable locale.</p>
<p>Dans un chapitre précédent, j&rsquo;ai expliqué comment les variables <a href="variables-locales.html#un-autre-cas-limite-de-port%C3%A9e">sont définies en deux étapes</a>. Cela assure que vous ne pouvez pas accéder à la valeur d&rsquo;une variable à l&rsquo;intérieur de l&rsquo;initialisateur de la variable elle-même. Cela serait mauvais parce que la variable n&rsquo;a pas de valeur <em>encore</em>.</p>
<p>Les fonctions ne souffrent pas de ce problème. Il est sûr pour une fonction de se référer à son propre nom à l&rsquo;intérieur de son corps. Vous ne pouvez pas <em>appeler</em> la fonction et exécuter le corps jusqu&rsquo;à ce qu&rsquo;elle soit pleinement définie, donc vous ne verrez jamais la variable dans un état non initialisé. Pratiquement parlant, il est utile de permettre ceci afin de supporter les fonctions locales récursives.</p>
<p>Pour faire fonctionner cela, nous marquons la variable de la déclaration de fonction &ldquo;initialisée&rdquo; aussitôt que nous compilons le nom, avant que nous compilions le corps. De cette façon le nom peut être référencé à l&rsquo;intérieur du corps sans générer une erreur.</p>
<p>Nous avons besoin d&rsquo;une vérification, cependant.</p>
<div class="codehilite"><pre class="insert-before">static void markInitialized() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>markInitialized</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> == <span class="n">0</span>) <span class="k">return</span>;
</pre><pre class="insert-after">  current-&gt;locals[current-&gt;localCount - 1].depth =
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>markInitialized</em>()</div>

<p>Avant, nous appelions <code>markInitialized()</code> seulement quand nous savions déjà que nous étions dans une portée locale. Maintenant, une déclaration de fonction de niveau supérieur appellera aussi cette fonction. Quand cela arrive, il n&rsquo;y a pas de variable locale à marquer initialisée<span class="em">&mdash;</span>la fonction est liée à une variable globale.</p>
<p>Ensuite, nous compilons la fonction elle-même<span class="em">&mdash;</span>sa liste de paramètres et son corps de bloc. Pour cela, nous utilisons une fonction aide séparée. Cette aide génère du code qui laisse l&rsquo;objet fonction résultant au sommet de la pile. Après cela, nous appelons <code>defineVariable()</code> pour stocker cette fonction en retour dans la variable que nous avons déclarée pour elle.</p>
<p>J&rsquo;ai séparé le code pour compiler les paramètres et le corps parce que nous le réutiliserons plus tard pour analyser les déclarations de méthode à l&rsquo;intérieur des classes. Construisons-le incrémentalement, commençant avec ceci :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>block</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">function</span>(<span class="t">FunctionType</span> <span class="i">type</span>) {
  <span class="t">Compiler</span> <span class="i">compiler</span>;
  <span class="i">initCompiler</span>(&amp;<span class="i">compiler</span>, <span class="i">type</span>);
  <span class="i">beginScope</span>();<span name="no-end-scope"> </span>

  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after function name.&quot;</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after parameters.&quot;</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_BRACE</span>, <span class="s">&quot;Expect &#39;{&#39; before function body.&quot;</span>);
  <span class="i">block</span>();

  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">endCompiler</span>();
  <span class="i">emitBytes</span>(<span class="a">OP_CONSTANT</span>, <span class="i">makeConstant</span>(<span class="a">OBJ_VAL</span>(<span class="i">function</span>)));
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>block</em>()</div>

<aside name="no-end-scope">
<p>Ce <code>beginScope()</code> n&rsquo;a pas d&rsquo;appel <code>endScope()</code> correspondant. Parce que nous terminons Compiler complètement quand nous atteignons la fin du corps de la fonction, il n&rsquo;y a pas besoin de fermer la portée la plus extérieure persistante.</p>
</aside>
<p>Pour l&rsquo;instant, nous ne nous soucierons pas des paramètres. Nous analysons une paire vide de parenthèses suivies par le corps. Le corps commence avec une accolade gauche, que nous analysons ici. Ensuite nous appelons notre fonction <code>block()</code> existante, qui sait comment compiler le reste d&rsquo;un bloc incluant l&rsquo;accolade fermante.</p>
<h3><a href="#une-pile-de-compilateurs" id="une-pile-de-compilateurs"><small>24&#8202;.&#8202;4&#8202;.&#8202;1</small>Une pile de compilateurs</a></h3>
<p>Les parties intéressantes sont les trucs de compilateur au sommet et au bas. La structure Compiler stocke des données comme quels emplacements sont possédés par quelles variables locales, combien de blocs d&rsquo;imbrication nous sommes actuellement dedans, etc. Tout cela est spécifique à une fonction unique. Mais maintenant le front end a besoin de gérer la compilation de multiples fonctions <span name="nested">imbriquées</span> les unes dans les autres.</p>
<aside name="nested">
<p>Rappelez-vous que le compilateur traite le code de niveau supérieur comme le corps d&rsquo;une fonction implicite, donc aussitôt que nous ajoutons <em>n&rsquo;importe quelles</em> déclarations de fonction, nous sommes dans un monde de fonctions imbriquées.</p>
</aside>
<p>Le truc pour gérer cela est de créer un Compiler séparé pour chaque fonction étant compilée. Quand nous commençons à compiler une déclaration de fonction, nous créons un nouveau Compiler sur la pile C et l&rsquo;initialisons. <code>initCompiler()</code> règle ce Compiler pour être le courant. Ensuite, comme nous compilons le corps, toutes les fonctions qui émettent du bytecode écrivent au fragment possédé par la fonction du nouveau Compiler.</p>
<p>Après que nous atteignons la fin du corps de bloc de la fonction, nous appelons <code>endCompiler()</code>. Cela produit l&rsquo;objet fonction nouvellement compilé, que nous stockons comme une constante dans la table des constantes de la fonction <em>enveloppante</em>. Mais, attendez, comment revenons-nous à la fonction enveloppante ? Nous l&rsquo;avons perdue quand <code>initCompiler()</code> a écrasé le pointeur de compilateur courant.</p>
<p>Nous réparons cela en traitant la série de structures Compiler imbriquées comme une pile. Contrairement aux piles Value et CallFrame dans la VM, nous n&rsquo;utiliserons pas un tableau. Au lieu de cela, nous utilisons une liste chaînée. Chaque Compiler pointe en arrière vers le Compiler pour la fonction qui l&rsquo;entoure, tout le chemin de retour au Compiler racine pour le code de niveau supérieur.</p>
<div class="codehilite"><pre class="insert-before">} FunctionType;

</pre><div class="source-file"><em>compiler.c</em><br>
add after enum <em>FunctionType</em><br>
replace 1 line</div>
<pre class="insert"><span class="k">typedef</span> <span class="k">struct</span> <span class="t">Compiler</span> {
  <span class="k">struct</span> <span class="t">Compiler</span>* <span class="i">enclosing</span>;
</pre><pre class="insert-after">  ObjFunction* function;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after enum <em>FunctionType</em>, replace 1 line</div>

<p>À l&rsquo;intérieur de la structure Compiler, nous ne pouvons pas référencer le <em>typedef</em> Compiler puisque cette déclaration n&rsquo;a pas fini encore. Au lieu de cela, nous donnons un nom à la structure elle-même et utilisons cela pour le type du champ. Le C est bizarre.</p>
<p>Lors de l&rsquo;initialisation d&rsquo;un nouveau Compiler, nous capturons celui sur-le-point-de-ne-plus-être-courant dans ce pointeur.</p>
<div class="codehilite"><pre class="insert-before">static void initCompiler(Compiler* compiler, FunctionType type) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>initCompiler</em>()</div>
<pre class="insert">  <span class="i">compiler</span>-&gt;<span class="i">enclosing</span> = <span class="i">current</span>;
</pre><pre class="insert-after">  compiler-&gt;function = NULL;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>

<p>Ensuite quand un Compiler finit, il se dépile lui-même de la pile en restaurant le compilateur précédent pour être le nouveau courant.</p>
<div class="codehilite"><pre class="insert-before">#endif

</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endCompiler</em>()</div>
<pre class="insert">  <span class="i">current</span> = <span class="i">current</span>-&gt;<span class="i">enclosing</span>;
</pre><pre class="insert-after">  return function;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>()</div>

<p>Notez que nous n&rsquo;avons même pas besoin d&rsquo;allouer <span name="compiler">dynamiquement</span> les structures Compiler. Chacune est stockée comme une variable locale dans la pile C<span class="em">&mdash;</span>soit dans <code>compile()</code> ou <code>function()</code>. La liste chaînée de Compilers s&rsquo;enfile à travers la pile C. La raison pour laquelle nous pouvons obtenir un nombre illimité d&rsquo;entre eux est parce que notre compilateur utilise la descente récursive, donc <code>function()</code> finit par s&rsquo;appeler elle-même récursivement quand vous avez des déclarations de fonction imbriquées.</p>
<aside name="compiler">
<p>Utiliser la pile native pour les structures Compiler signifie bien que notre compilateur a une limite pratique sur jusqu&rsquo;à quelle profondeur les déclarations de fonction imbriquées peuvent être. Allez trop loin et vous pourriez déborder la pile C. Si nous voulons que le compilateur soit plus robuste contre le code pathologique ou même malveillant<span class="em">&mdash;</span>une vraie préoccupation pour des outils comme les VMs JavaScript<span class="em">&mdash;</span>il serait bon d&rsquo;avoir notre compilateur limiter artificiellement la quantité d&rsquo;imbrication de fonction qu&rsquo;il permet.</p>
</aside>
<h3><a href="#paramètres-de-fonction" id="paramètres-de-fonction"><small>24&#8202;.&#8202;4&#8202;.&#8202;2</small>Paramètres de fonction</a></h3>
<p>Les fonctions ne sont pas très utiles si vous ne pouvez pas leur passer des arguments, donc faisons les paramètres ensuite.</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_LEFT_PAREN, &quot;Expect '(' after function name.&quot;);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>function</em>()</div>
<pre class="insert">  <span class="k">if</span> (!<span class="i">check</span>(<span class="a">TOKEN_RIGHT_PAREN</span>)) {
    <span class="k">do</span> {
      <span class="i">current</span>-&gt;<span class="i">function</span>-&gt;<span class="i">arity</span>++;
      <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">function</span>-&gt;<span class="i">arity</span> &gt; <span class="n">255</span>) {
        <span class="i">errorAtCurrent</span>(<span class="s">&quot;Can&#39;t have more than 255 parameters.&quot;</span>);
      }
      <span class="t">uint8_t</span> <span class="i">constant</span> = <span class="i">parseVariable</span>(<span class="s">&quot;Expect parameter name.&quot;</span>);
      <span class="i">defineVariable</span>(<span class="i">constant</span>);
    } <span class="k">while</span> (<span class="i">match</span>(<span class="a">TOKEN_COMMA</span>));
  }
</pre><pre class="insert-after">  consume(TOKEN_RIGHT_PAREN, &quot;Expect ')' after parameters.&quot;);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>function</em>()</div>

<p>Sémantiquement, un paramètre est simplement une variable locale déclarée dans la portée lexicale la plus extérieure du corps de la fonction. Nous arrivons à utiliser le support existant du compilateur pour déclarer des variables locales nommées pour analyser et compiler les paramètres. Contrairement aux variables locales, qui ont des initialisateurs, il n&rsquo;y a pas de code ici pour initialiser la valeur du paramètre. Nous verrons comment ils sont initialisés plus tard quand nous ferons le passage d&rsquo;arguments dans les appels de fonction.</p>
<p>Pendant que nous y sommes, nous notons l&rsquo;arité de la fonction en comptant combien de paramètres nous analysons. L&rsquo;autre morceau de métadonnée que nous stockons avec une fonction est son nom. Lors de la compilation d&rsquo;une déclaration de fonction, nous appelons <code>initCompiler()</code> juste après que nous analysons le nom de la fonction. Cela signifie que nous pouvons attraper le nom juste là depuis le jeton précédent.</p>
<div class="codehilite"><pre class="insert-before">  current = compiler;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>initCompiler</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">type</span> != <span class="a">TYPE_SCRIPT</span>) {
    <span class="i">current</span>-&gt;<span class="i">function</span>-&gt;<span class="i">name</span> = <span class="i">copyString</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">start</span>,
                                         <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">length</span>);
  }
</pre><pre class="insert-after">

  Local* local = &amp;current-&gt;locals[current-&gt;localCount++];
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>

<p>Notez que nous faisons attention de créer une copie de la chaîne de nom. Rappelez-vous, le lexème pointe directement dans la chaîne de code source originale. Cette chaîne peut être libérée une fois que le code est fini de compiler. L&rsquo;objet fonction que nous créons dans le compilateur survit au compilateur et persiste jusqu&rsquo;à l&rsquo;exécution. Donc il a besoin de sa propre chaîne de nom allouée sur le tas qu&rsquo;il peut garder autour.</p>
<p>Radical. Maintenant nous pouvons compiler les déclarations de fonction, comme ceci :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">areWeHavingItYet</span>() {
  <span class="k">print</span> <span class="s">&quot;Yes we are!&quot;</span>;
}

<span class="k">print</span> <span class="i">areWeHavingItYet</span>;
</pre></div>
<p>Nous ne pouvons juste rien faire d&rsquo;<span name="useful">utile</span> avec elles.</p>
<aside name="useful">
<p>Nous pouvons les afficher ! Je devine que ce n&rsquo;est pas très utile, cependant.</p>
</aside>
<h2><a href="#appels-de-fonction" id="appels-de-fonction"><small>24&#8202;.&#8202;5</small>Appels de Fonction</a></h2>
<p>À la fin de cette section, nous commencerons à voir quelque comportement intéressant. L&rsquo;étape suivante est d&rsquo;appeler les fonctions. Nous ne pensons pas habituellement à cela de cette façon, mais une expression d&rsquo;appel de fonction est une sorte d&rsquo;opérateur <code>(</code> infixe. Vous avez une expression de haute priorité sur la gauche pour la chose étant appelée<span class="em">&mdash;</span>habituellement juste un identifiant simple. Ensuite la <code>(</code> au milieu, suivie par les expressions arguments séparées par des virgules, et une <code>)</code> finale pour envelopper le tout à la fin.</p>
<p>Cette perspective grammaticale étrange explique comment accrocher la syntaxe dans notre table d&rsquo;analyse.</p>
<div class="codehilite"><pre class="insert-before">ParseRule rules[] = {
</pre><div class="source-file"><em>compiler.c</em><br>
add after <em>unary</em>()<br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_LEFT_PAREN</span>]    = {<span class="i">grouping</span>, <span class="i">call</span>,   <span class="a">PREC_CALL</span>},
</pre><pre class="insert-after">  [TOKEN_RIGHT_PAREN]   = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>unary</em>(), replace 1 line</div>

<p>Quand l&rsquo;analyseur rencontre une parenthèse gauche suivant une expression, il répartit vers une nouvelle fonction d&rsquo;analyseur.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>binary</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">call</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="t">uint8_t</span> <span class="i">argCount</span> = <span class="i">argumentList</span>();
  <span class="i">emitBytes</span>(<span class="a">OP_CALL</span>, <span class="i">argCount</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>binary</em>()</div>

<p>Nous avons déjà consommé le jeton <code>(</code>, donc ensuite nous compilons les arguments en utilisant une aide <code>argumentList()</code> séparée. Cette fonction renvoie le nombre d&rsquo;arguments qu&rsquo;elle a compilés. Chaque expression argument génère du code qui laisse sa valeur sur la pile en préparation pour l&rsquo;appel. Après cela, nous émettons une nouvelle instruction <code>OP_CALL</code> pour invoquer la fonction, utilisant le compte d&rsquo;arguments comme un opérande.</p>
<p>Nous compilons les arguments en utilisant cette amie :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>defineVariable</em>()</div>
<pre><span class="k">static</span> <span class="t">uint8_t</span> <span class="i">argumentList</span>() {
  <span class="t">uint8_t</span> <span class="i">argCount</span> = <span class="n">0</span>;
  <span class="k">if</span> (!<span class="i">check</span>(<span class="a">TOKEN_RIGHT_PAREN</span>)) {
    <span class="k">do</span> {
      <span class="i">expression</span>();
      <span class="i">argCount</span>++;
    } <span class="k">while</span> (<span class="i">match</span>(<span class="a">TOKEN_COMMA</span>));
  }
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after arguments.&quot;</span>);
  <span class="k">return</span> <span class="i">argCount</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>defineVariable</em>()</div>

<p>Ce code devrait sembler familier de jlox. Nous mâchons à travers les arguments tant que nous trouvons des virgules après chaque expression. Une fois que nous sommes à court, nous consommons la parenthèse fermante finale et nous avons fini.</p>
<p>Eh bien, presque. De retour dans jlox, nous avions ajouté une vérification à la compilation que vous ne passez pas plus de 255 arguments à un appel. À l&rsquo;époque, j&rsquo;ai dit que c&rsquo;était parce que clox aurait besoin d&rsquo;une limite similaire. Maintenant vous pouvez voir pourquoi<span class="em">&mdash;</span>puisque nous fourrons le compte d&rsquo;arguments dans le bytecode comme un opérande d&rsquo;un seul octet, nous ne pouvons aller que jusqu&rsquo;à 255. Nous avons besoin de vérifier cela dans ce compilateur aussi.</p>
<div class="codehilite"><pre class="insert-before">      expression();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>argumentList</em>()</div>
<pre class="insert">      <span class="k">if</span> (<span class="i">argCount</span> == <span class="n">255</span>) {
        <span class="i">error</span>(<span class="s">&quot;Can&#39;t have more than 255 arguments.&quot;</span>);
      }
</pre><pre class="insert-after">      argCount++;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>argumentList</em>()</div>

<p>C&rsquo;est le front end. Sautons vers le back end, avec un arrêt rapide au milieu pour déclarer la nouvelle instruction.</p>
<div class="codehilite"><pre class="insert-before">  OP_LOOP,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_CALL</span>,
</pre><pre class="insert-after">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<h3><a href="#lier-les-arguments-aux-paramètres" id="lier-les-arguments-aux-paramètres"><small>24&#8202;.&#8202;5&#8202;.&#8202;1</small>Lier les arguments aux paramètres</a></h3>
<p>Avant que nous n&rsquo;arrivions à l&rsquo;implémentation, nous devrions penser à ce à quoi la pile ressemble au point d&rsquo;un appel et ce que nous devons faire à partir de là. Quand nous atteignons l&rsquo;instruction d&rsquo;appel, nous avons déjà exécuté l&rsquo;expression pour la fonction étant appelée, suivie par ses arguments. Disons que notre programme ressemble à ceci :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">sum</span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>) {
  <span class="k">return</span> <span class="i">a</span> + <span class="i">b</span> + <span class="i">c</span>;
}

<span class="k">print</span> <span class="n">4</span> + <span class="i">sum</span>(<span class="n">5</span>, <span class="n">6</span>, <span class="n">7</span>);
</pre></div>
<p>Si nous mettons la VM en pause juste sur l&rsquo;instruction <code>OP_CALL</code> pour cet appel à <code>sum()</code>, la pile ressemble à ceci :</p><img src="image/calls-and-functions/argument-stack.png" alt="Pile : 4, fn sum, 5, 6, 7." />
<p>Imaginez ceci de la perspective de <code>sum()</code> elle-même. Quand le compilateur a compilé <code>sum()</code>, il a automatiquement alloué l&rsquo;emplacement zéro. Ensuite, après cela, il a alloué des emplacements locaux pour les paramètres <code>a</code>, <code>b</code>, et <code>c</code>, dans l&rsquo;ordre. Pour effectuer un appel à <code>sum()</code>, nous avons besoin d&rsquo;une CallFrame initialisée avec la fonction étant appelée et une région d&rsquo;emplacements de pile qu&rsquo;elle peut utiliser. Ensuite nous avons besoin de collecter les arguments passés à la fonction et les obtenir dans les emplacements correspondants pour les paramètres.</p>
<p>Quand la VM commence à exécuter le corps de <code>sum()</code>, nous voulons que sa fenêtre de pile ressemble à ceci :</p><img src="image/calls-and-functions/parameter-window.png" alt="La même pile avec la fenêtre de cadre d'appel de la fonction sum() entourant fn sum, 5, 6, et 7." />
<p>Remarquez-vous comment les emplacements d&rsquo;argument que l&rsquo;appelant configure et les emplacements de paramètre dont l&rsquo;appelé a besoin sont tous deux dans exactement le bon ordre ? Quelle commodité ! Ce n&rsquo;est pas une coïncidence. Quand j&rsquo;ai parlé de chaque CallFrame ayant sa propre fenêtre dans la pile, je n&rsquo;ai jamais dit que ces fenêtres doivent être <em>disjointes</em>. Il n&rsquo;y a rien qui nous empêche de les chevaucher, comme ceci :</p><img src="image/calls-and-functions/overlapping-windows.png" alt="La même pile avec le cadre d'appel de niveau supérieur couvrant la pile entière et la fenêtre de cadre d'appel de la fonction sum() entourant fn sum, 5, 6, et 7." />
<p><span name="lua">Le</span> sommet de la pile de l&rsquo;appelant contient la fonction étant appelée suivie par les arguments dans l&rsquo;ordre. Nous savons que l&rsquo;appelant n&rsquo;a pas d&rsquo;autres emplacements au-dessus de ceux-ci en usage parce que tous les temporaires nécessaires lors de l&rsquo;évaluation des expressions arguments ont été jetés maintenant. Le bas de la pile de l&rsquo;appelé chevauche de sorte que les emplacements paramètre s&rsquo;alignent exactement avec où les valeurs argument vivent déjà.</p>
<aside name="lua">
<p>Différentes VMs à bytecode et architectures CPU réelles ont différentes <em>conventions d&rsquo;appel</em>, qui est le mécanisme spécifique qu&rsquo;elles utilisent pour passer les arguments, stocker l&rsquo;adresse de retour, etc. Le mécanisme que j&rsquo;utilise ici est basé sur la machine virtuelle propre, rapide de Lua.</p>
</aside>
<p>Cela signifie que nous n&rsquo;avons pas besoin de faire <em>aucun</em> travail pour &ldquo;lier un argument à un paramètre&rdquo;. Il n&rsquo;y a pas de copie de valeurs entre des emplacements ou à travers des environnements. Les arguments sont déjà exactement où ils ont besoin d&rsquo;être. Il est dur de battre cela pour la performance.</p>
<p>Temps d&rsquo;implémenter l&rsquo;instruction d&rsquo;appel.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_CALL</span>: {
        <span class="t">int</span> <span class="i">argCount</span> = <span class="a">READ_BYTE</span>();
        <span class="k">if</span> (!<span class="i">callValue</span>(<span class="i">peek</span>(<span class="i">argCount</span>), <span class="i">argCount</span>)) {
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nous avons besoin de connaître la fonction étant appelée et le nombre d&rsquo;arguments passés à elle. Nous obtenons ce dernier du opérande de l&rsquo;instruction. Cela nous dit aussi où trouver la fonction sur la pile en comptant passé les emplacements argument depuis le sommet de la pile. Nous remettons ces données à une fonction <code>callValue()</code> séparée. Si celle-ci renvoie <code>false</code>, cela signifie que l&rsquo;appel a causé quelque sorte d&rsquo;erreur d&rsquo;exécution. Quand cela arrive, nous avortons l&rsquo;interpréteur.</p>
<p>Si <code>callValue()</code> a du succès, il y aura un nouveau cadre sur la pile CallFrame pour la fonction appelée. La fonction <code>run()</code> a son propre pointeur mis en cache vers le cadre courant, donc nous avons besoin de mettre à jour cela.</p>
<div class="codehilite"><pre class="insert-before">          return INTERPRET_RUNTIME_ERROR;
        }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];
</pre><pre class="insert-after">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Puisque la boucle de répartition bytecode lit depuis cette variable <code>frame</code>, quand la VM va exécuter l&rsquo;instruction suivante, elle lira l&rsquo;<code>ip</code> depuis la CallFrame de la fonction nouvellement appelée et sautera vers son code. Le travail pour exécuter cet appel commence ici :</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>peek</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">callValue</span>(<span class="t">Value</span> <span class="i">callee</span>, <span class="t">int</span> <span class="i">argCount</span>) {
  <span class="k">if</span> (<span class="a">IS_OBJ</span>(<span class="i">callee</span>)) {
    <span class="k">switch</span> (<span class="a">OBJ_TYPE</span>(<span class="i">callee</span>)) {
      <span class="k">case</span> <span class="a">OBJ_FUNCTION</span>:<span name="switch"> </span>
        <span class="k">return</span> <span class="i">call</span>(<span class="a">AS_FUNCTION</span>(<span class="i">callee</span>), <span class="i">argCount</span>);
      <span class="k">default</span>:
        <span class="k">break</span>; <span class="c">// Non-callable object type.</span>
    }
  }
  <span class="i">runtimeError</span>(<span class="s">&quot;Can only call functions and classes.&quot;</span>);
  <span class="k">return</span> <span class="k">false</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>peek</em>()</div>

<aside name="switch">
<p>Utiliser une instruction <code>switch</code> pour vérifier un type unique est excessif maintenant, mais aura du sens quand nous ajouterons des cas pour gérer d&rsquo;autres types appelables.</p>
</aside>
<p>Il y a plus qui se passe ici que juste initialiser une nouvelle CallFrame. Parce que Lox est typé dynamiquement, il n&rsquo;y a rien pour empêcher un utilisateur d&rsquo;écrire du mauvais code comme :</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">notAFunction</span> = <span class="n">123</span>;
<span class="i">notAFunction</span>();
</pre></div>
<p>Si cela arrive, le runtime a besoin de rapporter sûrement une erreur et s&rsquo;arrêter. Donc la première chose que nous faisons est de vérifier le type de la valeur que nous essayons d&rsquo;appeler. Si ce n&rsquo;est pas une fonction, nous sortons en erreur. Sinon, l&rsquo;appel réel arrive ici :</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>peek</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">call</span>(<span class="t">ObjFunction</span>* <span class="i">function</span>, <span class="t">int</span> <span class="i">argCount</span>) {
  <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span>++];
  <span class="i">frame</span>-&gt;<span class="i">function</span> = <span class="i">function</span>;
  <span class="i">frame</span>-&gt;<span class="i">ip</span> = <span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>;
  <span class="i">frame</span>-&gt;<span class="i">slots</span> = <span class="i">vm</span>.<span class="i">stackTop</span> - <span class="i">argCount</span> - <span class="n">1</span>;
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>peek</em>()</div>

<p>Ceci initialise simplement la prochaine CallFrame sur la pile. Cela stocke un pointeur vers la fonction étant appelée et pointe l&rsquo;<code>ip</code> du cadre vers le début du bytecode de la fonction. Finalement, cela configure le pointeur <code>slots</code> pour donner au cadre sa fenêtre dans la pile. L&rsquo;arithmétique là assure que les arguments déjà sur la pile s&rsquo;alignent avec les paramètres de la fonction :</p>
<p><img src="image/calls-and-functions/arithmetic.png" alt="L'arithmétique pour calculer frame->slots à partir de stackTop et argCount.&rdquo; /></p>
<p>Le petit <code>- 1</code> rigolo est pour prendre en compte l&rsquo;emplacement de pile zéro que le compilateur a mis de côté pour quand nous ajouterons les méthodes plus tard. Les paramètres commencent à l&rsquo;emplacement un donc nous faisons commencer la fenêtre un emplacement plus tôt pour les aligner avec les arguments.</p>
<p>Avant que nous passions à autre chose, ajoutons la nouvelle instruction à notre désassembleur.</p>
<div class="codehilite"><pre class="insert-before">      return jumpInstruction(&quot;OP_LOOP&quot;, -1, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_CALL</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">&quot;OP_CALL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Et un autre petit voyage rapide. Maintenant que nous avons une fonction pratique pour initier une CallFrame, nous pouvons aussi bien l&rsquo;utiliser pour configurer le premier cadre pour exécuter le code de niveau supérieur.</p>
<div class="codehilite"><pre class="insert-before">  push(OBJ_VAL(function));
</pre><div class="source-file"><em>vm.c</em><br>
in <em>interpret</em>()<br>
replace 4 lines</div>
<pre class="insert">  <span class="i">call</span>(<span class="i">function</span>, <span class="n">0</span>);
</pre><pre class="insert-after">

  return run();
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 4 lines</div>

<p>OK, maintenant retour aux appels<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h3><a href="#vérification-derreur-&agrave;-lexécution" id="vérification-derreur-&agrave;-lexécution"><small>24&#8202;.&#8202;5&#8202;.&#8202;2</small>Vérification d&rsquo;erreur &agrave; l&rsquo;exécution</a></h3>
<p>Les fenêtres de pile chevauchantes fonctionnent basées sur l&rsquo;hypothèse qu&rsquo;un appel passe exactement un argument pour chacun des paramètres de la fonction. Mais, encore, parce que Lox n&rsquo;est pas typé statiquement, un utilisateur insensé pourrait passer trop ou trop peu d&rsquo;arguments. Dans Lox, nous avons défini cela comme étant une erreur d&rsquo;exécution, que nous rapportons comme ceci :</p>
<div class="codehilite"><pre class="insert-before">static bool call(ObjFunction* function, int argCount) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>call</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">argCount</span> != <span class="i">function</span>-&gt;<span class="i">arity</span>) {
    <span class="i">runtimeError</span>(<span class="s">&quot;Expected %d arguments but got %d.&quot;</span>,
        <span class="i">function</span>-&gt;<span class="i">arity</span>, <span class="i">argCount</span>);
    <span class="k">return</span> <span class="k">false</span>;
  }

</pre><pre class="insert-after">  CallFrame* frame = &amp;vm.frames[vm.frameCount++];
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>call</em>()</div>

<p>Assez direct. C&rsquo;est pourquoi nous stockons l&rsquo;arité de chaque fonction à l&rsquo;intérieur de l&rsquo;ObjFunction pour elle.</p>
<p>Il y a une autre erreur que nous devons rapporter qui a moins à voir avec la bêtise de l&rsquo;utilisateur qu&rsquo;avec la nôtre. Parce que le tableau CallFrame a une taille fixe, nous devons nous assurer qu&rsquo;une chaîne d&rsquo;appels profonde ne le déborde pas.</p>
<div class="codehilite"><pre class="insert-before">  }

</pre><div class="source-file"><em>vm.c</em><br>
in <em>call</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">vm</span>.<span class="i">frameCount</span> == <span class="a">FRAMES_MAX</span>) {
    <span class="i">runtimeError</span>(<span class="s">&quot;Stack overflow.&quot;</span>);
    <span class="k">return</span> <span class="k">false</span>;
  }

</pre><pre class="insert-after">  CallFrame* frame = &amp;vm.frames[vm.frameCount++];
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>call</em>()</div>

<p>En pratique, si un programme arrive n&rsquo;importe où près de cette limite, il y a très probablement un bug dans quelque code récursif emballé.</p>
<h3><a href="#afficher-les-traces-de-pile" id="afficher-les-traces-de-pile"><small>24&#8202;.&#8202;5&#8202;.&#8202;3</small>Afficher les traces de pile</a></h3>
<p>Pendant que nous sommes sur le sujet des erreurs d&rsquo;exécution, passons un peu de temps à les rendre plus utiles. S&rsquo;arrêter sur une erreur d&rsquo;exécution est important pour empêcher la VM de planter et brûler d&rsquo;une manière mal définie. Mais simplement avorter n&rsquo;aide pas l&rsquo;utilisateur à réparer son code qui a <em>causé</em> cette erreur.</p>
<p>L&rsquo;outil classique pour aider à déboguer les échecs d&rsquo;exécution est une <strong>trace de pile</strong><span class="em">&mdash;</span>une impression de chaque fonction qui était encore en train d&rsquo;exécuter quand le programme est mort, et où l&rsquo;exécution était au point où il est mort. Maintenant que nous avons une pile d&rsquo;appels et que nous avons commodément stocké le nom de chaque fonction, nous pouvons montrer cette pile entière quand une erreur d&rsquo;exécution perturbe l&rsquo;harmonie de l&rsquo;existence de l&rsquo;utilisateur. Cela ressemble à ceci :</p>
<div class="codehilite"><pre class="insert-before">  fputs(&quot;\n&quot;, stderr);

</pre><div class="source-file"><em>vm.c</em><br>
in <em>runtimeError</em>()<br>
replace 4 lines</div>
<pre class="insert">  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
    <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">i</span>];
    <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">frame</span>-&gt;<span class="i">function</span>;
    <span class="t">size_t</span> <span class="i">instruction</span> = <span class="i">frame</span>-&gt;<span class="i">ip</span> - <span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span> - <span class="n">1</span>;
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;[line %d] in &quot;</span>,<span name="minus"> </span>
            <span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">lines</span>[<span class="i">instruction</span>]);
    <span class="k">if</span> (<span class="i">function</span>-&gt;<span class="i">name</span> == <span class="a">NULL</span>) {
      <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;script</span><span class="e">\n</span><span class="s">&quot;</span>);
    } <span class="k">else</span> {
      <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">&quot;%s()</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">function</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
    }
  }

</pre><pre class="insert-after">  resetStack();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>runtimeError</em>(), replace 4 lines</div>

<aside name="minus">
<p>Le <code>- 1</code> est parce que l&rsquo;IP est déjà assis sur la prochaine instruction à être exécutée mais nous voulons que la trace de pile pointe vers l&rsquo;instruction échouée précédente.</p>
</aside>
<p>Après avoir affiché le message d&rsquo;erreur lui-même, nous marchons la pile d&rsquo;appels du <span name="top">haut</span> (la fonction la plus récemment appelée) au bas (le code de niveau supérieur). Pour chaque cadre, nous trouvons le numéro de ligne qui correspond à l&rsquo;<code>ip</code> courant à l&rsquo;intérieur de la fonction de ce cadre. Ensuite nous affichons ce numéro de ligne avec le nom de la fonction.</p>
<aside name="top">
<p>Il y a quelque désaccord sur dans quel ordre les cadres de pile devraient être montrés dans une trace. La plupart mettent la fonction la plus intérieure comme la première ligne et travaillent leur chemin vers le bas de la pile. Python les imprime dans l&rsquo;ordre opposé. Donc lire de haut en bas vous dit comment votre programme est arrivé où il est, et la dernière ligne est où l&rsquo;erreur s&rsquo;est réellement produite.</p>
<p>Il y a une logique à ce style. Cela assure que vous pouvez toujours voir la fonction la plus intérieure même si la trace de pile est trop longue pour tenir sur un écran. D&rsquo;un autre côté, la &ldquo;<a href="https://fr.wikipedia.org/wiki/Plan_de_la_pyramide_invers%C3%A9e">pyramide inversée</a>&rdquo; du journalisme nous dit que nous devrions mettre l&rsquo;information la plus importante <em>d&rsquo;abord</em> dans un bloc de texte. Dans une trace de pile, c&rsquo;est la fonction où l&rsquo;erreur s&rsquo;est réellement produite. La plupart des autres implémentations de langage font cela.</p>
</aside>
<p>Par exemple, si vous exécutez ce programme cassé :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">a</span>() { <span class="i">b</span>(); }
<span class="k">fun</span> <span class="i">b</span>() { <span class="i">c</span>(); }
<span class="k">fun</span> <span class="i">c</span>() {
  <span class="i">c</span>(<span class="s">&quot;too&quot;</span>, <span class="s">&quot;many&quot;</span>);
}

<span class="i">a</span>();
</pre></div>
<p>Il affiche :</p>
<div class="codehilite"><pre>Expected 0 arguments but got 2.
[line 4] in c()
[line 2] in b()
[line 1] in a()
[line 7] in script
</pre></div>
<p>Cela ne semble pas trop mal, n&rsquo;est-ce pas ?</p>
<h3><a href="#retourner-des-fonctions" id="retourner-des-fonctions"><small>24&#8202;.&#8202;5&#8202;.&#8202;4</small>Retourner des fonctions</a></h3>
<p>Nous nous approchons. Nous pouvons appeler des fonctions, et la VM les exécutera. Mais nous ne pouvons pas <em>retourner</em> d&rsquo;elles encore. Nous avons eu une instruction <code>OP_RETURN</code> depuis pas mal de temps, mais elle a toujours eu quelque sorte de code temporaire traînant dedans juste pour nous sortir de la boucle bytecode. Le temps est arrivé pour une vraie implémentation.</p>
<div class="codehilite"><pre class="insert-before">      case OP_RETURN: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 2 lines</div>
<pre class="insert">        <span class="t">Value</span> <span class="i">result</span> = <span class="i">pop</span>();
        <span class="i">vm</span>.<span class="i">frameCount</span>--;
        <span class="k">if</span> (<span class="i">vm</span>.<span class="i">frameCount</span> == <span class="n">0</span>) {
          <span class="i">pop</span>();
          <span class="k">return</span> <span class="a">INTERPRET_OK</span>;
        }

        <span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">frame</span>-&gt;<span class="i">slots</span>;
        <span class="i">push</span>(<span class="i">result</span>);
        <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];
        <span class="k">break</span>;
</pre><pre class="insert-after">      }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>

<p>Quand une fonction renvoie une valeur, cette valeur sera au sommet de la pile. Nous sommes sur le point de jeter la fenêtre de pile entière de la fonction appelée, donc nous dépilons cette valeur de retour et nous y accrochons. Ensuite nous jetons la CallFrame pour la fonction retournante. Si c&rsquo;était la toute dernière CallFrame, cela signifie que nous avons fini d&rsquo;exécuter le code de niveau supérieur. Le programme entier est fini, donc nous dépilons la fonction de script principale de la pile et ensuite sortons de l&rsquo;interpréteur.</p>
<p>Sinon, nous jetons tous les emplacements que l&rsquo;appelé utilisait pour ses paramètres et variables locales. Cela inclut les mêmes emplacements que l&rsquo;appelant a utilisés pour passer les arguments. Maintenant que l&rsquo;appel est fait, l&rsquo;appelant n&rsquo;en a plus besoin. Cela signifie que le sommet de la pile finit juste au début de la fenêtre de pile de la fonction retournante.</p>
<p>Nous empilons la valeur de retour en arrière sur la pile à ce nouvel emplacement, plus bas. Ensuite nous mettons à jour le pointeur mis en cache de la fonction <code>run()</code> vers le cadre courant. Juste comme quand nous avons commencé un appel, à la prochaine itération de la boucle de répartition bytecode, la VM lira l&rsquo;<code>ip</code> depuis ce cadre, et l&rsquo;exécution sautera en retour vers l&rsquo;appelant, juste où elle a laissé, immédiatement après l&rsquo;instruction <code>OP_CALL</code>.</p><img src="image/calls-and-functions/return.png" alt="Chaque étape du processus de retour : dépiler la valeur de retour, jeter le cadre d'appel, empiler la valeur de retour." />
<p>Notez que nous supposons ici que la fonction <em>a</em> réellement renvoyé une valeur, mais une fonction peut implicitement retourner en atteignant la fin de son corps :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">noReturn</span>() {
  <span class="k">print</span> <span class="s">&quot;Do stuff&quot;</span>;
  <span class="c">// No return here.</span>
}

<span class="k">print</span> <span class="i">noReturn</span>(); <span class="c">// ???</span>
</pre></div>
<p>Nous avons besoin de gérer cela correctement aussi. Le langage est spécifié pour retourner implicitement <code>nil</code> dans ce cas. Pour faire arriver cela, nous ajoutons ceci :</p>
<div class="codehilite"><pre class="insert-before">static void emitReturn() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>emitReturn</em>()</div>
<pre class="insert">  <span class="i">emitByte</span>(<span class="a">OP_NIL</span>);
</pre><pre class="insert-after">  emitByte(OP_RETURN);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>emitReturn</em>()</div>

<p>Le compilateur appelle <code>emitReturn()</code> pour écrire l&rsquo;instruction <code>OP_RETURN</code> à la fin d&rsquo;un corps de fonction. Maintenant, avant cela, il émet une instruction pour empiler <code>nil</code> sur la pile. Et avec ça, nous avons des appels de fonction fonctionnels ! Ils peuvent même prendre des paramètres ! Cela ressemble à presque que nous savons ce que nous faisons ici.</p>
<h2><a href="#instructions-return" id="instructions-return"><small>24&#8202;.&#8202;6</small>Instructions Return</a></h2>
<p>Si vous voulez une fonction qui renvoie quelque chose d&rsquo;autre que le <code>nil</code> implicite, vous avez besoin d&rsquo;une instruction <code>return</code>. Faisons fonctionner ça.</p>
<div class="codehilite"><pre class="insert-before">    ifStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_RETURN</span>)) {
    <span class="i">returnStatement</span>();
</pre><pre class="insert-after">  } else if (match(TOKEN_WHILE)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>Quand le compilateur voit un mot-clé <code>return</code>, il va ici :</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>printStatement</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">returnStatement</span>() {
  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_SEMICOLON</span>)) {
    <span class="i">emitReturn</span>();
  } <span class="k">else</span> {
    <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after return value.&quot;</span>);
    <span class="i">emitByte</span>(<span class="a">OP_RETURN</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>printStatement</em>()</div>

<p>L&rsquo;expression valeur de retour est optionnelle, donc l&rsquo;analyseur cherche un jeton point-virgule pour dire si une valeur a été fournie. S&rsquo;il n&rsquo;y a pas de valeur de retour, l&rsquo;instruction renvoie implicitement <code>nil</code>. Nous implémentons cela en appelant <code>emitReturn()</code>, qui émet une instruction <code>OP_NIL</code>. Sinon, nous compilons l&rsquo;expression valeur de retour et la renvoyons avec une instruction <code>OP_RETURN</code>.</p>
<p>C&rsquo;est la même instruction <code>OP_RETURN</code> que nous avons déjà implémentée<span class="em">&mdash;</span>nous n&rsquo;avons pas besoin de nouveau code runtime. C&rsquo;est tout une différence de jlox. Là, nous devions utiliser des exceptions pour dérouler la pile quand une instruction <code>return</code> était exécutée. C&rsquo;était parce que vous pouviez retourner depuis le fond de quelques blocs imbriqués. Puisque jlox marche récursivement l&rsquo;AST, cela signifiait qu&rsquo;il y avait un tas d&rsquo;appels de méthode Java desquels nous avions besoin d&rsquo;échapper.</p>
<p>Notre compilateur bytecode aplatit tout cela. Nous faisons une descente récursive durant l&rsquo;analyse, mais à l&rsquo;exécution, la boucle de répartition bytecode de la VM est complètement plate. Il n&rsquo;y a pas de récursivité se passant au niveau C du tout. Donc retourner, même depuis l&rsquo;intérieur de quelques blocs imbriqués, est aussi direct que retourner depuis la fin du corps de la fonction.</p>
<p>Nous n&rsquo;avons pas totalement fini, cependant. La nouvelle instruction <code>return</code> nous donne une nouvelle erreur de compilation dont il faut se soucier. Les retours sont utiles pour retourner depuis des fonctions mais le niveau supérieur d&rsquo;un programme Lox est du code impératif aussi. Vous ne devriez pas être capable de <span name="worst">retourner</span> depuis là.</p>
<div class="codehilite"><pre><span class="k">return</span> <span class="s">&quot;What?!&quot;</span>;
</pre></div>
<aside name="worst">
<p>Permettre <code>return</code> au niveau supérieur n&rsquo;est pas la pire idée du monde. Cela vous donnerait un moyen naturel de terminer un script tôt. Vous pourriez peut-être même utiliser un nombre retourné pour indiquer le code de sortie du processus.</p>
</aside>
<p>Nous avons spécifié que c&rsquo;est une erreur de compilation d&rsquo;avoir une instruction <code>return</code> en dehors de toute fonction, que nous implémentons comme ceci :</p>
<div class="codehilite"><pre class="insert-before">static void returnStatement() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>returnStatement</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">type</span> == <span class="a">TYPE_SCRIPT</span>) {
    <span class="i">error</span>(<span class="s">&quot;Can&#39;t return from top-level code.&quot;</span>);
  }

</pre><pre class="insert-after">  if (match(TOKEN_SEMICOLON)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>returnStatement</em>()</div>

<p>C&rsquo;est une des raisons pour lesquelles nous avons ajouté cette énumération FunctionType au compilateur.</p>
<h2><a href="#fonctions-natives" id="fonctions-natives"><small>24&#8202;.&#8202;7</small>Fonctions Natives</a></h2>
<p>Notre VM devient plus puissante. Nous avons des fonctions, des appels, des paramètres, des retours. Vous pouvez définir beaucoup de fonctions différentes qui peuvent s&rsquo;appeler les unes les autres de façons intéressantes. Mais, ultimement, elles ne peuvent pas vraiment <em>faire</em> quoi que ce soit. La seule chose visible par l&rsquo;utilisateur qu&rsquo;un programme Lox peut faire, indépendamment de sa complexité, est d&rsquo;afficher. Pour ajouter plus de capacités, nous avons besoin de les exposer à l&rsquo;utilisateur.</p>
<p>Une implémentation de langage de programmation tend la main et touche le monde matériel à travers des <strong>fonctions natives</strong>. Si vous voulez être capable d&rsquo;écrire des programmes qui vérifient l&rsquo;heure, lisent une entrée utilisateur, ou accèdent au système de fichiers, nous avons besoin d&rsquo;ajouter des fonctions natives<span class="em">&mdash;</span>appelables depuis Lox mais implémentées en C<span class="em">&mdash;</span>qui exposent ces capacités.</p>
<p>Au niveau du langage, Lox est passablement complet<span class="em">&mdash;</span>il a des fermetures, des classes, de l&rsquo;héritage, et d&rsquo;autres trucs amusants. Une raison pour laquelle il se sent comme un langage jouet est parce qu&rsquo;il n&rsquo;a presque pas de capacités natives. Nous pourrions le transformer en un vrai langage en ajoutant une longue liste d&rsquo;entre elles.</p>
<p>Cependant, moudre à travers une pile d&rsquo;opérations OS n&rsquo;est pas réellement très éducatif. Une fois que vous avez vu comment lier un morceau de code C à Lox, vous avez l&rsquo;idée. Mais vous avez besoin d&rsquo;en voir <em>une</em>, et même une seule fonction native nous demande de construire toute la machinerie pour interfacer Lox avec C. Donc nous passerons à travers cela et ferons tout le travail dur. Ensuite, quand c&rsquo;est fait, nous ajouterons une minuscule fonction native juste pour prouver que cela fonctionne.</p>
<p>La raison pour laquelle nous avons besoin de nouvelle machinerie est parce que, de la perspective de l&rsquo;implémentation, les fonctions natives sont différentes des fonctions Lox. Quand elles sont appelées, elles n&rsquo;empilent pas de CallFrame, parce qu&rsquo;il n&rsquo;y a pas de code bytecode vers lequel ce cadre peut pointer. Elles n&rsquo;ont pas de fragment bytecode. Au lieu de cela, elles référencent d&rsquo;une manière ou d&rsquo;une autre un morceau de code C natif.</p>
<p>Nous gérons cela dans clox en définissant les fonctions natives comme un type d&rsquo;objet entièrement différent.</p>
<div class="codehilite"><pre class="insert-before">} ObjFunction;
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjFunction</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="t">Value</span> (*<span class="t">NativeFn</span>)(<span class="t">int</span> <span class="i">argCount</span>, <span class="t">Value</span>* <span class="i">args</span>);

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">NativeFn</span> <span class="i">function</span>;
} <span class="t">ObjNative</span>;
</pre><pre class="insert-after">

struct ObjString {
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjFunction</em></div>

<p>La représentation est plus simple qu&rsquo;ObjFunction<span class="em">&mdash;</span>simplement un en-tête Obj et un pointeur vers la fonction C qui implémente le comportement natif. La fonction native prend le compte d&rsquo;arguments et un pointeur vers le premier argument sur la pile. Elle accède aux arguments à travers ce pointeur. Une fois qu&rsquo;elle a fini, elle renvoie la valeur résultat.</p>
<p>Comme toujours, un nouveau type d&rsquo;objet transporte quelques accoutrements avec lui. Pour créer une ObjNative, nous déclarons une fonction de type constructeur.</p>
<div class="codehilite"><pre class="insert-before">ObjFunction* newFunction();
</pre><div class="source-file"><em>object.h</em><br>
add after <em>newFunction</em>()</div>
<pre class="insert"><span class="t">ObjNative</span>* <span class="i">newNative</span>(<span class="t">NativeFn</span> <span class="i">function</span>);
</pre><pre class="insert-after">ObjString* takeString(char* chars, int length);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after <em>newFunction</em>()</div>

<p>Nous implémentons cela ainsi :</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>newFunction</em>()</div>
<pre><span class="t">ObjNative</span>* <span class="i">newNative</span>(<span class="t">NativeFn</span> <span class="i">function</span>) {
  <span class="t">ObjNative</span>* <span class="i">native</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjNative</span>, <span class="a">OBJ_NATIVE</span>);
  <span class="i">native</span>-&gt;<span class="i">function</span> = <span class="i">function</span>;
  <span class="k">return</span> <span class="i">native</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>newFunction</em>()</div>

<p>Le constructeur prend un pointeur de fonction C pour l&rsquo;envelopper dans une ObjNative. Il configure l&rsquo;en-tête de l&rsquo;objet et stocke la fonction. Pour l&rsquo;en-tête, nous avons besoin d&rsquo;un nouveau type d&rsquo;objet.</p>
<div class="codehilite"><pre class="insert-before">typedef enum {
  OBJ_FUNCTION,
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_NATIVE</span>,
</pre><pre class="insert-after">  OBJ_STRING,
} ObjType;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>La VM a aussi besoin de savoir comment désallouer un objet fonction native.</p>
<div class="codehilite"><pre class="insert-before">    }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_NATIVE</span>:
      <span class="a">FREE</span>(<span class="t">ObjNative</span>, <span class="i">object</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_STRING: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>Il n&rsquo;y a pas grand-chose ici puisque ObjNative ne possède aucune mémoire supplémentaire. L&rsquo;autre capacité que tous les objets Lox supportent est d&rsquo;être affiché.</p>
<div class="codehilite"><pre class="insert-before">      break;
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_NATIVE</span>:
      <span class="i">printf</span>(<span class="s">&quot;&lt;native fn&gt;&quot;</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_STRING:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p>Afin de supporter le typage dynamique, nous avons une macro pour voir si une valeur est une fonction native.</p>
<div class="codehilite"><pre class="insert-before">#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define IS_NATIVE(value)       isObjType(value, OBJ_NATIVE)</span>
</pre><pre class="insert-after">#define IS_STRING(value)       isObjType(value, OBJ_STRING)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Supposant que cela renvoie vrai, cette macro extrait le pointeur de fonction C depuis une Value représentant une fonction native :</p>
<div class="codehilite"><pre class="insert-before">#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define AS_NATIVE(value) \</span>
<span class="a">    (((ObjNative*)AS_OBJ(value))-&gt;function)</span>
</pre><pre class="insert-after">#define AS_STRING(value)       ((ObjString*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Tout ce bagage laisse la VM traiter les fonctions natives comme n&rsquo;importe quel autre objet. Vous pouvez les stocker dans des variables, les passer autour comme des anniversaires, leur faire des fêtes d&rsquo;anniversaire, etc. Bien sûr, l&rsquo;opération dont nous nous soucions réellement est <em>les appeler</em><span class="em">&mdash;</span>en utiliser une comme l&rsquo;opérande de main gauche dans une expression d&rsquo;appel.</p>
<p>Là-bas dans <code>callValue()</code> nous ajoutons un autre cas de type.</p>
<div class="codehilite"><pre class="insert-before">      case OBJ_FUNCTION:<span name="switch"> </span>
        return call(AS_FUNCTION(callee), argCount);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>callValue</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OBJ_NATIVE</span>: {
        <span class="t">NativeFn</span> <span class="i">native</span> = <span class="a">AS_NATIVE</span>(<span class="i">callee</span>);
        <span class="t">Value</span> <span class="i">result</span> = <span class="i">native</span>(<span class="i">argCount</span>, <span class="i">vm</span>.<span class="i">stackTop</span> - <span class="i">argCount</span>);
        <span class="i">vm</span>.<span class="i">stackTop</span> -= <span class="i">argCount</span> + <span class="n">1</span>;
        <span class="i">push</span>(<span class="i">result</span>);
        <span class="k">return</span> <span class="k">true</span>;
      }
</pre><pre class="insert-after">      default:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>

<p>Si l&rsquo;objet étant appelé est une fonction native, nous invoquons la fonction C juste là et maintenant. Il n&rsquo;y a pas besoin de boue avec des CallFrames ou quoi que ce soit. Nous passons juste la main au C, obtenons le résultat, et le fourrons de retour dans la pile. Cela rend les fonctions natives aussi rapides que nous le pouvons.</p>
<p>Avec cela, les utilisateurs devraient être capables d&rsquo;appeler des fonctions natives, mais il n&rsquo;y en a aucune à appeler. Sans quelque chose comme une interface de fonction étrangère, les utilisateurs ne peuvent pas définir leurs propres fonctions natives. C&rsquo;est notre travail en tant qu&rsquo;implémenteurs de VM. Nous commencerons avec un aide pour définir une nouvelle fonction native exposée aux programmes Lox.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>runtimeError</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">defineNative</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">NativeFn</span> <span class="i">function</span>) {
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">copyString</span>(<span class="i">name</span>, (<span class="t">int</span>)<span class="i">strlen</span>(<span class="i">name</span>))));
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">newNative</span>(<span class="i">function</span>)));
  <span class="i">tableSet</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="a">AS_STRING</span>(<span class="i">vm</span>.<span class="i">stack</span>[<span class="n">0</span>]), <span class="i">vm</span>.<span class="i">stack</span>[<span class="n">1</span>]);
  <span class="i">pop</span>();
  <span class="i">pop</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>runtimeError</em>()</div>

<p>Elle prend un pointeur vers une fonction C et le nom sous lequel elle sera connue dans Lox. Nous enveloppons la fonction dans une ObjNative et ensuite stockons cela dans une variable globale avec le nom donné.</p>
<p>Vous vous demandez probablement pourquoi nous empilons et dépilons le nom et la fonction sur la pile. Cela semble bizarre, non ? C&rsquo;est le genre de trucs dont vous avez à vous soucier quand le ramassage de <span name="worry">miettes</span> devient impliqué. À la fois <code>copyString()</code> et <code>newNative()</code> allouent dynamiquement de la mémoire. Cela signifie qu&rsquo;une fois que nous avons un GC, ils peuvent potentiellement déclencher une collecte. Si cela arrive, nous avons besoin de nous assurer que le collecteur sait que nous n&rsquo;avons pas fini avec le nom et l&rsquo;ObjFunction pour qu&rsquo;il ne les libère pas sous nous. Les stocker sur la pile de valeurs accomplit cela.</p>
<aside name="worry">
<p>Ne vous inquiétez pas si vous n&rsquo;avez pas suivi tout cela. Cela aura beaucoup plus de sens une fois que nous arriverons à <a href="garbage-collection.html">implémenter le GC</a>.</p>
</aside>
<p>Cela semble idiot, mais après tout ce travail, nous allons ajouter seulement une petite fonction native.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after variable <em>vm</em></div>
<pre><span class="k">static</span> <span class="t">Value</span> <span class="i">clockNative</span>(<span class="t">int</span> <span class="i">argCount</span>, <span class="t">Value</span>* <span class="i">args</span>) {
  <span class="k">return</span> <span class="a">NUMBER_VAL</span>((<span class="t">double</span>)<span class="i">clock</span>() / <span class="a">CLOCKS_PER_SEC</span>);
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after variable <em>vm</em></div>

<p>Celle-ci renvoie le temps écoulé depuis que le programme a commencé à tourner, en secondes. C&rsquo;est pratique pour benchmarker les programmes Lox. Dans Lox, nous la nommerons <code>clock()</code>.</p>
<div class="codehilite"><pre class="insert-before">  initTable(&amp;vm.strings);
</pre><div class="source-file"><em>vm.c</em><br>
in <em>initVM</em>()</div>
<pre class="insert">

  <span class="i">defineNative</span>(<span class="s">&quot;clock&quot;</span>, <span class="i">clockNative</span>);
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>

<p>Pour aller à la fonction <code>clock()</code> de la bibliothèque standard C, le module &ldquo;vm&rdquo; a besoin d&rsquo;une inclusion.</p>
<div class="codehilite"><pre class="insert-before">#include &lt;string.h&gt;
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert"><span class="a">#include &lt;time.h&gt;</span>
</pre><pre class="insert-after">

#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>

<p>C&rsquo;était beaucoup de matériel à travailler, mais nous l&rsquo;avons fait ! Tapez ceci et essayez-le :</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">fib</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> &lt; <span class="n">2</span>) <span class="k">return</span> <span class="i">n</span>;
  <span class="k">return</span> <span class="i">fib</span>(<span class="i">n</span> - <span class="n">2</span>) + <span class="i">fib</span>(<span class="i">n</span> - <span class="n">1</span>);
}

<span class="k">var</span> <span class="i">start</span> = <span class="i">clock</span>();
<span class="k">print</span> <span class="i">fib</span>(<span class="n">35</span>);
<span class="k">print</span> <span class="i">clock</span>() - <span class="i">start</span>;
</pre></div>
<p>Nous pouvons écrire une fonction Fibonacci récursive vraiment inefficace. Encore mieux, nous pouvons mesurer juste <span name="faster"><em>combien</em></span> elle est inefficace. C&rsquo;est, bien sûr, pas le moyen le plus intelligent de calculer un nombre de Fibonacci. Mais c&rsquo;est un bon moyen de tester en stress le support d&rsquo;une implémentation de langage pour les appels de fonction. Sur ma machine, exécuter ceci dans clox est environ cinq fois plus rapide que dans jlox. C&rsquo;est toute une amélioration.</p>
<aside name="faster">
<p>C&rsquo;est un peu plus lent qu&rsquo;un programme Ruby comparable exécuté dans Ruby 2.4.3p205, et environ 3x plus rapide qu&rsquo;un exécuté dans Python 3.7.3. Et nous avons encore beaucoup d&rsquo;optimisations simples que nous pouvons faire dans notre VM.</p>
</aside>
<div class="challenges">
<h2><a href="#défis" id="défis"><small>24&#8202;.&#8202;8</small>Défis</a></h2>
<ol>
<li>
<p>Lire et écrire le champ <code>ip</code> est une des opérations les plus fréquentes à l&rsquo;intérieur de la boucle bytecode. En ce moment, nous y accédons à travers un pointeur vers la CallFrame courante. Cela nécessite une indirection de pointeur qui peut forcer le CPU à contourner le cache et frapper la mémoire principale. Cela peut être un vrai gouffre de performance.</p>
<p>Idéalement, nous garderions l&rsquo;<code>ip</code> dans un registre CPU natif. C ne nous laisse pas <em>exiger</em> cela sans tomber dans l&rsquo;assembleur inline, mais nous pouvons structurer le code pour encourager le compilateur à faire cette optimisation. Si nous stockons l&rsquo;<code>ip</code> directement dans une variable locale C et la marquons <code>register</code>, il y a une bonne chance que le compilateur C accède à notre requête polie.</p>
<p>Cela signifie bien que nous devons faire attention de charger et stocker l&rsquo;<code>ip</code> local en retour dans la bonne CallFrame lors du démarrage et de la fin des appels de fonction. Implémentez cette optimisation. Écrivez une couple de benchmarks et voyez comment cela affecte la performance. Pensez-vous que la complexité de code supplémentaire en vaut la peine ?</p>
</li>
<li>
<p>Les appels de fonction native sont rapides en partie parce que nous ne validons pas que l&rsquo;appel passe autant d&rsquo;arguments que la fonction attend. Nous devrions vraiment, ou un appel incorrect à une fonction native sans assez d&rsquo;arguments pourrait causer la fonction de lire de la mémoire non initialisée. Ajoutez la vérification d&rsquo;arité.</p>
</li>
<li>
<p>En ce moment, il n&rsquo;y a pas de moyen pour une fonction native de signaler une erreur d&rsquo;exécution. Dans une vraie implémentation, c&rsquo;est quelque chose que nous aurions besoin de supporter parce que les fonctions natives vivent dans le monde typé statiquement du C mais sont appelées depuis le pays Lox typé dynamiquement. Si un utilisateur, disons, essaie de passer une chaîne à <code>sqrt()</code>, cette fonction native a besoin de rapporter une erreur d&rsquo;exécution.</p>
<p>Étendez le système de fonction native pour supporter cela. Comment cette capacité affecte-t-elle la performance des appels natifs ?</p>
</li>
<li>
<p>Ajoutez quelques fonctions natives de plus pour faire des choses que vous trouvez utiles. Écrivez quelques programmes utilisant celles-ci. Qu&rsquo;avez-vous ajouté ? Comment affectent-elles le feeling du langage et à quel point il est pratique ?</p>
</li>
</ol>
</div>

<footer>
<a href="fermetures.html" class="next">
  Next Chapter: &ldquo;Fermetures&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
